/*
 * xtc - The eXTensible Compiler
 * Copyright (C) 2004-2006 Robert Grimm
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
 * USA.
 */

/* modified from 

java xtc.parser.Rats -combined xtc/lang/Java.rats > ~/research/papers/LL-star/PEG-ANTLR/Java.rats

ANTLRWorks refactored left-recursion.

Move out lexer rules and replaced with lexer from sample ANTLR java grammar. 
"token" names are consistent with Rats! Java parser grammar.

Rats! Parser Generator, v. 1.15.0, (C) 2004-2009 Robert Grimm
*/

// ===========================================================================
// Generated by Rats!, version 1.15.0, (C) 2004-2009 Robert Grimm.
// ===========================================================================

/**
 * Java grammar with AST support.
 * 
 * @author Robert Grimm
 * @author Stacey Kuznetsov
 * @version $Revision: 1.13 $
 */
grammar RatsJava;

options { backtrack=true; memoize=true; }

/*
body {
  static {
    add(JAVA_KEYWORDS, new String[] {
      "abstract",  "continue",  "for",         "new",        "switch",
      "assert",    "default",   "if",          "package",    "synchronized",
      "boolean",   "do",        "goto",        "private",    "this",
      "break",     "double",    "implements",  "protected",  "throw",
      "byte",      "else",      "import",      "public",     "throws",
      "case",                   "instanceof",  "return",     "transient",
      "catch",     "extends",   "int",         "short",      "try",
      "char",      "final",     "interface",   "static",     "void",
      "class",     "finally",   "long",        "strictfp",   "volatile",
      "const",     "float",     "native",      "super",      "while"
    });
  }
}
*/

//option withLocation, constant, flatten, setOfString(JAVA_KEYWORDS);

compilationUnit : 
  packageDeclaration? importDeclaration* declaration* CTRLZ? EOF
  ;

packageDeclaration : 
  'package' qualifiedIdentifier ';'
  ;

importDeclaration : 
  'import' qualifiedIdentifier dotStarTail? 
  ';'
  ;

dotStarTail : 
  '.' '*'
  ;

name : 
  Identifier
  ;

modifiers : 
  modifierList
  ;

modifierList : 
  modifier*
  ;

modifier : 
  'public'
  | 'protected'
  | 'private'
  | 'static'
  | 'abstract'
  | 'final'
  | 'native'
  | 'synchronized'
  | 'transient'
  | 'volatile'
  | 'strictfp'
  ;

formalParameter : 
  variableModifiers type Identifier dimensions?
  ;

variableModifiers : 
  finalModifier modifiers
  | modifiers
  ;

finalModifier : 
  'final'
  ;

formalParameters : 
  '(' formalParameter ( 
    ',' formalParameter
  )* ')'
  | '(' ')'
  ;

declarator : 
  name dimensions? ( 
    '=' variableInitializer
  )?
  ;

declarators : 
  declarator ( 
    ',' declarator
  )*
  ;

classBody : 
  '{' declaration* '}'
  ;

declaration : 
  fieldDeclaration
  | methodDeclaration
  | constructorDeclaration
  | classDeclaration
  | interfaceDeclaration
  | blockDeclaration
  | emptyDeclaration
  ;

fieldDeclaration : 
  modifiers type declarators ';'
  ;

methodDeclaration : 
  modifiers resultType name formalParameters dimensions? 
  throwsClause? ( 
    block
    | ';'
  )
  ;

constructorDeclaration : 
  modifiers name formalParameters throwsClause? block
  ;

classDeclaration : 
  modifiers 'class' name extension? 
  implementation? classBody
  ;

interfaceDeclaration : 
  modifiers 'interface' name extension? classBody
  ;

blockDeclaration : 
  ( 
    'static'
  )? block
  ;

emptyDeclaration : 
  ';'
  ;

throwsClause : 
  'throws' qualifiedIdentifier ( 
    ',' qualifiedIdentifier
  )*
  ;

extension : 
  'extends' type ( 
    ',' type
  )*
  ;

implementation : 
  'implements' type ( 
    ',' type
  )*
  ;

block : 
  '{' declarationOrStatement* '}'
  ;

declarationOrStatement : 
  inBlockDeclaration
  | statement
  ;

inBlockDeclaration : 
  variableDeclaration
  | classDeclaration
  | interfaceDeclaration
  ;

variableDeclaration : 
  variableModifiers type declarators ';' 
//  @FieldDeclaration
  ;

statement : 
  block
  | conditionalStatement
  | forStatement
  | whileStatement
  | doWhileStatement
  | tryCatchFinallyStatement
  | switchStatement
  | synchronizedStatement
  | returnStatement
  | throwStatement
  | breakStatement
  | continueStatement
  | labeledStatement
  | expressionStatement
  | assertStatement
  | emptyStatement
  ;

conditionalStatement : 
  'if' parExpression statement 'else' statement
  | 'if' parExpression statement
  ;

forStatement : 
  'for' '(' forControl ')' statement
  ;

forControl : 
  basicForControl
  ;

basicForControl : 
  variableModifiers type declarators ';' expression? 
  ';' expressionList?
  | expressionList? ';' expression? 
  ';' expressionList?
  ;

whileStatement : 
  'while' parExpression statement
  ;

doWhileStatement : 
  'do' statement 'while' parExpression ';'
  ;

parExpression : 
  '(' expression ')'
  ;

tryCatchFinallyStatement : 
  'try' block catchClause* 'finally' block
  | 'try' block catchClause+
  ;

catchClause : 
  'catch' '(' formalParameter ')' block
  ;

switchStatement : 
  'switch' parExpression '{' switchClause* 
  '}'
  ;

switchClause : 
  caseClause
  | defaultClause
  ;

caseClause : 
  'case' expression ':' declarationOrStatement*
  ;

defaultClause : 
  'default' ':' declarationOrStatement*
  ;

synchronizedStatement : 
  'synchronized' parExpression block
  ;

returnStatement : 
  'return' expression? ';'
  ;

throwStatement : 
  'throw' expression ';'
  ;

breakStatement : 
  'break' Identifier? ';'
  ;

continueStatement : 
  'continue' Identifier? ';'
  ;

labeledStatement : 
  Identifier ':' statement
  ;

expressionStatement : 
  expression ';'
  ;

assertStatement : 
  'assert' expression ( 
    ':' expression
  )? ';'
  ;

emptyStatement : 
  ';'
  ;

expressionList : 
  expression ( 
    ',' expression
  )*
  ;

expression : 
  conditionalExpression assignmentOperator expression
  | conditionalExpression
  ;

assignmentOperator : 
  '='
  | '+='
  | '-='
  | '*='
  | '/='
  | '&='
  | '|='
  | '^='
  | '%='
  | '<<='
  | '>>='
  | '>>>='
  ;

conditionalExpression : 
  logicalOrExpression '?' expression ':' 
  conditionalExpression
  | logicalOrExpression
  ;

logicalOrExpression : 
  logicalAndExpression ('||' logicalAndExpression)*
  ;

logicalAndExpression : 
  bitwiseOrExpression ('&&' bitwiseOrExpression)*
  ;

bitwiseOrExpression : 
  bitwiseXorExpression ('|' bitwiseXorExpression)*
  ;

bitwiseXorExpression : 
  bitwiseAndExpression ('^' bitwiseAndExpression)*
  ;

bitwiseAndExpression : 
  equalityExpression ('&' equalityExpression)*
  ;

equalityExpression : 
  instanceOfExpression (equalityOperator instanceOfExpression)*
  ;

equalityOperator : 
  '=='
  | '!='
  ;

instanceOfExpression : 
  relationalExpression 'instanceof' type
  | relationalExpression
  ;

relationalExpression : 
  shiftExpression (relationalOperator shiftExpression)*
  ;

relationalOperator : 
  '<'
  | '>'
  | '<='
  | '>='
  ;

shiftExpression : 
  additiveExpression (shiftOperator additiveExpression)*
  ;

shiftOperator : 
  '<<'
  | '>>'
  | '>>>'
  ;

additiveExpression : 
  multiplicativeExpression (additiveOperator multiplicativeExpression)*
  ;

additiveOperator : 
  '+'
  | '-'
  ;

multiplicativeExpression : 
  unaryExpression (multiplicativeOperator unaryExpression)*
  ;

multiplicativeOperator : 
  '*'
  | '/'
  | '%'
  ;

unaryExpression : 
  '+' unaryExpression
  | '-' unaryExpression
  | '++' unaryExpression
  | '--' unaryExpression
  | unaryExpressionNotPlusMinus
  ;

unaryExpressionNotPlusMinus : 
  bitwiseNegationExpression
  | logicalNegationExpression
  | basicCastExpression
  | castExpression
  | postfixExpression
  ;

bitwiseNegationExpression : 
  '~' unaryExpression
  ;

logicalNegationExpression : 
  '!' unaryExpression
  ;

basicCastExpression : 
  '(' primitiveType dimensions? ')' unaryExpression
  ;

castExpression : 
  '(' type ')' unaryExpressionNotPlusMinus
  ;

postfixExpression :
	primaryExpression
 	(	'.' name arguments
 	|	'.' 'super' arguments
 	|	'.' 'super'
 	| 	'.' name
 	| 	'[' expression ']' 
 	| 	'++' 
 	| 	'--' 
 	| 	'.' 'new' typeName arguments classBody?
 	)*
  ;

primaryExpression : 
  literal
  | callExpression
  | classLiteralExpression
  | thisCallExpression
  | thisExpression
  | superCallExpression
  | superExpression
  | primaryIdentifier
  | newClassExpression
  | newArrayExpression
  | '(' expression ')'
  ;

callExpression : 
  name arguments
  ;

classLiteralExpression : 
  resultType '.' 'class'
  ;

thisCallExpression : 
  'this' arguments //@CallExpression
  ;

thisExpression : 
  ( 
    qualifiedIdentifier '.'
  )? 'this'
  ;

superCallExpression : 
  'super' arguments //@CallExpression
  ;

superExpression : 
  'super'
  ;

primaryIdentifier : 
  Identifier
  ;

newClassExpression : 
  'new' typeName arguments classBody?
  ;

newArrayExpression : 
  'new' typeName concreteDimensions dimensions?
  | 'new' typeName dimensions? arrayInitializer
  ;

concreteDimensions
	:  concreteDimension+
	;

concreteDimension : 
  '[' expression ']'
  ;

arrayInitializer : 
  '{' variableInitializer ( 
    ',' variableInitializer
  )* ( 
    ','
  )? '}'
  | '{' ( 
    ','
  )? '}'
  ;

variableInitializer : 
  arrayInitializer
  | expression
  ;

arguments : 
  '(' expression ( 
    ',' expression
  )* ')'
  | '(' ')'
  ;

resultType : 
  voidType
  | type
  ;

voidType : 
  'void'
  ;

type : 
  typeName dimensions?
  ;

typeName : 
  primitiveType
  | classType
  ;

primitiveType : 
  'byte'
  | 'short'
  | 'char'
  | 'int'
  | 'long'
  | 'float'
  | 'double'
  | 'boolean'
  ;

classType : 
  qualifiedIdentifier
  ;

dimensions : 
  ( 
    '[' ']'
  )+
  ;

literal : 
  FloatingPointLiteral
  | integerLiteral
  | CharacterLiteral
  | StringLiteral
  | booleanLiteral
  | nullLiteral
  ;

integerLiteral : 
  HexLiteral
  | OctalLiteral
  | DecimalLiteral
  ;
  
booleanLiteral : 
  'true'
  | 'false'
  ;

nullLiteral : 
  'null'
  ;

qualifiedIdentifier : 
  Identifier ( 
    '.' Identifier
  )*
  ;

// LEXER FROM SAMPLE ANTLR JAVA GRAMMAR

HexLiteral : '0' ('x'|'X') HexDigit+ IntegerTypeSuffix? ;

DecimalLiteral : ('0' | '1'..'9' '0'..'9'*) IntegerTypeSuffix? ;

OctalLiteral : '0' ('0'..'7')+ IntegerTypeSuffix? ;

fragment
HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
IntegerTypeSuffix : ('l'|'L') ;

FloatingPointLiteral
    :   ('0'..'9')+ '.' ('0'..'9')* Exponent? FloatTypeSuffix?
    |   '.' ('0'..'9')+ Exponent? FloatTypeSuffix?
    |   ('0'..'9')+ Exponent FloatTypeSuffix?
    |   ('0'..'9')+ FloatTypeSuffix
    ;

fragment
Exponent : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

fragment
FloatTypeSuffix : ('f'|'F'|'d'|'D') ;

CharacterLiteral
    :   '\'' ( EscapeSequence | ~('\''|'\\') ) '\''
    ;

StringLiteral
    :  '"' ( EscapeSequence | ~('\\'|'"') )* '"'
    ;

fragment
EscapeSequence
    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
    |   UnicodeEscape
    |   OctalEscape
    ;

fragment
OctalEscape
    :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7')
    ;

fragment
UnicodeEscape
    :   '\\' 'u' HexDigit HexDigit HexDigit HexDigit
    ;

Identifier
    :   Letter (Letter|JavaIDDigit)*
    ;

/**I found this char range in JavaCC's grammar, but Letter and Digit overlap.
   Still works, but...
 */
fragment
Letter
    :  '\u0024' |
       '\u0041'..'\u005a' |
       '\u005f' |
       '\u0061'..'\u007a' |
       '\u00c0'..'\u00d6' |
       '\u00d8'..'\u00f6' |
       '\u00f8'..'\u00ff' |
       '\u0100'..'\u1fff' |
       '\u3040'..'\u318f' |
       '\u3300'..'\u337f' |
       '\u3400'..'\u3d2d' |
       '\u4e00'..'\u9fff' |
       '\uf900'..'\ufaff'
    ;

fragment
JavaIDDigit
    :  '\u0030'..'\u0039' |
       '\u0660'..'\u0669' |
       '\u06f0'..'\u06f9' |
       '\u0966'..'\u096f' |
       '\u09e6'..'\u09ef' |
       '\u0a66'..'\u0a6f' |
       '\u0ae6'..'\u0aef' |
       '\u0b66'..'\u0b6f' |
       '\u0be7'..'\u0bef' |
       '\u0c66'..'\u0c6f' |
       '\u0ce6'..'\u0cef' |
       '\u0d66'..'\u0d6f' |
       '\u0e50'..'\u0e59' |
       '\u0ed0'..'\u0ed9' |
       '\u1040'..'\u1049'
   ;

WS  :  (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;}
    ;

COMMENT
    :   '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;}
    ;

LINE_COMMENT
    : '//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
    ;

// needed by Rats! grammar    
CTRLZ : '\u001a' ;


// ===========================================================================

