/*
 * xtc - The eXTensible Compiler
 * Copyright (C) 2004-2006 Robert Grimm
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
 * USA.
 */

/* modified from 

java xtc.parser.Rats -combined xtc/lang/C.rats > ~/research/papers/LL-star/PEG-ANTLR/C.rats

ANTLRWorks refactored left-recursion.

Move out lexer rules and replaced with lexer from sample ANTLR C grammar. 
"token" names are consistent with Rats! Java parser grammar.

Rats! Parser Generator, v. 1.15.0, (C) 2004-2009 Robert Grimm
Processing xtc/lang/C.rats ...
*/

// ===========================================================================
// Generated by Rats!, version 1.15.0, (C) 2004-2009 Robert Grimm.
// ===========================================================================

/**
 * A complete C grammar.
 * 
 * @author Robert Grimm
 * @version $Revision: 1.20 $
 */
grammar RatsC;

options {backtrack=true; memoize=true;}
//options {backtrack=true; memoize=true; output=AST;}
//options {backtrack=true; output=AST;}
//options {output=AST;}

//option withLocation, constant, flatten, flag(GCC, setOfString(C_KEYWORDS), 
//  flag(RELOCATE), flag(C99), stateful(xtc.lang.CParserState);
scope Symbols {
    Set types; // only track types in order to get parser working
}

@header {
import java.util.Set;
import java.util.HashSet;
}

@members {
	public boolean GCC = true;

    boolean isType(String name) {
        for (int i = Symbols_stack.size()-1; i>=0; i--) {
            Symbols_scope scope = (Symbols_scope)Symbols_stack.get(i);
            if ( scope.types.contains(name) ) {
                return true;    
            }           
        }       
        return false;
    }   
}

translationUnit 
scope Symbols; // entire file is a scope
@init {
  $Symbols::types = new HashSet();
}
	:	prelude externalDeclaration* annotations EOF ;

prelude : 
  Directive?
  ;

externalDeclaration
	:	declaration 
	|	functionDefinition
	|	assemblyDefinition
	|	emptyDefinition
  ;

functionDefinition
scope Symbols; // put parameters and locals into same scope for now
@init {
  $Symbols::types = new HashSet();
}
	:
	(  
    '__extension__'
  )? declarationSpecifiers? declarator 
  declarationList? compoundStatement
  ;

declarationList :
	declarationListEntry+
  ;

declarationListEntry :
	declaration
  ;

emptyDefinition :
  ';'
  ;

annotations :
  ;

declaration
scope {
  boolean isTypedef;
}
@init {
  $declaration::isTypedef = false;
}
	:
  (  
    '__extension__'
  )? declarationSpecifiers initializedDeclaratorList? 
  //&{ yyState.isValid(l) }
  ';'
  ;

declarationSpecifiers :
  declarationSpecifierPlus
  ;

declarationSpecifierPlus :
  declarationSpecifier+
  ;

declarationSpecifier :
	storageClassSpecifier
	|	typeSpecifier 
	|	typeQualifier
	|	functionSpecifier
	|	attributeSpecifier
  ;

initializedDeclaratorList :
	initializedDeclarator (  
    ',' initializedDeclarator
  )*
  ;

initializedDeclarator :
  attributeSpecifierList? declarator ({GCC}? simpleAssemblyExpression|) // added gcc test
  attributeSpecifierList? (  
    '=' initializer
  )?
  ;

storageClassSpecifier :
	autoSpecifier
	|	externSpecifier
	|	registerSpecifier
	|	staticSpecifier
	|	threadSpecifier
	|	typedefSpecifier
  ;

autoSpecifier :
  'auto'
  ;

externSpecifier :
  'extern'
  ;

registerSpecifier :
  'register'
  ;

staticSpecifier :
  'static'
  ;

threadSpecifier :
  '__thread'
  ;

typedefSpecifier :
  'typedef' {$declaration::isTypedef=true;}
  ;

typeQualifier :
	volatileQualifier
	|	constantQualifier
	|	restrictQualifier
  ;

volatileQualifier :
  'volatile'
  | '__volatile'
  | '__volatile__'
  ;

constantQualifier :
  'const'
  | '__const'
  | '__const__'
  ;

restrictQualifier :
  'restrict'
  | '__restrict'
  | '__restrict__'
  ;

functionSpecifier :
  'inline'
  | '__inline'
  | '__inline__'
  ;

typeSpecifier :
	enumerationTypeSpecifier
	|	structureTypeSpecifier
	|	unionTypeSpecifier
	|	floatingPointTypeSpecifier
	|	integerTypeSpecifier
	|	typedefName
	|	typeofSpecifier
	|	voidTypeSpecifier
	|	varArgListSpecifier
  ;

enumerationTypeSpecifier
scope Symbols; // structs are scopes
@init {
  $Symbols::types = new HashSet();
}
	:
	enumerationTypeDefinition
	|	enumerationTypeReference
  ;

enumerationTypeDefinition :
	'enum' attributeSpecifierList? enumerationTag? 
  '{' enumeratorList (  
    ','
  )? '}' attributeSpecifierList?
  ;

enumerationTag :
  Identifier
  ;

enumeratorList :
	enumerator (  
    ',' enumerator
  )*
  ;

enumerator :
	Identifier (  
    '=' constantExpression
  )?
  ;

enumerationTypeReference :
	'enum' attributeSpecifierList? enumerationTag
  ;

structureTypeSpecifier
scope Symbols; // structs are scopes
@init {
  $Symbols::types = new HashSet();
}
	:
	structureTypeDefinition
	|	structureTypeReference
  ;

structureTypeDefinition :
	'struct' attributeSpecifierList? structureTag? 
  '{' structureDeclarationList 
  '}' attributeSpecifierList?
  ;

structureTypeReference :
	'struct' attributeSpecifierList? structureTag
  ;

structureTag :
	Identifier
  ;

unionTypeSpecifier :
	unionTypeDefinition
	|	unionTypeReference
  ;

unionTypeDefinition :
	'union' attributeSpecifierList? unionTag? 
  '{' structureDeclarationList 
  '}' attributeSpecifierList?
  ;

unionTypeReference :
	'union' attributeSpecifierList? unionTag
  ;

unionTag :
	Identifier
  ;

structureDeclarationList :
	annotatedStructureDeclaration+ annotations
	|	{GCC}? annotations
  ;

annotatedStructureDeclaration :
  structureDeclaration 
  ;

structureDeclaration :
	(   '__extension__'  )?
	specifierQualifierList optionalStructureDeclaratorList ';'
	(  {GCC}? ';'+ 
	|
	)
  ;

specifierQualifierList :
  specifierQualifierPlus
  ;

specifierQualifierPlus :
  specifierQualifier+
  ;

specifierQualifier :
		typeSpecifier
	|	typeQualifier
	|	attributeSpecifier
  ;

optionalStructureDeclaratorList :
		structureDeclaratorList
	|	{GCC}? 
  ;

structureDeclaratorList :
	structureDeclarator (  
    ',' structureDeclarator
  )*
  ;

structureDeclarator :
	bitField
	|	attributedDeclarator
  ;

bitField :
  attributeSpecifierList? declarator? ':' constantExpression 
  attributeSpecifierList?
  ;

attributedDeclarator :
  attributeSpecifierList? declarator attributeSpecifierList?
  ;

declarator :
		pointerDeclarator
	|	directDeclarator
	;

pointerDeclarator :
  pointer directDeclarator
  ;

pointer :
  '*' typeQualifierList pointer?
  ;

typeQualifierList :
  (  
    typeQualifier
    | attributeSpecifier
  )*
  ;

directDeclarator :
	( '(' attributedDeclarator ')' | simpleDeclarator )
	(	'(' parameterTypeList ')' 
	|	'(' identifierList? ')'
	|	'[' arrayQualifierList arraySizeExpression? ']'
	|	'[' arrayQualifierList variableLength ']'
	)*
  ;

variableLength :
  '*'
  ;

simpleDeclarator :
	Identifier
    {
       if ($declaration.size()>0&&$declaration::isTypedef) {
           $Symbols::types.add($Identifier.text);
           System.out.println("define type "+$Identifier.text);
       }
    }
  ;

parameterTypeList :
  parameterList (  
    ',' '...'
  )?
  ;

parameterList :
  parameterDeclaration (  
    ',' parameterDeclaration
  )*
  ;

parameterDeclaration :
		declarationSpecifiers declarator attributeSpecifierList?
	|	declarationSpecifiers abstractDeclarator? attributeSpecifierList?
	;

attributedAbstractDeclarator :
  attributeSpecifierList? abstractDeclarator
  ;

// avoided predicate &{ (null != p) || (null != d) } by delineating
abstractDeclarator :
		pointer directAbstractDeclarator
	|	directAbstractDeclarator
	;

directAbstractDeclarator :
		(	'(' attributedAbstractDeclarator ')'
		|	
		)
		(	'[' assignmentExpression? ']'
		|	'[' variableLength ']'
		|	'(' parameterTypeList? ')'
		)*
  ;

identifierList :
  Identifier (  
    ',' Identifier
  )*
  ;

arrayQualifierList :
  (  
    arrayQualifier
    | attributeSpecifier
  )*
  ;

arrayQualifier :
	staticSpecifier
	|	volatileQualifier
	|	restrictQualifier
	|	constantQualifier
  ;

floatingPointTypeSpecifier :
	complex
	|	double_
	|	float_
  ;

complex :
  '_Complex'
  | '__complex__'
  ;

double_ :
  'double'
  ;

float_ :
  'float'
  ;

integerTypeSpecifier :
	long_
	|	int_
	|	short_
	|	char_
	|	bool
	|	unsigned_
	|	signed
  ;

long_ :
  'long'
  ;

int_ :
  'int'
  ;

short_ :
  'short'
  ;

char_ :
  'char'
  ;

bool :
  '_Bool'
  ;

unsigned_ :
  'unsigned'
  ;

signed :
  'signed'
  | '__signed'
  | '__signed__'
  ;

typedefName :
   {isType(input.LT(1).getText())}? Identifier
   {System.out.println($Identifier.text+" is a type");}
  ;

typeofSpecifier :
	typeofKeyword '(' typeName ')'
	|	typeofKeyword '(' expression ')'
  ;

typeofKeyword :
  'typeof'
  | '__typeof'
  | '__typeof__'
  ;

voidTypeSpecifier :
  'void'
  ;

varArgListSpecifier :
  '__builtin_va_list'
  ;

initializer :
	'{' initializerList (  
    ','
  )? '}'
	|	assignmentExpression
  ;

initializerList :
  initializerListEntry (  
    ',' initializerListEntry
  )*
  | {GCC}?
  ;

initializerListEntry :
  designation? initializer
  ;

designation :
	designator+ '='
	|	{GCC}? obsoleteArrayDesignation
	|	{GCC}? obsoleteFieldDesignation
  ;

designator :
	'[' constantExpression ']'
	|	{GCC}? '[' constantExpression '...' 
  constantExpression ']'
	|	'.' primaryIdentifier
  ;

obsoleteArrayDesignation :
	'[' constantExpression ']'
	|	'[' constantExpression '...' 
  constantExpression ']'
  ;

obsoleteFieldDesignation :
  Identifier ':'
  ;

typeName :
  specifierQualifierList abstractDeclarator?
  ;

attributeSpecifierList :
  attributeSpecifierPlus
  ;

attributeSpecifierPlus :
  attributeSpecifier+
  ;

attributeSpecifier :
  attributeKeyword '(' '(' attributeList? ')' ')'
  ;

attributeKeyword :
  '__attribute'
  | '__attribute__'
  ;

attributeList :
  attributeListEntry (  
    ',' attributeListEntry
  )*
  ;

attributeListEntry :
  identifierOrAttrKeyword (  
    '(' expressionList? ')'
  )?
  ;

identifierOrAttrKeyword
	: Identifier | '__alignof'|   '__alignof__'|
      'asm'|         '__asm'|         '__asm__'|
      '__attribute'| '__attribute__'|
      '__builtin_offsetof'|
      '__builtin_types_compatible_p'|
      '__builtin_va_arg'|             '__builtin_va_list'|
      '__complex__'|
      '__const'|     '__const__'|
      '__extension__'|
      '__inline'|    '__inline__'|
      '__label__'|
      '__restrict'|  '__restrict__'|
      '__signed'|    '__signed__'|
      '__thread'|
      'typeof'|      '__typeof'|      '__typeof__'|
      '__volatile'|  '__volatile__'
	;

statement :
	expressionStatement
	|	compoundStatement
	|	conditionalStatement
	|	iterationStatement
	|	switchStatement
	|	labeledStatement
	|	breakStatement
	|	continueStatement
	|	returnStatement
	|	gotoStatement
	|	assemblyStatement
	|	emptyStatement
  ;

labeledStatement :
	label statement
	| {GCC}? label 
  ;

label :
	namedLabel
	|	caseLabel
	|	defaultLabel
  ;

namedLabel :
	Identifier ':' attributeSpecifierList?
  ;

defaultLabel :
  'default' ':'
  ;

caseLabel :
	{GCC}? 'case' constantExpression '...' 
  constantExpression ':'
	|	'case' constantExpression ':'
  ;

compoundStatement
scope Symbols; // blocks have a scope of symbols
@init {
  $Symbols::types = new HashSet();
}
	:
	'{' localLabelDeclarationStar declarationOrStatementStar annotations '}' 
  ;

localLabelDeclarationStar :
  localLabelDeclaration*
  ;

localLabelDeclaration :
  '__label__' Identifier (  
    ',' Identifier
  )* ';'
  ;

declarationOrStatementStar :
  declarationOrStatement*
  ;

declarationOrStatement :
	declaration 
	|	statement
  ;

conditionalStatement :
	ifElseStatement
	|	ifStatement
  ;

ifElseStatement :
  'if' '(' expression ')' statement 
  'else' statement
  ;

ifStatement :
  'if' '(' expression ')' statement
  ;

iterationStatement :
	whileStatement
	|	doStatement
	|	forStatement
  ;

whileStatement :
  'while' '(' expression ')' statement
  ;

doStatement :
  'do' statement 'while' '(' expression 
  ')' ';'
  ;

forStatement :
  'for' '(' initialClause expression? ';' expression? ')' statement  ;

initialClause :
	declaration
	|	expression? ';'
  ;

switchStatement :
  'switch' '(' expression ')' statement
  ;

breakStatement :
  'break' ';'
  ;

continueStatement :
  'continue' ';'
  ;

returnStatement :
  'return' expression? ';'
  ;

gotoStatement :
	'goto' primaryIdentifier ';'
	|	{GCC}? 'goto' '*' expression 
  ';'
  ;

expressionStatement :
  expression ';'
  ;

emptyStatement :
  ';'
  ;

expression :
  commaExpression
  ;

commaExpression :
	(assignmentExpression) (',' assignmentExpression)*
  ;

arraySizeExpression :
  assignmentExpression
  ;

assignmentExpression :
	unaryExpression assignmentOperator assignmentExpression
	|	conditionalExpression
  ;

assignmentOperator :
	'='
	|	'+='
	|	'-='
	|	'*='
	|	'/='
	|	'%='
	|	'<<='
	|	'>>='
	|	'&='
	|	'^='
	|	'|='
  ;

constantExpression :
  conditionalExpression
  ;

conditionalExpression :
	logicalOrExpression '?' expression ':'  conditionalExpression
	|	{GCC}? logicalOrExpression '?'  ':' conditionalExpression
	|	logicalOrExpression
  ;

logicalOrExpression :
	(logicalAndExpression) ('||' logicalAndExpression)*
  ;

logicalAndExpression :
	(bitwiseOrExpression) ('&&' bitwiseOrExpression)*
  ;

bitwiseOrExpression :
	(bitwiseXorExpression) ('|' bitwiseXorExpression)*
  ;

bitwiseXorExpression :
	(bitwiseAndExpression) ('^' bitwiseAndExpression)*
  ;

bitwiseAndExpression :
	(equalityExpression) ('&' equalityExpression)*
  ;

equalityExpression :
	(relationalExpression) (equalityOperator relationalExpression)*
  ;

equalityOperator :
	'=='
	|	'!='
  ;

relationalExpression :
	(shiftExpression) (relationalOperator shiftExpression)*
  ;

relationalOperator :
	'<='
	|	'<'
	|	'>='
	|	'>'
  ;

shiftExpression :
	(additiveExpression) (shiftOperator additiveExpression)*
  ;

shiftOperator :
	'<<'
	|	'>>'
  ;

additiveExpression :
	(multiplicativeExpression) (additiveOperator multiplicativeExpression)*
  ;

additiveOperator :
	'+'
	|	'-'
  ;

multiplicativeExpression :
	(castExpression) (multiplicativeOperator castExpression)*
  ;

multiplicativeOperator :
	'*'
	|	'/'
	|	'%'
  ;

castExpression :
	'(' typeName ')' castExpression
	|	unaryExpression
  ;

unaryExpression :
	sizeofExpression
	|	alignofExpression
	|	offsetofExpression
	|	typeCompatibilityExpression
	|	unaryMinusExpression
	|	unaryPlusExpression
	|	logicalNegationExpression
	|	bitwiseNegationExpression
	|	addressExpression
	|	labelAddressExpression
	|	indirectionExpression
	|	preincrementExpression
	|	predecrementExpression
	|	extensionExpression
	|	postfixExpression
  ;

sizeofExpression
	:	'sizeof' unaryExpression {System.out.println("sizeof unary: "+$text);}
	|	'sizeof' '(' typeName ')' {System.out.println("sizeof type: "+$text);} //!('{') 
    ;

alignofExpression
	:	alignofKeyword unaryExpression
	|	alignofKeyword '(' typeName ')' //!('{')
	;

alignofKeyword :
  '__alignof__'
  | '__alignof'
  ;

offsetofExpression :
  '__builtin_offsetof' '(' typeName ',' 
  postfixExpression ')'
  ;

typeCompatibilityExpression :
  '__builtin_types_compatible_p' '(' typeName 
  ',' typeName ')'
  ;

unaryMinusExpression :
  '-' castExpression
  ;

unaryPlusExpression :
  '+' castExpression
  ;

logicalNegationExpression :
  '!' castExpression
  ;

bitwiseNegationExpression :
  '~' castExpression
  ;

addressExpression :
  '&' castExpression
  ;

indirectionExpression :
  '*' castExpression
  ;

preincrementExpression :
  '++' unaryExpression
  ;

predecrementExpression :
  '--' unaryExpression
  ;

labelAddressExpression :
	{GCC}?'&&' Identifier
  ;

extensionExpression :
	{GCC}? '__extension__' castExpression
  ;

postfixExpression :
	(compoundLiteral | primaryExpression)
	('[' expression ']'
	 | '.' Identifier
	  | '->' Identifier
	   | '(' expressionList? ')'
	    | '++'
	     | '--')*
  ;

expressionList :
	assignmentExpression (  
    ',' assignmentExpression
  )*
  ;

compoundLiteral :
  '(' typeName ')' '{' initializerList (',')? '}'
  ;

primaryExpression :
	constant
	|	primaryIdentifier
	|	statementAsExpression
	|	variableArgumentAccess
	|	'(' expression ')'
  ;

primaryIdentifier :
  Identifier
  ;


statementAsExpression :
  {GCC}? '(' compoundStatement ')'
  ;

variableArgumentAccess :
  '__builtin_va_arg' '(' assignmentExpression 
  ',' typeName ')'
  ;

assemblyDefinition :
  simpleAssemblyExpression ';'
  ;

simpleAssemblyExpression :
  asmKeyword '(' StringConstant ')'
  ;

assemblyStatement :
  asmKeyword typeQualifier? '(' assemblyArgument ')' 
  ';'
  ;

assemblyArgument :
    StringConstant ':' assemblyOperands? ':' assemblyOperands? ':' assemblyClobbers
  | StringConstant ':' assemblyOperands? ':' assemblyOperands?
  | StringConstant ':' assemblyOperands?
  | StringConstant
  ;

assemblyOperands :
  assemblyOperand (  
    ',' assemblyOperand
  )*
  ;

assemblyOperand :
  (  
    '[' Identifier ']'
  )? StringConstant '(' expression ')'
  ;

assemblyClobbers :
  StringConstant (  
    ',' StringConstant
  )*
  ;

asmKeyword :
  'asm'
  | '__asm'
  | '__asm__'
  ;

constant :
  FloatingConstant
  | integerConstant
  | CharacterConstant
  | StringConstant
  ;

integerConstant :
	HexConstant
	|	OctalConstant
	|	DecimalConstant
  ;

Identifier
	:	LETTER (LETTER|'0'..'9')*
	;
	
fragment
LETTER
	:	'A'..'Z'
	|	'a'..'z'
	|	'_'
	;

CharacterConstant
    :   '\'' ( EscapeSequence | ~('\''|'\\') ) '\''
    ;

StringConstant
	:	STRING (WS STRING)* WS?
	;

fragment
STRING
    :  '"' ( EscapeSequence | ~('\\'|'"') )* '"'
    ;

HexConstant : '0' ('x'|'X') HexDigit+ IntegerTypeSuffix? ;

DecimalConstant : ('0' | '1'..'9' '0'..'9'*) IntegerTypeSuffix? ;

OctalConstant : '0' ('0'..'7')+ IntegerTypeSuffix? ;

fragment
HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
IntegerTypeSuffix
	:	('u'|'U')
	|	('l'|'L')
	|	('u'|'U') ('l'|'L')
	;

FloatingConstant
    :   ('0'..'9')+ '.' ('0'..'9')* Exponent? FloatTypeSuffix?
    |   '.' ('0'..'9')+ Exponent? FloatTypeSuffix?
    |   ('0'..'9')+ Exponent FloatTypeSuffix
    |   ('0'..'9')+ Exponent
    |   ('0'..'9')+ FloatTypeSuffix
	;

fragment
Exponent : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

fragment
FloatTypeSuffix : ('f'|'F'|'d'|'D') ;

fragment
EscapeSequence
    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
    |   OctalEscape
    ;

fragment
OctalEscape
    :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7')
    ;

fragment
UnicodeEscape
    :   '\\' 'u' HexDigit HexDigit HexDigit HexDigit
    ;

SKIPWS : WS {skip();} ;

fragment
WS  :  (' '|'\r'|'\t'|'\u000C'|'\n')+
    ;

COMMENT
    :   '/*' ( options {greedy=false;} : . )* '*/' {skip();}
    ;

LINE_COMMENT
    : '//' ~('\n'|'\r')* '\r'? '\n' {skip();}
    ;

// ignore #line info for now
Directive
    : '#' ~('\n'|'\r')* '\r'? '\n' {skip();}
    ;

// ===========================================================================

