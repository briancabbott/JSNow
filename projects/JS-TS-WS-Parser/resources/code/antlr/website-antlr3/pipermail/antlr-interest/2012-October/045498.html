<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Way to &quot;cut&quot; parsing?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Way%20to%20%22cut%22%20parsing%3F&In-Reply-To=%3CCAN1YFWteiYjFNOtgeeTM4imyRkbG0vduF5B242SWWzS_2xf8xA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="045497.html">
   <LINK REL="Next"  HREF="045499.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Way to &quot;cut&quot; parsing?</H1>
    <B>Juancarlo A&#241;ez</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Way%20to%20%22cut%22%20parsing%3F&In-Reply-To=%3CCAN1YFWteiYjFNOtgeeTM4imyRkbG0vduF5B242SWWzS_2xf8xA%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Way to &quot;cut&quot; parsing?">apalala at gmail.com
       </A><BR>
    <I>Mon Oct 15 21:34:02 PDT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="045497.html">[antlr-interest] Way to &quot;cut&quot; parsing?
</A></li>
        <LI>Next message: <A HREF="045499.html">[antlr-interest] Way to &quot;cut&quot; parsing?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45498">[ date ]</a>
              <a href="thread.html#45498">[ thread ]</a>
              <a href="subject.html#45498">[ subject ]</a>
              <a href="author.html#45498">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>If you are using the backtrack = true option, then that is how it works.


I'm not using the bactrack option, but a lot of backtracking goes on when I
look at the trace output.

I'm using the Python target.

As I mentioned, the grammar makes heavy use of ()=&gt; lookaheads to resolve
the many ambiguities in the language.

The language is AG Natural, in which there are no statement terminators
except for some statements that contain other statements, and in which 4
out of 5 keywords in a statement are optional.

The parser is complete as of the current test harness. I need to make it
behave more reasonably before new test cases arrive.

I wish to be able to tell the parser to stop looking for alternatives after
a given set of keywords have been scanned. If it wend down from the
&quot;statement&quot; rule, into the &quot;upload&quot; rule, it should fail if can't parse the
phrase after the &quot;UPLOAD&quot; keyword, and not backtrack to tell me that the
enclosing &quot;IF&quot; did not parse.

When I wrote grammars in Prolog, I could resource to the &quot;!&quot; (cut, or
&quot;commit to this rule&quot;) expression to ease the parser's work. I'm looking
for something like that in ANTLR. I don't care about error recovery. Having
an error message exactly at the point on which the parser couldn't go on
would be perfect. I have a ~3000 LOC grammar, and test cases on the
500-1000LOC. I need the parser to be efficient and pragmatic.

... and, I can't port to ANTLRv4 until there's news about it's Python
target.

Thanks again,

-- 
Juancarlo *A&#241;ez*
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="045497.html">[antlr-interest] Way to &quot;cut&quot; parsing?
</A></li>
	<LI>Next message: <A HREF="045499.html">[antlr-interest] Way to &quot;cut&quot; parsing?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45498">[ date ]</a>
              <a href="thread.html#45498">[ thread ]</a>
              <a href="subject.html#45498">[ subject ]</a>
              <a href="author.html#45498">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
