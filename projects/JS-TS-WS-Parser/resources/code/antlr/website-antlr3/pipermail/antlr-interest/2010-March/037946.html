<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Gated semantic predicates - performance problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Gated%20semantic%20predicates%20-%20performance%20problem&In-Reply-To=%3Ca382aa011003151319q36553471i20ac6407161a9a68%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="037940.html">
   <LINK REL="Next"  HREF="037942.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Gated semantic predicates - performance problem</H1>
    <B>Andrew Haritonkin</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Gated%20semantic%20predicates%20-%20performance%20problem&In-Reply-To=%3Ca382aa011003151319q36553471i20ac6407161a9a68%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Gated semantic predicates - performance problem">thikone at gmail.com
       </A><BR>
    <I>Mon Mar 15 13:19:18 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="037940.html">[antlr-interest] Gated semantic predicates - performance problem
</A></li>
        <LI>Next message: <A HREF="037942.html">[antlr-interest] Gated semantic predicates - performance problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37946">[ date ]</a>
              <a href="thread.html#37946">[ thread ]</a>
              <a href="subject.html#37946">[ subject ]</a>
              <a href="author.html#37946">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2010/3/15 Marcin Rze&#378;nicki &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">marcin.rzeznicki at gmail.com</A>&gt;:
&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, Mar 15, 2010 at 2:25 PM, Andrew Haritonkin &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">thikone at gmail.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hello everyone,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> While writing grammar for PL/SQL I have encountered a problem with
</I>&gt;&gt;<i> performance of generated code.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Hi Andrew,
</I>&gt;<i> First of all - I am not sure why do you need predicates in this part of your
</I>&gt;<i> grammar. In case you haven't got an ambiguity, and I can't spot it in your
</I>&gt;<i> grammar, predicates are not needed at all. They could help if, let's say, OR
</I>&gt;<i> could be unary, where parser could not by itself decide whether 'OR' in:
</I>&gt;<i> condition_and OR condition_and &#160;means binary or unary OR (assuming&#160;unary OR
</I>&gt;<i> exists and you have somewhere construct that chains conditions together).
</I>&gt;<i> Perhaps I am missing something so please clarify.
</I>&gt;<i> On the other hand, the quality of code generated by ANTLR is very low. I
</I>&gt;<i> have long stopped using generated code &quot;as is&quot; and perform various
</I>&gt;<i> &quot;amendments&quot; manually, which is painful if you care for automated build
</I>&gt;<i> process. It can be argued that you do not need maintainable code with parser
</I>&gt;<i> generator, but I suppose that not only maintainability, but also performance
</I>&gt;<i> suffers due to lousy code generation. Counter-argument that ANTLR code-gen
</I>&gt;<i> is supposed to be human-readable fails miserably with invention of clever
</I>&gt;<i> DFAs state encoding scheme. My favorite example is:
</I>&gt;<i> if ((LA6_0 == '\t' || (LA6_0 &gt;= ' ' &amp;&amp; LA6_0 &lt;= '$')
</I>&gt;<i> || (LA6_0 &gt;= '&amp;' &amp;&amp; LA6_0 &lt;= '~')
</I>&gt;<i> || (LA6_0 &gt;= '\u00A0' &amp;&amp; LA6_0 &lt;= '\uD7FF') || (LA6_0 &gt;= '\uDC00' &amp;&amp; LA6_0
</I>&gt;<i> &lt;= '\uFFFF'))) {
</I>&gt;<i> alt6 = 1;
</I>&gt;<i> } else if (((LA6_0 &gt;= '\uD800' &amp;&amp; LA6_0 &lt;= '\uDBFF'))) {
</I>&gt;<i> alt6 = 2;
</I>&gt;<i> } else {
</I>&gt;<i> NoViableAltException nvae = new NoViableAltException(
</I>&gt;<i> &quot;&quot;,
</I>&gt;<i> 6,
</I>&gt;<i> 0,
</I>&gt;<i> input);
</I>&gt;<i> throw nvae;
</I>&gt;<i> }
</I>&gt;<i> which is followed, within the same method, just two lines below, by:
</I>&gt;<i> if (input.LA(1) == '\t'
</I>&gt;<i> || (input.LA(1) &gt;= ' ' &amp;&amp; input.LA(1) &lt;= '$')
</I>&gt;<i> || (input.LA(1) &gt;= '&amp;' &amp;&amp; input.LA(1) &lt;= '~')
</I>&gt;<i> || (input.LA(1) &gt;= '\u00A0' &amp;&amp; input.LA(1) &lt;= '\uD7FF')
</I>&gt;<i> || (input.LA(1) &gt;= '\uDC00' &amp;&amp; input.LA(1) &lt;= '\uFFFF')) {
</I>&gt;<i> input.consume();
</I>&gt;<i> }
</I>&gt;<i> Let's hope that JIT can eliminate common input.LA(1) calls, but I wouldn't
</I>&gt;<i> count on it.
</I>&gt;<i> Parser code also suffers from mess of unread yet initialized variables which
</I>&gt;<i> may significantly raise GC pressure and lower performance due to constant
</I>&gt;<i> creation of unneeded objects (possibly eliminated by Escape Analysis ?).
</I>&gt;<i> Also, tons of unneeded null checks, static inner classes that can be
</I>&gt;<i> eliminated or merged (DFAs also rule results sometimes) add up to the
</I>&gt;<i> overall&#160;picture. I really hope some of this problems will be fixed with new
</I>&gt;<i> releases and I keep my fingers crossed.
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Greetings
</I>&gt;<i> Marcin Rze&#378;nicki
</I>&gt;<i>
</I>
Sorry, there is a mistake in one rule:

condition_not
       :       ( 'NOT' )? expression_add
       ;

Predicates needed because condition rules reuse expression rules. But
for recursion in the end of expression chain I need to go to right top
level rule. Either condition top rule or expression top rule.

For example, if we parse condition call stack might look like this:

sql_condition
condition_or
condition_and
condition_not
expression_add
expression_mul
expression_sign
expression_expr
expression_par  &lt;-- at this point we need to go to condition_or
condition_or
condition_and
...
and so on.

In case of expression call stack will be different:

sql_expression
expression_add
expression_mul
expression_sign
expression_expr
expression_par  &lt;-- at this point we need to go to expression_add, not
condition_or!
expression_add
expression_mul
...
and so on.

As you may notice, expression_par rule calls top rule recursively. But
which top rule depends on how it started - from sql_condition or from
sql_expression. That's the place where gated semantic predicate is
needed.

Unfortunately, I don't see how to do it in efficient way. Since
predicates, even gated semantic predicates, evaluated after prediction
(predicates embedded in DFA as last conditions for each possible
path).

Is it possible to shut down lookahead completely (k = 0) and just take
first path for which predicate is evaluated as true?

Andrew
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="037940.html">[antlr-interest] Gated semantic predicates - performance problem
</A></li>
	<LI>Next message: <A HREF="037942.html">[antlr-interest] Gated semantic predicates - performance problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37946">[ date ]</a>
              <a href="thread.html#37946">[ thread ]</a>
              <a href="subject.html#37946">[ subject ]</a>
              <a href="author.html#37946">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
