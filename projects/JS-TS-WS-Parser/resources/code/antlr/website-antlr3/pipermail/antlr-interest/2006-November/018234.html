<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=C40CD76A-070A-4AC9-9DCA-E0BEBA0A43DE%40classdump.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018229.html">
   <LINK REL="Next"  HREF="018235.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=C40CD76A-070A-4AC9-9DCA-E0BEBA0A43DE%40classdump.org"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Thu Nov  2 11:48:43 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018229.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018235.html">[antlr-interest] (not really about) philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18234">[ date ]</a>
              <a href="thread.html#18234">[ thread ]</a>
              <a href="subject.html#18234">[ subject ]</a>
              <a href="author.html#18234">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Kay Roepke wrote:

&gt;<i>
</I>&gt;<i> On 2. Nov 2006, at 17:10 , Andy Tripp wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> No, I don't mean &quot;...*dont need* to be an expert&quot;, but rather &quot;dont  
</I>&gt;&gt;<i> need to know about the layers below&quot;. Java is great
</I>&gt;&gt;<i> because it doesn't require any knowledge about memory management,  
</I>&gt;&gt;<i> for example. The tool should let you
</I>&gt;&gt;<i> only be an expert *at one level of abstraction*. I can program in  
</I>&gt;&gt;<i> Java without knowing (almost) any details about
</I>&gt;&gt;<i> any of the underlying layers.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> IMHO the problem with this approach is that people who started out  
</I>&gt;<i> with no knowledge about memory management at all, will not get it  
</I>&gt;<i> afterwards, most of the time. They've been spoiled. 
</I>
Right, just as the car driver is spoiled by not having to know how the 
car works....i.e. &quot;spoiled&quot; is a good thing here.

&gt;<i> The fact that I  sometimes would like not having to care about memory 
</I>&gt;<i> management  doesn't say that I want to have to use it all the time.
</I>
And you can tinker under your car's hood all you want, no problem.
The main point is that the automatic transmission is a good design, 
because it hides the user from the underlying
&quot;gears&quot; layer. At home, I prefer to drive a stick because it's fun. But 
at work, I don't prefer to see bytecode, because
I don't find that fun.

&gt;<i> Sometimes I  need to be able to specify data locality for performance 
</I>&gt;<i> reasons.  Java, AFAIK, doesn't allow me to do that, so it's out.
</I>
If you're talking about the C &quot;register&quot; keyword, C and C++ don't 
usually allow you to do that anymore either :)
Most modern C and C++ compilers ignore the &quot;register&quot; keyword, or so 
I've heard.

&gt;<i> In other words, Java not only doesn't require the knowledge, it  
</I>&gt;<i> actively prevents you from gaining that knowledge. 
</I>
Yes, just as the automatic transmission prevents you from even knowing 
how many gears your car has.
That's not a big issue with cars, as most people can shift as well as an 
automatic.
But with programming languages it's important, because most of the time,
when people access those underlying layers (doing their own memory 
management, guessing which
variables should be &quot;register&quot;, etc), they don't do it as well as the 
machine.

&gt;<i> To return briefly  to the distinction of &quot;great&quot; vs. &quot;popular&quot; and 
</I>&gt;<i> what constitutes  greatness:
</I>&gt;<i> Whatever you may think of Perl and Larry Wall, one motto is  
</I>&gt;<i> describing this situation perfectly: &quot;Making easy things easy and  
</I>&gt;<i> hard things possible.&quot;
</I>&gt;<i> Java isn't great (for me), because it locks me in. I'd prefer a  
</I>&gt;<i> system/language that makes the normal case easy, allows me to be  
</I>&gt;<i> sloppy if I wanted to just hack it down to get it working. But at the  
</I>&gt;<i> same time it shouldn't get in the way if I want to write very tight  
</I>&gt;<i> code - tight in terms of memory usage, code size and runtime  
</I>&gt;<i> performance.
</I>
Just stick with Java long enough to &quot;get it&quot;. I went through several 
weeks of trying to &quot;really get&quot; OO, and it was tough going.
After a couple of months, I was as comfortable with Java as with C/C++. 
After a year or so, I felt that
I was several times more productive in Java, and there was no turning back.

&gt;<i>
</I>&gt;&gt;<i> Maybe. From my experience, almost always when someone says &quot;I need  
</I>&gt;&gt;<i> to set individual bits by hand,
</I>&gt;&gt;<i> so Java isn't a good fit&quot;, it turns out that in fact he does not  
</I>&gt;&gt;<i> need to set individual bits by hand, and Java will
</I>&gt;&gt;<i> work just fine. He just thinks he needs to bit-twiddle because  
</I>&gt;&gt;<i> that's how he's used to doing things, and he
</I>&gt;&gt;<i> wouldn't even think to just use an array of booleans because he  
</I>&gt;&gt;<i> can't make that mental leap.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I shudder at the thought of a bitvector as an array of booleans.  
</I>&gt;<i> Sure, if I have an vector of YES/NO information I think of it as  
</I>&gt;<i> exactly that, and I might even implement a very quick and dirty  
</I>&gt;<i> version that way (if there isn't already a class that handles this  
</I>&gt;<i> particular case for me - I'm thinking in OO terms here, but the same  
</I>&gt;<i> applies to procedural languages), but eventually I would want to  
</I>&gt;<i> optimize it. If you then tell me that the language cannot do it, I  
</I>&gt;<i> think I'm justified in saying &quot;What a crappy language is this?&quot;. The  
</I>&gt;<i> fact that this person thinks he must fiddle with bits is based on  
</I>&gt;<i> experience: The array approach is slow and wasteful, whatever the  
</I>&gt;<i> language.
</I>&gt;<i> I'm no child, I'm a programmer - why prevent me from accessing  
</I>&gt;<i> computer specific details from me?
</I>
That's a great example. You make the assumption that an array of 
booleans is somehow going to be slower or use more memory
than a bitvector. You've got to let that old thinking go, Luke! You 
worry about your application and pick the appropriate
data structure for it. Let the compiler and runtime be smart about 
performance and memory management. It is better at
those things than you are (and certainly better than you think it is).

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> For the record, any Java program I have used has amazed me with a  
</I>&gt;<i> huge waste of resources. A comparable C/C++-based implementation has  
</I>&gt;<i> in all cases been order of magnitude faster and at the same time  
</I>&gt;<i> consumed *a lot* less memory. If have yet to see a snappy Java program.
</I>
Just write yourself a 10-line benchmark and run it. Be sure to subtract 
out the JVM startup and class loading time
(assuming you're doing server-side work and don't care about the few 
seconds of startup time). Just be careful
because if your benchmark isn't complicated enough, the JIT will 
optimize all your code away :)

&gt;<i> If the issue is maintenance, mainenance requires discipline, but the  
</I>&gt;<i> quality of it isn't limited to any language.
</I>&gt;<i>
</I>&gt;<i> As to what &quot;average&quot; programmers get or don't get, I think that is  
</I>&gt;<i> simply an issue of education. If you present stuff in the right way,  
</I>&gt;<i> motivate people by relating to stuff they are already familiar with,  
</I>&gt;<i> you'd be surprised how much a &quot;dumb average programmer, that is so  
</I>&gt;<i> much worse than me&quot;(tm) can learn. To say MI, ASTs, operator  
</I>&gt;<i> overloading et al, are out of reach of the majority of programmers,  
</I>&gt;<i> is in my opinion just one thing: arrogant. (This is not meant to  
</I>&gt;<i> insult anyone, please don't get me wrong!)
</I>
I sure wasn't saying that those are &quot;out of reach&quot; - I was saying that 
they're misused more often than not.

&gt;<i> Sorry for the outburst, but I always get sort of angry when I hear/ 
</I>&gt;<i> read something like this, because it implies a certain &quot;screw them&quot;- 
</I>&gt;<i> attitude.
</I>&gt;<i>
</I>&gt;<i> Anyway, if you think it possible to build a product that handles all  
</I>&gt;<i> the AST mucking behind the scenes, allowing you to specify rules to  
</I>&gt;<i> reliably translate source-to-source, then by all means do it. If it  
</I>&gt;<i> uses ANTLR behind the scenes, congratulations! In essence, if you've  
</I>&gt;<i> got an idea, pursue it. Great things have always come from those  
</I>&gt;<i> ideas and computers are built for exactly this purpose:
</I>&gt;<i>
</I>&gt;<i> &quot;Making easy things easy and hard things possible.&quot;
</I>&gt;<i>
</I>&gt;<i> cheers,
</I>&gt;<i> -k
</I>
Thanks!
Andy

&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018229.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018235.html">[antlr-interest] (not really about) philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18234">[ date ]</a>
              <a href="thread.html#18234">[ thread ]</a>
              <a href="subject.html#18234">[ subject ]</a>
              <a href="author.html#18234">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
