<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] antlr-2007-12-31.14 was a great pre-release
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20antlr-2007-12-31.14%20was%20a%20great%20pre-release&In-Reply-To=%3C20080212135215.00004335%40goanna%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026365.html">
   <LINK REL="Next"  HREF="026366.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] antlr-2007-12-31.14 was a great pre-release</H1>
    <B>Mark Wright</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20antlr-2007-12-31.14%20was%20a%20great%20pre-release&In-Reply-To=%3C20080212135215.00004335%40goanna%3E"
       TITLE="[antlr-interest] antlr-2007-12-31.14 was a great pre-release">markwright at internode.on.net
       </A><BR>
    <I>Mon Feb 11 18:52:15 PST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026365.html">[antlr-interest] antlr-2007-12-31.14 was a great pre-release
</A></li>
        <LI>Next message: <A HREF="026366.html">[antlr-interest] Do lexer rules have scopes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26390">[ date ]</a>
              <a href="thread.html#26390">[ thread ]</a>
              <a href="subject.html#26390">[ subject ]</a>
              <a href="author.html#26390">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 11 Feb 2008 09:51:54 -0800
Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt; wrote:

&gt;<i> Hi Mark,
</I>&gt;<i> 
</I>&gt;<i>   very strange.  I have added this to my near-term to do list!
</I>&gt;<i> Ter
</I>
Hello Ter and everyone,

Great, thanks very much.

Another great thing about the antlr-2007-12-31.14 pre-release is the
generated parser works!  Well I assume it is probably my fault that code
generated by the antlr-2007-12-31.17 to antlr-2008-02-05.15 pre-releases
does not work, as any mistake in a dis-ambiguating semantic predicate
would provide the wrong answer to ANTLR, which of course would cause the
parser not to work.  Anyway sometime after 25th February when I have some
time (I am under lots of time pressure at the moment) I will investigate
the problem with the generated parser not working with the antlr-2007-12-31.17
to antlr-2008-02-05.15 pre-releases.

The problem with the generated parser not working occurs on this input:

class A
{
public:
  A(void);
};

The log of my answers from my dis-ambiguating semantic predicates with
the generated parser with antlr-2007-12-31.14 is:

12/02/2008 01:43:08 SemanticActions isStorageClassSpecifierOptTypeIdInitDeclarator
INFO: 1:0 false 
12/02/2008 01:43:08 SemanticActions isStorageClassSpecifierOptTypeIdNoInitDeclarator
INFO: 1:0 true 
12/02/2008 01:43:08 SemanticActions isNonTemplateSpecializationClassDefinitionHead
INFO: 1:0 true 
12/02/2008 01:43:08 SemanticActions isNonTemplateElaboratedClassSpecifier
INFO: 1:0 false 
12/02/2008 01:43:08 SemanticActions isTemplateElaboratedClassSpecifier
INFO: 1:0 false 
12/02/2008 01:43:08 SemanticActions isTypeSpecifierSeqAbstractDeclarator
INFO: 1:0 false 
12/02/2008 01:43:08 SemanticActions isTemplateSpecializationClassDefinitionHead
INFO: 1:0 false 
12/02/2008 01:43:08 SemanticActions isConstructorDefinition
INFO: 4:2 false 
12/02/2008 01:43:08 SemanticActions isConstructorDefaultDefinition
INFO: 4:2 false 
12/02/2008 01:43:08 SemanticActions isConstructorDeleteDefinition
INFO: 4:2 false 
12/02/2008 01:43:08 SemanticActions isConstructorDeclaration
INFO: 4:2 true 
12/02/2008 01:43:08 SemanticActions isNoCcQualifierName
INFO: 4:2 false 
(CLASS_DEFINITION (CLASS_HEAD class A) public (CONSTRUCTOR_DECLARATION A (PARAMETER_DECLARATION_LIST (PARAMETER_DECLARATION void))))

And with antlr-2008-02-05.15:

12/02/2008 01:48:41 SemanticActions isStorageClassSpecifierOptTypeIdInitDeclarator
INFO: 1:0 false 
12/02/2008 01:48:41 SemanticActions isStorageClassSpecifierOptTypeIdNoInitDeclarator
INFO: 1:0 true 
12/02/2008 01:48:41 SemanticActions isTemplateElaboratedClassSpecifier
INFO: 1:0 false 
12/02/2008 01:48:41 SemanticActions isTemplateSpecializationClassDefinitionHead
INFO: 1:0 false 
12/02/2008 01:48:41 SemanticActions isTypeSpecifierSeqAbstractDeclarator
INFO: 1:0 false 
12/02/2008 01:48:41 SemanticActions isNonTemplateElaboratedClassSpecifier
INFO: 1:0 false 
12/02/2008 01:48:41 SemanticActions isNonTemplateSpecializationClassDefinitionHead
INFO: 1:0 true 
12/02/2008 01:48:41 SemanticActions isConstructorDefaultDefinition
INFO: 4:2 false 
12/02/2008 01:48:41 SemanticActions isConstructorDefinition
INFO: 4:2 false 
12/02/2008 01:48:41 SemanticActions isConstructorDeleteDefinition
INFO: 4:2 false 
12/02/2008 01:48:42 SemanticActions isConstructorDeclaration
INFO: 4:2 true 
12/02/2008 01:48:42 SemanticActions isNoCcQualifierName
INFO: 4:2 false 
12/02/2008 01:48:42 SemanticActions isPureDestructorDeclaration
INFO: 4:2 false 
12/02/2008 01:48:42 SemanticActions isPureConversionFunctionDeclaration
INFO: 4:2 false 
12/02/2008 01:48:42 SemanticActions isTypeSpecifierSeqAbstractDeclarator
INFO: 4:2 true 
12/02/2008 01:48:42 SemanticActions isQualifiedTemplateKeywordSimpleTemplateId
INFO: 4:2 false 
line 4:3 [translation_unit, declaration_seq, declaration, block_declaration, simple_declaration, decl_defn_declaration, type_id, type_specifier_seq, type_specifier, class_specifier, member_specification, member_declaration_or_access_specifier_c, member_declaration]  no viable alt; token=[@10,21:21='(',&lt;10&gt;,4:3] (decision=210 state 3) decision=&lt;&lt;1558:1: member_declaration : ( member_function_definition ( ';' )? | {...}? constructor_head ';' -&gt; ^( CONSTRUCTOR_DECLARATION constructor_head ) | {...}? destructor_head pure_specifier ';' -&gt; ^( PURE_DESTRUCTOR_DECLARATION destructor_head ) | {...}? conversion_function_head pure_specifier ';' -&gt; ^( PURE_CONVERSION_FUNCTION_DECLARATION conversion_function_head ) | {...}? destructor_head ';' -&gt; ^( DESTRUCTOR_DECLARATION destructor_head ) | {...}? conversion_function_head ';' -&gt; ^( CONVERSION_FUNCTION_DECLARATION conversion_function_head ) | ( function_specifier )? ( storage_class_specifier )? type_id member_declarator_list[$function_specifier.tree, $storage_class_specifier.tree, $type_id.tree] ';' -&gt; member_declarator_list | t= 'typedef' type_id typedef_declarator_list[$t, null, null, $type_id.tree] ';' -&gt; typedef_declarator_list | member_friend_declaration | cc_opt_nested_name_specifier ( 'template' )? unqualified_id ';' | using_declaration | static_assert_declaration | template_declaration );&gt;&gt;
&lt;missing type: 5&gt;

I guess its my fault.  I can debug it later (starting 25th February).
I just mention it as another difference between the antlr-2007-12-31.14 
and later pre-releases.  It looks tricky, I don't really like to ask anyone
to look at that until I have a chance to do more testing and debugging
since it could be my fault.

The rule has the second alternative with the sa.isConstructorDeclaration()
dis-ambiguating semantic predicate which the answer is true.

There are lots of ambiguities in the grammar which are all resolved with
dis-ambiguating semantic predicates.  So the
sa.isTypeSpecifierSeqAbstractDeclarator() is hoisted into the 7th alternative,
and its true, a constructor does look like a typeid followed by an
abstract_declarator.  I was kind of hoping the second alternative would be
chosen since it is listed earlier, and it is in antlr-2007-12-31.14
pre-release.  In later pre-releases its not.  But of course an error in
a dis-ambiguating semantic predicate or in my grammar could cause the
second alternative to not match, I will investigate it later.

member_declaration
        :   member_function_definition ';'?
        |   {sa.isConstructorDeclaration((TokenStream)input)}?
                constructor_head ';'
                {sa.memberDeclarationConstructorDeclaration($constructor_head.tree);}
                -&gt; ^(CONSTRUCTOR_DECLARATION constructor_head)
        |   {sa.isPureDestructorDeclaration((TokenStream)input)}?
                destructor_head pure_specifier ';'
                {sa.memberDeclarationDestructorDeclaration($destructor_head.tree, true);}
                -&gt; ^(PURE_DESTRUCTOR_DECLARATION destructor_head)
        |   {sa.isPureConversionFunctionDeclaration((TokenStream)input)}?
                conversion_function_head pure_specifier ';'
                {sa.memberDeclarationConversionFunctionDeclaration($conversion_function_head.tree, true);}
                -&gt; ^(PURE_CONVERSION_FUNCTION_DECLARATION conversion_function_head)
        |   {sa.isDestructorDeclaration((TokenStream)input)}?
                destructor_head ';'
                {sa.memberDeclarationDestructorDeclaration($destructor_head.tree, false);}
                -&gt; ^(DESTRUCTOR_DECLARATION destructor_head)
        |   {sa.isConversionFunctionDeclaration((TokenStream)input)}?
                conversion_function_head ';'
                {sa.memberDeclarationConversionFunctionDeclaration($conversion_function_head.tree, false);}
                -&gt; ^(CONVERSION_FUNCTION_DECLARATION conversion_function_head)
        |   function_specifier? storage_class_specifier? type_id member_declarator_list[$function_specifier.tree, $storage_class_specifier.tree, $type_id.tree] ';'
                -&gt; member_declarator_list
        |   t='typedef' type_id typedef_declarator_list[$t, null, null, $type_id.tree] ';'
                -&gt; typedef_declarator_list
        |   member_friend_declaration
        |   cc_opt_nested_name_specifier 'template'? unqualified_id ';'
        |   using_declaration
        |   static_assert_declaration
        |   template_declaration
        ;

Thanks very much, Mark

-- 
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026365.html">[antlr-interest] antlr-2007-12-31.14 was a great pre-release
</A></li>
	<LI>Next message: <A HREF="026366.html">[antlr-interest] Do lexer rules have scopes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26390">[ date ]</a>
              <a href="thread.html#26390">[ thread ]</a>
              <a href="subject.html#26390">[ subject ]</a>
              <a href="author.html#26390">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
