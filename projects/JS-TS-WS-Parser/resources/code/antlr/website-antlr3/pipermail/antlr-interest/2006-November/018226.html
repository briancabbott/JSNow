<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=qBd4yNMcibSFFwLV%40thewolery.demon.co.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018220.html">
   <LINK REL="Next"  HREF="018229.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=qBd4yNMcibSFFwLV%40thewolery.demon.co.uk"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Thu Nov  2 08:10:33 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018220.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018229.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18226">[ date ]</a>
              <a href="thread.html#18226">[ thread ]</a>
              <a href="subject.html#18226">[ subject ]</a>
              <a href="author.html#18226">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
&gt;&gt;<i>
</I>&gt;&gt;<i> Every time I've heard anyone say they NEED MI, operator overloading, 
</I>&gt;&gt;<i> or Aspects, I've thought
</I>&gt;&gt;<i> that they really don't need them, they're just not good enough 
</I>&gt;&gt;<i> programmers to see a clean way
</I>&gt;&gt;<i> to do without them. I've been programming for 25 years without ever 
</I>&gt;&gt;<i> NEEDING any of these,
</I>&gt;&gt;<i> and so have most other programmers.
</I>&gt;&gt;<i>
</I>&gt;<i> I programmed for many years without needing pointers. FORTRAN didn't 
</I>&gt;<i> have them, so I tended not to use them in C. I notice you said *MOST* 
</I>&gt;<i> other programmers. You're jumping to conclusions - because &quot;all the 
</I>&gt;<i> programmers I know are too stupid to live without these features&quot; you 
</I>&gt;<i> conclude that these features &quot;mostly aren't needed&quot;. So you'd like to 
</I>&gt;<i> see them removed from any tool you use ... :-(
</I>
I conclude that these features &quot;mostly aren't needed&quot; (really more like 
&quot;almost never&quot; or even &quot;never&quot;) from personal
experience, not from something you or I said.

&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So - you're quite happy to see Antlr crippled to suit you, ignoring 
</I>&gt;&gt;&gt;<i> the NEEDS of those who need its power!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Don't worry, I can't cripple ANTLR.  But yes, I'd be happy to see 
</I>&gt;&gt;<i> ANTLR4 become a &quot;crippled&quot; version,
</I>&gt;&gt;<i> in the same sense that Java is a &quot;crippled&quot; version of C++.
</I>&gt;&gt;<i>
</I>&gt;<i> And as I said, you're quite happy to ruin the tool for all those 
</I>&gt;<i> people who need that power ...
</I>
Yes, if you consider Java to be &quot;ruining&quot; C++. New tool without all the 
warts. Those
who &quot;need the power&quot; of the warts can keep using the old tool.

&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> But required knowledge of the tool's internals limits the &quot;average&quot; 
</I>&gt;&gt;&gt;&gt;<i> user's productivity.
</I>&gt;&gt;&gt;&gt;<i> If I had done AST-based translation, I'd be spending way to much 
</I>&gt;&gt;&gt;&gt;<i> time worrying about the details
</I>&gt;&gt;&gt;&gt;<i> of the AST, rather than the syntax and semantics of the two 
</I>&gt;&gt;&gt;&gt;<i> languages. I demand to spend 95% of
</I>&gt;&gt;&gt;&gt;<i> my time on *what* to do, rather than *how* to do it. With ASTs, I 
</I>&gt;&gt;&gt;&gt;<i> found myself spending
</I>&gt;&gt;&gt;&gt;<i> 95% of my time on *how*.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In other words, as you said earlier, ASTs are the wrong tool for 
</I>&gt;&gt;&gt;<i> you. So you seem happy to delete ASTs from Antlr because *you* don't 
</I>&gt;&gt;&gt;<i> need them, irregardless of what other people *NEED*.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, just as I railed against operator overloading and MI in C++, and 
</I>&gt;&gt;<i> found bliss in Java.
</I>&gt;&gt;<i> I don't much care that other people think they *NEED* MI. They can 
</I>&gt;&gt;<i> always stick with C++.
</I>&gt;&gt;<i>
</I>&gt;<i> Or you could find some other language instead of Java? You'd much 
</I>&gt;<i> rather inconvenience all the other Java programmers by removing 
</I>&gt;<i> features they need, rather than convenience yourself by finding 
</I>&gt;<i> something that suits you better?
</I>
No, you're messing up the metaphor. I'm proposing that the next version 
of ANTLR (or maybe it's a completely new tool)
be to today's ANTLR as Java is to C++: a new and improved version that's 
really better, in part because it takes programming
to a higher level.

&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Let's ask a question ... how can a tool be &quot;great&quot; if it *relies* on 
</I>&gt;&gt;&gt;<i> other tools even for its existence?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sure, of course! Virtually all software relies on other tools 
</I>&gt;&gt;<i> (compilers, operating systems, etc) for their existence.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> A C compiler can compile itself. Can a Java system build itself? How 
</I>&gt;&gt;&gt;<i> much of Java is actually written in Java? (Oh and I'm including the 
</I>&gt;&gt;&gt;<i> supporting libraries here!)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Almost all of Java is written in Java. The only part that's not is 
</I>&gt;&gt;<i> the lowest layer, which is OS and hardware specific.
</I>&gt;&gt;<i>
</I>&gt;<i> Assembler is written in assembler, pretty much without exception. C is 
</I>&gt;<i> written in C, pretty much without exception.
</I>&gt;<i>
</I>&gt;<i> The reason for demanding that a great tool be written in itself is 
</I>&gt;<i> exemplified by my databasic example above - the primitives for the 
</I>&gt;<i> version I initially used were written in machine code, and followed 
</I>&gt;<i> the spec. The C rewrite introduced loads of subtle bugs, because the 
</I>&gt;<i> characteristics of the C environment were different. How much of Java 
</I>&gt;<i> DEPENDS on the lowest layer? How much knowledge do you need to 
</I>&gt;<i> understand that layer?
</I>
Heheh...didn't know that most of Java was written in Java, did you? ;)
Yes, all of Java DEPENDS on C.  All of C DEPENDS on object code. All of 
object code DEPENDS on
the operating system. All of the operating system DEPENDS on the hardware.

&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Antlr v3 is due to be rewritten in Antlr v3. To my mind, that's a 
</I>&gt;&gt;&gt;<i> &quot;necessary but not sufficient&quot; condition for greatness.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Wow. Only software that's written in itself can be &quot;great&quot;? Are you 
</I>&gt;&gt;<i> really saying that?
</I>&gt;&gt;<i>
</I>&gt;<i> Yes I am. Because otherwise it requires you to understand much more 
</I>&gt;<i> than you want about the execution environment. Note my comments about 
</I>&gt;<i> subtle bugs. Because it requires the system guys to be *experts* in 
</I>&gt;<i> two completely different environments!
</I>&gt;<i>
</I>&gt;<i> I note that you think a &quot;great tool&quot; is one that means you *don't* 
</I>&gt;<i> *need* to be an expert. By your logic, Java therefore has to be a crap 
</I>&gt;<i> tool for Java system programmers ...
</I>
No, I don't mean &quot;...*dont need* to be an expert&quot;, but rather &quot;dont need 
to know about the layers below&quot;. Java is great
because it doesn't require any knowledge about memory management, for 
example. The tool should let you
only be an expert *at one level of abstraction*. I can program in Java 
without knowing (almost) any details about
any of the underlying layers.

&gt;<i>
</I>&gt;<i> Which is why, in the system I want to build with Antlr, it's very 
</I>&gt;<i> important to me that AS MUCH AS POSSIBLE of the system is built using 
</I>&gt;<i> DATABASIC, because that's what the programmers using it will have 
</I>&gt;<i> experience in. *THAT* is why a great tool must be built using itself.
</I>
I think maybe you're only picturing cases where the tool developer is 
the same person as the tool user.
I don't care at all whether ANTLR (Or Java, or anything else I use) is 
built with itself. I'm sure Terence cares,
but he's the exception.

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Well, virtually every coder in the world is like that. Only a handful 
</I>&gt;&gt;<i> of people in the world know the details of what their
</I>&gt;&gt;<i> compiler is doing as they use it every day. Same goes for the OS and 
</I>&gt;&gt;<i> the hardware. Same goes for  the car you drive
</I>&gt;&gt;<i> and just about everything other non-trivial machine you use: you use 
</I>&gt;&gt;<i> it without knowing much about how it works.
</I>&gt;&gt;<i> That's what makes the world go round :)
</I>&gt;&gt;<i>
</I>&gt;<i> You miss the point. Let's take the car example. There's a big 
</I>&gt;<i> difference between what I wrote and you responded to. As far as I can 
</I>&gt;<i> see, you're saying that if a guy has a driving licence, you're quite 
</I>&gt;<i> happy to get him to repair your car brakes ... WHAT...!!!
</I>
No, I'm just saying that what makes the car useful is that you don't 
have to understand it to use it. You're
hidden from the layers below.

&gt;<i>
</I>&gt;<i> You do not give a problem to someone to solve, if they do not have the 
</I>&gt;<i> mental capacity to understand the problem. You do not ask a guy to 
</I>&gt;<i> repair the brakes on your car if he has no experience of being a 
</I>&gt;<i> mechanic, even if he does have a driving licence (and there's a lot of 
</I>&gt;<i> people I would hate to have service my car, even if they do have a 
</I>&gt;<i> mechanics qualification, because they learnt to follow the diagrams in 
</I>&gt;<i> the book and didn't learn to work through what was *actually* 
</I>&gt;<i> *happening*!).
</I>
I agree.

&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> And then the programmer needs a pointer to write to a bit of 
</I>&gt;&gt;&gt;<i> hardware, and throws Java out in disgust because his &quot;great&quot; tool is 
</I>&gt;&gt;&gt;<i> useless for the job at hand ...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Right. And probably gets fired if his boss finds out that he's trying 
</I>&gt;&gt;<i> to write a bit directly to hardware.
</I>&gt;&gt;<i> He thinks he needs to do that, and he thinks he's smart, but he's 
</I>&gt;&gt;<i> not. That's pretty rare these days to
</I>&gt;&gt;<i> have anyone feel that they need direct access to the hardware. We're 
</I>&gt;&gt;<i> many levels beyond that now.
</I>&gt;&gt;<i>
</I>&gt;<i> Given the ability of many bosses, I bet the boss gave him the job, and 
</I>&gt;<i> told him to use the wrong tool ...
</I>
Maybe. From my experience, almost always when someone says &quot;I need to 
set individual bits by hand,
so Java isn't a good fit&quot;, it turns out that in fact he does not need to 
set individual bits by hand, and Java will
work just fine. He just thinks he needs to bit-twiddle because that's 
how he's used to doing things, and he
wouldn't even think to just use an array of booleans because he can't 
make that mental leap.

&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Because javac is meant to convert java source accurately to java 
</I>&gt;&gt;&gt;<i> bytecode. While Antlr is meant to (and does) accurately convert its 
</I>&gt;&gt;&gt;<i> sourcecode into a lexer/parser/treewalker, it is also designed to 
</I>&gt;&gt;&gt;<i> let do things beyond the power of the tool. Both fit their design 
</I>&gt;&gt;&gt;<i> aims  - javac creates a java program, Antlr creates an extensible 
</I>&gt;&gt;&gt;<i> lexer/parser/treewalker. Both are *good* tools, that doesn't 
</I>&gt;&gt;&gt;<i> necessarily mean they are *great* tools.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> At the end of the day, I think your definition of &quot;great&quot; is badly 
</I>&gt;&gt;&gt;<i> flawed - &quot;a great tool lets a mediocre programmer do a decent job&quot;. 
</I>&gt;&gt;&gt;<i> A great programmer could probably outperform that mediocre 
</I>&gt;&gt;&gt;<i> programmer without that tool.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Heh, it's been a while since I heard the &quot;A great programmer can 
</I>&gt;&gt;<i> write better code than the compiler&quot; line.
</I>&gt;&gt;<i> Used to hear that a lot 20 years ago, not much any more.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I gather the statistics still hold true. The best programmers still 
</I>&gt;<i> outperform the average ones by about 1000% ... that's a MASSIVE 
</I>&gt;<i> difference.
</I>
Yea, that's about right. But the best compilers now outperform the best 
programmers at compiling. We're
comparing people to tools above, not people to people.

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The greater the tool, the greater the level of maturity required to 
</I>&gt;&gt;&gt;<i> be able to use it safely.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you want to use that meaning for &quot;great&quot;, that's fine. But I do 
</I>&gt;&gt;<i> disagree. If you had one space shuttle
</I>&gt;&gt;<i> that was completely safe and automated, that would be a &quot;greater&quot; 
</I>&gt;&gt;<i> tool than one that requires maturity, IMO.
</I>&gt;&gt;<i> Especially if you have millions of shuttle pilots, and not just a few.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You've obviously not read Dick Feynmann then ... :-) even *I* could 
</I>&gt;<i> fly the space shuttle :-)
</I>
&quot;Surely You're Joking!&quot; ;) Maybe you could point me to where he talks 
about this issue,
because I don't remember it.

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> Fine. Since Java is such a great language, let's see you write the 
</I>&gt;<i> BIOS for all new computers in it ... what? you mean all new computers 
</I>&gt;<i> will be bricks if you do? What a crap tool ...
</I>
Just because a car can't fly doesn't mean it's not a great tool. ;)

&gt;<i>
</I>&gt;<i> Oh - and as for &quot;we smart programmers&quot;, you do realise you've just 
</I>&gt;<i> disqualified yourself as a member of that set? You used the word &quot;we&quot;! 
</I>&gt;<i> If the &quot;other&quot; guy respects you, he'll do as you say. I've done some 
</I>&gt;<i> crazy things in my time, like using a goto in C :-) But when other 
</I>&gt;<i> programmers have said &quot;you shouldn't do that&quot; I've just said &quot;well, 
</I>&gt;<i> you do better&quot;. Usually, they've looked at the problem to be solved, 
</I>&gt;<i> and backed down. If you're a smart programmer, you'll show the other 
</I>&gt;<i> guy how to do it better. If you can't, he's smarter than you thought!
</I>
I'll take that challenge...show me a piece of code that really needs a 
goto, and I'll remove it (assuming you let me rewrite
the whole darn thing if I need to).

&gt;<i>
</I>&gt;<i> &quot;Perfection is achieved, not when everything that is necessary has 
</I>&gt;<i> been added, but when everything that is unnecessary has been taken away&quot;.
</I>
And so it is with C++ and Java.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I *know* I'm an expert in DATABASIC. I would *like* to *think* I'm a 
</I>&gt;<i> guru, but until somebody like Jim, or Rob, or Monty, tells me I am 
</I>&gt;<i> (and I probably wouldn't believe Monty), then I'm not! And even then, 
</I>&gt;<i> I wouldn't believe them unless other people I trusted agreed with them.
</I>&gt;<i>
</I>&gt;<i> Ask Loring what unnecessary stuff can be removed from Antlr. Ask Ter. 
</I>&gt;<i> Ask Jim. Ask Monty. Ask the people *YOU* *RESPECT* *AS* *EXPERTS* (or 
</I>&gt;<i> aren't there any such on this list? :-)
</I>
Ask Bjourne what unnecessary stuff can be removed from C++. Now ask 
Gosling. Often, the experts are the
exact wrong people to ask.

&gt;<i>
</I>&gt;<i> I think you'll find everything in Antlr is there because it's needed. 
</I>&gt;<i> Like ASTs for example - I think they happen to be a perfect solution 
</I>&gt;<i> to my problem :-)
</I>&gt;<i>
</I>&gt;<i> I know Antlr doesn't do what you want. So stop trying to drive screws 
</I>&gt;<i> with a hammer, and go find yourself a screwdriver :-) Don't try and 
</I>&gt;<i> ban hammers :-)
</I>
You do understand that I'm not trying to &quot;disable&quot; or &quot;take away 
features&quot; from ANTLR, right?
I think it's perfectly reasonable for someone to post his crazy dreams 
for an &quot;electric hammer&quot; on
a &quot;Joe's hammer&quot; forum. If you don't want to read it, then don't.

&gt;<i>
</I>&gt;<i> (Incidentally, one of the features I found Antlr lacked - or rather 
</I>&gt;<i> seemed incredibly complex to implement - in v2 was a stream rewriter - 
</I>&gt;<i> I wanted a state engine to flip token types - certain types may or may 
</I>&gt;<i> not follow other types and I could do it a lot easier in a stream 
</I>&gt;<i> rewriter than by tracking state in the lexer. Maybe that would be a 
</I>&gt;<i> useful tool for you, maybe not.)
</I>
Probably not, as I can't imagine how it could be easier than looping 
through the List of tokens &quot;by hand&quot;.

Andy

&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Wol
</I>

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018220.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018229.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18226">[ date ]</a>
              <a href="thread.html#18226">[ thread ]</a>
              <a href="subject.html#18226">[ subject ]</a>
              <a href="author.html#18226">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
