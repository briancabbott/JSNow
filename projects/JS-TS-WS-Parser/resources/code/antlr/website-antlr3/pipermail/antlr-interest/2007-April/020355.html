<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Compiling the Generated Code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Compiling%20the%20Generated%20Code&In-Reply-To=%3C462E7FC5.9060307%40ciise.concordia.ca%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020350.html">
   <LINK REL="Next"  HREF="020356.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Compiling the Generated Code</H1>
    <B>Marc-Andr&#233; Laverdi&#232;re</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Compiling%20the%20Generated%20Code&In-Reply-To=%3C462E7FC5.9060307%40ciise.concordia.ca%3E"
       TITLE="[antlr-interest] Compiling the Generated Code">ma_laver at ciise.concordia.ca
       </A><BR>
    <I>Tue Apr 24 15:08:05 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="020350.html">[antlr-interest] Compiling the Generated Code
</A></li>
        <LI>Next message: <A HREF="020356.html">[antlr-interest] (no subject)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20355">[ date ]</a>
              <a href="thread.html#20355">[ thread ]</a>
              <a href="subject.html#20355">[ subject ]</a>
              <a href="author.html#20355">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

It looks like I replied to Johannes only! My apologies! I used his 
suggestion, which takes care of the greedy problem, but the code won't 
compile unless I comment out the code about error handling here. This is 
obviously not a showstopper, but should be fixed.

I used Antlrworks b11, generating code in Java. My IDE is Eclipse 
running Sun Java 1.6.0.1.

I didn't see this in the bug tracking... I would file the bug myself, 
but I can't get an account ;)

 From the grammar:
sh_behavior
     :    'BeginBehavior' sh_code_blob 'EndBehavior';
sh_primitive_parameter
     :    '&lt;' sh_code_blob '&gt;';
sh_code_blob
     :    ( options {greedy=false;} : . )*;    // can we disable the 
white space analysis for this?

Here is the function in the parser where Java complains...

     // $ANTLR start sh_code_blob
     // C:\\Documents and Settings\\marc-andre\\Desktop\\SHL.g:72:1: 
sh_code_blob : ( options {greedy=false; } : . )* ;
     public final void sh_code_blob() throws RecognitionException {
         try {
             // C:\\Documents and 
Settings\\marc-andre\\Desktop\\SHL.g:73:4: ( ( options {greedy=false; } 
:<i> . )* )
</I>             // C:\\Documents and 
Settings\\marc-andre\\Desktop\\SHL.g:73:4: ( options {greedy=false; } : . )*
             {
             // C:\\Documents and 
Settings\\marc-andre\\Desktop\\SHL.g:73:4: ( options {greedy=false; } : . )*
             loop18:
             do {
                 int alt18=2;
                 switch ( input.LA(1) ) {
                 case 19:
                     {
                     switch ( input.LA(2) ) {
                     case 17:
                         {
                         alt18=2;
                         }
                         break;
                     case 33:
                     case 34:
                     case 35:
                         {
                         alt18=2;
                         }
                         break;
                     case ID:
                     case FILE:
                     case INT:
                     case WS:
                     case 8:
                     case 9:
                     case 10:
                     case 11:
                     case 12:
                     case 13:
                     case 14:
                     case 15:
                     case 16:
                     case 18:
                     case 19:
                     case 20:
                     case 21:
                     case 22:
                     case 23:
                     case 24:
                     case 25:
                     case 26:
                     case 27:
                     case 28:
                     case 29:
                     case 30:
                     case 31:
                     case 32:
                     case 36:
                     case 37:
                     case 38:
                     case 39:
                     case 40:
                     case 41:
                         {
                         alt18=1;
                         }
                         break;

                     }

                     }
                     break;
                 case 32:
                     {
                     switch ( input.LA(2) ) {
                     case 28:
                         {
                         alt18=2;
                         }
                         break;
                     case 26:
                         {
                         alt18=2;
                         }
                         break;
                     case 27:
                         {
                         alt18=2;
                         }
                         break;
                     case 38:
                     case 39:
                         {
                         alt18=2;
                         }
                         break;
                     case 18:
                         {
                         alt18=2;
                         }
                         break;
                     case 29:
                         {
                         alt18=2;
                         }
                         break;
                     case 32:
                         {
                         alt18=2;
                         }
                         break;
                     case ID:
                     case FILE:
                     case INT:
                     case WS:
                     case 8:
                     case 9:
                     case 10:
                     case 11:
                     case 12:
                     case 13:
                     case 14:
                     case 15:
                     case 16:
                     case 17:
                     case 19:
                     case 20:
                     case 21:
                     case 22:
                     case 23:
                     case 24:
                     case 25:
                     case 30:
                     case 31:
                     case 33:
                     case 34:
                     case 35:
                     case 36:
                     case 37:
                     case 40:
                     case 41:
                         {
                         alt18=1;
                         }
                         break;

                     }

                     }
                     break;
                 case ID:
                 case FILE:
                 case INT:
                 case WS:
                 case 8:
                 case 9:
                 case 10:
                 case 11:
                 case 12:
                 case 13:
                 case 14:
                 case 15:
                 case 16:
                 case 17:
                 case 18:
                 case 20:
                 case 21:
                 case 22:
                 case 23:
                 case 24:
                 case 25:
                 case 26:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:
                 case 33:
                 case 34:
                 case 35:
                 case 36:
                 case 37:
                 case 38:
                 case 39:
                 case 40:
                 case 41:
                     {
                     alt18=1;
                     }
                     break;

                 }

                 switch (alt18) {
                 case 1 :
                     // C:\\Documents and 
Settings\\marc-andre\\Desktop\\SHL.g:73:32: .
                     {
                     matchAny(input);

                     }
                     break;

                 default :
                     break loop18;
                 }
             } while (true);


             }

         }
         catch (RecognitionException re) {
             reportError(re);
             recover(input,re);
         }
         finally {
         }
         return ;
     }
     // $ANTLR end sh_code_blob

Johannes Luber wrote:
&gt;<i> Marc-Andr&#233; Laverdi&#232;re wrote:
</I>&gt;&gt;<i> Hello,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I generated the code from my grammar using ANTLRWorks 1.0b11 and I've
</I>&gt;&gt;<i> imported the code in my Eclipse project. There are compiler errors that
</I>&gt;&gt;<i> I don't understand.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> They happen in the parser: one of my rules has {greedy=false;}, and this
</I>&gt;&gt;<i> is put in the Java code, but the compiler complains that greedy doesn't
</I>&gt;&gt;<i> exist. When I comment it out, it complains about a RecognitionException
</I>&gt;&gt;<i> that can't be thrown, so I'd have to remove the try, catch and finally
</I>&gt;&gt;<i> structure. Is it supposed to be like that?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Further, looking at that code, I don't see how it is supposed to act in
</I>&gt;&gt;<i> a non-greedy manner! It is a (.)* rule, non-greedy, that should stop
</I>&gt;&gt;<i> when a given token is read.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It works fine in AntlrWorks, btw (tested in 1.0b10). So, its a bit of a
</I>&gt;&gt;<i> surprise here.
</I>&gt;<i> 
</I>&gt;<i> Can you post the relevant parts of the grammar? Makes it easier to see
</I>&gt;<i> if you have a syntax error, which is now discovered, or if ANTLRworks
</I>&gt;<i> got a new bug. Your rule should look like this: &quot;( options
</I>&gt;<i> {greedy=false;} : . )*&quot;.
</I>&gt;<i> 
</I>&gt;&gt;<i> Thanks a ton in advance. This is my first excursion in the field of
</I>&gt;&gt;<i> programming language design, and I hope it won't be a too painful one!
</I>&gt;<i> 
</I>&gt;<i> Did you read this tutorial (and the others)
</I>&gt;<i> &lt;<A HREF="http://www.antlr.org/wiki/display/ANTLR3/Quick+Starter+on+Parser+Grammars+-+No+Past+Experience+Required">http://www.antlr.org/wiki/display/ANTLR3/Quick+Starter+on+Parser+Grammars+-+No+Past+Experience+Required</A>&gt;
</I>&gt;<i> already?
</I>&gt;<i> 
</I>&gt;<i> Best regards,
</I>&gt;<i> Johannes Luber
</I>
-- 
Marc-Andr&#233; LAVERDI&#200;RE, B. Eng., M. A. Sc. (in progress)
Computer Security Laboratory - Laboratoire de s&#233;curit&#233; informatique
CIISE, Universit&#233; Concordia University, Montr&#233;al, Qu&#233;bec, Canada
www.ciise.concordia.ca

/&quot;\
\ /    ASCII Ribbon Campaign
  X      against HTML e-mail
/ \

&quot;Perseverance must finish its work so that you may be mature and 
complete, not lacking anything.&quot; -James 1:4
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020350.html">[antlr-interest] Compiling the Generated Code
</A></li>
	<LI>Next message: <A HREF="020356.html">[antlr-interest] (no subject)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20355">[ date ]</a>
              <a href="thread.html#20355">[ thread ]</a>
              <a href="subject.html#20355">[ subject ]</a>
              <a href="author.html#20355">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
