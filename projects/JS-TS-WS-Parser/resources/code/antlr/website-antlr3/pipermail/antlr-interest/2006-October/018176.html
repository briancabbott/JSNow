<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=45475DC0.9070206%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018172.html">
   <LINK REL="Next"  HREF="018186.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Micheal J</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=45475DC0.9070206%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">open.zone at virgin.net
       </A><BR>
    <I>Tue Oct 31 08:38:48 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018172.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018186.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18176">[ date ]</a>
              <a href="thread.html#18176">[ thread ]</a>
              <a href="subject.html#18176">[ subject ]</a>
              <a href="author.html#18176">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Andy,

You seem to be changing your position on the issue of whether (as Anthony
put it):

&quot;If it really *is* great, then the chances are the majority of programmers
*can't* 'easily &quot;get it&quot; '.&quot;

I'm leaning towards agreeing with Anthony as I said.

&gt;<i> &gt;Many would argue that Java is a limited implementation of OO 
</I>&gt;<i> principles 
</I>&gt;<i> &gt;as pioneered in LISP et al and later Smalltalk. Everything inherits 
</I>&gt;<i> &gt;from System.Object is plain ugly and, no multiple inheritance?. AOD 
</I>&gt;<i> &gt;(AspectJ and
</I>&gt;<i> &gt;cousins) can be viewed as a series of hacks to try and 
</I>&gt;<i> simulate some of the
</I>&gt;<i> &gt;important OO bits that were thrown out to make Java.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> I view Java's decision to do a &quot;limited implementation&quot; by avoiding 
</I>&gt;<i> things like multiple inheritance
</I>&gt;<i> as exactly what made it successful.
</I>
Being a great tool for the job doesn't guarantee popularity. Popularity is
ultimately a measure of the tool's accessibility to average programmers
(they are the majority). Great tools are often beyond the ability of the
average programmer. Certainly to build. And often to use too.

C++ is a great tool (Java was written using it). Most Java programmers
wouldn't be able to master it. Or the domain expertise needed to build Java
itself.

&gt;<i> By avoiding being 
</I>&gt;<i> &quot;completely pure&quot;, 
</I>&gt;<i> Java is accessible
</I>&gt;<i> to average programmers.
</I>
My point exactly (not sure about the &quot;pure OO&quot; label though). 

Incidentally &quot;above average&quot; Java programmers understand the value of the
missing features and are forever trying to add them back. As I suggested,
AspectOrientedDesign in Java can be viewed as attempts to hack some of them
back into Java.

&gt;<i> And that's why Java is popular and 
</I>&gt;<i> Smalltalk and 
</I>&gt;<i> LISP are not.
</I>&gt;<i> It's also why people prefer Java over C++.
</I>
It is a easier tool to use. Less powerful. But easier.

&gt;<i> &gt;So, I'm tending to agree with Anthony here. Great tools 
</I>&gt;<i> often require 
</I>&gt;<i> &gt;in-depth domain expertise that the majority simply don't have.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Sometimes they do, but sometimes they don't. Compilers never require 
</I>&gt;<i> in-depth
</I>&gt;<i> domain expertise.
</I>
Try feeding Java code or an ANTLR grammar to a C++ compiler. ;-)

&gt;<i> I know almost nothing about byte-code 
</I>&gt;<i> generation, yet 
</I>&gt;<i> I use javac
</I>&gt;<i> every minute or two. I think the world would benefit from an 
</I>&gt;<i> ANTLR tool 
</I>&gt;<i> that was like that.
</I>
For your examples of [general purpose language] compiler and ANTLR [grammar
language compiler], the domain expertise isn't primarily about the internals
of the tool. It's about the syntax, semantics and idioms of the language
recognized by the tool. Knowledge of the tool's internals can elevate those
who have it above the &quot;average&quot; user who doesn't.

&gt;<i> &gt;&gt;I think a tool can be great while being simple enough for most
</I>&gt;<i> &gt;&gt;programmers (e.g. Java).
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Not without limiting it's power.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Yes, just as Java's power is &quot;limited&quot; by not supporting MI, 
</I>&gt;<i> pointers, etc. I love to have my power &quot;limited&quot; by not 
</I>&gt;<i> giving me lots of rope to hang 
</I>&gt;<i> myself with.
</I>&gt;<i> And so do most people, judging by the popularity of Java over C++ and 
</I>&gt;<i> every high-level
</I>&gt;<i> language over assembly.
</I>
Java's swan song is productivity (for those problems to which to it can be
applied). Not power as in flexibility, expressivity or performance.

I use Java/C# for the productivity benefits. If performance, flexibility or
expressivity was *more* important in a particular project, there are better
tools than Java/C# (e.g. C++, Occaml).

&gt;<i> &gt;&gt;I think Terence could make a huge leap forward by not thinking about
</I>&gt;<i> &gt;&gt;ANTLR as &quot;a tool to automate what
</I>&gt;<i> &gt;&gt;a guru would have written by hand&quot;, but rather &quot;a tool that 
</I>&gt;<i> hides all 
</I>&gt;<i> &gt;&gt;the details of language manipulation, so that
</I>&gt;<i> &gt;&gt;most any programmer can do it&quot;.
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Don't think so. My point about domain expertise is relevant 
</I>&gt;<i> here. Joe 
</I>&gt;<i> &gt;Average just can't start developing language recognition 
</I>&gt;<i> tools with an 
</I>&gt;<i> &gt;appreciation of the theory that underlies that subject area.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Sure he could. Joe average could easily write:
</I>&gt;<i> a + b --&gt; a.add(b)
</I>&gt;<i> and have his tool do the rest (and maybe warn him about cases 
</I>&gt;<i> that might 
</I>&gt;<i> match that he hadn't
</I>&gt;<i> thought about).
</I>
Not without understanding the syntax and semantics of the DSL you created.
Not without understanding just what that input string instructs your DSL's
&quot;compiler&quot; to do.

Incidentally, your DSL is just a small part of your particular language
recognition toolkit. My comment refers to someone building the whole
toolkit. Examples abound of tools that offer multiple DSLs to tackle the
various phases/modules of a language processing toolkit (e.g. Cocktail,
Stratego).

&gt;<i> I've had a programmer working with me for a few months now, 
</I>&gt;<i> and he's had 
</I>&gt;<i> no trouble writing
</I>&gt;<i> translation rules without every learning ANTLR grammar or knowing 
</I>&gt;<i> anything about language
</I>&gt;<i> recognition tools.
</I>
He isn't using ANTLR directly (i.e. creating/maintaining ANTLR grammars) so,
no surprise if he hasn't had to learn to use ANTLR. 

He isn't developing a language translation toolkit (you've done that
already) so, no surprise if he he has no grounding in formal language
theory.

He _is_ using a DSL you created to encode source-to-source transformations.
You just expressed the opinion that he has aquired the domain expertise
required to use your DSL.

&gt;<i> &gt;&gt;Most programmers use a
</I>&gt;<i> &gt;&gt;compiler without 
</I>&gt;<i> &gt;&gt;ever knowing much more than
</I>&gt;<i> &gt;&gt;&quot;it generates some lower-level code from my code&quot;. Similarly, 
</I>&gt;<i> &gt;&gt;it would 
</I>&gt;<i> &gt;&gt;be nice if most programmers working on
</I>&gt;<i> &gt;&gt;language transformation could use ANTLR without knowing much 
</I>&gt;<i> &gt;&gt;more than 
</I>&gt;<i> &gt;&gt;&quot;it generates a lexer/parser from
</I>&gt;<i> &gt;&gt;my grammar&quot;.
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;The analogy isn't quite apples-to-apples. Programmers using 
</I>&gt;<i> a compiler 
</I>&gt;<i> &gt;[for a programming language like C/C++] have to understand 
</I>&gt;<i> the syntax 
</I>&gt;<i> &gt;and semantics of the language the compiler recognises. Plus 
</I>&gt;<i> the rules 
</I>&gt;<i> &gt;for using other related tools such as linkers, loaders etc. True, an 
</I>&gt;<i> &gt;IDE and the OS can hide much of that these days but they still exist.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Similarly with ANTLR. ANTLR users have to understand the syntax and 
</I>&gt;<i> &gt;semantics of the grammars they develop. ANTLR projects involve *two* 
</I>&gt;<i> &gt;languages - ANTLR's grammar language and a general purpose 
</I>&gt;<i> programming 
</I>&gt;<i> &gt;language such as Java/C/C#/ObjC etc.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Beyond that, it's the same user experience: &quot;I feed in some code and 
</I>&gt;<i> &gt;this tool (compiler or ANTLR) generates a whole lotta stuff I don't 
</I>&gt;<i> &gt;need to understand&quot;.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> No, there's a real difference. Yes, you have to know java syntax and 
</I>&gt;<i> semantics to use javac.
</I>&gt;<i> And you have to know ANTLR syntax and symantics to use ANTLR. 
</I>&gt;<i> But with 
</I>&gt;<i> ANTLR, it's
</I>&gt;<i> not enough to know the syntax and semantics of ANTLR. To do anything 
</I>&gt;<i> useful, you almost
</I>&gt;<i> always have to know something about the internals of what ANTLR is 
</I>&gt;<i> doing. I find that I
</I>&gt;<i> often have to look at the generated code to figure out what 
</I>&gt;<i> went wrong 
</I>&gt;<i> or how to do what
</I>&gt;<i> I want to do. I *never* have to look at java byte code - I'm 
</I>&gt;<i> completely 
</I>&gt;<i> hidden from that
</I>&gt;<i> by the design of the compiler.
</I>
Not by the design of the compiler. But by how well tested it is. And by how
well documented Java (and javacc) is. Many Javacc users - who can and care
to look under hood - have tripped over bugs-a-plenty in it yet, &quot;average&quot;
Javacc users don't discover those same bugs in the same tool even when they
write code that triggers it.

Knowledge of Java and bytecode and how javacc works means &quot;above average&quot;
users can do more with Java and javacc than the average programmer can. 

Knowing more, lets you do more.

ANTLR is similar and different. Different because it suffers in comparison
by being a less popular tool with less resources behind it. Nevertheless,
for someone with a deep knowledge of ANTLR's grammar language, it's
limitations (e.g. no predicate hoisting and approximate-LLk in 2.x) and the
available documentation, there really is no need to look at the output code.
You develop your grammar, you develop your tests, you build the whole lot
and, the tests will alert you if you need to change anything. Unless you
trip over a bug in ANTLR of course...

Now with ANTLR V3, not only can you look at the output code it if you wish
but, for the price of a little more knowledge (i.e. domain expertise), you
can change it!. 

The &quot;average&quot; ANTLR user has no need to change the code and would never do
so but, others will.


Micheal

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018172.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018186.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18176">[ date ]</a>
              <a href="thread.html#18176">[ thread ]</a>
              <a href="subject.html#18176">[ subject ]</a>
              <a href="author.html#18176">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
