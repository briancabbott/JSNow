<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] SeeGramWrap: Yet another refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20SeeGramWrap%3A%20Yet%20another%20refactoring&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006695.html">
   <LINK REL="Next"  HREF="006697.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] SeeGramWrap: Yet another refactoring</H1>
    <B>edcjones</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20SeeGramWrap%3A%20Yet%20another%20refactoring&In-Reply-To="
       TITLE="[antlr-interest] SeeGramWrap: Yet another refactoring">edcjones at yahoo.com
       </A><BR>
    <I>Wed Mar  3 17:19:56 PST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006695.html">[antlr-interest] Re: optional rule confusion
</A></li>
        <LI>Next message: <A HREF="006697.html">[antlr-interest] SeeGramWrap: Yet another refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6696">[ date ]</a>
              <a href="thread.html#6696">[ thread ]</a>
              <a href="subject.html#6696">[ subject ]</a>
              <a href="author.html#6696">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I have placed a re-refactored version of &quot;SeeGramWrap-03.02.2004.tgz&quot;
on my webpage at &quot;<A HREF="http://members.tripod.com/~edcjones/pycode.html&quot;.">http://members.tripod.com/~edcjones/pycode.html&quot;.</A>
SeeGramWrap parses a piece of C code and the resulting parse tree is
output in man and machine readable form. The result can be used for
program transformations. Since a particular trnsformation algorithm
may not require all the information present in the tree, the user can
select what to output.

This program has been written and tested only under linux.

Thanks to John Mitchell and Monty Zukowski for &quot;cgram.tgz&quot;. Every
parser generator need to have a good C grammar. Also thanks to
Terrence Parr for ANTLR (<A HREF="http://www.antlr.org/">http://www.antlr.org/</A>).

==============================================================
                          CONTEXT

Python (<A HREF="http://www.python.org">http://www.python.org</A>) is a scripting language that is both
easy to read and easy to write. It is so easy to read that I can
usually read my own code six months after I write it. But Python is
slow. If speed is needed for part of a project, Pythonistas write C
code that call functions in Python's large API. It also common to wrap
large C libraries so they can be called by Python. The wrapping code
is repetitive and there may be a lot of it so methods have been
developed for automated wrapping.

The best-known approach is SWIG (<A HREF="http://www.swig.org/">http://www.swig.org/</A>). For complex
wrappings, SWIG requires the writing of &quot;typemaps&quot;, an unintuitive
process where pieces of C code you write are spliced into the wrapper
code generated by SWIG.

Another wrapper related approach is Pyrex which is found at

    <A HREF="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/</A>

Pyrex has its own repetitive boilerplate that has to be written. But
the Pyrex boilerplate is so straightforward that it can be taught
algorithmically. See &quot;Michael's Quick Guide to Pyrex&quot; at
&quot;<A HREF="http://ldots.org/pyrex-guide/&quot;.">http://ldots.org/pyrex-guide/&quot;.</A>

I think that the Pyrex boilerplate is _so_ straightforward that it can
be machine generated. Therefore I have been sporatically developing
software to do this. A thoroughly buggy version of this is on my web
page, &quot;<A HREF="http://members.tripod.com/~edcjones&quot;.">http://members.tripod.com/~edcjones&quot;.</A> It is called
&quot;cgram.tar.gz&quot; (The name will be changed). Look at it but don't use
it. &quot;SeeGramWrap&quot; is a major revision of the front end of &quot;cgram.tr.gz&quot;.

I think the automatic-wrapper program can be made to work. It might be
easier to use than SWIG. It is still a lot of work to prepare complex
C header files. What we have is really a &quot;program transformation&quot; or
&quot;tree transformation&quot; problem.

I think some of the issues are:

1. Since parser generators have a long and steep learning curve, I
prefer to use them as black boxes which generate parsers which output
results that I can analyze using Python. The parser created by a
parser generator should output trees in two formats: one easy to look
at and another that a program can easily read. For examples, see below.

2. I find trees very easy to work with. I want the trees to be front
and center and highly visible. I prefer to &quot;manipulate a tree&quot; rather
than &quot;fire a rule&quot;.

3. The most common type of C macro has a type as one of its arguments:

    #define CAST(x, type) (type *) x

How can these be automatically wrapped for Python which is a
dynamically typed language?

=============================================================
                    TECHNICAL OVERVIEW

I use some C grammars associated with ANTLR. The grammar package is
called &quot;cgram&quot;. See &quot;<A HREF="http://www.antlr.org/resources.html&quot;.">http://www.antlr.org/resources.html&quot;.</A>

In &quot;cgram&quot; there is a java program &quot;TestThrough.java&quot; which parses C
code into an AST then runs a tree grammar on the AST and outputs the
original code. The tree grammar is named &quot;GnuCEmitter.g&quot;. I work with
this grammar because the terminal tokens are printed in the correct
order. I modified the grammar turning it into a template. A piece of
the original &quot;GnuCEmitter.g&quot; is:

----
typeQualifier
        :       a:&quot;const&quot;                       { print( a ); }
        |       b:&quot;volatile&quot;                    { print( b ); }
        ;
----

The modified version is:

----
typeQualifier
        :       a:&quot;const&quot;                       { &lt;@ a @&gt; }
        |       b:&quot;volatile&quot;                    { &lt;@ b @&gt; }
        ;
----

In this template, strings of the form &quot;&lt;@ ... @&gt;&quot; will each be
replaced by a set of print statements. Moreover the entire rule will
be wrapped by prints.  The template is used in
&quot;emitter/insert_prints.py&quot;. If &quot;insert_prints.py&quot; is run the result is:

----
typeQualifier
  { if ( inputState.guessing==0 ) {
          print(Open);
          print(&quot;typeQualifier&quot;);
       }
    }
        :  (
                a:&quot;const&quot;        {  print(Open);
print(&quot;typeQualifier.0&quot;); print( a ); print(Close); }
        |       b:&quot;volatile&quot;     {  print(Open);
print(&quot;typeQualifier.1&quot;); print( b ); print(Close); }
           )
  { currentOutput.print(Close + MyTokenSep); }
        ;
----

If the original C program , &quot;temp2.c&quot;, is

    char* s = &quot;ab&quot;;

The output of the modified emitter grammar is &quot;temp2.c.data&quot;:

----
    &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;
    externalList             declarator               expr
    &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;
    externalDef              pointerGroup             primaryExpr
    &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;
    declaration              pointerGroup.0           stringConst
    &lt;&lt;OPEN&gt;&gt;                 *                        &lt;&lt;OPEN&gt;&gt;
    declSpecifiers           &lt;&lt;CLOSE&gt;&gt;                stringConst.0
    &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;                &quot;ab&quot;
    typeSpecifier            &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;
    &lt;&lt;OPEN&gt;&gt;                 declarator.0             &lt;&lt;CLOSE&gt;&gt;
    typeSpecifier.1          s                        &lt;&lt;CLOSE&gt;&gt;
    char                     &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;
    &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;
    &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;
    &lt;&lt;CLOSE&gt;&gt;                initDecl.0               &lt;&lt;CLOSE&gt;&gt;
    &lt;&lt;OPEN&gt;&gt;                 =                        ;
    initDeclList             &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;
    &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;
    initDecl                 initializer              &lt;&lt;CLOSE&gt;&gt;
----

This output can be processed by &quot;tree.py&quot; to produce &quot;temp2.c.nest&quot;

----
(externalList,
  (externalDef,
    (declaration,
      (declSpecifiers,
        (typeSpecifier,
          (typeSpecifier.1, |char|))),
      (initDeclList,
        (initDecl,
          (declarator,
            (pointerGroup,
              (pointerGroup.0, |*|)),
            (declarator.0, |s|)),
          (initDecl.0, |=|),
          (initializer,
            (expr,
              (primaryExpr,
                (stringConst,
                  (stringConst.0, |&quot;ab&quot;|))))))), |;|)))
----

or &quot;temp2.c.src&quot;:

    char * s = &quot;ab&quot; ;

If &quot;temp2.c.src&quot; is put through the entire process itself we get
&quot;temp2.c.src.src&quot; which is identical to &quot;temp2.c.src&quot;. This test is
done by &quot;docheck.py&quot;.

In the &quot;.data&quot; or &quot;.nest&quot; files the tokens from the original C code
are in the correct order. It is easy to recover

    ('char', '*', 's', '=', '&quot;ab&quot;', ';')

Thanks,
Ed Jones





 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
     <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
     <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
     <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006695.html">[antlr-interest] Re: optional rule confusion
</A></li>
	<LI>Next message: <A HREF="006697.html">[antlr-interest] SeeGramWrap: Yet another refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6696">[ date ]</a>
              <a href="thread.html#6696">[ thread ]</a>
              <a href="subject.html#6696">[ subject ]</a>
              <a href="author.html#6696">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
