<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Working around the LALL(k) vs. LL(k) problem ?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Working%20around%20the%20LALL%28k%29%20vs.%20LL%28k%29%20problem%20%3F&In-Reply-To=004501c1d067%24feffa420%240200a8c0%40matthewfnb">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000829.html">
   <LINK REL="Next"  HREF="000815.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Working around the LALL(k) vs. LL(k) problem ?</H1>
    <B>antlr-list at wonderclown.com</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Working%20around%20the%20LALL%28k%29%20vs.%20LL%28k%29%20problem%20%3F&In-Reply-To=004501c1d067%24feffa420%240200a8c0%40matthewfnb"
       TITLE="[antlr-interest] Working around the LALL(k) vs. LL(k) problem ?">antlr-list at wonderclown.com
       </A><BR>
    <I>Wed Mar 20 17:17:38 PST 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000829.html">[antlr-interest] Working around the LALL(k) vs. LL(k) problem ?
</A></li>
        <LI>Next message: <A HREF="000815.html">[antlr-interest] ANTLR and guarded predicates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#830">[ date ]</a>
              <a href="thread.html#830">[ thread ]</a>
              <a href="subject.html#830">[ subject ]</a>
              <a href="author.html#830">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, Mar 21, 2002 at 10:35:58AM +1100, Matthew Ford wrote:
&gt;<i> It depends what you mean by &quot;ambiguous&quot;.
</I>&gt;<i> I assume you mean for some given k lookahead the grammar is not &quot;ambiguous&quot;.
</I>&gt;<i> But you still have to decide what value of k you need and this may change as
</I>&gt;<i> your grammar evolves.
</I>
Actually, I don't want to reference k at all for this purpose.
Syntactic ambiguity of a grammar is independent of method used to
parse the language.  (I'm specifically referring to context-free
grammars; e.g., EBNF.)  A grammar is unambiguous if each string has
only a single corresponding parse tree (aka AST).  (Note that a
grammar might require infinite look-ahead and still be unambiguous.)
If a given string in the language can be parsed into more than one
valid tree, then the grammar is ambiguous.  The infamous
&quot;dangling-else&quot; problem is an example of syntactic ambiguity.  I want
to make sure I avoid such problems in my grammar.  (Of course,
imposing rules that say that an &quot;else&quot; attaches to the nearest &quot;if&quot; is
used to eliminate the ambiguity in practice, but the grammar itself
does not encode these sorts of rules, and is therefore still
ambiguous.)

As another example, the grammars of natural human languages are
typically overflowing with ambiguity.  We determine what the intended
meaning was from context and &quot;common sense&quot;.  There are constructed
human languages (e.g., Lojban, <A HREF="http://www.lojban.org">http://www.lojban.org</A>) which have
unambiguous grammars.  (I believe that Lojban may require infinite
lookahead, but it is unambiguous, and I believe an EBNF grammar can be
downloaded from somewhere on the above website.  Tools for parsing it
have been written; I'm not sure whether the parsers are top-down or
bottom-up.  It might be interesting to write an ANTLR grammar for it.)

I suspect that ANTLR, for all its power in generating parsers, is
actually not quite the right tool for verifying that a given grammar
is unambiguous.  Because it uses linear approximation, it can see
ambiguity where there is none.  If I'm not mistaken, using predicates
to work around this problem might cause ANTLR to not complain about an
actual ambiguity.

Unfortunately, I don't know of any tools which will validate a
grammar's unambiguity without being tied to a particular parsing
method.  I'm not even sure if such a thing is possible, or
computationally practical.  I do know that grammars can be proven
unambiguous by hand, through formal mathematical proof, but that's
rather time-consuming except for simple grammars.  If anybody knows of
methods for automatic validation, I'd love to hear about them.

Let me reiterate, before I make myself unwelcome on this list, that
I'm not criticizing ANTLR in the slightest.  I think it's great at
what it does.  I'm just wondering if it's great at what I want it to
do -- the right tool for the job, and all that.

Randall Nortman

 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000829.html">[antlr-interest] Working around the LALL(k) vs. LL(k) problem ?
</A></li>
	<LI>Next message: <A HREF="000815.html">[antlr-interest] ANTLR and guarded predicates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#830">[ date ]</a>
              <a href="thread.html#830">[ thread ]</a>
              <a href="subject.html#830">[ subject ]</a>
              <a href="author.html#830">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
