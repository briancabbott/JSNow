<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] No match
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20No%20match&In-Reply-To=%3C200705261921.46467.rschulz%40sonic.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020932.html">
   <LINK REL="Next"  HREF="020915.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] No match</H1>
    <B>Randall R Schulz</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20No%20match&In-Reply-To=%3C200705261921.46467.rschulz%40sonic.net%3E"
       TITLE="[antlr-interest] No match">rschulz at sonic.net
       </A><BR>
    <I>Sat May 26 19:21:46 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="020932.html">[antlr-interest] No match
</A></li>
        <LI>Next message: <A HREF="020915.html">[antlr-interest] Writing Delphi Target for Antlr3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20913">[ date ]</a>
              <a href="thread.html#20913">[ thread ]</a>
              <a href="subject.html#20913">[ subject ]</a>
              <a href="author.html#20913">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Saturday 26 May 2007 18:37, Jason Hocker wrote:
&gt;<i> We have a rule like:
</I>&gt;<i>
</I>&gt;<i> code: (ruleA | ruleB | ruleC | ruleD)*;
</I>&gt;<i>
</I>&gt;<i> So if we try to parse code that is wrong... it won't match any of
</I>&gt;<i> these rules, and the parser continues and end.
</I>&gt;<i>
</I>&gt;<i> How can we better implement error handling?
</I>
For one thing, when zero valid productions is explicitly acceptable, 
match an explicit end-of-file (actually, match it regardless--otherwise 
there can be garbage left over without any kind of diagnostic at all).

Secondly, you can often write productions for common error cases and 
issue diagnostics. Then you can go on parsing. You have to watch out 
for ambiguities that might be introduced and most of all don't preclude 
a proper parse of an acceptable input (of course), but the technique 
makes for much more &quot;user friendly&quot; parsers.

For example, in a Lisp-like grammar I have, I add productions that 
accept unmatched close parentheses. I issue a diagnostic and then go on 
parsing. From the user perspective, it's far preferable than bailing 
out as soon as something that is not strictly grammatically acceptable 
occurs.


Randall Schulz
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020932.html">[antlr-interest] No match
</A></li>
	<LI>Next message: <A HREF="020915.html">[antlr-interest] Writing Delphi Target for Antlr3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20913">[ date ]</a>
              <a href="thread.html#20913">[ thread ]</a>
              <a href="subject.html#20913">[ subject ]</a>
              <a href="author.html#20913">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
