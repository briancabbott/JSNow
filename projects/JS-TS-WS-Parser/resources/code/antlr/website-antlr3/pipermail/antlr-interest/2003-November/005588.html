<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] open-ended speed question: order of magnitude comparison?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20open-ended%20speed%20question%3A%20order%20of%20magnitude%20comparison%3F&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005583.html">
   <LINK REL="Next"  HREF="005589.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] open-ended speed question: order of magnitude comparison?</H1>
    <B>Tripp Lilley</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20open-ended%20speed%20question%3A%20order%20of%20magnitude%20comparison%3F&In-Reply-To="
       TITLE="[antlr-interest] open-ended speed question: order of magnitude comparison?">tlilley at perspex.com
       </A><BR>
    <I>Tue Nov 18 15:24:38 PST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="005583.html">[antlr-interest] added to code gen blog
</A></li>
        <LI>Next message: <A HREF="005589.html">[antlr-interest] open-ended speed question: order of magnitude comparison?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5588">[ date ]</a>
              <a href="thread.html#5588">[ thread ]</a>
              <a href="subject.html#5588">[ subject ]</a>
              <a href="author.html#5588">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
In another thread, John &quot;Lingua Idiota&quot; Mitchell wrote:

&gt;<i> For example, if very high speed is so important then what the hell are
</I>&gt;<i> you doing using any &quot;language&quot; that needs such complexity to lex, parse,
</I>&gt;<i> understand, and act upon to solve the problem? I.e., why aren't you
</I>&gt;<i> using a purpose specific, fixed, highly normalized language that's 
</I>&gt;<i> extremely easy to robustly deal with rapidly?
</I>

I was searching for some really open-ended information on ANTLR
performance (and, generally, performance of automatically-generated
recognizers/parsers) when I stumbled on this. I was planning on posting
this question anyway, but John's comment is of particular relevance to it.

The question, and then some qualifiers:

	Does anyone have a rough, order of magnitude, back of the 
	envelope, rule of thumb, etc. idea about the (runtime, lexing and 
	parsing and what-not) speed difference between a parser 
	generated with ANTLR, with one of the LALR(1) tools, or by hand
	(by someone competent but not necessarily wizardly)?

Now, to qualify that question:

	- I realize it's entirely open-ended and very much dependant on 
	  unique characteristics of the grammar being recognized that 
	  would either make it a &quot;good&quot; fit for automated recognition or a 
	  &quot;good&quot; fit for hand coding.

	- As John's post suggests, some languages optimized for easy 
	  parsing would be... parsed easily :-) which also implies that 
	  writing a &quot;more&quot; efficient parser would be eas{y,ier}.

However, in my particular application (or, at least, the application I'm 
considering), I don't really have control over the &quot;languages&quot; that would 
be recognized, and therefore their &quot;parsability&quot; characteristics.

Furthermore, the entire point of my wanting to use generators is to not 
have to hand-code the parsers for each new language I encounter in the 
application (and there would be plenty). Moreover, I want the people 
extending my application to not have to hand-code new parsers as they 
expand the system (and writing new parsers is definitely an integral part 
of expanding the system).

Finally, I'm hoping to be able to use the generated parsers to do 
'realtime' (for some values of &quot;realtime&quot;) recognition of instances of the 
languages.

So, I realize that's entirely broad and open-ended. I'm not looking for 
any definitive statements, just general wisdom along the lines of &quot;well, 
no, you're screwed&quot; or &quot;you could probably do it&quot; or &quot;yeah, no problem, 
performance is comparable for all but the tightest languages hand-coded by 
the most wizardly of parser mages&quot;.

Thanks!

- t.




 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005583.html">[antlr-interest] added to code gen blog
</A></li>
	<LI>Next message: <A HREF="005589.html">[antlr-interest] open-ended speed question: order of magnitude comparison?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5588">[ date ]</a>
              <a href="thread.html#5588">[ thread ]</a>
              <a href="subject.html#5588">[ subject ]</a>
              <a href="author.html#5588">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
