<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Can subrules be set to 'n-to-m'?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Can%20subrules%20be%20set%20to%20%27n-to-m%27%3F&In-Reply-To=ECOWS01MDUOIQs2VK4r00091ccf%40smtp-out1.blueyonder.co.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011644.html">
   <LINK REL="Next"  HREF="011646.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Can subrules be set to 'n-to-m'?</H1>
    <B>John D. Mitchell</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Can%20subrules%20be%20set%20to%20%27n-to-m%27%3F&In-Reply-To=ECOWS01MDUOIQs2VK4r00091ccf%40smtp-out1.blueyonder.co.uk"
       TITLE="[antlr-interest] Can subrules be set to 'n-to-m'?">johnm-antlr at non.net
       </A><BR>
    <I>Sat Mar 26 13:42:34 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011644.html">[antlr-interest] Can subrules be set to 'n-to-m'?
</A></li>
        <LI>Next message: <A HREF="011646.html">[antlr-interest] Can subrules be set to 'n-to-m'?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11645">[ date ]</a>
              <a href="thread.html#11645">[ thread ]</a>
              <a href="subject.html#11645">[ subject ]</a>
              <a href="author.html#11645">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;&gt;&gt;&gt;<i> &quot;Richard&quot; == Richard Matthias &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">richard at exaflop.org</A>&gt; writes:
</I>[...]

&gt;<i> As an example from the CSS grammar, because it doesn't allow spaces
</I>&gt;<i> between some tokens the lexer cannot just discard whitespace which means
</I>&gt;<i> the parser rules have to be peppered with (mostly optional) whitespace
</I>&gt;<i> tokens. So you get lots of rules like this:-
</I>
Yeah, that's usually a sign of a poorly designed language.  Alas, there's
all too many of those kinds of problems in the languages we have to deal
with. :-(


&gt;<i> Needless to say you have to be very careful where you place those (S)*
</I>&gt;<i> sub-rules to avoid non-determinism. Oh, the comments on the ends of the
</I>&gt;<i> lines are where the original yacc grammar had what I think are
</I>&gt;<i> superfluous whitespace swallowing sub-rules. Actually I'd like to open a
</I>&gt;<i> discussion on the best way to handle a language that needs to allow
</I>&gt;<i> whitespace but only in certain places.
</I>
Well, besides &quot;don't&quot;? :-)

&gt;<i> Like I could allow the lexer to drop whitespace but then make everything
</I>&gt;<i> where whitespace wasn't allowed into a single custom token, but I don't
</I>&gt;<i> know if ANTLR's lexer could handle that.
</I>
Personally, I've never found a completely satisfactory solution using any
tool.

What I've done a couple of times in manually create a lexer that has just
enough understanding of the parse level to deal with the whitespace
vagarities.


&gt;<i> While we're on the subject of lexers, one of John D. Mitchell's emails on
</I>&gt;<i> this subject appears to denigrate the regex as something that's only
</I>&gt;<i> useful for simple operations or hacks.
</I>
Hmm... I can see how it could be read that way.  To be clear, at heart,
regexps are just another tool.  One of the big problems is that because of
their easy to get started with nature, people have gone well and truly
insane in their abuse of both the usage of regexps as well as
gerrymandering them to attempt to become full blown grammars.  That's
become a vicious cycle.

And yes, I too have written ridiculously impenetrable regexp abusing code
in a number of languages, including Perl. :-)

&gt;<i> That may be so, but I'd kill for a lexer right now that could handle
</I>&gt;<i> common left prefixes without requiring syntactic predicates (like I want
</I>&gt;<i> a load of exception-based backtracking on every token). There are some
</I>&gt;<i> clever things you can do with a LL(k) based lexer but there are also some
</I>&gt;<i> very basic things that you can do with lex that are an absolute nightmare
</I>&gt;<i> with antlr. Hopefully the DFA-based LL(*) algorithm for antlr3 will sort
</I>&gt;<i> most of this.
</I>
Yeah, the LL* stuff seems to kick ass on that sort of thing.

Do you have some good examples of some easy-using-lex constructs readily at
hand?  Those would be good for us to keep in mind as we beat on Antlr v3.

Thanks,
	John
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011644.html">[antlr-interest] Can subrules be set to 'n-to-m'?
</A></li>
	<LI>Next message: <A HREF="011646.html">[antlr-interest] Can subrules be set to 'n-to-m'?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11645">[ date ]</a>
              <a href="thread.html#11645">[ thread ]</a>
              <a href="subject.html#11645">[ subject ]</a>
              <a href="author.html#11645">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
