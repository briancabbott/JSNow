<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Why don't parsers support character ranges?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Why%20don%27t%20parsers%20support%20character%20ranges%3F&In-Reply-To=%3C1080AEABD1979E42A15840F08084B67BFE3AF7%40vcmsydexh.vecommerce.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028003.html">
   <LINK REL="Next"  HREF="028008.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Why don't parsers support character ranges?</H1>
    <B>Peter Nann</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Why%20don%27t%20parsers%20support%20character%20ranges%3F&In-Reply-To=%3C1080AEABD1979E42A15840F08084B67BFE3AF7%40vcmsydexh.vecommerce.com%3E"
       TITLE="[antlr-interest] Why don't parsers support character ranges?">peter.nann at vecommerce.com.au
       </A><BR>
    <I>Wed Apr 23 18:06:42 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="028003.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
        <LI>Next message: <A HREF="028008.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28004">[ date ]</a>
              <a href="thread.html#28004">[ thread ]</a>
              <a href="subject.html#28004">[ subject ]</a>
              <a href="author.html#28004">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE> 
Randall R Schulz wrote:
&gt;<i> If you got that stuff in CS101,
</I>
OK, Maybe it was CS201... But you know what I mean.

&gt;<i> Show the ANTLR principals wrong by besting them at their own game. If 
</I>&gt;<i> you drop the sour-puss act, they'll probably wish you well, even help 
</I>&gt;<i> you, and certainly congratulate you if you succeed.
</I>
I think the problem was that my task was quite simple.
I think ANTLR makes hard things easier (has many cool features for
that), but in my case my simple task didn't turn out to be a simple
solution in ANTLR.

No tool is perfect, and (almost?) to tool can maintain a linear
relationship between problem complexity and solution complexity, I get
that.

So, let's just put it down to bad luck for my specific requirements.
ANTLR does look like an awesome tool for a very broad range of more
complex problems, and I'll leave it at that!


Thanks for your well put response(s).


-----Original Message-----
From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>
[mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] On Behalf Of Randall R Schulz
Sent: Thursday, 24 April 2008 10:56 AM
To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
Subject: Re: [antlr-interest] Why don't parsers support character
ranges?

On Wednesday 23 April 2008 17:01, Peter Nann wrote:
&gt;<i> Hmmm, I was hoping for more than the 'efficiency' argument...
</I>&gt;<i> I am wondering if that argument is about 10 years past its use-by 
</I>&gt;<i> date...
</I>&gt;<i> We are not in the days of single-digit-Megahertz and RAM measured in k
</I>
&gt;<i> anymore... when lexx and yacc were written...
</I>
Well, ANTLR goes well beyond lex and yacc. However, if you believe that
lexer / parser stratification is no longer justified, you could set out
to prove that thesis by writing a unified lexer / parser generator tool.
(That does everything current tools do!) Many good current parser
generators are open source (including ANTLR, of course), so you can
exploit the techniques they use and that you like and replace or improve
the ones you don't.

Personally, I'm not sure stratifying the lexical and syntactic analysis
is a bad thing. I've certainly never found it to be a problem, and I've
written my share of parsers, using lex &amp; yacc (or flex and bison, I
guess), JavaCC, ANTLR 2.x and 3.x. The only thing I don't care for is
the use of alphabetic case to distinguish lexical from syntactical
rules.


&gt;<i> It would depend on the scale of parsing you need to do of course, but 
</I>&gt;<i> for small-scale parsing I would question whether CPU and RAM matters 
</I>&gt;<i> any more on that task...
</I>
You know, there's a reason we don't call them &quot;little languages&quot; any
more. They are never little and they never were little! And while it's
legitimate to make a considered choice about trading off, say, developer
time and execution time, it's not really OK to do something slowly when
you don't get something in turn for it.


&gt;<i> I will have to take your word about 'combinatorial explosion' for some
</I>
&gt;<i> problems, but I thought simple RDP's could pretty much break down to 
</I>&gt;<i> one branch (as in: switch statement) per character (or token if you 
</I>&gt;<i> tokenize it), which doesn't seem excessive, or combinatorial.
</I>
You may still want to produce a DFA, and that can in general yield and
exponential increase in the number of states. Not stratifying the
lexical and syntactic layers will exacerbate that problem (I think).

And I don't have any idea about the consequences of unifying lexical
analysis with syntax analysis in the face of arbitrary or variable
look-ahead or backtracking.

Lastly, I still think lexical states (as they exist in JavaCC, e.g.)
would be a good thing. It seems that would be harder to do when the
lexer is not separated from the parser.


&gt;<i>  - But, yes, that was just my CS101 project!
</I>
Interesting. If you got that stuff in CS101, you must have gotten one
hell of a CS education.


&gt;<i> ...
</I>&gt;<i>
</I>&gt;<i> Sorry to be a sour-puss, but I was quite excited about ANTLR at first
</I>&gt;<i> look, but then got disappointed very quickly, so I'm a bit like a
</I>&gt;<i> child who just broke his favourite toy...  ;-)
</I>
Show the ANTLR principals wrong by besting them at their own game. If 
you drop the sour-puss act, they'll probably wish you well, even help 
you, and certainly congratulate you if you succeed.


Randall Schulz
</PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028003.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
	<LI>Next message: <A HREF="028008.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28004">[ date ]</a>
              <a href="thread.html#28004">[ thread ]</a>
              <a href="subject.html#28004">[ subject ]</a>
              <a href="author.html#28004">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
