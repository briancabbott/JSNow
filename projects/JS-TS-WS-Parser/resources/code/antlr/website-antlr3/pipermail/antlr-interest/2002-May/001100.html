<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] token stream synchronization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20token%20stream%20synchronization&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001105.html">
   <LINK REL="Next"  HREF="001101.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] token stream synchronization</H1>
    <B>Dennis Marsa</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20token%20stream%20synchronization&In-Reply-To="
       TITLE="[antlr-interest] token stream synchronization">drm at xilinx.com
       </A><BR>
    <I>Mon May 13 11:28:02 PDT 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="001105.html">[antlr-interest] Any known good ways to recover from simple parse errors
</A></li>
        <LI>Next message: <A HREF="001101.html">[antlr-interest] Any known good ways to recover from simple parse errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1100">[ date ]</a>
              <a href="thread.html#1100">[ thread ]</a>
              <a href="subject.html#1100">[ subject ]</a>
              <a href="author.html#1100">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The default exception handler generated by ANTLR includes
calls to both consume() and consumeUntil() as in:

  catch (RecognitionException&amp; ex) {
    if( inputState-&gt;guessing == 0 ) {
      reportError(ex);
      consume();
      consumeUntil(_tokenSet_0);
    } else {
      throw;
    }
  }

The call to consume() discards the bad token that led
to the exception being thrown.  consumeUntil() discards
0 or more additional tokens until one is found that is
in the rule's follow set, or EOF is found.

Consequently, the 1st token (the one that caused the
exception to be thrown) is never compared against the
follow set.

Thus, it is never possible to resynchronize the token
stream *and* consume 0 tokens.  The first token will
*always* be discarded (by the consume() call), even if
it is a token that is in the follow set.

Is this a requirement?  Is there some reason the first
token should not be compared against the follow aet
as well?

Is there a fundamental reason that the following exception
handler (call to consume() removed) would not be as effective
as the original?  The benefit would be that synchronizations
that consume 0 tokens are now possible.

  catch (RecognitionException&amp; ex) {
    if( inputState-&gt;guessing == 0 ) {
      reportError(ex);
      consumeUntil(_tokenSet_0);
    } else {
      throw;
    }
  }

Regards,

Dennis Marsa

 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001105.html">[antlr-interest] Any known good ways to recover from simple parse errors
</A></li>
	<LI>Next message: <A HREF="001101.html">[antlr-interest] Any known good ways to recover from simple parse errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1100">[ date ]</a>
              <a href="thread.html#1100">[ thread ]</a>
              <a href="subject.html#1100">[ subject ]</a>
              <a href="author.html#1100">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
