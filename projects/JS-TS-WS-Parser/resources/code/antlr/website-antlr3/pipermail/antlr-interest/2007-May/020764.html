<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] rule vs. subrule conflict, or
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20rule%20vs.%20subrule%20conflict%2C%20or&In-Reply-To=%3Cbc4938830705200042i61d0046dt806c75e630dd8556%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020762.html">
   <LINK REL="Next"  HREF="020767.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] rule vs. subrule conflict, or</H1>
    <B>Cameron Palmer</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20rule%20vs.%20subrule%20conflict%2C%20or&In-Reply-To=%3Cbc4938830705200042i61d0046dt806c75e630dd8556%40mail.gmail.com%3E"
       TITLE="[antlr-interest] rule vs. subrule conflict, or">cameron.palmer at gmail.com
       </A><BR>
    <I>Sun May 20 00:42:27 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="020762.html">[antlr-interest] Morse Code in the Book
</A></li>
        <LI>Next message: <A HREF="020767.html">[antlr-interest] rule vs. subrule conflict, or
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20764">[ date ]</a>
              <a href="thread.html#20764">[ thread ]</a>
              <a href="subject.html#20764">[ subject ]</a>
              <a href="author.html#20764">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jim - Thank you very much. I believe I have conquered Comment handling, and
I also found a bit on the case insensitive issue at
<A HREF="http://www.antlr.org/wiki/display/ANTLR3/Migrating+from+ANTLR+2+to+ANTLR+3.">http://www.antlr.org/wiki/display/ANTLR3/Migrating+from+ANTLR+2+to+ANTLR+3.</A>

I am encountering an interesting conflict between a rule and a subrule.

In the dsBody rule if i choose an ID that matches one of the iStructElement
rules I get a MismatchTokenException or with a slightly different
formulation NoViableAltException.

Example Input that causes error:
.data
i:12 &lt;- problem if you change 'i' to 'b' all is well
i 12
i 13
i 14
.end

what i find stange is that I would assume that the ID COLON INT EOL in the
grammar below would be checked beforehand and therefore no ambiguity. The
syntax diagram in ANTLRworks and the source code generated by ANTLR leads me
to believe this is the correct interpretation.

Grammar fragment:
dataSection
    : DATABEGIN EOL
    dsBody
    DATAEND EOL
    ;

dsBody    : ID COLON INT EOL
    (iStructElement EOL)+
    ;

iStructElement
    : 'i' INT
    | 'ri' INT INT
    | 'f'
    | 'rf' INT
    | 'a' INT
    | 'ra' INT INT
    | 'u'
    | 'ru' INT
    ;

Thank you,

Cameron.

On 5/18/07, Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i>  Cameron,
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Your comment rule for the lexer needs to change a little to terminate in
</I>&gt;<i> a  non-greedy fashion and not to attempt to embed one rule (EOL) in the
</I>&gt;<i> other (otherwise you need to use a separate &quot;fragment&quot; and reference that (I
</I>&gt;<i> prefer the formulation below, but you may or may not want the EOL to be part
</I>&gt;<i> of the comment token (I assume not)):
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> COMMENT
</I>&gt;<i>     : SEMI (~( '\r' | '\n'))* {$channel=HIDDEN};
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Case sensitivity is normal for the ANTLR 3 token stream, however I have
</I>&gt;<i> posted (or someone posted my code at least if I don't post it ;-), a way to
</I>&gt;<i> override the default stream with a method that will compare in a case
</I>&gt;<i> insensitive way but preserve the original case in the token text (useful in
</I>&gt;<i> some cases such as formatters and for literals so on). See:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://www.antlr.org/pipermail/antlr-interest/2007-January/019008.html">http://www.antlr.org/pipermail/antlr-interest/2007-January/019008.html</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I need to move this code into the wiki, but then, I need to do a lot of
</I>&gt;<i> things ;-)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Jim
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> *From:* <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] *On Behalf Of *Cameron Palmer
</I>&gt;<i> *Sent:* Thursday, May 17, 2007 10:17 PM
</I>&gt;<i> *To:* <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> *Subject:* [antlr-interest] SDF assembly language grammar
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I am a student rewriting the assembler for an ISA called SDF (Scheduled
</I>&gt;<i> Dataflow). You can check out our work at <A HREF="http://csrl.unt.edu/sdf">http://csrl.unt.edu/sdf</A> . Anyway
</I>&gt;<i> I am just writing the grammar and am having trouble making the leap to code
</I>&gt;<i> generation. I had started with v2 but figure I might just convert the
</I>&gt;<i> grammar to v3 today. The goal of this grammar is to emit opcodes for each
</I>&gt;<i> instruction and maintain numeric translations for the labels. I think I
</I>&gt;<i> would rather do the label translation as an AST rather than backpatching. I
</I>&gt;<i> have attached my grammar and sample assembly. My questions:
</I>&gt;<i> Why it seems to stop parsing about the comment line (what am i doing it
</I>&gt;<i> wrong?)
</I>&gt;<i> Where did the caseSensitiveLiterals option disappear?
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Cameron.
</I>&gt;<i>
</I>&gt;<i> A sample of the assembly:
</I>&gt;<i> version 2.0.0
</I>&gt;<i> .data
</I>&gt;<i> .end
</I>&gt;<i> code main
</I>&gt;<i>         putr1 main.1
</I>&gt;<i>         forkep r1
</I>&gt;<i>         stop
</I>&gt;<i> main.1:
</I>&gt;<i>         ; alloc sum frame
</I>&gt;<i>         put sum, r4
</I>&gt;<i>         put 4, r5
</I>&gt;<i>         falloc r4, r5, r6
</I>&gt;<i>         ; alloc result frame
</I>&gt;<i>         put main_res, r4
</I>&gt;<i>         put 1, r5
</I>&gt;<i>         falloc r4, r5, r7
</I>&gt;<i>         ;
</I>&gt;<i>         putr1 main.2
</I>&gt;<i>         forksp r1
</I>&gt;<i>         stop
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The Grammar:
</I>&gt;<i> grammar SDF;
</I>&gt;<i>
</I>&gt;<i> @header {
</I>&gt;<i> package edu.unt.csrl.sdf.asm;
</I>&gt;<i> import java.util.HashMap();
</I>&gt;<i> }
</I>&gt;<i> @members {
</I>&gt;<i> HashMap memory = new HashMap(); // Something like this to hold label
</I>&gt;<i> values that will be rewritten
</I>&gt;<i> }
</I>&gt;<i> program
</I>&gt;<i>     : (EOL)?
</I>&gt;<i>     versionSection
</I>&gt;<i>     dataSection
</I>&gt;<i>     (codeBlock)*
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> versionSection
</I>&gt;<i>     : 'version' (.)+ EOL;
</I>&gt;<i>
</I>&gt;<i> dataSection
</I>&gt;<i>     : DATABEGIN EOL
</I>&gt;<i>         dsBody
</I>&gt;<i>       DATAEND EOL;
</I>&gt;<i>
</I>&gt;<i> dsBody
</I>&gt;<i>     : ID COLON INT EOL
</I>&gt;<i>         iStructBody
</I>&gt;<i>         dsBody
</I>&gt;<i>     | ;
</I>&gt;<i>
</I>&gt;<i> iStructBody
</I>&gt;<i>     : ('i' | 'ri' | 'f' | 'rf' | 'a' | 'ra' | 'u' | 'ru')=&gt;
</I>&gt;<i>         iStructElement
</I>&gt;<i>         iStructBody
</I>&gt;<i>     | ;
</I>&gt;<i>
</I>&gt;<i> iStructElement
</I>&gt;<i>     : 'i' INT EOL
</I>&gt;<i>     | 'ri' INT INT EOL
</I>&gt;<i>     | 'f' FLOAT EOL
</I>&gt;<i>     | 'rf' INT FLOAT EOL
</I>&gt;<i>     | 'a' INT EOL
</I>&gt;<i>     | 'ra' INT INT EOL
</I>&gt;<i>     | 'u' EOL
</I>&gt;<i>     | 'ru' INT EOL;
</I>&gt;<i>
</I>&gt;<i> codeBlock
</I>&gt;<i>     : 'code' ID EOL
</I>&gt;<i>         code;
</I>&gt;<i>
</I>&gt;<i> code
</I>&gt;<i>     : label code
</I>&gt;<i>     | instruction code
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> label
</I>&gt;<i>     : ID COLON (EOL)?;
</I>&gt;<i>
</I>&gt;<i> instruction
</I>&gt;<i>     : 'nop' EOL
</I>&gt;<i>     | 'add' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'sub' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'mul' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'div' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'mod' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'and' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'or' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'not' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'xor' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'band' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'bor' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'bnot' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'shl' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'shr' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'sar' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'neg' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'max' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'min' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'abs' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'lt' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'le' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'eq' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'ne' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'ge' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'gt' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'tbl' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'tch' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'fadd' reg['f'] COMMA reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'fsub' reg['f'] COMMA reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'fmul' reg['f'] COMMA reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'fdiv' reg['f'] COMMA reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'flr' reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'ceil' reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'flt' reg['f'] COMMA reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'fle' reg['f'] COMMA reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'feq' reg['f'] COMMA reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'fne' reg['f'] COMMA reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'fge' reg['f'] COMMA reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'fgt' reg['f'] COMMA reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'trl' reg['r'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'tdb' EOL // TODO
</I>&gt;<i>     | 'tin' reg['f'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'gput' INT COMMA reg['g'] EOL
</I>&gt;<i>     | 'gadd' reg['g'] COMMA reg['g'] COMMA reg['g'] EOL
</I>&gt;<i>     | 'gsub' reg['g'] COMMA reg['g'] COMMA reg['g'] EOL
</I>&gt;<i>     | 'gmul' reg['g'] COMMA reg['g'] COMMA reg['g'] EOL
</I>&gt;<i>     | 'gtl' reg['g'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'ltg' reg['r'] COMMA reg['g'] EOL
</I>&gt;<i>     | 'move' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'putr1' (INT | ID) EOL
</I>&gt;<i>     | 'put' (INT | ID) COMMA reg['r'] EOL
</I>&gt;<i>     | 'load' reg['r'] PIPE (reg['r'] | INT) COMMA reg['r'] EOL
</I>&gt;<i>     | 'store' reg['r'] COMMA reg['r'] PIPE (reg['r'] | INT) EOL
</I>&gt;<i>     | 'store1' EOL // TODO
</I>&gt;<i>     | 'rstore' EOL // TODO
</I>&gt;<i>     | 'ialloc' reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'ifree' reg['r'] EOL
</I>&gt;<i>     | 'ifetch' reg['r'] PIPE (reg['r'] | INT) COMMA reg['r'] EOL
</I>&gt;<i>     | 'istore' reg['r'] COMMA reg['r'] PIPE (reg['r'] | INT) EOL
</I>&gt;<i>     | 'forksp' reg['r'] ( | COMMA reg['r']) EOL
</I>&gt;<i>     | 'forkep' reg['r'] ( | COMMA reg['r']) EOL
</I>&gt;<i>     | 'stop' EOL
</I>&gt;<i>     | 'falloc' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'ralloc' EOL // TODO
</I>&gt;<i>     | 'ffree' ( | reg['r']) EOL
</I>&gt;<i>     | 'input' INT COMMA reg['r'] EOL
</I>&gt;<i>     | 'output' reg['r'] COMMA INT EOL
</I>&gt;<i>     | 'skip' EOL // TODO
</I>&gt;<i>     | 'ifchcl' EOL // TODO
</I>&gt;<i>     | 'pow' reg['r'] COMMA reg['r'] COMMA reg['r'] EOL
</I>&gt;<i>     | 'sfalloc' EOL // TODO
</I>&gt;<i>     | 'fput' FLOAT COMMA reg['f'] EOL
</I>&gt;<i>     | 'finput' INT COMMA reg['f'] EOL
</I>&gt;<i>     | 'halt' EOL
</I>&gt;<i>     | 'fmove' reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'fneg' reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'fabs' reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'fmath' INT COMMA reg['f'] COMMA reg['f'] EOL
</I>&gt;<i>     | 'sforkep' EOL // TODO
</I>&gt;<i>     | 'sforksp' EOL // TODO
</I>&gt;<i>     | 'scforksp' EOL // TODO
</I>&gt;<i>     | 'sffree' EOL // TODO
</I>&gt;<i>     | 'sread' EOL
</I>&gt;<i>     ;
</I>&gt;<i>
</I>&gt;<i> reg[char type] returns[int rNum = -1]
</I>&gt;<i>     : rStr=ID {
</I>&gt;<i>         try {
</I>&gt;<i>             if(Character.toLowerCase (rStr.charAt(0)) != type)
</I>&gt;<i>                 throw new SemanticException(&quot;expected &quot; + type + &quot;x, found
</I>&gt;<i> &quot; + rStr);
</I>&gt;<i>
</I>&gt;<i>             if(rStr.equals(&quot;RFP&quot;))
</I>&gt;<i>                 rNum = 63;
</I>&gt;<i>             else
</I>&gt;<i>                 rNum = Integer.parseInt(rStr.substring(1));
</I>&gt;<i>         } catch(Exception ex) {
</I>&gt;<i>             throw new SemanticException(&quot;expected &quot; + type + &quot;x, found &quot; +
</I>&gt;<i> rStr);
</I>&gt;<i>         }
</I>&gt;<i>     };
</I>&gt;<i>
</I>&gt;<i> DATABEGIN:
</I>&gt;<i>     '.data';
</I>&gt;<i> DATAEND:
</I>&gt;<i>     '.end';
</I>&gt;<i> COMMENT
</I>&gt;<i>     : SEMI (.)* EOL {$channel=HIDDEN};
</I>&gt;<i> fragment DIGIT
</I>&gt;<i>     : ('0'..'9');
</I>&gt;<i> INT
</I>&gt;<i>     : ('-')? (DIGIT)+;
</I>&gt;<i> FLOAT
</I>&gt;<i>     : INT '.' (DIGIT)+;
</I>&gt;<i> SEMI
</I>&gt;<i>     : ';';
</I>&gt;<i> COLON
</I>&gt;<i>     : ':';
</I>&gt;<i> COMMA
</I>&gt;<i>     : ',';
</I>&gt;<i> PIPE
</I>&gt;<i>     : '|';
</I>&gt;<i>
</I>&gt;<i> ID
</I>&gt;<i>     : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'.'|'0'..'9')*;
</I>&gt;<i>
</I>&gt;<i> EOL
</I>&gt;<i>     : (('\r')? '\n') {newline();};
</I>&gt;<i>
</I>&gt;<i> WS
</I>&gt;<i>     : (
</I>&gt;<i>     | (' ' | '\t')
</I>&gt;<i>     ) { $channel=HIDDEN; }
</I>&gt;<i>     ;
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20070520/57072837/attachment-0001.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20070520/57072837/attachment-0001.html</A> 
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020762.html">[antlr-interest] Morse Code in the Book
</A></li>
	<LI>Next message: <A HREF="020767.html">[antlr-interest] rule vs. subrule conflict, or
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20764">[ date ]</a>
              <a href="thread.html#20764">[ thread ]</a>
              <a href="subject.html#20764">[ subject ]</a>
              <a href="author.html#20764">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
