<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=001101c6fd0b%240b7173d0%24c704a8c0%40hercules">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018193.html">
   <LINK REL="Next"  HREF="018196.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=001101c6fd0b%240b7173d0%24c704a8c0%40hercules"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Wed Nov  1 11:45:07 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018193.html">[antlr-interest] Conditional tree parsing
</A></li>
        <LI>Next message: <A HREF="018196.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18194">[ date ]</a>
              <a href="thread.html#18194">[ thread ]</a>
              <a href="subject.html#18194">[ subject ]</a>
              <a href="author.html#18194">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Micheal J wrote:

&gt;<i>Andy,
</I>&gt;<i>
</I>&gt;<i>You seem to be changing your position on the issue of whether (as Anthony
</I>&gt;<i>put it):
</I>&gt;<i>
</I>&gt;<i>&quot;If it really *is* great, then the chances are the majority of programmers
</I>&gt;<i>*can't* 'easily &quot;get it&quot; '.&quot;
</I>&gt;<i>
</I>&gt;<i>I'm leaning towards agreeing with Anthony as I said.
</I>&gt;<i>  
</I>&gt;<i>
</I>I don't think I'm changing my position. I still disagree with that 
quote. I think almost all the great tools
are the ones that the majority of programmers to &quot;get&quot;. In fact, that's 
part of what makes them great.

&gt;&gt;<i>I view Java's decision to do a &quot;limited implementation&quot; by avoiding 
</I>&gt;&gt;<i>things like multiple inheritance
</I>&gt;&gt;<i>as exactly what made it successful.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Being a great tool for the job doesn't guarantee popularity. Popularity is
</I>&gt;<i>ultimately a measure of the tool's accessibility to average programmers
</I>&gt;<i>(they are the majority). Great tools are often beyond the ability of the
</I>&gt;<i>average programmer. Certainly to build. And often to use too.
</I>&gt;<i>  
</I>&gt;<i>
</I>I disagree. I view Java as being &quot;great&quot; and C++ not being &quot;great&quot;. And 
the main thing that makes
Java great is that all the features that made it inaccessible to average 
programmers were removed.
And, it's no coincidence that these same features are what always got 
the supposedly &quot;great programmers&quot;
into trouble: pointers, multiple inheritence, operator overloading, etc.

&gt;<i>C++ is a great tool (Java was written using it). Most Java programmers
</I>&gt;<i>wouldn't be able to master it. Or the domain expertise needed to build Java
</I>&gt;<i>itself.
</I>&gt;<i>  
</I>&gt;<i>
</I>Well, I think Java is far better than C++, and I think the vast majority 
of programmers who know both
agree with me. Probably the main benefit is that it's easy to use for 
&quot;average programmers&quot;. That's also why
ANTLR is better than the competition - because it's easier to use.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>By avoiding being 
</I>&gt;&gt;<i>&quot;completely pure&quot;, 
</I>&gt;&gt;<i>Java is accessible
</I>&gt;&gt;<i>to average programmers.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>My point exactly (not sure about the &quot;pure OO&quot; label though). 
</I>&gt;<i>
</I>&gt;<i>Incidentally &quot;above average&quot; Java programmers understand the value of the
</I>&gt;<i>missing features and are forever trying to add them back. As I suggested,
</I>&gt;<i>AspectOrientedDesign in Java can be viewed as attempts to hack some of them
</I>&gt;<i>back into Java.
</I>&gt;<i>  
</I>&gt;<i>
</I>Yes, a few people want to add stuff back, but most do not. It's just 
that the few are very vocal.
The vast majority don't want MI, operator overloading, or built-in 
AspectOrientedDesign.
And of course, those who want them think they're &quot;above average&quot;, but 
then so does almost
everyone.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>And that's why Java is popular and 
</I>&gt;&gt;<i>Smalltalk and 
</I>&gt;&gt;<i>LISP are not.
</I>&gt;&gt;<i>It's also why people prefer Java over C++.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>It is a easier tool to use. Less powerful. But easier.
</I>&gt;<i>  
</I>&gt;<i>
</I>Right - so I hope there's nothing wrong with me pushing to make ANTLR 
(or some successor)
easier to use. A compiler is easier to use than compiling by hand, but 
also less powerful.
I'm ok with that.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>So, I'm tending to agree with Anthony here. Great tools 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>often require 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>in-depth domain expertise that the majority simply don't have.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Sometimes they do, but sometimes they don't. Compilers never require 
</I>&gt;&gt;<i>in-depth
</I>&gt;&gt;<i>domain expertise.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Try feeding Java code or an ANTLR grammar to a C++ compiler. ;-)
</I>&gt;<i>  
</I>&gt;<i>
</I>Of course you need to know the input syntax and symantics (a little). 
That's different from
knowing the details of what the tool is doing. When talking to Ter, at 
one point I said
&quot;and how do I know how many times that pattern was matched?&quot; and he said 
&quot;just check
n &lt; 4&quot;. How was I supposed to know that ANTLR generated some code that 
included
a variable called n? That's like having to know the details about the 
bytecode that
javac creates. I don't have to read the manual for that stuff...I'd 
rather have the tool not
force me to know those details.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>I know almost nothing about byte-code 
</I>&gt;&gt;<i>generation, yet 
</I>&gt;&gt;<i>I use javac
</I>&gt;&gt;<i>every minute or two. I think the world would benefit from an 
</I>&gt;&gt;<i>ANTLR tool 
</I>&gt;&gt;<i>that was like that.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>For your examples of [general purpose language] compiler and ANTLR [grammar
</I>&gt;<i>language compiler], the domain expertise isn't primarily about the internals
</I>&gt;<i>of the tool. It's about the syntax, semantics and idioms of the language
</I>&gt;<i>recognized by the tool. Knowledge of the tool's internals can elevate those
</I>&gt;<i>who have it above the &quot;average&quot; user who doesn't.
</I>&gt;<i>  
</I>&gt;<i>
</I>But required knowledge of the tool's internals limits the &quot;average&quot; 
user's productivity.
If I had done AST-based translation, I'd be spending way to much time 
worrying about the details
of the AST, rather than the syntax and semantics of the two languages. I 
demand to spend 95% of
my time on *what* to do, rather than *how* to do it. With ASTs, I found 
myself spending
95% of my time on *how*.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>I think a tool can be great while being simple enough for most
</I>&gt;&gt;&gt;&gt;<i>programmers (e.g. Java).
</I>&gt;&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Not without limiting it's power.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Yes, just as Java's power is &quot;limited&quot; by not supporting MI, 
</I>&gt;&gt;<i>pointers, etc. I love to have my power &quot;limited&quot; by not 
</I>&gt;&gt;<i>giving me lots of rope to hang 
</I>&gt;&gt;<i>myself with.
</I>&gt;&gt;<i>And so do most people, judging by the popularity of Java over C++ and 
</I>&gt;&gt;<i>every high-level
</I>&gt;&gt;<i>language over assembly.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Java's swan song is productivity (for those problems to which to it can be
</I>&gt;<i>applied). Not power as in flexibility, expressivity or performance.
</I>&gt;<i>
</I>&gt;<i>I use Java/C# for the productivity benefits. If performance, flexibility or
</I>&gt;<i>expressivity was *more* important in a particular project, there are better
</I>&gt;<i>tools than Java/C# (e.g. C++, Occaml).
</I>&gt;<i>  
</I>&gt;<i>
</I>Right, so you're just like the rest of us. You've chosen to limit your 
own &quot;power&quot; by using Java rather
than, say, assembly. So I'm sticking with my claim that
&quot;I think a tool can be great while being simple enough for most 
programmers (e.g. Java).&quot;
and not buying your &quot;Not without limiting it's power&quot; reply.

&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Sure he could. Joe average could easily write:
</I>&gt;&gt;<i>a + b --&gt; a.add(b)
</I>&gt;&gt;<i>and have his tool do the rest (and maybe warn him about cases 
</I>&gt;&gt;<i>that might 
</I>&gt;&gt;<i>match that he hadn't
</I>&gt;&gt;<i>thought about).
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Not without understanding the syntax and semantics of the DSL you created.
</I>&gt;<i>Not without understanding just what that input string instructs your DSL's
</I>&gt;<i>&quot;compiler&quot; to do.
</I>&gt;<i>  
</I>&gt;<i>
</I>There's little more to my DSL than knowing that &quot;--&gt;&quot; is a separator, 
&quot;v&quot; matches a
single constant or variable tokens, and &quot;x&quot; matches zero or more tokens. 
I'd say it's several
orders of magnitude simpler than ANTLR. I'm not comparing it to ANTLR, 
just saying that
I do believe that I do believe that a does what ANTLR does, but is far 
simpler (like an order
of magnitude or two simpler).

&gt;<i>Incidentally, your DSL is just a small part of your particular language
</I>&gt;<i>recognition toolkit. 
</I>&gt;<i>
</I>It is??? How do you know that?

&gt;<i>My comment refers to someone building the whole
</I>&gt;<i>toolkit. Examples abound of tools that offer multiple DSLs to tackle the
</I>&gt;<i>various phases/modules of a language processing toolkit (e.g. Cocktail,
</I>&gt;<i>Stratego).
</I>&gt;<i>  
</I>&gt;<i>
</I>I'm referring to my &quot;whole toolkit&quot; too, so I think we're talking about 
the same thing.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>I've had a programmer working with me for a few months now, 
</I>&gt;&gt;<i>and he's had 
</I>&gt;&gt;<i>no trouble writing
</I>&gt;&gt;<i>translation rules without every learning ANTLR grammar or knowing 
</I>&gt;&gt;<i>anything about language
</I>&gt;&gt;<i>recognition tools.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>He isn't using ANTLR directly (i.e. creating/maintaining ANTLR grammars) so,
</I>&gt;<i>no surprise if he hasn't had to learn to use ANTLR. 
</I>&gt;<i>  
</I>&gt;<i>
</I>Ah, but he is using ANTLR directly: he spends all day working with the 
Token streams produced by ANTLR,
without having ever seen an ANTLR grammar. That's possible when using 
ANTLR as a lexer,
but that wouldn't be possible using its parser.

&gt;<i>He isn't developing a language translation toolkit (you've done that
</I>&gt;<i>already) so, no surprise if he he has no grounding in formal language
</I>&gt;<i>theory.
</I>&gt;<i>
</I>&gt;<i>He _is_ using a DSL you created to encode source-to-source transformations.
</I>&gt;<i>You just expressed the opinion that he has aquired the domain expertise
</I>&gt;<i>required to use your DSL.
</I>&gt;<i>  
</I>&gt;<i>
</I>Yes, so if you believe me when I say that my DSL is orders of magnitude 
easier to use than
to use ANTLR to build and walk ASTs, then you must see my point: He's 
much more productive.
So I'm building my DSL (and other code) on top of ANTLR/lexer. I think 
there's an opportunity
for Terence to build a better and different tool in place of the 
ANTLR/parser - one that doesn't
require users to know formal language theory or picture ASTs in their 
heads.

&gt;&gt;<i>I want to do. I *never* have to look at java byte code - I'm 
</I>&gt;&gt;<i>completely 
</I>&gt;&gt;<i>hidden from that
</I>&gt;&gt;<i>by the design of the compiler.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Not by the design of the compiler. But by how well tested it is. And by how
</I>&gt;<i>well documented Java (and javacc) is. 
</I>&gt;<i>
</I>No, I do think it's by the design of the compiler - by the design of 
compilers in general.
Compiler designers take it as a given that users need only know the 
syntax/semantics of the input
language. If Ter took it as a given that ANTLR4 users need only know the 
syntax/semantics
of the input language, he'd end up with a very different tool.

&gt;<i>Many Javacc users - who can and care
</I>&gt;<i>to look under hood - have tripped over bugs-a-plenty in it yet, &quot;average&quot;
</I>&gt;<i>Javacc users don't discover those same bugs in the same tool even when they
</I>&gt;<i>write code that triggers it.
</I>&gt;<i>
</I>&gt;<i>Knowledge of Java and bytecode and how javacc works means &quot;above average&quot;
</I>&gt;<i>users can do more with Java and javacc than the average programmer can. 
</I>&gt;<i>
</I>&gt;<i>Knowing more, lets you do more.
</I>&gt;<i>
</I>&gt;<i>ANTLR is similar and different. Different because it suffers in comparison
</I>&gt;<i>by being a less popular tool with less resources behind it. Nevertheless,
</I>&gt;<i>for someone with a deep knowledge of ANTLR's grammar language, it's
</I>&gt;<i>limitations (e.g. no predicate hoisting and approximate-LLk in 2.x) and the
</I>&gt;<i>available documentation, there really is no need to look at the output code.
</I>&gt;<i>  
</I>&gt;<i>
</I>Well, sure, it's mostly covered in the documentation. But that doesn't 
change the fact that it could be
made a lot easier (IMO). What makes Java great and C++ not-so-great is 
that Java programmers
never have to go look up the syntax for &quot;pointer to function that 
returns an int pointer&quot;. Similarly,
a tool that didn't make me look up how to figure out how many patterns a 
&quot;*&quot; matched would make
the tool great.

&gt;<i>You develop your grammar, you develop your tests, you build the whole lot
</I>&gt;<i>and, the tests will alert you if you need to change anything. Unless you
</I>&gt;<i>trip over a bug in ANTLR of course...
</I>&gt;<i>
</I>&gt;<i>Now with ANTLR V3, not only can you look at the output code it if you wish
</I>&gt;<i>but, for the price of a little more knowledge (i.e. domain expertise), you
</I>&gt;<i>can change it!. 
</I>&gt;<i>  
</I>&gt;<i>
</I>I can change the bytecode generated by javac, too. If javac let me do 
that, it would be an indication
to the javac designer that his design is less-than-great.

&gt;<i>The &quot;average&quot; ANTLR user has no need to change the code and would never do
</I>&gt;<i>so but, others will.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Micheal
</I>&gt;<i>  
</I>&gt;<i>
</I>OK,
Andy

&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018193.html">[antlr-interest] Conditional tree parsing
</A></li>
	<LI>Next message: <A HREF="018196.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18194">[ date ]</a>
              <a href="thread.html#18194">[ thread ]</a>
              <a href="subject.html#18194">[ subject ]</a>
              <a href="author.html#18194">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
