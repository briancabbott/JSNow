<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] identifiers that are not allowed to be like
	keywords
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20identifiers%20that%20are%20not%20allowed%20to%20be%20like%0A%09keywords&In-Reply-To=7AFBC425-7272-42F1-AE19-77C005B5D83D%40martin-probst.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016562.html">
   <LINK REL="Next"  HREF="016564.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] identifiers that are not allowed to be like
	keywords</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20identifiers%20that%20are%20not%20allowed%20to%20be%20like%0A%09keywords&In-Reply-To=7AFBC425-7272-42F1-AE19-77C005B5D83D%40martin-probst.com"
       TITLE="[antlr-interest] identifiers that are not allowed to be like
	keywords">parrt at cs.usfca.edu
       </A><BR>
    <I>Fri Jun  9 08:35:17 PDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="016562.html">[antlr-interest] identifiers that are not allowed to be like
	keywords
</A></li>
        <LI>Next message: <A HREF="016564.html">[antlr-interest] Something like EOF token for tree parsers?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16563">[ date ]</a>
              <a href="thread.html#16563">[ thread ]</a>
              <a href="subject.html#16563">[ subject ]</a>
              <a href="author.html#16563">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Jun 9, 2006, at 7:19 AM, Martin Probst wrote:
&gt;<i> Don't worry, ANTLR does this for you automatically (in fact, it's  
</I>&gt;<i> really difficult to get a different behaviour). Sequences of  
</I>&gt;<i> characters will get the ID token type (or something similar). Then  
</I>&gt;<i> they will be tested against the so called Literals table, which  
</I>&gt;<i> contains stuff like 'true'. If it matches, the token type is  
</I>&gt;<i> changed from ID to something different, e.g. LITERAL_true. A rule  
</I>&gt;<i> like:
</I>&gt;<i>
</I>&gt;<i> identifier: ID;
</I>&gt;<i>
</I>&gt;<i> will not match that token then, and everything is fine for you. You  
</I>&gt;<i> can read about that in the manual by looking for the option  
</I>&gt;<i> &quot;testLiterals&quot;.
</I>
For ANTLR v3, it's even simpler than v2.  There is no literals  
table.  All literals are rules in the lexer and when rules overlap  
like ID and keyword, the ambiguity is resolved by choosing the rule  
mentioned first.  So

B : &quot;begin&quot; ;

ID : 'a'..'z'+ ;

will do what you want.  Just mention keywords as 'if' in the grammar  
and v3 will take care of the rest.

BTW, we will need this java grammar built from the spec so I'm  
willing to help you out here. ;)

Ter
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016562.html">[antlr-interest] identifiers that are not allowed to be like
	keywords
</A></li>
	<LI>Next message: <A HREF="016564.html">[antlr-interest] Something like EOF token for tree parsers?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16563">[ date ]</a>
              <a href="thread.html#16563">[ thread ]</a>
              <a href="subject.html#16563">[ subject ]</a>
              <a href="author.html#16563">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
