<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Why don't parsers support character ranges?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Why%20don%27t%20parsers%20support%20character%20ranges%3F&In-Reply-To=%3C%21%26%21AAAAAAAAAAAgAAAAAAAAABjTxn8agx9HoAwEBZw3asQAAAAAspsWAABwBgAQAAAAcDiBdUNsKka%0A%09cYkAn0kgGqQEAAAAA%40temporal-wave.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028004.html">
   <LINK REL="Next"  HREF="028007.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Why don't parsers support character ranges?</H1>
    <B>Jim Idle</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Why%20don%27t%20parsers%20support%20character%20ranges%3F&In-Reply-To=%3C%21%26%21AAAAAAAAAAAgAAAAAAAAABjTxn8agx9HoAwEBZw3asQAAAAAspsWAABwBgAQAAAAcDiBdUNsKka%0A%09cYkAn0kgGqQEAAAAA%40temporal-wave.com%3E"
       TITLE="[antlr-interest] Why don't parsers support character ranges?">jimi at temporal-wave.com
       </A><BR>
    <I>Wed Apr 23 20:03:08 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="028004.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
        <LI>Next message: <A HREF="028007.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28008">[ date ]</a>
              <a href="thread.html#28008">[ thread ]</a>
              <a href="subject.html#28008">[ subject ]</a>
              <a href="author.html#28008">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You may have already stated what it is you were trying to do, but scanning threads isn't making this obvious to me, so perhaps a paragraph on the requirement might help a bit here? It is the case that ANTLR isn't the best tool for all parsing jobs of course, for instance HTML isn't easy and XML is very awkward because it was designed to be 'simple to parse' - as in you can do it with a bit of hand crafted stuff that will be very fast and probably isn't difficult to maintain because it isn't that complicated a language - I dealt with it in the lexer for a VB.Net parser for instance. 

I am sure you can get a bit more help for your parsing, but if you already came up with something else that works, then that might be just fine for you. Mostly it is the fragility of hand-crafted parsers that makes generated recognizers so attractive.

Jim


&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Peter Nann
</I>&gt;<i> Sent: Wednesday, April 23, 2008 6:07 PM
</I>&gt;<i> To: Randall R Schulz; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Subject: Re: [antlr-interest] Why don't parsers support character
</I>&gt;<i> ranges?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Randall R Schulz wrote:
</I>&gt;<i> &gt; If you got that stuff in CS101,
</I>&gt;<i> 
</I>&gt;<i> OK, Maybe it was CS201... But you know what I mean.
</I>&gt;<i> 
</I>&gt;<i> &gt; Show the ANTLR principals wrong by besting them at their own game. If
</I>&gt;<i> &gt; you drop the sour-puss act, they'll probably wish you well, even help
</I>&gt;<i> &gt; you, and certainly congratulate you if you succeed.
</I>&gt;<i> 
</I>&gt;<i> I think the problem was that my task was quite simple.
</I>&gt;<i> I think ANTLR makes hard things easier (has many cool features for
</I>&gt;<i> that), but in my case my simple task didn't turn out to be a simple
</I>&gt;<i> solution in ANTLR.
</I>&gt;<i> 
</I>&gt;<i> No tool is perfect, and (almost?) to tool can maintain a linear
</I>&gt;<i> relationship between problem complexity and solution complexity, I get
</I>&gt;<i> that.
</I>&gt;<i> 
</I>&gt;<i> So, let's just put it down to bad luck for my specific requirements.
</I>&gt;<i> ANTLR does look like an awesome tool for a very broad range of more
</I>&gt;<i> complex problems, and I'll leave it at that!
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Thanks for your well put response(s).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>
</I>&gt;<i> [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] On Behalf Of Randall R Schulz
</I>&gt;<i> Sent: Thursday, 24 April 2008 10:56 AM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Subject: Re: [antlr-interest] Why don't parsers support character
</I>&gt;<i> ranges?
</I>&gt;<i> 
</I>&gt;<i> On Wednesday 23 April 2008 17:01, Peter Nann wrote:
</I>&gt;<i> &gt; Hmmm, I was hoping for more than the 'efficiency' argument...
</I>&gt;<i> &gt; I am wondering if that argument is about 10 years past its use-by
</I>&gt;<i> &gt; date...
</I>&gt;<i> &gt; We are not in the days of single-digit-Megahertz and RAM measured in
</I>&gt;<i> k
</I>&gt;<i> 
</I>&gt;<i> &gt; anymore... when lexx and yacc were written...
</I>&gt;<i> 
</I>&gt;<i> Well, ANTLR goes well beyond lex and yacc. However, if you believe that
</I>&gt;<i> lexer / parser stratification is no longer justified, you could set out
</I>&gt;<i> to prove that thesis by writing a unified lexer / parser generator
</I>&gt;<i> tool.
</I>&gt;<i> (That does everything current tools do!) Many good current parser
</I>&gt;<i> generators are open source (including ANTLR, of course), so you can
</I>&gt;<i> exploit the techniques they use and that you like and replace or
</I>&gt;<i> improve
</I>&gt;<i> the ones you don't.
</I>&gt;<i> 
</I>&gt;<i> Personally, I'm not sure stratifying the lexical and syntactic analysis
</I>&gt;<i> is a bad thing. I've certainly never found it to be a problem, and I've
</I>&gt;<i> written my share of parsers, using lex &amp; yacc (or flex and bison, I
</I>&gt;<i> guess), JavaCC, ANTLR 2.x and 3.x. The only thing I don't care for is
</I>&gt;<i> the use of alphabetic case to distinguish lexical from syntactical
</I>&gt;<i> rules.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; It would depend on the scale of parsing you need to do of course, but
</I>&gt;<i> &gt; for small-scale parsing I would question whether CPU and RAM matters
</I>&gt;<i> &gt; any more on that task...
</I>&gt;<i> 
</I>&gt;<i> You know, there's a reason we don't call them &quot;little languages&quot; any
</I>&gt;<i> more. They are never little and they never were little! And while it's
</I>&gt;<i> legitimate to make a considered choice about trading off, say,
</I>&gt;<i> developer
</I>&gt;<i> time and execution time, it's not really OK to do something slowly when
</I>&gt;<i> you don't get something in turn for it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; I will have to take your word about 'combinatorial explosion' for
</I>&gt;<i> some
</I>&gt;<i> 
</I>&gt;<i> &gt; problems, but I thought simple RDP's could pretty much break down to
</I>&gt;<i> &gt; one branch (as in: switch statement) per character (or token if you
</I>&gt;<i> &gt; tokenize it), which doesn't seem excessive, or combinatorial.
</I>&gt;<i> 
</I>&gt;<i> You may still want to produce a DFA, and that can in general yield and
</I>&gt;<i> exponential increase in the number of states. Not stratifying the
</I>&gt;<i> lexical and syntactic layers will exacerbate that problem (I think).
</I>&gt;<i> 
</I>&gt;<i> And I don't have any idea about the consequences of unifying lexical
</I>&gt;<i> analysis with syntax analysis in the face of arbitrary or variable
</I>&gt;<i> look-ahead or backtracking.
</I>&gt;<i> 
</I>&gt;<i> Lastly, I still think lexical states (as they exist in JavaCC, e.g.)
</I>&gt;<i> would be a good thing. It seems that would be harder to do when the
</I>&gt;<i> lexer is not separated from the parser.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt;  - But, yes, that was just my CS101 project!
</I>&gt;<i> 
</I>&gt;<i> Interesting. If you got that stuff in CS101, you must have gotten one
</I>&gt;<i> hell of a CS education.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sorry to be a sour-puss, but I was quite excited about ANTLR at first
</I>&gt;<i> &gt; look, but then got disappointed very quickly, so I'm a bit like a
</I>&gt;<i> &gt; child who just broke his favourite toy...  ;-)
</I>&gt;<i> 
</I>&gt;<i> Show the ANTLR principals wrong by besting them at their own game. If
</I>&gt;<i> you drop the sour-puss act, they'll probably wish you well, even help
</I>&gt;<i> you, and certainly congratulate you if you succeed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Randall Schulz
</I>


</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028004.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
	<LI>Next message: <A HREF="028007.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28008">[ date ]</a>
              <a href="thread.html#28008">[ thread ]</a>
              <a href="subject.html#28008">[ subject ]</a>
              <a href="author.html#28008">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
