<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=4548F943.7070906%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018273.html">
   <LINK REL="Next"  HREF="018210.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Micheal J</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=4548F943.7070906%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">open.zone at virgin.net
       </A><BR>
    <I>Wed Nov  1 14:49:26 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018273.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018210.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18201">[ date ]</a>
              <a href="thread.html#18201">[ thread ]</a>
              <a href="subject.html#18201">[ subject ]</a>
              <a href="author.html#18201">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Andy,

&gt;<i> I don't think I'm changing my position. I still disagree with that 
</I>&gt;<i> quote. I think almost all the great tools
</I>&gt;<i> are the ones that the majority of programmers to &quot;get&quot;. In 
</I>&gt;<i> fact, that's 
</I>&gt;<i> part of what makes them great.
</I>
I don't think &quot;popular&quot; and &quot;great&quot; (when applied to tools) are synonyms.

Some &quot;great&quot; tools are accessible to the majority. Others are not.

&gt;<i> &gt;Being a great tool for the job doesn't guarantee popularity. 
</I>&gt;<i> Popularity 
</I>&gt;<i> &gt;is ultimately a measure of the tool's accessibility to average 
</I>&gt;<i> &gt;programmers (they are the majority). Great tools are often 
</I>&gt;<i> beyond the 
</I>&gt;<i> &gt;ability of the average programmer. Certainly to build. And 
</I>&gt;<i> often to use 
</I>&gt;<i> &gt;too.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> I disagree. I view Java as being &quot;great&quot; and C++ not being 
</I>&gt;<i> &quot;great&quot;.
</I>
If productivity (not power) is the priority, Java/C# is likely to be a
better tool than C++ for those problems to which Java is applicable.

Otherwise C++ (or some other tool) is better.

&gt;<i> &gt;C++ is a great tool (Java was written using it). Most Java 
</I>&gt;<i> programmers
</I>&gt;<i> &gt;wouldn't be able to master it. Or the domain expertise 
</I>&gt;<i> needed to build 
</I>&gt;<i> &gt;Java itself.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Well, I think Java is far better than C++,
</I>
I thought you might.

&gt;<i> and I think the 
</I>&gt;<i> vast majority 
</I>&gt;<i> of programmers who know both
</I>&gt;<i> agree with me.
</I>
I make no such claim (I have no idea what the vast majority of competent
Java/C++ programmers think).

&gt;<i> Probably the main benefit is that it's easy to use for 
</I>&gt;<i> &quot;average programmers&quot;. That's also why
</I>&gt;<i> ANTLR is better than the competition - because it's easier to use.
</I>
Not to my mind. Coco/R, JavaCC, SLK are equally easy to use (if one takes
the time to learn them).

ANTLR's &quot;popularity&quot; is due to a lot if things including: Ter's predicated
LL(k)/LL(*) technology, [somewhat] comprehensible code generation for
multiple target languages, grammar as documentation for all phases of
translation, it's PD or BSD license, funky codegen in V3 etc

&gt;<i> Yes, a few people want to add stuff back, but most do not. It's just 
</I>&gt;<i> that the few are very vocal.
</I>&gt;<i> The vast majority don't want MI, operator overloading, or built-in 
</I>&gt;<i> AspectOrientedDesign.
</I>
The &quot;vast majority&quot; don't understand the value/utility of MI, mixins, or the
&quot;why?&quot; of AOD  etc.

&gt;<i> &gt;&gt;And that's why Java is popular and
</I>&gt;<i> &gt;&gt;Smalltalk and 
</I>&gt;<i> &gt;&gt;LISP are not.
</I>&gt;<i> &gt;&gt;It's also why people prefer Java over C++.
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;It is a easier tool to use. Less powerful. But easier.
</I>&gt;<i> &gt;  
</I>&gt;<i> Right - so I hope there's nothing wrong with me pushing to make ANTLR 
</I>&gt;<i> (or some successor)
</I>&gt;<i> easier to use. A compiler is easier to use than compiling by 
</I>&gt;<i> hand, but 
</I>&gt;<i> also less powerful.
</I>&gt;<i> I'm ok with that.
</I>
In the context of this thread, &quot;compiling by hand&quot; is not a tool.

How would you change in ANTLR to make it easier?

&gt;<i> &gt;&gt;Sometimes they do, but sometimes they don't. Compilers never require
</I>&gt;<i> &gt;&gt;in-depth
</I>&gt;<i> &gt;&gt;domain expertise.
</I>
&gt;<i> &gt;Try feeding Java code or an ANTLR grammar to a C++ compiler. ;-)
</I>
&gt;<i> Of course you need to know the input syntax and symantics (a little). 
</I>&gt;<i> That's different from
</I>&gt;<i> knowing the details of what the tool is doing.
</I>
&gt;<i> That's like having to know the details about the 
</I>&gt;<i> bytecode that
</I>&gt;<i> javac creates. I don't have to read the manual for that stuff...I'd 
</I>&gt;<i> rather have the tool not
</I>&gt;<i> force me to know those details.
</I>
Quite often just getting &quot;something that works&quot; is all that is required.
Getting the best output from a compiler requires knowing more about what
goes on under the hood.

&gt;<i> &gt;For your examples of [general purpose language] compiler and ANTLR 
</I>&gt;<i> &gt;[grammar language compiler], the domain expertise isn't 
</I>&gt;<i> primarily about 
</I>&gt;<i> &gt;the internals of the tool. It's about the syntax, semantics 
</I>&gt;<i> and idioms 
</I>&gt;<i> &gt;of the language recognized by the tool. Knowledge of the tool's 
</I>&gt;<i> &gt;internals can elevate those who have it above the &quot;average&quot; user who 
</I>&gt;<i> &gt;doesn't.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> But required knowledge of the tool's internals limits the &quot;average&quot; 
</I>&gt;<i> user's productivity.
</I>
A user is already limited if he/she don't understand how a tool works.
Whether or not that matters depends on what they are trying to accomplish.

&gt;<i> &gt;Java's swan song is productivity (for those problems to 
</I>&gt;<i> which to it can 
</I>&gt;<i> &gt;be applied). Not power as in flexibility, expressivity or 
</I>&gt;<i> performance.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;I use Java/C# for the productivity benefits. If performance, 
</I>&gt;<i> &gt;flexibility or expressivity was *more* important in a particular 
</I>&gt;<i> &gt;project, there are better tools than Java/C# (e.g. C++, Occaml).
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Right, so you're just like the rest of us. You've chosen to 
</I>&gt;<i> limit your 
</I>&gt;<i> own &quot;power&quot; by using Java rather
</I>&gt;<i> than, say, assembly. So I'm sticking with my claim that
</I>&gt;<i> &quot;I think a tool can be great while being simple enough for most 
</I>&gt;<i> programmers (e.g. Java).&quot;
</I>&gt;<i> and not buying your &quot;Not without limiting it's power&quot; reply.
</I>
It isn't &quot;my&quot; reply. The fact is:
- Java/C# is less powerful than assembler, C or C++ (you need them to build
java/c# in the first place).
- For some problems, Java/C# is more productive than assembler, C or C++.

&gt;<i> &gt;Incidentally, your DSL is just a small part of your 
</I>&gt;<i> particular language 
</I>&gt;<i> &gt;recognition toolkit.
</I>&gt;<i> &gt;
</I>&gt;<i> It is??? How do you know that?
</I>
Relying on what I've learned about similar systems.
If it isn't I'd like to hear more about it.

&gt;<i> &gt;He isn't using ANTLR directly (i.e. creating/maintaining ANTLR 
</I>&gt;<i> &gt;grammars) so, no surprise if he hasn't had to learn to use ANTLR.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Ah, but he is using ANTLR directly: he spends all day working 
</I>&gt;<i> with the 
</I>&gt;<i> Token streams produced by ANTLR,
</I>&gt;<i> without having ever seen an ANTLR grammar. That's possible when using 
</I>&gt;<i> ANTLR as a lexer,
</I>&gt;<i> but that wouldn't be possible using its parser.
</I>
I disagree. He is working with code generated by ANTLR. He isn't using
ANTLR.

&gt;<i> &gt;He _is_ using a DSL you created to encode source-to-source 
</I>&gt;<i> &gt;transformations. You just expressed the opinion that he has 
</I>&gt;<i> aquired the 
</I>&gt;<i> &gt;domain expertise required to use your DSL.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Yes, so if you believe me when I say that my DSL is orders of 
</I>&gt;<i> magnitude 
</I>&gt;<i> easier to use than
</I>&gt;<i> to use ANTLR to build and walk ASTs, then you must see my point: He's 
</I>&gt;<i> much more productive.
</I>
But he is also limited to what your DSL allows - cf. &quot;not without limiting
it's power&quot;. 

If he used ANTLR directly (like you did). He can do more. Your DSL (like
Java/C#) favours productivity over power/flexibility.

&gt;<i> So I'm building my DSL (and other code) on top of 
</I>&gt;<i> ANTLR/lexer. I think 
</I>&gt;<i> there's an opportunity
</I>&gt;<i> for Terence to build a better and different tool in place of the 
</I>&gt;<i> ANTLR/parser - one that doesn't
</I>&gt;<i> require users to know formal language theory or picture ASTs in their 
</I>&gt;<i> heads.
</I>
Personally, I can't see how that is possible.

&gt;<i> &gt;Not by the design of the compiler. But by how well tested it 
</I>&gt;<i> is. And by 
</I>&gt;<i> &gt;how well documented Java (and javacc) is.
</I>&gt;<i> &gt;
</I>&gt;<i> No, I do think it's by the design of the compiler - by the design of 
</I>&gt;<i> compilers in general.
</I>
ANTLR *is* a compiler.

&gt;<i> Compiler designers take it as a given that users need only know the 
</I>&gt;<i> syntax/semantics of the input
</I>&gt;<i> language. If Ter took it as a given that ANTLR4 users need 
</I>&gt;<i> only know the 
</I>&gt;<i> syntax/semantics
</I>&gt;<i> of the input language, he'd end up with a very different tool.
</I>
When using ANTLR, that is all one needs to know. By knowing even more, it is
possible to do even more than the &quot;average&quot; ANTLR user.

&gt;<i> &gt;Now with ANTLR V3, not only can you look at the output code 
</I>&gt;<i> it if you 
</I>&gt;<i> &gt;wish but, for the price of a little more knowledge (i.e. domain 
</I>&gt;<i> &gt;expertise), you can change it!.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> I can change the bytecode generated by javac, too. If javac let me do 
</I>&gt;<i> that, it would be an indication
</I>&gt;<i> to the javac designer that his design is less-than-great.
</I>
Or that &quot;the [above average] programmer knows best&quot; to paraphrase the C/C++
motto.

A compiler designer can't determine the best code to generate for every
possible situation in advance. This feature makes the tool more useful - for
those who care to acquire the knowledge required to use it effectively. It
empowers knowledgeable users to tailor the output for any given situation.


Micheal

</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018273.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018210.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18201">[ date ]</a>
              <a href="thread.html#18201">[ thread ]</a>
              <a href="subject.html#18201">[ subject ]</a>
              <a href="author.html#18201">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
