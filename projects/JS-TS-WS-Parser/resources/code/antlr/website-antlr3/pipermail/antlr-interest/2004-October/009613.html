<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] TreeDL (was: AST specification and processing)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20TreeDL%20%28was%3A%20AST%20specification%20and%20processing%29&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009612.html">
   <LINK REL="Next"  HREF="009616.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] TreeDL (was: AST specification and processing)</H1>
    <B>Tiller, Michael (M.M.)</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20TreeDL%20%28was%3A%20AST%20specification%20and%20processing%29&In-Reply-To="
       TITLE="[antlr-interest] TreeDL (was: AST specification and processing)">mtiller at ford.com
       </A><BR>
    <I>Mon Oct 18 13:53:07 PDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009612.html">[antlr-interest] Re: Why no children in tree generated by C++ parser?
</A></li>
        <LI>Next message: <A HREF="009616.html">[antlr-interest] C++, Rick, Not optimal Lexer's code.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9613">[ date ]</a>
              <a href="thread.html#9613">[ thread ]</a>
              <a href="subject.html#9613">[ subject ]</a>
              <a href="author.html#9613">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Alexey,

As a general comment, this sounds quite interesting to me but I need a
lot more concrete examples.

For example, could you create an example for expression manipulation
that shows how you could transform an expression AST into its derivative
(e.g. automatic differentiation).  Show how the tree is built from
within ANTLR, show how you can explore it, walk it, visit it, etc.  Then
show how you can transform it (e.g. differentiate it).  That would help
me understand what you are after.  Ideally, it would be good if you
could show how you could exploit the attribute information.  For
example, a generic &quot;binary op&quot; node type but with an attribute that
indicates the specific operator (+,-,*,/) or a &quot;function call&quot; node type
with a required function name and then an optional set of argument.

Personally, I've always had a preference for heterogenous tree
structures and TreeDL seems to be a step toward a formal tree structure
specification (and utilities to operate on them?).  Is that correct?

Any comments on XML representations (reading and writing XML versions),
performance issues while traversing, etc?

--
Mike

&gt;<i> -----Original Message-----
</I>&gt;<i> From: Alexey Demakov [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">demakov at ispras.ru</A>]
</I>&gt;<i> Sent: Friday, October 15, 2004 5:51 AM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>
</I>&gt;<i> Subject: Re: [antlr-interest] TreeDL (was: AST specification and
</I>&gt;<i> processing)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hi John,
</I>&gt;<i> 
</I>&gt;<i> Thank you for attention to my long message :)
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; How to split translator into subsystems, how to specify interfaces
</I>&gt;<i> &gt; &gt; between them?  Natural decomposition of translator is around
</I>internal
&gt;<i> &gt; &gt; representation of input data, i.e. around AST: Parser checks
</I>syntax
&gt;<i> and
</I>&gt;<i> &gt; &gt; builds AST, semantics checker verifies static semantics and adds
</I>&gt;<i> &gt; &gt; additional information to AST.  After that AST can be transformed,
</I>&gt;<i> &gt; &gt; processed in other way, output code can be generated.  All of
</I>these
&gt;<i> &gt; &gt; subsystems depends on AST format only, they are (theoretically)
</I>&gt;<i> &gt; &gt; independent of each other.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; But they aren't, a priori, independent of each other.
</I>Transformations,
&gt;<i> &gt; even while preserving the basic structure of the tree (i.e.,
</I>adhering to
&gt;<i> &gt; the same grammar) are often order dependent.  Also, many tree
</I>&gt;<i> &gt; walkings/manipulations accumulate and/or modify information stored
</I>&gt;<i> outside
</I>&gt;<i> &gt; the trees.
</I>&gt;<i> 
</I>&gt;<i> O'key, I mean implementations of transformations are independent.
</I>&gt;<i> Pre- and post-conditions for each transformation can be formulated
</I>&gt;<i> in terms of tree state - possible node types, required additional
</I>&gt;<i> information
</I>&gt;<i> (for example, reference-definition links). Information stored outside
</I>tree
&gt;<i> can be considered
</I>&gt;<i> as attribute of tree in whole, and can be referenced, for example,
</I>from
&gt;<i> root node,
</I>&gt;<i> so it is not a problem.
</I>&gt;<i> 
</I>&gt;<i> To specify a contract for each action over tree it is enough to
</I>describe
&gt;<i> tree structure
</I>&gt;<i> and state of attributes.
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; If there is separate AST specification (not in ANTLR parser), all
</I>of
&gt;<i> &gt; &gt; these subsystems (including parser) can be developed independently
</I>and
&gt;<i> at
</I>&gt;<i> &gt; &gt; the same time. AST specification can be used as a contract between
</I>&gt;<i> &gt; &gt; developers of different subsystems. According to my experience, it
</I>&gt;<i> speeds
</I>&gt;<i> &gt; &gt; up development and reduces number of errors.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sure (modulo taking the points I made above into account).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; I propose the notation called TreeDL to describe tree-like
</I>structures,
&gt;<i> &gt; &gt; open-source tool that checks consistence of tree description and
</I>&gt;<i> &gt; &gt; translates tree description to a set of classes (now in Java, C#
</I>will
&gt;<i> be
</I>&gt;<i> &gt; &gt; added in near future). The TreeDL tool also can generate HTML
</I>&gt;<i> &gt; &gt; cross-referenced version of tree description to be used as
</I>&gt;<i> documentation.
</I>&gt;<i> &gt; &gt; Tree nodes can be decorated by dynamic attributes to store
</I>additional
&gt;<i> &gt; &gt; information.  There is powerful template engine to generate code
</I>from
&gt;<i> &gt; &gt; tree.  Also there is framework for rapid tool development -
</I>library
&gt;<i> for
</I>&gt;<i> &gt; &gt; error reporting, functionality extention by plugins - TreeDL tool
</I>&gt;<i> itself
</I>&gt;<i> &gt; &gt; uses tree description in TreeDL, mentioned template engine and
</I>&gt;<i> framework,
</I>&gt;<i> &gt; &gt; so source code can be used as an example.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So, are you saying that TreeDL is e.g., a replacement for Antlr tree
</I>&gt;<i> &gt; handling?  Basically, what's the real point of TreeDL?  I.e., what
</I>&gt;<i> doesn't
</I>&gt;<i> &gt; Antlr's tree handling do that you want?
</I>&gt;<i> 
</I>&gt;<i> As far as I know, in ANTLR there is no way to sepatate tree definition
</I>&gt;<i> from parser.
</I>&gt;<i> It is harder for developers of tree processing than if they have clear
</I>and
&gt;<i> full description of tree structure.
</I>&gt;<i> 
</I>&gt;<i> So, the main point of TreeDL is to provide the notation for
</I>specification
&gt;<i> of tree structure.
</I>&gt;<i> For example, most of our developers are not familiar with ANTLR and
</I>they
&gt;<i> can't understand
</I>&gt;<i> a structure of tree that ANTLR builds - it is required to read all
</I>parser
&gt;<i> definition.
</I>&gt;<i> But it is unnesesary, because the only thing they should know - what
</I>kinds
&gt;<i> of nodes are used,
</I>&gt;<i> what children and attributes are defined for each node.
</I>&gt;<i> 
</I>&gt;<i> Moreover, TreeDL tree can be constructed even without parser. In one
</I>of
&gt;<i> our projects
</I>&gt;<i> we build TreeDL tree from GUI and use the same codegeneration library.
</I>&gt;<i> May be I am &quot;tree fan&quot; as Terence is &quot;grammar fan&quot; :)
</I>&gt;<i> As my colleague speaks: &quot;Not because I have no other ideas, but
</I>because
&gt;<i> this is the one I like most&quot;.
</I>&gt;<i> (Hm, not very easy to translate to English...)
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; Additional docs and downloads are at <A HREF="http://treedl.sourceforge.net">http://treedl.sourceforge.net</A>
</I>&gt;<i> &gt; &gt; Example tree description
</I>&gt;<i> &gt; &gt;
</I>&gt;<i>
</I><A HREF="http://treedl.sourceforge.net/treedl/treedl/com/unitesk/atp/treedl/TreeD">http://treedl.sourceforge.net/treedl/treedl/com/unitesk/atp/treedl/TreeD</A>
L.
&gt;<i> tdl-xref/index.html
</I>&gt;<i> &gt; &gt; TreeDL BNF grammar
</I>&gt;<i> &gt; &gt; <A HREF="http://treedl.sourceforge.net/treedl/bnf/TreeDL.bnf/index.html">http://treedl.sourceforge.net/treedl/bnf/TreeDL.bnf/index.html</A>
</I>&gt;<i> &gt; &gt; TreeDL language description
</I>&gt;<i> <A HREF="http://treedl.sourceforge.net/treedl/treedl_en.html">http://treedl.sourceforge.net/treedl/treedl_en.html</A>
</I>&gt;<i> &gt; &gt; TreeDL tool description
</I>&gt;<i> &gt; &gt; <A HREF="http://treedl.sourceforge.net/treedl/treedl_tool_en.html">http://treedl.sourceforge.net/treedl/treedl_tool_en.html</A>
</I>&gt;<i> &gt; &gt; Template engine usage example
</I>&gt;<i> &gt; &gt;
</I>&gt;<i>
</I><A HREF="http://treedl.sourceforge.net/treedl/xref/com/unitesk/atp/treedl/JavaNod">http://treedl.sourceforge.net/treedl/xref/com/unitesk/atp/treedl/JavaNod</A>
eG
&gt;<i> enerator.html
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Am I reading the docs correctly... Are you really using the visitor
</I>&gt;<i> pattern
</I>&gt;<i> &gt; rather than generating a recursive descent parser?
</I>&gt;<i> 
</I>&gt;<i> TreeDL notation itself doesn't define what is generated from tree
</I>&gt;<i> description. TreeDL tool provides
</I>&gt;<i> default implementation but it is easy to modify translation scheme, to
</I>&gt;<i> change what should be generated or
</I>&gt;<i> generate additional information you need.
</I>&gt;<i> 
</I>&gt;<i> Historically codegeneration library use visitor pattern, but it is not
</I>&gt;<i> required for all TreeDL users to use it also.
</I>&gt;<i> It is not clear for me, what task requires recursive descent parser?
</I>Do
&gt;<i> you mean tree walker?
</I>&gt;<i> (Plugin that generate tree walker can be written in several hours.)
</I>&gt;<i> TreeDL tool doesn't do ANTLR job - ANTLR is used for parsing. Actions
</I>that
&gt;<i> create TreeDL tree nodes
</I>&gt;<i> should be inserted in ANTLR parser rules. Of course, this code is
</I>longer
&gt;<i> than the use of ANTLR tree building,
</I>&gt;<i> but easy to write, understand and maintain (You see, there are rather
</I>many
&gt;<i> questions in this list about problems
</I>&gt;<i> with ANTLR tree building). And tree description guarantees that
</I>correct
&gt;<i> tree will be built - node constructor checks
</I>&gt;<i> that all required children and attributes are provided, and additional
</I>&gt;<i> checks of its values can be defined.
</I>&gt;<i> 
</I>&gt;<i> I plan to write small examples on how to write formal text processing
</I>tool
&gt;<i> using ANTLR and TreeDL,
</I>&gt;<i> are members of this list interested to read them?
</I>&gt;<i> 
</I>&gt;<i> Another tool that we've developed is caled BNF tool. It takes grammar
</I>in
&gt;<i> BNF form, check correctness
</I>&gt;<i> (well, it is simple - all used rules should be defined and reachable
</I>from
&gt;<i> start rule) and generates positive/negative tests,
</I>&gt;<i> i.e. sentences that a priory satisfy/unsatisfy grammar. Test can be
</I>&gt;<i> generated from any context-free grammar definition.
</I>&gt;<i> It is useful when source grammar should be adapted to be suitable for
</I>&gt;<i> ANTLR - we need some checking that
</I>&gt;<i> source and modified grammars are describing the same language.
</I>&gt;<i> 
</I>&gt;<i> Also HTML version of grammar with cross-references can be generated.
</I>This
&gt;<i> is example:
</I>&gt;<i> <A HREF="http://treedl.sourceforge.net/treedl/bnf/TreeDL.bnf/index.html">http://treedl.sourceforge.net/treedl/bnf/TreeDL.bnf/index.html</A>
</I>&gt;<i> 
</I>&gt;<i> Now BNF tool is not public available, but in the future it is
</I>possible.
&gt;<i> 
</I>&gt;<i> Thanks,
</I>&gt;<i> Alexey
</I>&gt;<i> -----
</I>&gt;<i> TreeDL: Tree Description Language: <A HREF="http://treedl.sourceforge.net">http://treedl.sourceforge.net</A>
</I>&gt;<i> RedVerst Group: <A HREF="http://www.unitesk.com">http://www.unitesk.com</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Yahoo! Groups Links
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>


 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
    <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
    <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
    <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009612.html">[antlr-interest] Re: Why no children in tree generated by C++ parser?
</A></li>
	<LI>Next message: <A HREF="009616.html">[antlr-interest] C++, Rick, Not optimal Lexer's code.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9613">[ date ]</a>
              <a href="thread.html#9613">[ thread ]</a>
              <a href="subject.html#9613">[ subject ]</a>
              <a href="author.html#9613">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
