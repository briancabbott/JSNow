<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Parsing fields in a CSV file
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Parsing%20fields%20in%20a%20CSV%20file&In-Reply-To=%3C95b1cc100903101056ufb7d381p1f76484cf44b883c%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033334.html">
   <LINK REL="Next"  HREF="033352.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Parsing fields in a CSV file</H1>
    <B>Rick Schumeyer</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Parsing%20fields%20in%20a%20CSV%20file&In-Reply-To=%3C95b1cc100903101056ufb7d381p1f76484cf44b883c%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Parsing fields in a CSV file">rschumeyer at gmail.com
       </A><BR>
    <I>Tue Mar 10 10:56:53 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="033334.html">[antlr-interest] Building AST by hand
</A></li>
        <LI>Next message: <A HREF="033352.html">[antlr-interest] Parsing fields in a CSV file
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33336">[ date ]</a>
              <a href="thread.html#33336">[ thread ]</a>
              <a href="subject.html#33336">[ subject ]</a>
              <a href="author.html#33336">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>What is the best strategy for parsing a CSV file?  Most CSV files I have
seen are simple one big data table.  The files I have are structured, with
different sections containing parameters, tables, etc.

I can easily parse the file into fields.  Most of the time, I don't care
what the field contains.  But sometimes, a field contains a timestamp like:

Fri Oct 24 09:54:27 EDT 2008,

I want to parse each individual piece of this field.  My understanding is
that ANTLR will try to return the longest match to a token it can find.  So
even if I want it to look for
STRING STRING INT INT:INT:INT etc.

it will simply return

FIELD

unless I do something with predicates.

If I do something in the parser like

timestamp : (STRING STRING INT INT:INT:INT etc) =&gt; (STRING STRING INT
INT:INT:INT etc);

will that work?  Will that cause the lexer to return each small token, or
will it still return a FIELD?

A couple of questions:

It seems to me that I want to use a predicate in the lexer based on what is
happening in the parser.  Is there an easy way to do that?  (I didn't see an
example of that in the ANTLR book).

Another alternative, which sounds crazy but I'll ask anyway, is to write a
separate parser that only parses the above date/time field, and call that
parser from within the rule that receives the timestamp field.

Thanks for any help!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20090310/f847df4c/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20090310/f847df4c/attachment.html</A> 
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033334.html">[antlr-interest] Building AST by hand
</A></li>
	<LI>Next message: <A HREF="033352.html">[antlr-interest] Parsing fields in a CSV file
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33336">[ date ]</a>
              <a href="thread.html#33336">[ thread ]</a>
              <a href="subject.html#33336">[ subject ]</a>
              <a href="author.html#33336">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
