<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=452D3180.2070907%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017915.html">
   <LINK REL="Next"  HREF="018104.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Anthony W. Youngman</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=452D3180.2070907%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">antlr at thewolery.demon.co.uk
       </A><BR>
    <I>Wed Oct 25 04:57:10 PDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="017915.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018104.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18102">[ date ]</a>
              <a href="thread.html#18102">[ thread ]</a>
              <a href="subject.html#18102">[ subject ]</a>
              <a href="author.html#18102">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In message &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">452D3180.2070907 at jazillian.com</A>&gt;, Andy Tripp 
&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; writes
&gt;&gt;<i> &quot;Thinking in trees&quot; does not come automatically.  It is like learning 
</I>&gt;&gt;<i>LISP or Forth or one of the functional languages (and, for that 
</I>&gt;&gt;<i>matter, object-oriented programming:  there is a lot of badly designed 
</I>&gt;&gt;<i>and implemented C++ code out there).  For a time, working with trees 
</I>&gt;&gt;<i>is like slogging through molasses, and then you get the &quot;Aha!&quot; 
</I>&gt;&gt;<i>experience and things become easy.  It usually is not about designing 
</I>&gt;&gt;<i>the perfect tree structure; instead, it is about simplifying the 
</I>&gt;&gt;<i>recognition problem and expressing target language constructs in tree  form.
</I>&gt;<i>
</I>&gt;<i>For the record, I had no trouble &quot;getting&quot; LISP when I learned it 25 
</I>&gt;<i>years ago. When I started with C++, I don't think I
</I>&gt;<i>really &quot;got&quot; OOD, and only started writing real OO code when learning 
</I>&gt;<i>Java forced me to. I think the fact that LISP never
</I>&gt;<i>became &quot;mainstream&quot; means that it failed to be easy enough to grasp. 
</I>&gt;<i>Regardless of how inherently beautiful it is,
</I>&gt;<i>if a lot of programmers don't easily &quot;get it&quot;, then it's not that 
</I>&gt;<i>great.
</I>
The trouble is, the &quot;average&quot; programmer is just that, average.

A great programmer can do the work of ten ordinary programmers. The 
trouble is, he probably does it with tools that are beyond the ability 
of the ordinary programmer to &quot;get&quot;.

As a result, the majority of tools on the market are &quot;average&quot; tools, 
aimed at the &quot;average&quot; programmer, and the product suffers accordingly. 
Look at the mass of IDEs available now - I *hate* them. I think verbally 
and an IDE gets in the way. But the majority of people think visually - 
that's why Windows is such a hit. But because they think visually, they 
can't think in abstract terms, and they can't do anything beyond basic 
problem solving. (As an aside, my University foray into childhood 
development said that kids start progressing beyond this stage at about 
the age of 14, and that modern thought says that maybe HALF the 
population NEVER get beyond it.)

I think it was Celko - wrote an article on databases and Access. He 
predicted that, because a certain (rather important) database concept 
couldn't be visualised, that it wouldn't be available in Access. Sure 
enough, it wasn't (even in the programming language behind it!)

Years ago, IBM did an experiment. They made a bunch of programmers write 
a program without access to the computer to test it. It was written on 
paper and desk-checked. When it was signed off, typed in and run, the 
&quot;quality profiler&quot; run on it equated it with a program that had been in 
production for two years with two years of bug-fixes done on it ...

Cheers,
Wol
-- 
Anthony W. Youngman - <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">anthony at thewolery.demon.co.uk</A>

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017915.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018104.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18102">[ date ]</a>
              <a href="thread.html#18102">[ thread ]</a>
              <a href="subject.html#18102">[ subject ]</a>
              <a href="author.html#18102">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
