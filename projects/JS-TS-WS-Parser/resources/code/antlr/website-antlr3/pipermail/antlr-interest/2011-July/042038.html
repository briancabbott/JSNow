<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Lines that don't match a rule ...
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Lines%20that%20don%27t%20match%20a%20rule%20...&In-Reply-To=%3CBAY149-w10F7FAF984343CAD32748EED410%40phx.gbl%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="042037.html">
   <LINK REL="Next"  HREF="042039.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Lines that don't match a rule ...</H1>
    <B>James Ladd</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Lines%20that%20don%27t%20match%20a%20rule%20...&In-Reply-To=%3CBAY149-w10F7FAF984343CAD32748EED410%40phx.gbl%3E"
       TITLE="[antlr-interest] Lines that don't match a rule ...">james_ladd at hotmail.com
       </A><BR>
    <I>Thu Jul  7 14:45:34 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="042037.html">[antlr-interest] targets without switch fall through...
</A></li>
        <LI>Next message: <A HREF="042039.html">[antlr-interest] Lines that don't match a rule ...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#42038">[ date ]</a>
              <a href="thread.html#42038">[ thread ]</a>
              <a href="subject.html#42038">[ subject ]</a>
              <a href="author.html#42038">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Thanks Jim !  I'm sure that will do the trick.
This list is so helpful.

&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-request at antlr.org</A>
</I>&gt;<i> Subject: antlr-interest Digest, Vol 80, Issue 7
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Date: Thu, 7 Jul 2011 12:00:01 -0700
</I>&gt;<i> 
</I>&gt;<i> Send antlr-interest mailing list submissions to
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> 
</I>&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-request at antlr.org</A>
</I>&gt;<i> 
</I>&gt;<i> You can reach the person managing the list at
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-owner at antlr.org</A>
</I>&gt;<i> 
</I>&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;<i> than &quot;Re: Contents of antlr-interest digest...&quot;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Today's Topics:
</I>&gt;<i> 
</I>&gt;<i>    1. left recursion removal (S?bastien Kirche)
</I>&gt;<i>    2. Re: left recursion removal (Jim Idle)
</I>&gt;<i>    3. Lines that don't match a rule ... (James Ladd)
</I>&gt;<i>    4. Re: left recursion removal (John B. Brodie)
</I>&gt;<i>    5. Re: Think I found a bug. (James Reid)
</I>&gt;<i>    6. Re: left recursion removal (S?bastien Kirche)
</I>&gt;<i>    7. Re: Lines that don't match a rule ... (Jim Idle)
</I>&gt;<i>    8. Re: left recursion removal (Jim Idle)
</I>&gt;<i>    9. Re: left recursion removal (Jim Idle)
</I>&gt;<i>   10. Re: Think I found a bug. (Terence Parr)
</I>&gt;<i>   11. Re: left recursion removal (John B. Brodie)
</I>&gt;<i>   12. Re: left recursion removal (S?bastien Kirche)
</I>&gt;<i>   13. C Target won't compile with MSVC (Ivan Brezina)
</I>&gt;<i>   14. Re: C Target won't compile with MSVC (Jim Idle)
</I>&gt;<i>   15. loops and syntax-directed interpreter ? (Roy Metzger)
</I>&gt;<i>   16. Re: left recursion removal (S?bastien Kirche)
</I>&gt;<i>   17. Re: left recursion removal (John B. Brodie)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 1
</I>&gt;<i> Date: Wed, 6 Jul 2011 21:19:39 +0200
</I>&gt;<i> From: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Subject: [antlr-interest] left recursion removal
</I>&gt;<i> To: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">CALGPt8YiQvER1svK_zfJQ7UkJXYz5ww0U0yRLj7ha_GMK+v8yw at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1
</I>&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> the language for which I am trying to build the grammar has 2 flavors
</I>&gt;<i> of if-then-else constructs
</I>&gt;<i> - a single line : if &lt;condition&gt; then &lt;statement&gt; [else &lt;statement&gt;]
</I>&gt;<i> - a multi line : if &lt;condition&gt; then &lt;statements&gt; [else &lt;statements&gt;] end if
</I>&gt;<i> 
</I>&gt;<i> I have defined the following (partial) :
</I>&gt;<i> 
</I>&gt;<i> codeBlock
</I>&gt;<i> 	:	(compoundStatement)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> compoundStatement
</I>&gt;<i> 	:	(
</I>&gt;<i> 			ifStatement
</I>&gt;<i> 		|	singleStatement
</I>&gt;<i> 		) (';' | EOL)
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> singleStatement
</I>&gt;<i> 	:	localVariableDeclaration
</I>&gt;<i> 	|	funCall
</I>&gt;<i> 	|	'return' expression
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> ifStatement
</I>&gt;<i> 	:	singleLineIf
</I>&gt;<i> 	|	multiLineIf
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> singleLineIf
</I>&gt;<i> 	:	'if' expression 'then' singleStatement EOL
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> multiLineIf
</I>&gt;<i> 	:	'if' expression 'then' codeBlock 'end if'
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I understand why the naive ifStatement fails with the following &quot;
</I>&gt;<i> [fatal] rule ifStatement has non-LL(*) decision due to recursive rule
</I>&gt;<i> invocations reachable from alts 1,2.  Resolve by left-factoring or
</I>&gt;<i> using syntactic predicates or using backtrack=true option.&quot;
</I>&gt;<i> 
</I>&gt;<i> I would like to avoid general backtracking, so after searching for a
</I>&gt;<i> while and reading the article
</I>&gt;<i> <A HREF="http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtracking+from+your+grammar">http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtracking+from+your+grammar</A>
</I>&gt;<i> I have tried first
</I>&gt;<i> 
</I>&gt;<i> ifStatement
</I>&gt;<i> 	:	'if' expression 'then' (singleStatement EOL)=&gt; singleLineIf
</I>&gt;<i> 	| 	multiLineIf
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> or
</I>&gt;<i> 
</I>&gt;<i> ifStatement
</I>&gt;<i> 	:	'if' expression 'then' (singleStatement EOL | codeBlock 'end if')
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> But they fail both with the same fatality.
</I>&gt;<i> How this case should be processed ?
</I>&gt;<i> -- 
</I>&gt;<i> S?bastien Kirche
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 2
</I>&gt;<i> Date: Wed, 6 Jul 2011 14:27:39 -0700
</I>&gt;<i> From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">fc73d76295d104694253b4775b459791 at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i> 
</I>&gt;<i> What language? This is usually distinguished by the fact that multi
</I>&gt;<i> statement blocks must begin on a new line after THEN or ELSE. VB.Net for
</I>&gt;<i> instance.
</I>&gt;<i> 
</I>&gt;<i> Jim
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of S?bastien Kirche
</I>&gt;<i> &gt; Sent: Wednesday, July 06, 2011 12:20 PM
</I>&gt;<i> &gt; To: antlr-interest
</I>&gt;<i> &gt; Subject: [antlr-interest] left recursion removal
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; the language for which I am trying to build the grammar has 2 flavors
</I>&gt;<i> &gt; of if-then-else constructs
</I>&gt;<i> &gt; - a single line : if &lt;condition&gt; then &lt;statement&gt; [else &lt;statement&gt;]
</I>&gt;<i> &gt; - a multi line : if &lt;condition&gt; then &lt;statements&gt; [else &lt;statements&gt;]
</I>&gt;<i> &gt; end if
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have defined the following (partial) :
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; codeBlock
</I>&gt;<i> &gt; 	:	(compoundStatement)*
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; compoundStatement
</I>&gt;<i> &gt; 	:	(
</I>&gt;<i> &gt; 			ifStatement
</I>&gt;<i> &gt; 		|	singleStatement
</I>&gt;<i> &gt; 		) (';' | EOL)
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; singleStatement
</I>&gt;<i> &gt; 	:	localVariableDeclaration
</I>&gt;<i> &gt; 	|	funCall
</I>&gt;<i> &gt; 	|	'return' expression
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ifStatement
</I>&gt;<i> &gt; 	:	singleLineIf
</I>&gt;<i> &gt; 	|	multiLineIf
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; singleLineIf
</I>&gt;<i> &gt; 	:	'if' expression 'then' singleStatement EOL
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; multiLineIf
</I>&gt;<i> &gt; 	:	'if' expression 'then' codeBlock 'end if'
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I understand why the naive ifStatement fails with the following &quot;
</I>&gt;<i> &gt; [fatal] rule ifStatement has non-LL(*) decision due to recursive rule
</I>&gt;<i> &gt; invocations reachable from alts 1,2.  Resolve by left-factoring or
</I>&gt;<i> &gt; using syntactic predicates or using backtrack=true option.&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I would like to avoid general backtracking, so after searching for a
</I>&gt;<i> &gt; while and reading the article
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtrack">http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtrack</A>
</I>&gt;<i> &gt; ing+from+your+grammar
</I>&gt;<i> &gt; I have tried first
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ifStatement
</I>&gt;<i> &gt; 	:	'if' expression 'then' (singleStatement EOL)=&gt;
</I>&gt;<i> singleLineIf
</I>&gt;<i> &gt; 	| 	multiLineIf
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; or
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ifStatement
</I>&gt;<i> &gt; 	:	'if' expression 'then' (singleStatement EOL | codeBlock
</I>&gt;<i> 'end
</I>&gt;<i> &gt; if')
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; But they fail both with the same fatality.
</I>&gt;<i> &gt; How this case should be processed ?
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; S?bastien Kirche
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> &gt; Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-">http://www.antlr.org/mailman/options/antlr-interest/your-</A>
</I>&gt;<i> &gt; email-address
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 3
</I>&gt;<i> Date: Thu, 7 Jul 2011 07:41:41 +1000
</I>&gt;<i> From: James Ladd &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">james_ladd at hotmail.com</A>&gt;
</I>&gt;<i> Subject: [antlr-interest] Lines that don't match a rule ...
</I>&gt;<i> To: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">BAY149-w32B3DDCD6F82F6E204DDF9ED5E0 at phx.gbl</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;iso-8859-1&quot;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hi All,
</I>&gt;<i> 
</I>&gt;<i> I hope I can get a little help on the grammar I have below.
</I>&gt;<i> It works to a degree but I'm having trouble with some edge cases and that is
</I>&gt;<i> stressing me a little.
</I>&gt;<i> 
</I>&gt;<i> When I write something like the following I get the right response - sequence of tokens.
</I>&gt;<i> 
</I>&gt;<i> Im putting '\n' where I would have new lines.
</I>&gt;<i> 
</I>&gt;<i> \n
</I>&gt;<i> + foo\n
</I>&gt;<i> \n
</I>&gt;<i> 
</I>&gt;<i> What I can't seem to do is put in a rule that matches a line that doesn't start with '+' or '-'
</I>&gt;<i> I get a no viable Alt Exception with all that I try.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> My goal is to be able to detect lines starting with a '+' or a '-' followed by a messagePattern.
</I>&gt;<i> And lines NOT starting with a '+' or a '-'.  The grammar below does not contain any rules
</I>&gt;<i> for this, because I can't get them to work.
</I>&gt;<i> 
</I>&gt;<i> Please help
</I>&gt;<i> 
</I>&gt;<i> Rgs, James.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> grammar Preprocessor;
</I>&gt;<i> 
</I>&gt;<i> options {
</I>&gt;<i>   language = Java;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> @header {
</I>&gt;<i>   package compiler;
</I>&gt;<i> 
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> @lexer::header {
</I>&gt;<i>   package compiler;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> lines
</I>&gt;<i>   : (lineBreak | messagePattern)* EOF
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> messagePattern
</I>&gt;<i>   : ('+' | '-') (unarySelector | keywordSelector | binarySelector)
</I>&gt;<i> 
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> unarySelector
</I>&gt;<i>   : NAME
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> keywordSelector
</I>&gt;<i>   : (KEYWORD NAME)+
</I>&gt;<i>   ;
</I>&gt;<i>   
</I>&gt;<i> binarySelector
</I>&gt;<i>   : BINARY_SYMBOL NAME
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> lineBreak
</I>&gt;<i>   : LINE_BREAK  ;
</I>&gt;<i> 
</I>&gt;<i> LINE_BREAK: ('\r'? '\n' | '\r');
</I>&gt;<i> 
</I>&gt;<i> NAME: ('a'..'z' | 'A'..'Z')('a'..'z' | 'A'..'Z' | '0'..'9')*;
</I>&gt;<i> KEYWORD: NAME':';
</I>&gt;<i> BINARY_SYMBOL: ('~'|'!'|'@'|'%'|'&amp;'|'*'|'-'|'+'|'='|'\\'|'|'|'?'|'/'|'&gt;'|'&lt;'|',') ('~'|'!'|'@'|'%'|'&amp;'|'*'|'-'|'+'|'='|'\\'|'|'|'?'|'/'|'&gt;'|'&lt;'|',')*;
</I>&gt;<i> 
</I>&gt;<i>  		 	   		  
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 4
</I>&gt;<i> Date: Wed, 06 Jul 2011 18:14:16 -0400
</I>&gt;<i> From: &quot;John B. Brodie&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">1309990456.23994.21.camel at gecko</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;utf-8&quot;
</I>&gt;<i> 
</I>&gt;<i> Greetings!
</I>&gt;<i> 
</I>&gt;<i> On Wed, 2011-07-06 at 21:19 +0200, S?bastien Kirche wrote:
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; the language for which I am trying to build the grammar has 2 flavors
</I>&gt;<i> &gt; of if-then-else constructs
</I>&gt;<i> &gt; - a single line : if &lt;condition&gt; then &lt;statement&gt; [else &lt;statement&gt;]
</I>&gt;<i> &gt; - a multi line : if &lt;condition&gt; then &lt;statements&gt; [else &lt;statements&gt;] end if
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I have defined the following (partial) :
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; codeBlock
</I>&gt;<i> &gt; 	:	(compoundStatement)*
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; compoundStatement
</I>&gt;<i> &gt; 	:	(
</I>&gt;<i> &gt; 			ifStatement
</I>&gt;<i> &gt; 		|	singleStatement
</I>&gt;<i> &gt; 		) (';' | EOL)
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 	
</I>&gt;<i> &gt; singleStatement
</I>&gt;<i> &gt; 	:	localVariableDeclaration
</I>&gt;<i> &gt; 	|	funCall
</I>&gt;<i> &gt; 	|	'return' expression
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ifStatement
</I>&gt;<i> &gt; 	:	singleLineIf
</I>&gt;<i> &gt; 	|	multiLineIf
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; singleLineIf
</I>&gt;<i> &gt; 	:	'if' expression 'then' singleStatement EOL
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; multiLineIf
</I>&gt;<i> &gt; 	:	'if' expression 'then' codeBlock 'end if'
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I understand why the naive ifStatement fails with the following &quot;
</I>&gt;<i> &gt; [fatal] rule ifStatement has non-LL(*) decision due to recursive rule
</I>&gt;<i> &gt; invocations reachable from alts 1,2.  Resolve by left-factoring or
</I>&gt;<i> &gt; using syntactic predicates or using backtrack=true option.&quot;
</I>&gt;<i> 
</I>&gt;<i> unable to reproduce.
</I>&gt;<i> 
</I>&gt;<i> given your admittedly partial grammar, i tried to construct a complete
</I>&gt;<i> example by adding the missing elements and creating an AST (so i could
</I>&gt;<i> know the resultant parse).
</I>&gt;<i> 
</I>&gt;<i> my test rig is attached.
</I>&gt;<i> 
</I>&gt;<i> it runs without error when Tool'd, compiled, and executed from the
</I>&gt;<i> command-line (FWIW i use Ubunto 11.04 Linux running Sun Java 6 and the
</I>&gt;<i> Antlr version from the antlr-3.4-complete.jar file).
</I>&gt;<i> 
</I>&gt;<i> Please try to post the *smallest* yet *complete* example of your
</I>&gt;<i> problem.
</I>&gt;<i> 
</I>&gt;<i> Hope this helps...
</I>&gt;<i>    -jbb
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I would like to avoid general backtracking, so after searching for a
</I>&gt;<i> &gt; while and reading the article
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtracking+from+your+grammar">http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtracking+from+your+grammar</A>
</I>&gt;<i> &gt; I have tried first
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ifStatement
</I>&gt;<i> &gt; 	:	'if' expression 'then' (singleStatement EOL)=&gt; singleLineIf
</I>&gt;<i> &gt; 	| 	multiLineIf
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; or
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ifStatement
</I>&gt;<i> &gt; 	:	'if' expression 'then' (singleStatement EOL | codeBlock 'end if')
</I>&gt;<i> &gt; 	;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; But they fail both with the same fatality.
</I>&gt;<i> &gt; How this case should be processed ?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> grammar Test;
</I>&gt;<i> 
</I>&gt;<i> options {
</I>&gt;<i>    output = AST;
</I>&gt;<i>    ASTLabelType = CommonTree;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> tokens { SINGLE; MULTI; } // imaginary tokens go here
</I>&gt;<i> 
</I>&gt;<i> @members {
</I>&gt;<i>    private static final String [] x = new String[] {
</I>&gt;<i>       &quot;local x\n&quot;,
</I>&gt;<i>       &quot;if x then return 1\n\n&quot;,
</I>&gt;<i>       &quot;if x then if y then return 1\n\nend if\n&quot;,
</I>&gt;<i>       &quot;local x;if x then return 1\n;&quot;,
</I>&gt;<i>   };
</I>&gt;<i> 
</I>&gt;<i>    public static void main(String [] args) {
</I>&gt;<i>       for( int i = 0; i &lt; x.length; ++i ) {
</I>&gt;<i>          try {
</I>&gt;<i>             System.out.println(&quot;about to parse:`&quot;+x[i]+&quot;`&quot;);
</I>&gt;<i> 
</I>&gt;<i>             TestLexer lexer = new TestLexer(new ANTLRStringStream(x[i]));
</I>&gt;<i>             CommonTokenStream tokens = new CommonTokenStream(lexer);
</I>&gt;<i>             TestParser parser = new TestParser(tokens);
</I>&gt;<i>             TestParser.test_return p_result = parser.test();
</I>&gt;<i> 
</I>&gt;<i>             // System.out.format(&quot;the token stream:\%n&quot;);
</I>&gt;<i>             // for( int j = 0; j &lt; tokens.size(); ++j ) {
</I>&gt;<i>             //    Token token = tokens.get(j);
</I>&gt;<i>             //    System.out.format(&quot;\%d: type = \%s, text = `\%s`\%n&quot;,
</I>&gt;<i>             //                      j,
</I>&gt;<i>             //                      tokenNames[token.getType()],
</I>&gt;<i>             //                      token.getText());
</I>&gt;<i>             // }
</I>&gt;<i> 
</I>&gt;<i>             CommonTree ast = p_result.tree;
</I>&gt;<i>             if( ast == null ) {
</I>&gt;<i>                System.out.println(&quot;resultant tree: is NULL&quot;);
</I>&gt;<i>             } else {
</I>&gt;<i>                System.out.println(&quot;resultant tree: &quot; + ast.toStringTree());
</I>&gt;<i>             }
</I>&gt;<i>             System.out.println();
</I>&gt;<i>          } catch(Exception e) {
</I>&gt;<i>             e.printStackTrace();
</I>&gt;<i>          }
</I>&gt;<i>       }
</I>&gt;<i>    }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> test : codeBlock EOF! ;
</I>&gt;<i> 
</I>&gt;<i> codeBlock
</I>&gt;<i>         :       (compoundStatement)*
</I>&gt;<i>         ;
</I>&gt;<i> 
</I>&gt;<i> compoundStatement
</I>&gt;<i>         :       (
</I>&gt;<i>                         ifStatement
</I>&gt;<i>                 |       singleStatement
</I>&gt;<i>                 ) (';' | EOL)
</I>&gt;<i>         ;
</I>&gt;<i>         
</I>&gt;<i> singleStatement
</I>&gt;<i>         :       localVariableDeclaration
</I>&gt;<i>         |       funCall
</I>&gt;<i>         |       'return'^ expression
</I>&gt;<i>         ;
</I>&gt;<i> 
</I>&gt;<i> ifStatement
</I>&gt;<i>         :       singleLineIf
</I>&gt;<i>         |       multiLineIf
</I>&gt;<i>         ;
</I>&gt;<i> 
</I>&gt;<i> singleLineIf
</I>&gt;<i>         :       'if' expression 'then' singleStatement EOL
</I>&gt;<i>       -&gt; ^(SINGLE expression singleStatement)
</I>&gt;<i>         ;
</I>&gt;<i> 
</I>&gt;<i> multiLineIf
</I>&gt;<i>         :       'if' expression 'then' codeBlock 'end if'
</I>&gt;<i>       -&gt; ^(MULTI expression codeBlock)
</I>&gt;<i>         ;
</I>&gt;<i> 
</I>&gt;<i> localVariableDeclaration : 'local'^ ID+ ;
</I>&gt;<i> funCall : ID '('^ args? ')'! ;
</I>&gt;<i> args : expression (','^ expression)* ;
</I>&gt;<i> expression : term (op^ term)* ;
</I>&gt;<i> term : ID | NUMBER ;
</I>&gt;<i> op : '+' | '-' | '*' | '/' ;
</I>&gt;<i> 
</I>&gt;<i> EOL : '\r'? '\n' ;
</I>&gt;<i> 
</I>&gt;<i> WS : (' ' | '\t')+ { skip(); };
</I>&gt;<i> 
</I>&gt;<i> ID : LETTER ( LETTER | DIGIT )* ;
</I>&gt;<i> 
</I>&gt;<i> NUMBER : DIGIT+ ;
</I>&gt;<i> 
</I>&gt;<i> fragment LETTER : ('a'..'z')|('A'..'Z') ;
</I>&gt;<i> fragment DIGIT : '0'..'9' ;
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 5
</I>&gt;<i> Date: Wed, 6 Jul 2011 19:15:59 -0400
</I>&gt;<i> From: James Reid &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">james1018 at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Think I found a bug.
</I>&gt;<i> To: Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt;
</I>&gt;<i> Cc: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">CAPtNrFbfvCY_f3hLTR62RqEh+N-uFfiZdrzJckmUnuxNqzbBuA at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1
</I>&gt;<i> 
</I>&gt;<i> This worked...
</I>&gt;<i> 
</I>&gt;<i> @Override
</I>&gt;<i>     public void reset() {
</I>&gt;<i>         super.reset();
</I>&gt;<i>         p = skipOffTokenChannels(0);
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> Glad I could contribute in some small way.
</I>&gt;<i> 
</I>&gt;<i> James
</I>&gt;<i> 
</I>&gt;<i> On Wed, Jul 6, 2011 at 1:57 PM, Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; Hi James. ack! i think reset() should call
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; skipOffTokenChannels()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Can you override reset to call super.reset() then skipOffTokenChannels()
</I>&gt;<i> &gt; and see if that works?  If so, i can fix for 3.4
</I>&gt;<i> &gt; Ter
</I>&gt;<i> &gt; On Jul 5, 2011, at 5:30 AM, James Reid wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; Hi all,
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;  I think I found a bug but I want to be sure.  I have a parser grammar
</I>&gt;<i> &gt; that
</I>&gt;<i> &gt; &gt; I run two passes on.  Here are short versions of the rules.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; firstpass
</I>&gt;<i> &gt; &gt;  :  (collect_matches
</I>&gt;<i> &gt; &gt;  |  collect_labels
</I>&gt;<i> &gt; &gt;  |  .)*
</I>&gt;<i> &gt; &gt;  ;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; script
</I>&gt;<i> &gt; &gt;  :  header? matches* EOF
</I>&gt;<i> &gt; &gt;  ;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; When I run the code I use a CommonTokenStream and do the following
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; CommonTokenStream tokens = new CommonTokenStream(lex);
</I>&gt;<i> &gt; &gt; MyParser parser = new MyParser(tokens);
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; parser.firstpass();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; tokens.reset();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; parser.script();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The problem comes when I do the tokens.reset().  If the very first token
</I>&gt;<i> &gt; is
</I>&gt;<i> &gt; &gt; a comment (i.e. on the hidden channel) it is returned in parser.script()
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt; &gt; throws a NoViableAlternativeException because nothing in my grammar is
</I>&gt;<i> &gt; &gt; expecting a comment.  To get around this I do the following...
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;           //Reset the tokens back to the begining
</I>&gt;<i> &gt; &gt;            tokens.reset();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;            //For some reason after the tokens have been buffered up if a
</I>&gt;<i> &gt; &gt; hidden
</I>&gt;<i> &gt; &gt;            //token is the first token it is returned instead getting the
</I>&gt;<i> &gt; &gt;            //first non-hidden token.  This little hack works around that.
</I>&gt;<i> &gt; &gt;            if (tokens.LT(1).getChannel() == Token.HIDDEN_CHANNEL){
</I>&gt;<i> &gt; &gt;                tokens.consume();
</I>&gt;<i> &gt; &gt;            }
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;            //now we can build the AST
</I>&gt;<i> &gt; &gt;            r=parser.script();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; If I consume the hidden token then the token stream points at the next
</I>&gt;<i> &gt; &gt; on-channel token like it is supposed to do.  Is this a bug or am I doing
</I>&gt;<i> &gt; &gt; things wrong?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Thanks,
</I>&gt;<i> &gt; &gt; James
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; PS:  This is with Antlr 3.3
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> &gt; &gt; Unsubscribe:
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 6
</I>&gt;<i> Date: Thu, 7 Jul 2011 01:27:33 +0200
</I>&gt;<i> From: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: &quot;John B. Brodie&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">CALGPt8bbeQOGHJEB8zzXYbyiMbjmQJoT6bqEqJEq5SbU03z7_g at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;iso-8859-1&quot;
</I>&gt;<i> 
</I>&gt;<i> Le 7 juillet 2011 00:14, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; Greetings!
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; [...]
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; unable to reproduce.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; given your admittedly partial grammar, i tried to construct a complete
</I>&gt;<i> &gt; example by adding the missing elements and creating an AST (so i could
</I>&gt;<i> &gt; know the resultant parse).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; my test rig is attached.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; it runs without error when Tool'd, compiled, and executed from the
</I>&gt;<i> &gt; command-line (FWIW i use Ubunto 11.04 Linux running Sun Java 6 and the
</I>&gt;<i> &gt; Antlr version from the antlr-3.4-complete.jar file).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Please try to post the *smallest* yet *complete* example of your
</I>&gt;<i> &gt; problem.
</I>&gt;<i> 
</I>&gt;<i> Sorry for not having posted a more complete code before, I though that
</I>&gt;<i> should have been enough...
</I>&gt;<i> 
</I>&gt;<i> I have worked further on my grammar, with trying to define more
</I>&gt;<i> precisely what an expression should be, with operator precedence. This
</I>&gt;<i> made me rewrite the singleStatement by moving the funCall  rule to the
</I>&gt;<i> primary rule. But my problem about the if-then-else construct is not
</I>&gt;<i> gone.
</I>&gt;<i> 
</I>&gt;<i> I have stripped down my grammar, keeping only the expression and
</I>&gt;<i> subsequent rules, removed all that define loops, switches, etc.
</I>&gt;<i> Given that simplified grammar, the following script should pass the
</I>&gt;<i> parsing, but it can't yet :
</I>&gt;<i> 
</I>&gt;<i> ---------------------------------------
</I>&gt;<i> string s1, s2
</I>&gt;<i> 
</I>&gt;<i> if s1='42' then s2='421'
</I>&gt;<i> 
</I>&gt;<i> if s2='421' then
</I>&gt;<i> 	string s3
</I>&gt;<i> 	s3='123'
</I>&gt;<i> else
</I>&gt;<i> 	string s4
</I>&gt;<i> 	s4='666'
</I>&gt;<i> end if
</I>&gt;<i> 
</I>&gt;<i> ---------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Also, to Jim Idle : the language I would be able to parse is
</I>&gt;<i> Powerbuilder. You can see it as a sort of basic, while it accepts
</I>&gt;<i> syntax like i++ or s += 'foo' He has also the ability to accept inline
</I>&gt;<i> sql statements... I tried to play on the EndOfLine delimiter to handle
</I>&gt;<i> the two if-then-else syntaxes but without success.
</I>&gt;<i> 
</I>&gt;<i> -- 
</I>&gt;<i> S?bastien Kirche
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> A non-text attachment was scrubbed...
</I>&gt;<i> Name: pbifthenelse.g
</I>&gt;<i> Type: application/octet-stream
</I>&gt;<i> Size: 2646 bytes
</I>&gt;<i> Desc: not available
</I>&gt;<i> Url : <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20110707/4b4433d8/attachment-0001.obj">http://www.antlr.org/pipermail/antlr-interest/attachments/20110707/4b4433d8/attachment-0001.obj</A> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 7
</I>&gt;<i> Date: Wed, 6 Jul 2011 16:30:52 -0700
</I>&gt;<i> From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Lines that don't match a rule ...
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">6556c9d271c906dfb308bb73f0e8e262 at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i> 
</I>&gt;<i> Try:
</I>&gt;<i> 
</I>&gt;<i> lines
</I>&gt;<i>   : (messagePattern LINE_BREAK)* EOF
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> messagePattern
</I>&gt;<i>   : ('+' | '-') (unarySelector | keywordSelector | binarySelector)
</I>&gt;<i>   | { while (input.LA(1) != LINE_BREAK &amp;&amp; input.LA(1) != EOF)
</I>&gt;<i> input.consume(); }
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> This will just eat the lines that don't
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of James Ladd
</I>&gt;<i> &gt; Sent: Wednesday, July 06, 2011 2:42 PM
</I>&gt;<i> &gt; To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> &gt; Subject: [antlr-interest] Lines that don't match a rule ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hi All,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I hope I can get a little help on the grammar I have below.
</I>&gt;<i> &gt; It works to a degree but I'm having trouble with some edge cases and
</I>&gt;<i> &gt; that is stressing me a little.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; When I write something like the following I get the right response -
</I>&gt;<i> &gt; sequence of tokens.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Im putting '\n' where I would have new lines.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; \n
</I>&gt;<i> &gt; + foo\n
</I>&gt;<i> &gt; \n
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; What I can't seem to do is put in a rule that matches a line that
</I>&gt;<i> &gt; doesn't start with '+' or '-'
</I>&gt;<i> &gt; I get a no viable Alt Exception with all that I try.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; My goal is to be able to detect lines starting with a '+' or a '-'
</I>&gt;<i> &gt; followed by a messagePattern.
</I>&gt;<i> &gt; And lines NOT starting with a '+' or a '-'.  The grammar below does not
</I>&gt;<i> &gt; contain any rules for this, because I can't get them to work.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Please help
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Rgs, James.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; grammar Preprocessor;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; options {
</I>&gt;<i> &gt;   language = Java;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @header {
</I>&gt;<i> &gt;   package compiler;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @lexer::header {
</I>&gt;<i> &gt;   package compiler;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; lines
</I>&gt;<i> &gt;   : (lineBreak | messagePattern)* EOF
</I>&gt;<i> &gt;   ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; messagePattern
</I>&gt;<i> &gt;   : ('+' | '-') (unarySelector | keywordSelector | binarySelector)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; unarySelector
</I>&gt;<i> &gt;   : NAME
</I>&gt;<i> &gt;   ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; keywordSelector
</I>&gt;<i> &gt;   : (KEYWORD NAME)+
</I>&gt;<i> &gt;   ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; binarySelector
</I>&gt;<i> &gt;   : BINARY_SYMBOL NAME
</I>&gt;<i> &gt;   ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; lineBreak
</I>&gt;<i> &gt;   : LINE_BREAK  ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; LINE_BREAK: ('\r'? '\n' | '\r');
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; NAME: ('a'..'z' | 'A'..'Z')('a'..'z' | 'A'..'Z' | '0'..'9')*;
</I>&gt;<i> &gt; KEYWORD: NAME':';
</I>&gt;<i> &gt; BINARY_SYMBOL: ('~'|'!'|'@'|'%'|'&amp;'|'*'|'-
</I>&gt;<i> &gt; '|'+'|'='|'\\'|'|'|'?'|'/'|'&gt;'|'&lt;'|',') ('~'|'!'|'@'|'%'|'&amp;'|'*'|'-
</I>&gt;<i> &gt; '|'+'|'='|'\\'|'|'|'?'|'/'|'&gt;'|'&lt;'|',')*;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> &gt; Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-">http://www.antlr.org/mailman/options/antlr-interest/your-</A>
</I>&gt;<i> &gt; email-address
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 8
</I>&gt;<i> Date: Wed, 6 Jul 2011 16:40:06 -0700
</I>&gt;<i> From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">f957627cd66bd58cdc0ac4c81c8c6234 at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i> 
</I>&gt;<i> yes - I pretty sure that you need to pass in the EOL token to the parser
</I>&gt;<i> for powerbuilder script to parse (it is pretty crummy but there is a lot
</I>&gt;<i> of it out there). Here is a snippet from my VB.Net grammar which allows
</I>&gt;<i> the various combinations. When you build the AST, it does not need to
</I>&gt;<i> distinguish between single and multi lines.
</I>&gt;<i> 
</I>&gt;<i> Also, do not worry about these things until you have the full expression
</I>&gt;<i> tree working as that will sometimes make you say &quot;Ahhhhhgggh, now I have
</I>&gt;<i> to rework all my statements. Do:
</I>&gt;<i> 
</I>&gt;<i> 1) Build the lexer, thinking ahead a bit about the parser;
</I>&gt;<i> 2) Build the expression tree and generate the AST for it;
</I>&gt;<i> 3) Build the language top down (though bottom up works too);
</I>&gt;<i> 
</I>&gt;<i> Or you could pay me to do it as I have no work on right now ;-) boo hoo.
</I>&gt;<i> 
</I>&gt;<i> Jim
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of S?bastien Kirche
</I>&gt;<i> &gt; Sent: Wednesday, July 06, 2011 4:28 PM
</I>&gt;<i> &gt; To: John B. Brodie
</I>&gt;<i> &gt; Cc: antlr-interest
</I>&gt;<i> &gt; Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Le 7 juillet 2011 00:14, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; &gt; Greetings!
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; [...]
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; unable to reproduce.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; given your admittedly partial grammar, i tried to construct a
</I>&gt;<i> &gt; complete
</I>&gt;<i> &gt; &gt; example by adding the missing elements and creating an AST (so i
</I>&gt;<i> &gt; could
</I>&gt;<i> &gt; &gt; know the resultant parse).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; my test rig is attached.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; it runs without error when Tool'd, compiled, and executed from the
</I>&gt;<i> &gt; &gt; command-line (FWIW i use Ubunto 11.04 Linux running Sun Java 6 and
</I>&gt;<i> &gt; the
</I>&gt;<i> &gt; &gt; Antlr version from the antlr-3.4-complete.jar file).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Please try to post the *smallest* yet *complete* example of your
</I>&gt;<i> &gt; &gt; problem.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sorry for not having posted a more complete code before, I though that
</I>&gt;<i> &gt; should have been enough...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have worked further on my grammar, with trying to define more
</I>&gt;<i> &gt; precisely what an expression should be, with operator precedence. This
</I>&gt;<i> &gt; made me rewrite the singleStatement by moving the funCall  rule to the
</I>&gt;<i> &gt; primary rule. But my problem about the if-then-else construct is not
</I>&gt;<i> &gt; gone.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have stripped down my grammar, keeping only the expression and
</I>&gt;<i> &gt; subsequent rules, removed all that define loops, switches, etc.
</I>&gt;<i> &gt; Given that simplified grammar, the following script should pass the
</I>&gt;<i> &gt; parsing, but it can't yet :
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt; string s1, s2
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if s1='42' then s2='421'
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if s2='421' then
</I>&gt;<i> &gt; 	string s3
</I>&gt;<i> &gt; 	s3='123'
</I>&gt;<i> &gt; else
</I>&gt;<i> &gt; 	string s4
</I>&gt;<i> &gt; 	s4='666'
</I>&gt;<i> &gt; end if
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Also, to Jim Idle : the language I would be able to parse is
</I>&gt;<i> &gt; Powerbuilder. You can see it as a sort of basic, while it accepts
</I>&gt;<i> &gt; syntax like i++ or s += 'foo' He has also the ability to accept inline
</I>&gt;<i> &gt; sql statements... I tried to play on the EndOfLine delimiter to handle
</I>&gt;<i> &gt; the two if-then-else syntaxes but without success.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; S?bastien Kirche
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 9
</I>&gt;<i> Date: Wed, 6 Jul 2011 16:42:16 -0700
</I>&gt;<i> From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">5fecdc401ad60835d82fdc1bc3cd50d1 at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i> 
</I>&gt;<i> With the example this time:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ifStatement
</I>&gt;<i> 	: IF e=expression
</I>&gt;<i> 		(
</I>&gt;<i> 			  t=THEN
</I>&gt;<i> 			  	(
</I>&gt;<i> 			  	  		// Single line IF
</I>&gt;<i> statement as the last token was not a NL
</I>&gt;<i> 			  	  		//
</I>&gt;<i> 			  	  		s1=statements
</I>&gt;<i> ((ELSE)=&gt;ELSE s2=statements)?
</I>&gt;<i> 
</I>&gt;<i> 						-&gt; {$s2.tree == null}?
</I>&gt;<i> ^(IFLINE $e ^(THEN $s1))
</I>&gt;<i> 						-&gt;
</I>&gt;<i> ^(IFLINE $e ^(THEN $s1) ^(ELSE $s2*))
</I>&gt;<i> 
</I>&gt;<i> 			  	  | (NL|COLON)+
</I>&gt;<i> 
</I>&gt;<i> 			  	  	// We discovered a NL token, hence
</I>&gt;<i> we process
</I>&gt;<i> 			  	    // a block If here as it has to be a
</I>&gt;<i> block when the line with
</I>&gt;<i> 			  	    // the IF on it has a NL before the
</I>&gt;<i> first statement.
</I>&gt;<i> 			  	    //
</I>&gt;<i> 			  	    ib=ifBlock
</I>&gt;<i> 
</I>&gt;<i> 			  	    	-&gt; ^(IF $e $ib)
</I>&gt;<i> 			  	)
</I>&gt;<i> 
</I>&gt;<i> 			| (NL|COLON)+
</I>&gt;<i> 
</I>&gt;<i> 			  // We did not see a THEN clause, but it is
</I>&gt;<i> optional on block IF statements
</I>&gt;<i> 			  // (which is a bit silly, but a left over from
</I>&gt;<i> VB 1 I suspect. Hence we process
</I>&gt;<i> 			  // a block If here.
</I>&gt;<i> 			  //
</I>&gt;<i> 			  ib=ifBlock
</I>&gt;<i> 
</I>&gt;<i> 			  		-&gt; ^(IF $e $ib)
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> ifBlock
</I>&gt;<i> 	: 		tb=block
</I>&gt;<i> 
</I>&gt;<i> 	  		(eib+=elseIfStatement)*
</I>&gt;<i> 
</I>&gt;<i> 	 		(
</I>&gt;<i> 	 			  ec=elseClause		// Else Clause
</I>&gt;<i> handles END IF
</I>&gt;<i> 				| END IF
</I>&gt;<i> 			)
</I>&gt;<i> 
</I>&gt;<i> 		-&gt;	^(THEN $tb?) $eib* $ec?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> elseClause
</I>&gt;<i> 	: 	ELSE^ 	(
</I>&gt;<i> 					  (NL!|COLON!)+ block END! IF!
</I>&gt;<i> 					| statement
</I>&gt;<i> 				)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> elseIfStatement
</I>&gt;<i> 	: ELSEIF e=expression THEN? (NL|COLON)+ b=block
</I>&gt;<i> 
</I>&gt;<i> 		-&gt; ^(ELSEIF $e $b?)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> Where 'block' is one or more statements (might need zero or more for
</I>&gt;<i> powerbuilder).
</I>&gt;<i> 
</I>&gt;<i> Jim
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of S?bastien Kirche
</I>&gt;<i> &gt; Sent: Wednesday, July 06, 2011 4:28 PM
</I>&gt;<i> &gt; To: John B. Brodie
</I>&gt;<i> &gt; Cc: antlr-interest
</I>&gt;<i> &gt; Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Le 7 juillet 2011 00:14, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; &gt; Greetings!
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; [...]
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; unable to reproduce.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; given your admittedly partial grammar, i tried to construct a
</I>&gt;<i> &gt; complete
</I>&gt;<i> &gt; &gt; example by adding the missing elements and creating an AST (so i
</I>&gt;<i> &gt; could
</I>&gt;<i> &gt; &gt; know the resultant parse).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; my test rig is attached.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; it runs without error when Tool'd, compiled, and executed from the
</I>&gt;<i> &gt; &gt; command-line (FWIW i use Ubunto 11.04 Linux running Sun Java 6 and
</I>&gt;<i> &gt; the
</I>&gt;<i> &gt; &gt; Antlr version from the antlr-3.4-complete.jar file).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Please try to post the *smallest* yet *complete* example of your
</I>&gt;<i> &gt; &gt; problem.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sorry for not having posted a more complete code before, I though that
</I>&gt;<i> &gt; should have been enough...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have worked further on my grammar, with trying to define more
</I>&gt;<i> &gt; precisely what an expression should be, with operator precedence. This
</I>&gt;<i> &gt; made me rewrite the singleStatement by moving the funCall  rule to the
</I>&gt;<i> &gt; primary rule. But my problem about the if-then-else construct is not
</I>&gt;<i> &gt; gone.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have stripped down my grammar, keeping only the expression and
</I>&gt;<i> &gt; subsequent rules, removed all that define loops, switches, etc.
</I>&gt;<i> &gt; Given that simplified grammar, the following script should pass the
</I>&gt;<i> &gt; parsing, but it can't yet :
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt; string s1, s2
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if s1='42' then s2='421'
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if s2='421' then
</I>&gt;<i> &gt; 	string s3
</I>&gt;<i> &gt; 	s3='123'
</I>&gt;<i> &gt; else
</I>&gt;<i> &gt; 	string s4
</I>&gt;<i> &gt; 	s4='666'
</I>&gt;<i> &gt; end if
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Also, to Jim Idle : the language I would be able to parse is
</I>&gt;<i> &gt; Powerbuilder. You can see it as a sort of basic, while it accepts
</I>&gt;<i> &gt; syntax like i++ or s += 'foo' He has also the ability to accept inline
</I>&gt;<i> &gt; sql statements... I tried to play on the EndOfLine delimiter to handle
</I>&gt;<i> &gt; the two if-then-else syntaxes but without success.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; S?bastien Kirche
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 10
</I>&gt;<i> Date: Wed, 6 Jul 2011 16:51:43 -0700
</I>&gt;<i> From: Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Think I found a bug.
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">james1018 at gmail.com</A>
</I>&gt;<i> Cc: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">2804C178-36DD-4203-A1BE-4640612C1C99 at cs.usfca.edu</A>&gt;
</I>&gt;<i> Content-Type: text/plain;	charset=us-ascii
</I>&gt;<i> 
</I>&gt;<i> tanx. fixed for 3.4
</I>&gt;<i> Ter
</I>&gt;<i> On Jul 6, 2011, at 4:15 PM, James Reid wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; This worked...
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; @Override
</I>&gt;<i> &gt;     public void reset() {
</I>&gt;<i> &gt;         super.reset();
</I>&gt;<i> &gt;         p = skipOffTokenChannels(0);
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Glad I could contribute in some small way.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; James
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; On Wed, Jul 6, 2011 at 1:57 PM, Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt; wrote:
</I>&gt;<i> &gt; Hi James. ack! i think reset() should call
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; skipOffTokenChannels()
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Can you override reset to call super.reset() then skipOffTokenChannels() and see if that works?  If so, i can fix for 3.4
</I>&gt;<i> &gt; Ter
</I>&gt;<i> &gt; On Jul 5, 2011, at 5:30 AM, James Reid wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; Hi all,
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;  I think I found a bug but I want to be sure.  I have a parser grammar that
</I>&gt;<i> &gt; &gt; I run two passes on.  Here are short versions of the rules.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; firstpass
</I>&gt;<i> &gt; &gt;  :  (collect_matches
</I>&gt;<i> &gt; &gt;  |  collect_labels
</I>&gt;<i> &gt; &gt;  |  .)*
</I>&gt;<i> &gt; &gt;  ;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; script
</I>&gt;<i> &gt; &gt;  :  header? matches* EOF
</I>&gt;<i> &gt; &gt;  ;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; When I run the code I use a CommonTokenStream and do the following
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; CommonTokenStream tokens = new CommonTokenStream(lex);
</I>&gt;<i> &gt; &gt; MyParser parser = new MyParser(tokens);
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; parser.firstpass();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; tokens.reset();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; parser.script();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The problem comes when I do the tokens.reset().  If the very first token is
</I>&gt;<i> &gt; &gt; a comment (i.e. on the hidden channel) it is returned in parser.script() and
</I>&gt;<i> &gt; &gt; throws a NoViableAlternativeException because nothing in my grammar is
</I>&gt;<i> &gt; &gt; expecting a comment.  To get around this I do the following...
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;           //Reset the tokens back to the begining
</I>&gt;<i> &gt; &gt;            tokens.reset();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;            //For some reason after the tokens have been buffered up if a
</I>&gt;<i> &gt; &gt; hidden
</I>&gt;<i> &gt; &gt;            //token is the first token it is returned instead getting the
</I>&gt;<i> &gt; &gt;            //first non-hidden token.  This little hack works around that.
</I>&gt;<i> &gt; &gt;            if (tokens.LT(1).getChannel() == Token.HIDDEN_CHANNEL){
</I>&gt;<i> &gt; &gt;                tokens.consume();
</I>&gt;<i> &gt; &gt;            }
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;            //now we can build the AST
</I>&gt;<i> &gt; &gt;            r=parser.script();
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; If I consume the hidden token then the token stream points at the next
</I>&gt;<i> &gt; &gt; on-channel token like it is supposed to do.  Is this a bug or am I doing
</I>&gt;<i> &gt; &gt; things wrong?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Thanks,
</I>&gt;<i> &gt; &gt; James
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; PS:  This is with Antlr 3.3
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> &gt; &gt; Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 11
</I>&gt;<i> Date: Wed, 06 Jul 2011 23:08:05 -0400
</I>&gt;<i> From: &quot;John B. Brodie&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">1310008085.28443.1.camel at gecko</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;utf-8&quot;
</I>&gt;<i> 
</I>&gt;<i> see attached.
</I>&gt;<i> 
</I>&gt;<i> I, also, am available for hire, if you should opt for that...
</I>&gt;<i> 
</I>&gt;<i>    -jbb
</I>&gt;<i> 
</I>&gt;<i> On Thu, 2011-07-07 at 01:27 +0200, S?bastien Kirche wrote:
</I>&gt;<i> &gt; Le 7 juillet 2011 00:14, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; &gt; Greetings!
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; [...]
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; unable to reproduce.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; given your admittedly partial grammar, i tried to construct a complete
</I>&gt;<i> &gt; &gt; example by adding the missing elements and creating an AST (so i could
</I>&gt;<i> &gt; &gt; know the resultant parse).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; my test rig is attached.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; it runs without error when Tool'd, compiled, and executed from the
</I>&gt;<i> &gt; &gt; command-line (FWIW i use Ubunto 11.04 Linux running Sun Java 6 and the
</I>&gt;<i> &gt; &gt; Antlr version from the antlr-3.4-complete.jar file).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Please try to post the *smallest* yet *complete* example of your
</I>&gt;<i> &gt; &gt; problem.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Sorry for not having posted a more complete code before, I though that
</I>&gt;<i> &gt; should have been enough...
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I have worked further on my grammar, with trying to define more
</I>&gt;<i> &gt; precisely what an expression should be, with operator precedence. This
</I>&gt;<i> &gt; made me rewrite the singleStatement by moving the funCall  rule to the
</I>&gt;<i> &gt; primary rule. But my problem about the if-then-else construct is not
</I>&gt;<i> &gt; gone.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I have stripped down my grammar, keeping only the expression and
</I>&gt;<i> &gt; subsequent rules, removed all that define loops, switches, etc.
</I>&gt;<i> &gt; Given that simplified grammar, the following script should pass the
</I>&gt;<i> &gt; parsing, but it can't yet :
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt; string s1, s2
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; if s1='42' then s2='421'
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; if s2='421' then
</I>&gt;<i> &gt; 	string s3
</I>&gt;<i> &gt; 	s3='123'
</I>&gt;<i> &gt; else
</I>&gt;<i> &gt; 	string s4
</I>&gt;<i> &gt; 	s4='666'
</I>&gt;<i> &gt; end if
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Also, to Jim Idle : the language I would be able to parse is
</I>&gt;<i> &gt; Powerbuilder. You can see it as a sort of basic, while it accepts
</I>&gt;<i> &gt; syntax like i++ or s += 'foo' He has also the ability to accept inline
</I>&gt;<i> &gt; sql statements... I tried to play on the EndOfLine delimiter to handle
</I>&gt;<i> &gt; the two if-then-else syntaxes but without success.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> grammar pbifthenelse;
</I>&gt;<i> 
</I>&gt;<i> options {
</I>&gt;<i>    output = AST;
</I>&gt;<i>    ASTLabelType = CommonTree;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> @members {
</I>&gt;<i>    private static final String [] x = new String[] {
</I>&gt;<i>       &quot;string s1, s2\n&quot;+
</I>&gt;<i>       &quot;\n&quot;+
</I>&gt;<i>       &quot;if s1='42' then s2='421'\n&quot;+
</I>&gt;<i>       &quot;\n&quot;+
</I>&gt;<i>       &quot;if s2='421' then\n&quot;+
</I>&gt;<i>       &quot;        string s3\n&quot;+
</I>&gt;<i>       &quot;        s3='123'\n&quot;+
</I>&gt;<i>       &quot;else\n&quot;+
</I>&gt;<i>       &quot;        string s4\n&quot;+
</I>&gt;<i>       &quot;        s4='666'\n&quot;+
</I>&gt;<i>       &quot;end if\n&quot;,
</I>&gt;<i>       &quot;string s1 = '42', s2='999', s3='101'\n&quot;+
</I>&gt;<i>       &quot;\n&quot;+
</I>&gt;<i>       &quot;if s1='42' then s2='421'\n&quot;+
</I>&gt;<i>       &quot;\n&quot;+
</I>&gt;<i>       &quot;if s2='421' then\n&quot;+
</I>&gt;<i>       &quot;        s3='123'\n&quot;+
</I>&gt;<i>       &quot;else\n&quot;+
</I>&gt;<i>       &quot;        s3='666'\n&quot;+
</I>&gt;<i>       &quot;end if\n&quot;
</I>&gt;<i>   };
</I>&gt;<i> 
</I>&gt;<i>    public static void main(String [] args) {
</I>&gt;<i>       for( int i = 0; i &lt; x.length; ++i ) {
</I>&gt;<i>          try {
</I>&gt;<i>             System.out.println(&quot;about to parse:`&quot;+x[i]+&quot;`&quot;);
</I>&gt;<i> 
</I>&gt;<i>             pbifthenelseLexer lexer =
</I>&gt;<i>                new pbifthenelseLexer(new ANTLRStringStream(x[i]));
</I>&gt;<i>             CommonTokenStream tokens = new CommonTokenStream(lexer);
</I>&gt;<i>             pbifthenelseParser parser = new pbifthenelseParser(tokens);
</I>&gt;<i>             pbifthenelseParser.pgm_return p_result = parser.pgm();
</I>&gt;<i> 
</I>&gt;<i>             // System.out.format(&quot;the token stream:\%n&quot;);
</I>&gt;<i>             // for( int j = 0; j &lt; tokens.size(); ++j ) {
</I>&gt;<i>             //    Token token = tokens.get(j);
</I>&gt;<i>             //    System.out.format(&quot;\%d: type = \%s, text = `\%s`\%n&quot;,
</I>&gt;<i>             //                      j,
</I>&gt;<i>             //                      tokenNames[token.getType()],
</I>&gt;<i>             //                      token.getText());
</I>&gt;<i>             // }
</I>&gt;<i> 
</I>&gt;<i>             CommonTree ast = p_result.tree;
</I>&gt;<i>             if( ast == null ) {
</I>&gt;<i>                System.out.println(&quot;resultant tree: is NULL&quot;);
</I>&gt;<i>             } else {
</I>&gt;<i>                System.out.println(&quot;resultant tree: &quot; + ast.toStringTree());
</I>&gt;<i>             }
</I>&gt;<i>             System.out.println();
</I>&gt;<i>          } catch(Exception e) {
</I>&gt;<i>             e.printStackTrace();
</I>&gt;<i>          }
</I>&gt;<i>       }
</I>&gt;<i>    }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> pgm : codeBlock EOF!;
</I>&gt;<i> 
</I>&gt;<i> codeBlock : ( compoundStatement )* ;
</I>&gt;<i> 
</I>&gt;<i> compoundStatement
</I>&gt;<i>    : (  /* empty */
</I>&gt;<i>       | localVariableDeclaration
</I>&gt;<i>       | ifStatement
</I>&gt;<i>       | singleStatement
</I>&gt;<i>       ) ( ';' | EOL )
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> singleStatement : assignment ;
</I>&gt;<i> 
</I>&gt;<i> assignment : IDENTIFIER OPEQ expression ;
</I>&gt;<i> 
</I>&gt;<i> ifStatement
</I>&gt;<i>    : 'if' expression 'then'
</I>&gt;<i>       ((singleStatement ('else' singleStatement)? EOL)=&gt;
</I>&gt;<i>          singleStatement ('else' singleStatement)?
</I>&gt;<i>       | codeBlock ('else' codeBlock)? 'end if'
</I>&gt;<i>       )
</I>&gt;<i>    ;
</I>&gt;<i> // predicate is needed to distinguish between the singleStatment for a
</I>&gt;<i> // single line IF and the singleStatement within a compoundStatement
</I>&gt;<i> // comprising a codeBlock that contains just one statement within a
</I>&gt;<i> // multi-line IF.
</I>&gt;<i> 
</I>&gt;<i> localVariableDeclaration
</I>&gt;<i>    : dataType variableDeclaration (',' variableDeclaration)*
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> variableDeclaration
</I>&gt;<i>    : IDENTIFIER ( OPEQ literal)?
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> dataType
</I>&gt;<i>    : 'int' | 'integer'
</I>&gt;<i>    | 'long'
</I>&gt;<i>    | 'string'
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> expression : logicalORExpr ;
</I>&gt;<i> 
</I>&gt;<i> logicalORExpr : logicalANDExpr ('or' logicalANDExpr)* ;
</I>&gt;<i> 
</I>&gt;<i> logicalANDExpr : logicalNOTExpr ('and' logicalNOTExpr)* ;
</I>&gt;<i> 
</I>&gt;<i> logicalNOTExpr : 'not'? relationalExpr ;
</I>&gt;<i> 
</I>&gt;<i> relationalExpr : binaryPlusMinus (logicalOP binaryPlusMinus)* ;
</I>&gt;<i> 
</I>&gt;<i> binaryPlusMinus : unaryExpr (('+' | '-') binaryMulDiv)* ;
</I>&gt;<i> 
</I>&gt;<i> unaryExpr : ('+' | '-')? binaryMulDiv ;
</I>&gt;<i> 
</I>&gt;<i> binaryMulDiv : exponentExpr (('*' | '/') exponentExpr)* ;
</I>&gt;<i> 
</I>&gt;<i> exponentExpr : primary ( '^' primary )* ;
</I>&gt;<i> 
</I>&gt;<i> primary
</I>&gt;<i>    : ( '(' expression ')' )
</I>&gt;<i>    | literal
</I>&gt;<i>    | ( IDENTIFIER postFixExpr? )
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> postFixExpr
</I>&gt;<i>    : '!'
</I>&gt;<i>    | '++'
</I>&gt;<i>    | '--'
</I>&gt;<i>    | '(' expressionList? ')' // funCall
</I>&gt;<i>       // placing funCall here permits expressions like: f(x) + g(y)
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> expressionList : expression (',' expression)* ;
</I>&gt;<i> 
</I>&gt;<i> logicalOP
</I>&gt;<i>    : OPEQ
</I>&gt;<i>    | OPNEQ
</I>&gt;<i>    | OPINF
</I>&gt;<i>    | OPINFEQ
</I>&gt;<i>    | OPSUP
</I>&gt;<i>    | OPSUPEQ
</I>&gt;<i>    ;
</I>&gt;<i>  
</I>&gt;<i> literal
</I>&gt;<i>    : STRING_LITERAL
</I>&gt;<i>    | INTEGER_LITERAL
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> WS : (' '|'\t'|'\u000C') {$channel=HIDDEN;} ;
</I>&gt;<i> 
</I>&gt;<i> EOL
</I>&gt;<i>    : '\r' '\n'   // DOS
</I>&gt;<i>    | '\r'        // Mac
</I>&gt;<i>    | '\n'        // Unix
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> STRING_LITERAL
</I>&gt;<i>    : '\'' ( options{ greedy=false; }: ( ~('\\'|'\'') | ('\\' '\'') ) )* '\''
</I>&gt;<i>       {
</I>&gt;<i>          System.out.println(&quot;string&gt;&quot; + getText());
</I>&gt;<i>       }
</I>&gt;<i>    ;
</I>&gt;<i>     
</I>&gt;<i>   
</I>&gt;<i> INTEGER_LITERAL : '0' | ( '1'..'9' ( '0'..'9' )* ) ;
</I>&gt;<i> 
</I>&gt;<i> IDENTIFIER
</I>&gt;<i>    :  LETTER (LETTER|'0'..'9'|'$'|'#'|'%'|'-')*
</I>&gt;<i>       {
</I>&gt;<i>          System.out.println(&quot;identifier&gt;&quot; + getText());
</I>&gt;<i>       }
</I>&gt;<i>    ;
</I>&gt;<i> 
</I>&gt;<i> fragment LETTER : ('A'..'Z'|'a'..'z'|'_') ;
</I>&gt;<i> 
</I>&gt;<i> OPEQ    : '=' ;
</I>&gt;<i> OPNEQ   : '&lt;&gt;' ;
</I>&gt;<i> OPINF   : '&lt;' ;
</I>&gt;<i> OPINFEQ : '&lt;=' ;
</I>&gt;<i> OPSUP   : '&gt;' ;
</I>&gt;<i> OPSUPEQ : '&gt;=' ;
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 12
</I>&gt;<i> Date: Thu, 7 Jul 2011 08:47:35 +0200
</I>&gt;<i> From: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: &quot;John B. Brodie&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">CALGPt8bsE1DaBrVrLEWbJfuSJPMMiBfdyuviXseXgMaa4-_hjw at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1
</I>&gt;<i> 
</I>&gt;<i> Le 7 juillet 2011 05:08, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; see attached.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I, also, am available for hire, if you should opt for that...
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2011/7/7 Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;:
</I>&gt;<i> &gt; [...]
</I>&gt;<i> &gt; Or you could pay me to do it as I have no work on right now ;-) boo hoo.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hehe :o)
</I>&gt;<i> Thank you very much for your feedback, I will look at it later today.
</I>&gt;<i> I wish I could support you, but there is no funding in that PBScript
</I>&gt;<i> parser project : I am working on it in my free time and if I manage to
</I>&gt;<i> have something working, I plan to publish it as free open source code.
</I>&gt;<i> It could serve for building a syntax highlighter for the
</I>&gt;<i> scite/scintilla editor (a bit overkill maybe) and maybe it could also
</I>&gt;<i> be reused with Eclipse / IMP (though the parser generator used by IMP
</I>&gt;<i> is LPG, i am not sure if / how to use a custom antlr produced parser).
</I>&gt;<i> These tools are first to help my every day work with Powerbuilder.
</I>&gt;<i> 
</I>&gt;<i> Do you suggest that I could earn some money with a parser for a dying
</I>&gt;<i> language ?  ;o)
</I>&gt;<i> -- 
</I>&gt;<i> S?bastien Kirche
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 13
</I>&gt;<i> Date: Thu, 07 Jul 2011 10:11:44 +0200
</I>&gt;<i> From: Ivan Brezina &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">ibre5041 at ibrezina.net</A>&gt;
</I>&gt;<i> Subject: [antlr-interest] C Target won't compile with MSVC
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">20110707101144.x5vzv6h5gk4kw0sc at webmail.kamm.cz</A>&gt;
</I>&gt;<i> Content-Type: text/plain;	charset=ISO-8859-1;	DelSp=&quot;Yes&quot;;
</I>&gt;<i> 	format=&quot;flowed&quot;
</I>&gt;<i> 
</I>&gt;<i> Hi
</I>&gt;<i> I'm not sure whether this is a bug or not.
</I>&gt;<i> In my grammar I use following rule to match Perl style
</I>&gt;<i> quoted strings:
</I>&gt;<i> 
</I>&gt;<i> /* Perl-style quoted string */
</I>&gt;<i> QSTRING             : ('q'|'Q') ( QS_ANGLE | QS_BRACE | QS_BRACK |  
</I>&gt;<i> QS_PAREN | QS_OTHER) ;
</I>&gt;<i> fragment QS_ANGLE   : QUOTE '&lt;' ( options {greedy=false;} : . )* '&gt;' QUOTE ;
</I>&gt;<i> fragment QS_BRACE   : QUOTE '{' ( options {greedy=false;} : . )* '}' QUOTE ;
</I>&gt;<i> fragment QS_BRACK   : QUOTE '[' ( options {greedy=false;} : . )* ']' QUOTE ;
</I>&gt;<i> fragment QS_PAREN   : QUOTE '(' ( options {greedy=false;} : . )* ')' QUOTE ;
</I>&gt;<i> 
</I>&gt;<i> fragment QS_OTHER_CH: ~('&lt;'|'{'|'['|'('|' '|'\t'|'\n'|'\r');
</I>&gt;<i> fragment QS_OTHER
</I>&gt;<i> 		@init {
</I>&gt;<i>      		ANTLR3_UINT32 (*oldLA)(struct ANTLR3_INT_STREAM_struct *, ANTLR3_INT32);
</I>&gt;<i> 			oldLA = INPUT-&gt;istream-&gt;_LA;
</I>&gt;<i>              INPUT-&gt;setUcaseLA(INPUT, ANTLR3_FALSE);
</I>&gt;<i> 		}
</I>&gt;<i> 		:
</I>&gt;<i> 		QUOTE delimiter=QS_OTHER_CH
</I>&gt;<i> /* JAVA Syntax */
</I>&gt;<i> // 		( { input.LT(1) != $delimiter.text.charAt(0) || ( input.LT(1) ==  
</I>&gt;<i> $delimiter.text.charAt(0) &amp;&amp; input.LT(2) != '\'') }? =&gt; . )*
</I>&gt;<i> // 		( { input.LT(1) == $delimiter.text.charAt(0) &amp;&amp; input.LT(2) ==  
</I>&gt;<i> '\'' }? =&gt; . ) QUOTE
</I>&gt;<i> /* C Syntax */
</I>&gt;<i> 		( { LA(1) != $delimiter-&gt;getText(delimiter)-&gt;chars[0] || LA(2) !=  
</I>&gt;<i> '\'' }? =&gt; . )*
</I>&gt;<i> 		( { LA(1) == $delimiter-&gt;getText(delimiter)-&gt;chars[0] &amp;&amp; LA(2) ==  
</I>&gt;<i> '\'' }? =&gt; . ) QUOTE
</I>&gt;<i>   		{ INPUT-&gt;istream-&gt;_LA = oldLA; }
</I>&gt;<i> 		;
</I>&gt;<i> 
</I>&gt;<i> The problem is, that I need to declare my own variable inside @init section.
</I>&gt;<i> 
</I>&gt;<i> Antlr generates such a C source:
</I>&gt;<i> 
</I>&gt;<i> static ANTLR3_INLINE
</I>&gt;<i> void mQS_OTHER(pOracleSQLLexer ctx)
</I>&gt;<i> {
</I>&gt;<i> 	ANTLR3_UINT32	_type;
</I>&gt;<i>      pANTLR3_COMMON_TOKEN delimiter;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      delimiter = NULL;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>          		ANTLR3_UINT32 (*oldLA)(struct ANTLR3_INT_STREAM_struct *,  
</I>&gt;<i> ANTLR3_INT32);
</I>&gt;<i>      			oldLA = INPUT-&gt;istream-&gt;_LA;
</I>&gt;<i>                  INPUT-&gt;setUcaseLA(INPUT, ANTLR3_FALSE);
</I>&gt;<i> 
</I>&gt;<i> ... etc.
</I>&gt;<i> 
</I>&gt;<i> MSVC complains that the variable oldLA is declared AFTER assignment  
</I>&gt;<i> statement. Could you modify the it into this?
</I>&gt;<i> 
</I>&gt;<i> static ANTLR3_INLINE
</I>&gt;<i> void mQS_OTHER(pOracleSQLLexer ctx)
</I>&gt;<i> {
</I>&gt;<i>      ANTLR3_UINT32	_type;
</I>&gt;<i>      pANTLR3_COMMON_TOKEN delimiter = NULL;
</I>&gt;<i> 
</I>&gt;<i>      ANTLR3_UINT32 (*oldLA)(struct ANTLR3_INT_STREAM_struct *, ANTLR3_INT32);
</I>&gt;<i>      oldLA = INPUT-&gt;istream-&gt;_LA;
</I>&gt;<i>      INPUT-&gt;setUcaseLA(INPUT, ANTLR3_FALSE);
</I>&gt;<i> 
</I>&gt;<i> ...etc
</I>&gt;<i> 
</I>&gt;<i> Ivan
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ----------------------------------------------------------------
</I>&gt;<i> This message was sent using IMP, the Internet Messaging Program.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 14
</I>&gt;<i> Date: Thu, 7 Jul 2011 05:36:11 -0700
</I>&gt;<i> From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] C Target won't compile with MSVC
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">6f731513d5b601868af4f6bad31c420d at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i> 
</I>&gt;<i> That is what the @declarations section is for. It will ensure the variable
</I>&gt;<i> declaration is in the right place.
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://antlr.markmail.org/search/C+declarations">http://antlr.markmail.org/search/C+declarations</A>
</I>&gt;<i> 
</I>&gt;<i> Jim
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Ivan Brezina
</I>&gt;<i> &gt; Sent: Thursday, July 07, 2011 1:12 AM
</I>&gt;<i> &gt; To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> &gt; Subject: [antlr-interest] C Target won't compile with MSVC
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hi
</I>&gt;<i> &gt; I'm not sure whether this is a bug or not.
</I>&gt;<i> &gt; In my grammar I use following rule to match Perl style quoted strings:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Perl-style quoted string */
</I>&gt;<i> &gt; QSTRING             : ('q'|'Q') ( QS_ANGLE | QS_BRACE | QS_BRACK |
</I>&gt;<i> &gt; QS_PAREN | QS_OTHER) ;
</I>&gt;<i> &gt; fragment QS_ANGLE   : QUOTE '&lt;' ( options {greedy=false;} : . )* '&gt;'
</I>&gt;<i> &gt; QUOTE ;
</I>&gt;<i> &gt; fragment QS_BRACE   : QUOTE '{' ( options {greedy=false;} : . )* '}'
</I>&gt;<i> &gt; QUOTE ;
</I>&gt;<i> &gt; fragment QS_BRACK   : QUOTE '[' ( options {greedy=false;} : . )* ']'
</I>&gt;<i> &gt; QUOTE ;
</I>&gt;<i> &gt; fragment QS_PAREN   : QUOTE '(' ( options {greedy=false;} : . )* ')'
</I>&gt;<i> &gt; QUOTE ;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; fragment QS_OTHER_CH: ~('&lt;'|'{'|'['|'('|' '|'\t'|'\n'|'\r'); fragment
</I>&gt;<i> &gt; QS_OTHER
</I>&gt;<i> &gt; 		@init {
</I>&gt;<i> &gt;      		ANTLR3_UINT32 (*oldLA)(struct ANTLR3_INT_STREAM_struct
</I>&gt;<i> &gt; *, ANTLR3_INT32);
</I>&gt;<i> &gt; 			oldLA = INPUT-&gt;istream-&gt;_LA;
</I>&gt;<i> &gt;              INPUT-&gt;setUcaseLA(INPUT, ANTLR3_FALSE);
</I>&gt;<i> &gt; 		}
</I>&gt;<i> &gt; 		:
</I>&gt;<i> &gt; 		QUOTE delimiter=QS_OTHER_CH
</I>&gt;<i> &gt; /* JAVA Syntax */
</I>&gt;<i> &gt; // 		( { input.LT(1) != $delimiter.text.charAt(0) || (
</I>&gt;<i> input.LT(1)
</I>&gt;<i> &gt; ==
</I>&gt;<i> &gt; $delimiter.text.charAt(0) &amp;&amp; input.LT(2) != '\'') }? =&gt; . )*
</I>&gt;<i> &gt; // 		( { input.LT(1) == $delimiter.text.charAt(0) &amp;&amp;
</I>&gt;<i> input.LT(2)
</I>&gt;<i> &gt; ==
</I>&gt;<i> &gt; '\'' }? =&gt; . ) QUOTE
</I>&gt;<i> &gt; /* C Syntax */
</I>&gt;<i> &gt; 		( { LA(1) != $delimiter-&gt;getText(delimiter)-&gt;chars[0] ||
</I>&gt;<i> &gt; LA(2) != '\'' }? =&gt; . )*
</I>&gt;<i> &gt; 		( { LA(1) == $delimiter-&gt;getText(delimiter)-&gt;chars[0] &amp;&amp;
</I>&gt;<i> &gt; LA(2) == '\'' }? =&gt; . ) QUOTE
</I>&gt;<i> &gt;   		{ INPUT-&gt;istream-&gt;_LA = oldLA; }
</I>&gt;<i> &gt; 		;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The problem is, that I need to declare my own variable inside @init
</I>&gt;<i> &gt; section.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Antlr generates such a C source:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static ANTLR3_INLINE
</I>&gt;<i> &gt; void mQS_OTHER(pOracleSQLLexer ctx)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	ANTLR3_UINT32	_type;
</I>&gt;<i> &gt;      pANTLR3_COMMON_TOKEN delimiter;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;      delimiter = NULL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          		ANTLR3_UINT32 (*oldLA)(struct
</I>&gt;<i> ANTLR3_INT_STREAM_struct
</I>&gt;<i> &gt; *, ANTLR3_INT32);
</I>&gt;<i> &gt;      			oldLA = INPUT-&gt;istream-&gt;_LA;
</I>&gt;<i> &gt;                  INPUT-&gt;setUcaseLA(INPUT, ANTLR3_FALSE);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ... etc.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; MSVC complains that the variable oldLA is declared AFTER assignment
</I>&gt;<i> &gt; statement. Could you modify the it into this?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static ANTLR3_INLINE
</I>&gt;<i> &gt; void mQS_OTHER(pOracleSQLLexer ctx)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt;      ANTLR3_UINT32	_type;
</I>&gt;<i> &gt;      pANTLR3_COMMON_TOKEN delimiter = NULL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;      ANTLR3_UINT32 (*oldLA)(struct ANTLR3_INT_STREAM_struct *,
</I>&gt;<i> &gt; ANTLR3_INT32);
</I>&gt;<i> &gt;      oldLA = INPUT-&gt;istream-&gt;_LA;
</I>&gt;<i> &gt;      INPUT-&gt;setUcaseLA(INPUT, ANTLR3_FALSE);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ...etc
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Ivan
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ----------------------------------------------------------------
</I>&gt;<i> &gt; This message was sent using IMP, the Internet Messaging Program.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> &gt; Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-">http://www.antlr.org/mailman/options/antlr-interest/your-</A>
</I>&gt;<i> &gt; email-address
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 15
</I>&gt;<i> Date: Thu, 7 Jul 2011 06:57:41 -0700 (PDT)
</I>&gt;<i> From: Roy Metzger &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlrmen at yahoo.com</A>&gt;
</I>&gt;<i> Subject: [antlr-interest] loops and syntax-directed interpreter ?
</I>&gt;<i> To: &quot;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">1310047061.42770.YahooMailNeo at web121116.mail.ne1.yahoo.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=iso-8859-1
</I>&gt;<i> 
</I>&gt;<i> Hello everyone and good day,
</I>&gt;<i> 
</I>&gt;<i> I'm following Mr. Parr's tutorial on syntax-directed interpreter for Pie language
</I>&gt;<i> (link: <A HREF="http://www.antlr.org/wiki/display/ANTLR3/Pie">http://www.antlr.org/wiki/display/ANTLR3/Pie</A> ). So, for this one? I'm not interested
</I>&gt;<i> into building tree's and such.
</I>&gt;<i> 
</I>&gt;<i> Now, the problem. I'm using code provided with the tutorial with minimal tweaks. My issue is with the while loop.
</I>&gt;<i> It looks like this:
</I>&gt;<i> 
</I>&gt;<i> while[boolean defer]:
</I>&gt;<i> 'while' e=expr [defer]
</I>&gt;<i> s=statement[defer]+
</I>&gt;<i> 'stop' 'loop'
</I>&gt;<i> {if (!defer) interp.allWhile($e.start, $s.start);} ;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> My issue is with starting location of the statements passed(token index).For example this works:
</I>&gt;<i> 
</I>&gt;<i> while(true)
</I>&gt;<i> print 1 //print unlimited number of 1's
</I>&gt;<i> stop loop
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> However, whenever I use multiple statements, only last one is executed, for example:
</I>&gt;<i> while(true)
</I>&gt;<i> print 1
</I>&gt;<i> print 2
</I>&gt;<i> print 3
</I>&gt;<i> stop loop
</I>&gt;<i> 
</I>&gt;<i> This will print non-stop 3's, and? not 1,2,3,1,2,3 as I would want etc.
</I>&gt;<i> 
</I>&gt;<i> If there are multiple statements in the while loop, while function in the interpreter always rewinds input to
</I>&gt;<i> the last statement in the while clasue(print 3 in above example, while I would like to rewind input to print 1).
</I>&gt;<i> 
</I>&gt;<i> In the interpreter, callWhile function is not changed from the tutorial(aside statements instead of slist):
</I>&gt;<i> 
</I>&gt;<i> ?public void callWhile(Token condStart, Token codeStart) 
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i> ?????? Boolean c = (Boolean)exec(&quot;expr&quot;, condStart.getTokenIndex());
</I>&gt;<i> 
</I>&gt;<i> ??????? while ( c ) 
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i> ??????????? exec(&quot;statement&quot;, codeStart.getTokenIndex());
</I>&gt;<i> ??????????? c = (Boolean)exec(&quot;expr&quot;, condStart.getTokenIndex());
</I>&gt;<i> ?? }
</I>&gt;<i> ?? }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Also, exec is not changed from the tutorial:
</I>&gt;<i> 
</I>&gt;<i> ?public Object exec(String rule, int tokenIndex) 
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i> ??????? Object rv = null;
</I>&gt;<i> ??????? try 
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i> ??????????? int oldPosition = parser.input.index(); // save current location
</I>&gt;<i> ??????????? parser.input.seek(tokenIndex); // seek to place to start execution
</I>&gt;<i> ??????????? try { // which rule are we executing?
</I>&gt;<i> ??????????????? if ( rule.equals(&quot;expr&quot;) ) { rv = parser.expr(false).value; }
</I>&gt;<i> ??????????????? else if ( rule.equals(&quot;statement&quot;) ) { parser.statement(false); }
</I>&gt;<i> ??????????????? else listener.error(&quot;error: can't start at &quot;+rule);
</I>&gt;<i> ??? }
</I>&gt;<i> ??????????? finally { parser.input.seek(oldPosition); }// restore location
</I>&gt;<i> ?????? }
</I>&gt;<i> ??????? catch (Exception e) {
</I>&gt;<i> ??????????? listener.error(&quot;can't exec code @ index &quot;+tokenIndex, e);
</I>&gt;<i> ?????? }
</I>&gt;<i> ??????? return rv;
</I>&gt;<i> ?? }
</I>&gt;<i> 
</I>&gt;<i> Now, I would really appreciate if someone could point me out why is this happening and
</I>&gt;<i> how it can be fixed? Also, I've noticed that even code from the tutorial has similar issues.
</I>&gt;<i> 
</I>&gt;<i> I would really appreciate any help, hints or tricks to help solve this problem.
</I>&gt;<i> Thanks,
</I>&gt;<i> Lee
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 16
</I>&gt;<i> Date: Thu, 7 Jul 2011 17:04:55 +0200
</I>&gt;<i> From: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: &quot;John B. Brodie&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">CALGPt8ZeOHcgejygQsbmmbaCue2M7VvwwQ2uJnu33n-Li4x09g at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;iso-8859-1&quot;
</I>&gt;<i> 
</I>&gt;<i> Le 7 juillet 2011 05:08, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; see attached.
</I>&gt;<i> 
</I>&gt;<i> Many, many thanks, as your corrections on my example helped me
</I>&gt;<i> considerably and the initial recursion is gone.
</I>&gt;<i> I had also an obvious bug in my &quot;NOT&quot; expression. Now I have added
</I>&gt;<i> some other structures like for/next and choose/case
</I>&gt;<i> 
</I>&gt;<i> My current problem is that your refactor of my funCall rule by
</I>&gt;<i> following an expression by a postfix notation seems not working on my
</I>&gt;<i> test code.
</I>&gt;<i> That looks clever, but during parsing, the Parser seem to look for a
</I>&gt;<i> missing assignment between the function identifier and the parameter
</I>&gt;<i> list. I did not found why yet.
</I>&gt;<i> 
</I>&gt;<i> I join my grammar in its current state.
</I>&gt;<i> -- 
</I>&gt;<i> S?bastien Kirche
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> A non-text attachment was scrubbed...
</I>&gt;<i> Name: PowerScript.g
</I>&gt;<i> Type: application/octet-stream
</I>&gt;<i> Size: 8175 bytes
</I>&gt;<i> Desc: not available
</I>&gt;<i> Url : <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20110707/55c5fd2c/attachment-0001.obj">http://www.antlr.org/pipermail/antlr-interest/attachments/20110707/55c5fd2c/attachment-0001.obj</A> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 17
</I>&gt;<i> Date: Thu, 07 Jul 2011 11:51:52 -0400
</I>&gt;<i> From: &quot;John B. Brodie&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] left recursion removal
</I>&gt;<i> To: S?bastien Kirche &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">sebastien.kirche at gmail.com</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">1310053912.9154.2.camel at gecko</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;UTF-8&quot;
</I>&gt;<i> 
</I>&gt;<i> Greetings!
</I>&gt;<i> 
</I>&gt;<i> On Thu, 2011-07-07 at 17:04 +0200, S?bastien Kirche wrote:
</I>&gt;<i> &gt; Le 7 juillet 2011 05:08, John B. Brodie &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jbb at acm.org</A>&gt; a ?crit :
</I>&gt;<i> &gt; &gt; see attached.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Many, many thanks, as your corrections on my example helped me
</I>&gt;<i> &gt; considerably and the initial recursion is gone.
</I>&gt;<i> 
</I>&gt;<i> you are welcome. i actually enjoy doing this stuff.
</I>&gt;<i> 
</I>&gt;<i> &gt; I had also an obvious bug in my &quot;NOT&quot; expression. Now I have added
</I>&gt;<i> &gt; some other structures like for/next and choose/case
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; My current problem is that your refactor of my funCall rule by
</I>&gt;<i> &gt; following an expression by a postfix notation seems not working on my
</I>&gt;<i> &gt; test code.
</I>&gt;<i> &gt; That looks clever, but during parsing, the Parser seem to look for a
</I>&gt;<i> &gt; missing assignment between the function identifier and the parameter
</I>&gt;<i> &gt; list. I did not found why yet.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I join my grammar in its current state.
</I>&gt;<i> 
</I>&gt;<i> change the singleStatement rule to this:
</I>&gt;<i> 
</I>&gt;<i> singleStatement
</I>&gt;<i> 	:	IDENT ( OPEQ expression | '(' expressionList? ')' )
</I>&gt;<i> 	|	'return' expression
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> and delete the now unnecessary assignment rule.
</I>&gt;<i>    -jbb
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> antlr-interest mailing list
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> 
</I>&gt;<i> End of antlr-interest Digest, Vol 80, Issue 7
</I>&gt;<i> *********************************************
</I> 		 	   		  
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="042037.html">[antlr-interest] targets without switch fall through...
</A></li>
	<LI>Next message: <A HREF="042039.html">[antlr-interest] Lines that don't match a rule ...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#42038">[ date ]</a>
              <a href="thread.html#42038">[ thread ]</a>
              <a href="subject.html#42038">[ subject ]</a>
              <a href="author.html#42038">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
