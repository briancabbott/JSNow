<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] postmortem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3C47D98673.5010105%40jazillian.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027203.html">
   <LINK REL="Next"  HREF="027168.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] postmortem</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3C47D98673.5010105%40jazillian.com%3E"
       TITLE="[antlr-interest] postmortem">antlr at jazillian.com
       </A><BR>
    <I>Thu Mar 13 12:54:27 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027203.html">[antlr-interest] postmortem
</A></li>
        <LI>Next message: <A HREF="027168.html">[antlr-interest] antlr 3, language=C,	getting pANTLR3_RECOGNIZER_SHARED_STATE unknown
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27218">[ date ]</a>
              <a href="thread.html#27218">[ thread ]</a>
              <a href="subject.html#27218">[ subject ]</a>
              <a href="author.html#27218">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thomas Brandon wrote:
&gt;<i> On Fri, Mar 14, 2008 at 2:00 AM, Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
</I>&gt;<i>   
</I>&gt;&gt;&gt;<i> Thomas Brandon wrote:
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i>  On Thu, Mar 13, 2008 at 7:58 AM, Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i>  Yes, most ANTLR users want a non-flat tree. But most (if not all) of
</I>&gt;&gt;&gt;<i> these users do not want a parse tree.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i>  Agreed. But keep in mind that for many applications, simply walking the AST
</I>&gt;&gt;<i> by hand is enough.
</I>&gt;&gt;<i>     
</I>&gt;<i> I'm familiar with your views so I tried to though it's a rather alien
</I>&gt;<i> approach to me so forgive any oversights..
</I>&gt;<i>   
</I>&gt;&gt;&gt;<i>  The parse trees generated by
</I>&gt;&gt;&gt;<i> ANTLR are not just like ASTs and cannot be used as such. Parse trees
</I>&gt;&gt;&gt;<i> consist of standard AST nodes for all the actual language nodes and
</I>&gt;&gt;&gt;<i> special parse tree nodes (of type ParseTree extending CommonTree) for
</I>&gt;&gt;&gt;<i> the rule references. These parse tree nodes have a token type of 0.
</I>&gt;&gt;&gt;<i> Thus you cannot use a tree parser against a parse tree and manually
</I>&gt;&gt;&gt;<i> walking the tree would be complicated. Parse trees (as generated by
</I>&gt;&gt;&gt;<i> ANTLR) are more of a debugging aid than a type of AST that
</I>&gt;&gt;&gt;<i> automatically adds structure.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i>  ...I think that in many cases processing the parse tree would be very
</I>&gt;&gt;<i> simple:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  if (!(ast instanceof ParseTree)) {
</I>&gt;&gt;<i>     doSomethingWith(ast);
</I>&gt;&gt;<i>  } else {
</I>&gt;&gt;<i>     // ignore ParseTree nodes
</I>&gt;&gt;<i>  }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;<i> Well, that's not going to process the children of parse trees which is
</I>&gt;<i> presumably not what you want. And if you're skipping them then what
</I>&gt;<i> use are they exactly?
</I>&gt;<i>   
</I>Sorry, I left out and assumed everyone would mentally fill in that the 
children might always get processed:
for (child: ast.getChildren()) {
    walk(child);   // recursive call to process children
}
&gt;<i> But my point was that with no token type you can switch on token
</I>&gt;<i> types. So you'd have to switch on the string name, which gets rather
</I>&gt;<i> nasty to maintain, and means changing a rule name will break your tree
</I>&gt;<i> walker but give no compile time errors. Not especially easy or
</I>&gt;<i> desirable.
</I>&gt;<i>   
</I>Uhhh...yea, OK. Sorry, I'm not familiar with ParseTree. Couldn't we use 
&quot;instanceof&quot; then...switch
on the class of the node?
&gt;<i> &lt;SNIP&gt;A fair bit of going round in circles with proposed heuristics&lt;/SNIP&gt;
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i>  ...but I guess maybe that puts us where we started - generating a full
</I>&gt;&gt;<i> parse tree.
</I>&gt;&gt;<i>  But even without solving this problem - go ahead and leave the tree as
</I>&gt;&gt;<i> being hard to walk -
</I>&gt;&gt;<i>  we're still ahead. The goal here is not to generate a &quot;good&quot; AST, but
</I>&gt;&gt;<i> rather just produce something
</I>&gt;&gt;<i>  that's better than nothing (i.e. a flat tree). So the newbie gets this
</I>&gt;&gt;<i> tree, sees that it's hard to
</I>&gt;&gt;<i>  distinguish the various cases where he's got an ID node, and starts reading
</I>&gt;&gt;<i> up on how to build
</I>&gt;&gt;<i>  an AST. He's better off here than the alternative: a blank stare at a flat
</I>&gt;&gt;<i> ast.
</I>&gt;&gt;<i>     
</I>&gt;<i> &lt;SNIP&gt;more circles&lt;/SNIP&gt;
</I>&gt;<i>   
</I>&gt;&gt;<i>  Thanks for writing this up. Let me know if you think the replies I gave
</I>&gt;&gt;<i> would work.
</I>&gt;&gt;<i>  As I said, if they work, but only make things somewhat better, but not a
</I>&gt;&gt;<i> completely usable AST, that's
</I>&gt;&gt;<i>  still a win IMO. If they don't work, then how about simply say &quot;if there
</I>&gt;&gt;<i> are no ^'s, I'll just use
</I>&gt;&gt;<i>  the existing code to get a parse tree and return that&quot;?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  Andy
</I>&gt;&gt;<i>     
</I>&gt;<i> (Can you please stop HTML posting or at least use a client with decent
</I>&gt;<i> quoting in it's HTML. Gmail can't handle your quoting and I've found
</I>&gt;<i> it's generally pretty good at that.)
</I>&gt;<i>   
</I>Yes, sorry about that.
&gt;<i> I could go through your various proposed rules and point out the case
</I>&gt;<i> where they produce a structure I can't see anyone wanting but I gather
</I>&gt;<i> you admit that point.
</I>&gt;<i>   
</I>Yes. Just trying to have an default AST who's usefulness is greater than 
0, not necessarily 100%
or close to it.
&gt;<i> The detect ^ and switch off automatic rules doesn't work because the
</I>&gt;<i> user may want a flat AST.
</I>&gt;<i>   
</I>Uh Oh. See my exchange with Jim on that.
Please explain a (non-contrived) case where someone may want a flat AST.
&gt;<i> And I don't accept your view that producing a bad AST is better than
</I>&gt;<i> producing a flat AST. Is anyone going to use a bad AST? 
</I>I think so. If nothing else, just to verify that the parser is doing 
something reasonable.

When it came time for me to start using C++ ASTs for expressions, I 
looked into it and decided
I could just use a C parser and C ASTs, after all, expressions are the 
same in C and C++, right?
Just this week, over a year later, I finally hit a case where a 
particular C++ expression isn't valid in C.

The point is that I was (mostly) fine using a subset of a C grammar for C++.
Now that I find that the C grammar is &quot;bad&quot; for C++, what did  I do? I found
a way to easy get around the problem by eliminating the invalid syntax from
the input. That may seem like a hack (the purist would have used a real 
C++ grammar), but it
does work and was far easier than switching grammars. My job is to get 
my application working
well as quickly as possible, not to learn any more of ANTLR than I need to.
&gt;<i> I can't see
</I>&gt;<i> why they would and don't think they should. Is it easy to allow such
</I>&gt;<i> auto-generation to be mixed with explicit construction to generate a
</I>&gt;<i> good AST? I don't think so. 
</I>As I said in another post, I'd simply say &quot;if there are no explicit 
AST-building constructs in
the grammar, return the parse tree&quot;. No mixing.
&gt;<i> At best you end up with a grammar that's
</I>&gt;<i> messier and harder to understand than if you'd just used manual
</I>&gt;<i> construction. 
</I>No mixing. The grammar is whatever it is, no different in any way.
If it has no ^ or ! characters, you get a parse tree.
&gt;<i> So you've spent all the time developing a system 
</I>&quot;All the time&quot; being about 20 lines of code: declare a flag, set the 
flag whenever you see
^ or !. In getTree(), if the flag is not set, return the parse tree instead.
&gt;<i> that no
</I>&gt;<i> one is ever going to use for more than the first grammar run that's
</I>&gt;<i> only purpose is to avoid giving someone a flat AST. 
</I>Yes, avoiding giving a flat AST is one purpose. I've said why that's 
good, and a couple
of people agreed (including the original poster, who bothered enough to 
mention it).

I also think even a &quot;bad AST&quot; would be useful. For one, to verify that 
the parser is working
as intended. Also, I think some applications would actually be able to 
just use the &quot;bad AST&quot;.
The guy who isn't even using an AST today might use it, if he gets it 
&quot;for free&quot;. The guys
who wrote that tool to automatically generate it might use it. And, of 
course, a
parse tree really is useful (e.g. ANTLRWorks uses it), it's just a 
matter of whether
it's provided as &quot;the default&quot; when you've asked for an AST but provided 
no &quot;^&quot;.
&gt;<i> And if they don't
</I>&gt;<i> look at enough docs\examples first and, heaven forbid, get a flat AST
</I>&gt;<i> they either go to the docs and quickly recognise their flawed
</I>&gt;<i> expectations of what output=AST will do or send a message to the list
</I>&gt;<i> that requires all of two or three sentences to answer. 
</I>By that time, it's &quot;too late&quot;. From the original post, you can see what 
happens.
After going through the long process of building a tree-like grammar, 
and having it successfully
parse some input, people realistically expect to be able to see some tree.

Suppose you say &quot;i = 1;&quot; without declaring i, in Java or any other 
statically typed language.
And suppose that that reference is in &quot;dead code&quot; that's never reached. 
The compiler could
silently ignore the problem, and the output bytecode (or executable or 
whatever) is perfectly
valid. But the user if left saying &quot;I wonder why the output isn't what I 
expected?&quot; and start
to dislike the tool.

The same is true here. This guy put &quot;output=AST&quot; and got out something 
unexpected.
Sure, he can search the book, the wiki, ask on the mailing list, and 
find the answer.
Just as the guy who forgot to define his variable could do all those 
things to find the answer.

Making sure that the answer is available is one thing, avoiding the 
confusion in the first place is
another. At a minimum, don't let me put &quot;output=AST&quot; and then forget to 
put any ^'s in
my grammar. There's no need to let me make that mistake. It's a 
usability issue.
&gt;<i> How is this in
</I>&gt;<i> anyway a good use of time or a justifiable addition of code
</I>&gt;<i> complexity?
</I>&gt;<i>   
</I>It would have helped the original poster, who seems so mad he won't be 
using ANTLR any more.
Obviously, it's not just this issue. In all these posts, I'm arguing for 
more usability work
overall, not just this specific AST thing.

I realize these &quot;make it easier for the newbie&quot;
suggestions make little sense to Terence and most others, and Terence 
has no time for stuff
like this. But usability does matter. I suspect for each frustrated guy 
like this who posted,
there are at least several more who didn't bother.

By analogy, all the C compilers have lots of documentation and mailing 
lists
and lots of users, and you could probably spend a lifetime with the gcc 
documentation alone.
And yet their error messages all suck compared to javac's messages. I 
don't know
exactly how Sun managed that, but I do know there's something 
fundamentally better
about javac.

Andy
&gt;<i> Tom.
</I>&gt;<i>
</I>&gt;<i>   
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20080313/ab7f0d7c/attachment-0001.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20080313/ab7f0d7c/attachment-0001.html</A> 
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027203.html">[antlr-interest] postmortem
</A></li>
	<LI>Next message: <A HREF="027168.html">[antlr-interest] antlr 3, language=C,	getting pANTLR3_RECOGNIZER_SHARED_STATE unknown
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27218">[ date ]</a>
              <a href="thread.html#27218">[ thread ]</a>
              <a href="subject.html#27218">[ subject ]</a>
              <a href="author.html#27218">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
