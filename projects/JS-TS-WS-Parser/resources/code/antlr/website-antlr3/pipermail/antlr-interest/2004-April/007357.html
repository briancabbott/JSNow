<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [POTENTIAL SPAM - OPEN AT USER DISCRETION] Re: [antlr-interest] debugging
 and testing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5BPOTENTIAL%20SPAM%20-%20OPEN%20AT%20USER%20DISCRETION%5D%20Re%3A%20%5Bantlr-interest%5D%20debugging%0A%20and%20testing&In-Reply-To=07993455-8CC7-11D8-A12A-000A95891192%40cs.usfca.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007356.html">
   <LINK REL="Next"  HREF="007360.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[POTENTIAL SPAM - OPEN AT USER DISCRETION] Re: [antlr-interest] debugging
 and testing</H1>
    <B>ronald.petty at milliman.com</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5BPOTENTIAL%20SPAM%20-%20OPEN%20AT%20USER%20DISCRETION%5D%20Re%3A%20%5Bantlr-interest%5D%20debugging%0A%20and%20testing&In-Reply-To=07993455-8CC7-11D8-A12A-000A95891192%40cs.usfca.edu"
       TITLE="[POTENTIAL SPAM - OPEN AT USER DISCRETION] Re: [antlr-interest] debugging
 and testing">ronald.petty at milliman.com
       </A><BR>
    <I>Mon Apr 12 14:17:31 PDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="007356.html">[antlr-interest] debugging and testing
</A></li>
        <LI>Next message: <A HREF="007360.html">[antlr-interest] debugging and testing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7357">[ date ]</a>
              <a href="thread.html#7357">[ thread ]</a>
              <a href="subject.html#7357">[ subject ]</a>
              <a href="author.html#7357">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Did you mean that java.util.Stack should be &quot;brought in&quot; through the 
grammar into VB6Parser?

&gt;<i> ANTLR Parser Generator   Version 2.7.3   1989-2004 jGuru.com
</I>&gt;<i> ./build/VB6Parser.java:41: cannot find symbol
</I>&gt;<i> symbol  : class Stack
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>         protected Stack currentParseTreeRoot = new Stack();
</I>
Because if so, that would probably fix that error.  However if that is the 
case, the example on the site I think is missing it (I can't find import 
java.util.Stack in the grammar).

Ron



Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt; 
04/12/2004 04:19 PM
Please respond to
<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>


To
<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>
cc

Subject
[POTENTIAL SPAM - OPEN AT USER DISCRETION] Re: [antlr-interest] debugging 
and testing 







On Apr 12, 2004, at 1:37 PM, <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">ronald.petty at milliman.com</A> wrote:

&gt;<i>
</I>&gt;<i> I am trying to follow along 
</I>&gt;<i> <A HREF="http://www.antlr.org/article/parse.trees/index.tml">http://www.antlr.org/article/parse.trees/index.tml</A>
</I>&gt;<i>
</I>&gt;<i> Do you need to do something with the classpath to get this to work? 
</I>&gt;<i>  Under cygwin is
</I>
Could be that the example assumes the parse tree stuff is in the 
current directory, but it has moved inside antlr.  It seems you have 
this correctly though:

&gt;<i> class VB6Parser extends Parser(&quot;antlr.debug.ParseTreeDebugParser&quot;);
</I>
Hmm...Stack should be from java.util.  Is that included in the header 
{...}?

Ter

&gt;<i>
</I>&gt;<i> $ echo $CLASSPATH
</I>&gt;<i> C:/antlr-2.7.3/antlr.jar;C:/antlr-2.7.3;C:/junit3.8.1/junit.jar;C:/ 
</I>&gt;<i> junit3.8.1;.
</I>&gt;<i>
</I>&gt;<i> I am using Sun's java, not the one from Cygwin
</I>&gt;<i>
</I>&gt;<i> so in my .bashrc the CLASSPATH is really
</I>&gt;<i>
</I>&gt;<i> export ANT_HOME=&quot;/cygdrive/c/apache-ant-1.6.1&quot;
</I>&gt;<i> export JAVA_HOME=&quot;/cygdrive/c/j2sdk1.5.0&quot;
</I>&gt;<i> export PATH=/cygdrive/c/j2sdk1.5.0/bin:${ANT_HOME}/bin:${PATH}
</I>&gt;<i> export CVSROOT=/cygdrive/c/repository
</I>&gt;<i> export 
</I>&gt;<i> CLASSPATH=&quot;C:/antlr-2.7.3/antlr.jar;C:/antlr 
</I>&gt;<i> -2.7.3;${JUNIT_HOME}${JUNIT_JAR};.&quot;
</I>&gt;<i>
</I>&gt;<i> I have a directory structure of
</I>&gt;<i> pwd/source
</I>&gt;<i> pwd/grammars
</I>&gt;<i>
</I>&gt;<i> When I build I do (in pwd)
</I>&gt;<i> alias build='mkdir ./build; java antlr.Tool -o ./build 
</I>&gt;<i> grammars/VB6Lexer.g; java antlr.Tool -o ./build grammars/VB6Parser.g; 
</I>&gt;<i> javac -d ./build ./build/*.java'
</I>&gt;<i>
</I>&gt;<i> Before I tried in do this debugging/testing it worked, however when I 
</I>&gt;<i> add the code from the example (pasted) I get.  (My grammar is below 
</I>&gt;<i> the errors).
</I>&gt;<i>
</I>&gt;<i> ANTLR Parser Generator   Version 2.7.3   1989-2004 jGuru.com
</I>&gt;<i> ANTLR Parser Generator   Version 2.7.3   1989-2004 jGuru.com
</I>&gt;<i> ./build/VB6Parser.java:41: cannot find symbol
</I>&gt;<i> symbol  : class Stack
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>         protected Stack currentParseTreeRoot = new Stack();
</I>&gt;<i>                   ^
</I>&gt;<i> ./build/VB6Parser.java:46: cannot find symbol
</I>&gt;<i> symbol  : class ParseTreeRule
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>         protected ParseTreeRule mostRecentParseTreeRoot = null;
</I>&gt;<i>                   ^
</I>&gt;<i> ./build/VB6Parser.java:51: cannot find symbol
</I>&gt;<i> symbol  : class ParseTree
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>         public ParseTree getParseTree() {
</I>&gt;<i>                ^
</I>&gt;<i> ./build/VB6Parser.java:26: cannot find symbol
</I>&gt;<i> symbol  : class ParseTree
</I>&gt;<i> location: class Main
</I>&gt;<i> ParseTree tree = parser.getParseTree();
</I>&gt;<i> ^
</I>&gt;<i> ./build/VB6Parser.java:41: cannot find symbol
</I>&gt;<i> symbol  : class Stack
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>         protected Stack currentParseTreeRoot = new Stack();
</I>&gt;<i>                                                    ^
</I>&gt;<i> ./build/VB6Parser.java:85: cannot find symbol
</I>&gt;<i> symbol  : class ParseTreeRule
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>                 ParseTreeRule root = 
</I>&gt;<i> (ParseTreeRule)currentParseTreeRoot.peek();
</I>&gt;<i>
</I>&gt;<i>                 ^
</I>&gt;<i> ./build/VB6Parser.java:85: cannot find symbol
</I>&gt;<i> symbol  : class ParseTreeRule
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>                 ParseTreeRule root = 
</I>&gt;<i> (ParseTreeRule)currentParseTreeRoot.peek();
</I>&gt;<i>
</I>&gt;<i>                                       ^
</I>&gt;<i> ./build/VB6Parser.java:86: cannot find symbol
</I>&gt;<i> symbol  : class ParseTreeToken
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>                 ParseTreeToken tokenNode = null;
</I>&gt;<i>                 ^
</I>&gt;<i> ./build/VB6Parser.java:88: cannot find symbol
</I>&gt;<i> symbol  : class ParseTreeToken
</I>&gt;<i> location: class VB6Parser
</I>&gt;<i>                         tokenNode = new ParseTreeToken(new 
</I>&gt;<i> antlr.CommonToken(&quot;EO
</I>&gt;<i> F&quot;));
</I>&gt;<i> .....  (more errors follow)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> {
</I>&gt;<i> import java.io.*;
</I>&gt;<i>
</I>&gt;<i> class Main {
</I>&gt;<i>         public static void main(String[] args) {
</I>&gt;<i>                 try {
</I>&gt;<i>                         VB6Lexer lexer = new VB6Lexer(System.in);
</I>&gt;<i>                         VB6Parser parser = new VB6Parser(lexer);
</I>&gt;<i>                         parser.program();
</I>&gt;<i>
</I>&gt;<i> ParseTree tree = parser.getParseTree();
</I>&gt;<i> System.out.println(&quot;parse tree:&quot;+tree.toStringTree());
</I>&gt;<i>
</I>&gt;<i>                 } catch(Exception e) {
</I>&gt;<i>                         e.printStackTrace();
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> class VB6Parser extends Parser(&quot;antlr.debug.ParseTreeDebugParser&quot;);
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i>         importVocab=VB6;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> {
</I>&gt;<i>         /** Each new rule invocation must have it's own subtree. 
</I>&gt;<i>  Tokens
</I>&gt;<i>          *  are added to the current root so we must have a stack of 
</I>&gt;<i> subtree roo
</I>&gt;<i> ts.
</I>&gt;<i>          */
</I>&gt;<i>         protected Stack currentParseTreeRoot = new Stack();
</I>&gt;<i>
</I>&gt;<i>         /** Track most recently created parse subtree so that when 
</I>&gt;<i> parsing
</I>&gt;<i>          *  is finished, we can get to the root.
</I>&gt;<i>          */
</I>&gt;<i>         protected ParseTreeRule mostRecentParseTreeRoot = null;
</I>&gt;<i>
</I>&gt;<i>         /** For every rule replacement with a production, we bump up 
</I>&gt;<i> count. */
</I>&gt;<i>         protected int numberOfDerivationSteps = 1; // n replacements 
</I>&gt;<i> plus step 0
</I>&gt;<i>
</I>&gt;<i>         public ParseTree getParseTree() {
</I>&gt;<i>                 return mostRecentParseTreeRoot;
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         public int getNumberOfDerivationSteps() {
</I>&gt;<i>                 return numberOfDerivationSteps;
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         public void match(int i) throws MismatchedTokenException, 
</I>&gt;<i> TokenStreamExc
</I>&gt;<i> eption {
</I>&gt;<i>                 addCurrentTokenToParseTree();
</I>&gt;<i>                 super.match(i);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         public void match(BitSet bitSet) throws 
</I>&gt;<i> MismatchedTokenException, TokenS
</I>&gt;<i> treamException {
</I>&gt;<i>                 addCurrentTokenToParseTree();
</I>&gt;<i>                 super.match(bitSet);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         public void matchNot(int i) throws MismatchedTokenException, 
</I>&gt;<i> TokenStream
</I>&gt;<i> Exception {
</I>&gt;<i>                 addCurrentTokenToParseTree();
</I>&gt;<i>                 super.matchNot(i);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /** This adds LT(1) to the current parse subtree.  Note that 
</I>&gt;<i> the match()
</I>&gt;<i>          *  routines add the node before checking for correct match. 
</I>&gt;<i>  This means
</I>&gt;<i>          *  that, upon mismatched token, there will a token node in 
</I>&gt;<i> the tree
</I>&gt;<i>          *  corresponding to where that token was expected.  For no 
</I>&gt;<i> viable
</I>&gt;<i>          *  alternative errors, no node will be in the tree as nothing 
</I>&gt;<i> was
</I>&gt;<i>          *  matched() (the lookahead failed to predict an alternative).
</I>&gt;<i>          */
</I>&gt;<i>         protected void addCurrentTokenToParseTree() throws 
</I>&gt;<i> TokenStreamException
</I>&gt;<i> {
</I>&gt;<i>                 if (inputState.guessing&gt;0) {
</I>&gt;<i>                         return;
</I>&gt;<i>                 }
</I>&gt;<i>                 ParseTreeRule root = 
</I>&gt;<i> (ParseTreeRule)currentParseTreeRoot.peek();
</I>&gt;<i>                 ParseTreeToken tokenNode = null;
</I>&gt;<i>                 if ( LA(1)==Token.EOF_TYPE ) {
</I>&gt;<i>                         tokenNode = new ParseTreeToken(new 
</I>&gt;<i> antlr.CommonToken(&quot;EO
</I>&gt;<i> F&quot;));
</I>&gt;<i>                 }
</I>&gt;<i>                 else {
</I>&gt;<i>                         tokenNode = new ParseTreeToken(LT(1));
</I>&gt;<i>                 }
</I>&gt;<i>                 root.addChild(tokenNode);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /** Create a rule node, add to current tree, and make it 
</I>&gt;<i> current root */
</I>&gt;<i>         public void traceIn(String s) throws TokenStreamException {
</I>&gt;<i>                 if (inputState.guessing&gt;0) {
</I>&gt;<i>                         return;
</I>&gt;<i>                 }
</I>&gt;<i>                 ParseTreeRule subRoot = new ParseTreeRule(s);
</I>&gt;<i>                 if ( currentParseTreeRoot.size()&gt;0 ) {
</I>&gt;<i>                         ParseTreeRule oldRoot = 
</I>&gt;<i> (ParseTreeRule)currentParseTreeR
</I>&gt;<i> oot.peek();
</I>&gt;<i>                         oldRoot.addChild(subRoot);
</I>&gt;<i>                 }
</I>&gt;<i>                 currentParseTreeRoot.push(subRoot);
</I>&gt;<i>                 numberOfDerivationSteps++;
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /** Pop current root; back to adding to old root */
</I>&gt;<i>         public void traceOut(String s) throws TokenStreamException {
</I>&gt;<i>                 if (inputState.guessing&gt;0) {
</I>&gt;<i>                         return;
</I>&gt;<i>                 }
</I>&gt;<i>                 mostRecentParseTreeRoot = 
</I>&gt;<i> (ParseTreeRule)currentParseTreeRoot.po
</I>&gt;<i> p();
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i> program
</I>&gt;<i>         :       (declaration)+
</I>&gt;<i>         { System.out.println(&quot;Matched Something&quot;); }
</I>&gt;<i>         ;
</I>&gt;<i>
</I>&gt;<i> declaration
</I>&gt;<i>         :       SUB
</I>&gt;<i>         |       FUNCTION
</I>&gt;<i>         ;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> //Lexer
</I>&gt;<i>
</I>&gt;<i> class VB6Lexer extends Lexer;
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i>         exportVocab=VB6;
</I>&gt;<i>         charVocabulary='\3'..'\377';
</I>&gt;<i>         caseSensitive=false;
</I>&gt;<i>         caseSensitiveLiterals=false;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> tokens {
</I>&gt;<i>         DIM=&quot;dim&quot;;
</I>&gt;<i>         SUB=&quot;sub&quot;;
</I>&gt;<i>         FUNCTION=&quot;function&quot;;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> IDENT
</I>&gt;<i> options {
</I>&gt;<i>         testLiterals=true;
</I>&gt;<i> }
</I>&gt;<i>         :       ('a'..'z')('a'..'z'|'0'..'9'|'_')*
</I>&gt;<i>         { System.out.println(&quot;found an ident&quot;); }
</I>&gt;<i>         ;
</I>&gt;<i>
</I>&gt;<i> WS
</I>&gt;<i>         :       ' '
</I>&gt;<i>         |       '\t'
</I>&gt;<i>         { $setType(Token.SKIP); }
</I>&gt;<i>         ;
</I>&gt;<i>
</I>&gt;<i> NL      :       '\r''\n'
</I>&gt;<i>         |       '\n'
</I>&gt;<i>         { $setType(Token.SKIP); }
</I>&gt;<i>         ;
</I>&gt;<i>
</I>&gt;<i> Thanks for the help.
</I>&gt;<i> Ron
</I>&gt;<i> *********************************************************************** 
</I>&gt;<i> ***************
</I>&gt;<i> This communication is intended solely for the addressee and is
</I>&gt;<i> confidential. If you are not the intended recipient, any disclosure,
</I>&gt;<i>  copying, distribution or any action taken or omitted to be taken in
</I>&gt;<i> reliance on it, is prohibited and may be unlawful. Unless indicated
</I>&gt;<i> to the contrary: it does not constitute professional advice or
</I>&gt;<i> opinions upon which reliance may be made by the addressee or any
</I>&gt;<i> other party, and it should be considered to be a work in progres s.
</I>&gt;<i> *********************************************************************** 
</I>&gt;<i> ***************
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yahoo! Groups Links
</I>&gt;<i>
</I>&gt;<i>                &#8226;               To visit your group on the web, go to:
</I>&gt;<i> <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>
</I>&gt;<i>  
</I>&gt;<i>                &#8226;                To unsubscribe from this group, send an 
</I>email to:
&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>
</I>&gt;<i>  
</I>&gt;<i>                &#8226;                Your use of Yahoo! Groups is subject to 
</I>the Yahoo! Terms of 
&gt;<i> Service.
</I>&gt;<i>
</I>&gt;<i>
</I>--
Professor Comp. Sci., University of San Francisco
Creator, ANTLR Parser Generator, <A HREF="http://www.antlr.org">http://www.antlr.org</A>
Cofounder, <A HREF="http://www.jguru.com">http://www.jguru.com</A>
Cofounder, <A HREF="http://www.knowspam.net">http://www.knowspam.net</A> enjoy email again!
Cofounder, <A HREF="http://www.peerscope.com">http://www.peerscope.com</A> pure link sharing





 
Yahoo! Groups Links



 




**************************************************************************************
This communication is intended solely for the addressee and is
confidential. If you are not the intended recipient, any disclosure, 
copying, distribution or any action taken or omitted to be taken in
reliance on it, is prohibited and may be unlawful. Unless indicated
to the contrary: it does not constitute professional advice or 
opinions upon which reliance may be made by the addressee or any
other party, and it should be considered to be a work in progress.
**************************************************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20040412/34fabc57/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20040412/34fabc57/attachment.html</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007356.html">[antlr-interest] debugging and testing
</A></li>
	<LI>Next message: <A HREF="007360.html">[antlr-interest] debugging and testing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7357">[ date ]</a>
              <a href="thread.html#7357">[ thread ]</a>
              <a href="subject.html#7357">[ subject ]</a>
              <a href="author.html#7357">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
