From marko.kukovec at gmail.com  Sun Oct  1 02:43:48 2006
From: marko.kukovec at gmail.com (Marko Kukovec)
Date: Sun, 1 Oct 2006 11:43:48 +0200
Subject: [antlr-interest] help: Few questions about undocumented constructs
Message-ID: <451f8dbd.2c532f79.0a89.ffff9097@mx.gmail.com>

Hello!

I'm quite new to ANTLR. I have been using it from time to time, but do not
have the feeling for its full potential. I'm still using ANTLR 2.7.5. Here
are some constructs that I come across regularly, but I don't know exactly
what they mean:

- LA(n); I have seen its usage in both parsers and lexers. Is LA like "look
ahead" for some token type (in parser) and character (in lexer) and is used
in semantic predicates?

- LT(n); What about LT? What's its usage?

- AST construction; I have seen people using constructs like

assignment_list: assignment (COMMA! assignment)*
//add in new root
{
##=#(#[SELECT_LIST,"SELECT_LIST"],##);
}
;

What does "##" do? There is no mention of it in the documentation.


Thank you for all the help.

Regards,
Marko Kukovec


From rukmal_fernando at yahoo.com  Sun Oct  1 21:45:32 2006
From: rukmal_fernando at yahoo.com (Rukmal Fernando)
Date: Sun, 1 Oct 2006 21:45:32 -0700 (PDT)
Subject: [antlr-interest] Parser performance dropping as a function of line
	count
Message-ID: <20061002044532.35071.qmail@web30801.mail.mud.yahoo.com>

Dear all, 

First of all, we are somewhat new to ANTLR and have not had any formal education on Parser construction. Secondly, we apologise for the long e-mail, but we would like to give you the complete picture wtih regard to our unusual problem.

We are a Sri Lankan software team developing a code diff / merge tool, and are creating a new version using .Net 2 and ANTLR 2.7.6 to replace the older Flex/ Bison / VC++ tool.

After trying a few PL\SQL grammar files which did not meed our particular needs, we decided to write a new PL\SQL parser from scratch, comprising of a subset of PLSQL features specific to our work. The (Lexer + Parser) grammar is only 670 lines with only one syntactic predicate.

The problem we have is that we have PL\SQL files of around 18K lines of code, consisting of a PL\SQL package with various procedures and functions. We now have some serious performance problems with this. 

As an example, we have a parser error generated at line 460. When the last bit of the file is truncated to bring the file size to 1K lines, the parser takes about 15-16 seconds to reach the error. When the file is truncated to about 2K lines, it takes 29 seconds to reach the error. Likewise, when the file is truncated to 3K and 5K lines, it take rougly 90 and 150 seconds respecitvely to reach the 460th line.

Just for clarification, what we mean by "truncating the file" is to remove procedures etc from the tail end so that the file is still syntactically valid. We are absolutely stumped by how the parser seems to take roughly n-times as much time to reach the same point of the file, when the file's line count is n*1000 lines of code.

We would greatly appreciate if anyone can point out
a. Whether such a drop in performance can be explained as a result of ANTLR itself, or the grammar file
b. Whether this can be fixed, and if so your suggestions.

Thank you in advance.

Rukmal Fernando.
IFS R&D, Sri Lanka.
rukmal UNDERSCORE fernando AT yahoo DOT com

p.s: Performance stats
File length (lines)   Time to reach line 460 (seconds)
1040                     15-16 [stopwatch on error message! :-) ]
2042                     29
3032                     41.5
5057                     70
10087                    153

Estimated time to parse complete file is below.
File line count           Estimated time to parse (seconds)
1040                        37

2042                        128

3032                        272

5057                        767

10087                      3347







From ric.klaren at gmail.com  Mon Oct  2 00:39:35 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Mon, 2 Oct 2006 09:39:35 +0200
Subject: [antlr-interest] Parser performance dropping as a function of
	line count
In-Reply-To: <20061002044532.35071.qmail@web30801.mail.mud.yahoo.com>
References: <20061002044532.35071.qmail@web30801.mail.mud.yahoo.com>
Message-ID: <bc607a4e0610020039v9cfd8bbgb51acc82f042f494@mail.gmail.com>

Hi,

On 10/2/06, Rukmal Fernando <rukmal_fernando at yahoo.com> wrote:
> After trying a few PL\SQL grammar files which did not meed our particular needs, we decided to write a new PL\SQL parser from scratch, comprising of a subset of PLSQL features specific to our work. The (Lexer + Parser) grammar is only 670 lines with only one syntactic predicate.
>
> The problem we have is that we have PL\SQL files of around 18K lines of code, consisting of a PL\SQL package with various procedures and functions. We now have some serious performance problems with this.
>
> As an example, we have a parser error generated at line 460. When the last bit of the file is truncated to bring the file size to 1K lines, the parser takes about 15-16 seconds to reach the error. When the file is truncated to about 2K lines, it takes 29 seconds to reach the error. Likewise, when the file is truncated to 3K and 5K lines, it take rougly 90 and 150 seconds respecitvely to reach the 460th line.

Did you try generating the parser with -traceParser and see what is
exactly happening? The times you list more or less hint at that the
syntactic predicate is in a pretty bad place. Looking at the output of
-traceParser will tell you wether that is happening. I'm not 100% sure
wether the default trace behaviour shows wether the parser is
backtracking, think it did, else you have to override the traceXX
methods.

Aside note: Did you check wether the lexer is the slowing factor?
ANTLR2's lexers are not really performance animals. You can easily
check this by making a loop that calls the lexer's nextToken() method
repeatedly.

Cheers,

Ric

From kirschner at inf.unibz.it  Mon Oct  2 03:15:12 2006
From: kirschner at inf.unibz.it (Manuel Kirschner)
Date: Mon, 2 Oct 2006 12:15:12 +0200
Subject: [antlr-interest] How to implement implicit concatenation operator
	(for Regular Expressions)
Message-ID: <f8282bdc0610020315h5af92d0fm1ae272562ed513fe@mail.gmail.com>

Hello,
I'm new to antlr, so please excuse the possibly trivial question.
For parsing Regular Expressions (REs), I need to implement "implicit"
concatenation by juxtaposition. So far, my grammar parses REs
successfully, as long as I insert some explicit concatenation operator
(CONCAT) into the input string. The relevant parsing rule:

basicRE : simpleRE ((CONCAT^) simpleRE)*;

How do I get antlr to introduce the CONCAT operator node into the AST
between every two simpleRE nodes, even though CONCAT has no character
representation in the input text?

Thanks for your hints!

From rukmal_fernando at yahoo.com  Mon Oct  2 03:27:12 2006
From: rukmal_fernando at yahoo.com (Rukmal Fernando)
Date: Mon, 2 Oct 2006 03:27:12 -0700 (PDT)
Subject: [antlr-interest] Parser performance dropping as a function of
	line count
Message-ID: <20061002102712.74371.qmail@web30813.mail.mud.yahoo.com>

Hi,

Thank you for the pointer, and while I was checking what you said about syntactic predicates I realised the gravity of my mistake - identifier was doing a syntactic predicate that I had somehow forgotten about.

I have removed it, and this seems to have rectified the problem. Thank you very much once again.

Out of curiosity, can anyone point out why a simple misplaced syntactic predicate could have such an impact, especially one that grew with the file size even when the number of lines parsed was fixed? (i.e.: in my case, the time the parser took to parse up to the first parser error @line 460 doubled for every 1000 lines in the source file).

Best regards,

Rukmal.

----- Original Message ----
From: Ric Klaren <ric.klaren at gmail.com>
To: Rukmal Fernando <rukmal_fernando at yahoo.com>
Cc: antlr-interest at antlr.org
Sent: Monday, October 2, 2006 1:09:35 PM
Subject: Re: [antlr-interest] Parser performance dropping as a function of line count

Hi,

On 10/2/06, Rukmal Fernando <rukmal_fernando at yahoo.com> wrote:
> After trying a few PL\SQL grammar files which did not meed our particular needs, we decided to write a new PL\SQL parser from scratch, comprising of a subset of PLSQL features specific to our work. The (Lexer + Parser) grammar is only 670 lines with only one syntactic predicate.
>
> The problem we have is that we have PL\SQL files of around 18K lines of code, consisting of a PL\SQL package with various procedures and functions. We now have some serious performance problems with this.
>
> As an example, we have a parser error generated at line 460. When the last bit of the file is truncated to bring the file size to 1K lines, the parser takes about 15-16 seconds to reach the error. When the file is truncated to about 2K lines, it takes 29 seconds to reach the error. Likewise, when the file is truncated to 3K and 5K lines, it take rougly 90 and 150 seconds respecitvely to reach the 460th line.

Did you try generating the parser with -traceParser and see what is
exactly happening? The times you list more or less hint at that the
syntactic predicate is in a pretty bad place. Looking at the output of
-traceParser will tell you wether that is happening. I'm not 100% sure
wether the default trace behaviour shows wether the parser is
backtracking, think it did, else you have to override the traceXX
methods.

Aside note: Did you check wether the lexer is the slowing factor?
ANTLR2's lexers are not really performance animals. You can easily
check this by making a loop that calls the lexer's nextToken() method
repeatedly.

Cheers,

Ric






From ric.klaren at gmail.com  Mon Oct  2 03:37:43 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Mon, 2 Oct 2006 12:37:43 +0200
Subject: [antlr-interest] Parser performance dropping as a function of
	line count
In-Reply-To: <20061002102712.74371.qmail@web30813.mail.mud.yahoo.com>
References: <20061002102712.74371.qmail@web30813.mail.mud.yahoo.com>
Message-ID: <bc607a4e0610020337p52d4ae1he0c42d08365f40c6@mail.gmail.com>

Hi,

On 10/2/06, Rukmal Fernando <rukmal_fernando at yahoo.com> wrote:
> I have removed it, and this seems to have rectified the problem. Thank you very much once again.

Great :)

> Out of curiosity, can anyone point out why a simple misplaced syntactic predicate could have such an impact, especially one that grew with the file size even when the number of lines parsed was fixed? (i.e.: in my case, the time the parser took to parse up to the first parser error @line 460 doubled for every 1000 lines in the source file).

A syntactic predicate let's ANTLR run in trial and error mode. E.g.
when it get's to the point that it needs to evaluate the predicate it
turns on the so called guessing mode. From this point on antlr tries
to evaluate a parse run of the predicate (with actions turned off) if
this fails parsing continues at the next alternative (or an error is
thrown). So in the best case ANTLR will look at the input twice to
parse it (once to evaluate the predicate, and once to really parse it
(but now including actions)). Worst case it will completely explode in
your face and look a gazillion times at eacht token before deciding
one alternative.. and then merrily continue with the next...

If you want to get a feel for this just make an example grammar and
look at the generated code.

Syntactic predicates are really nice to get something going. After you
got it going you should really carefully look at removing them as much
as possible. There's a trade-off in readability of the grammar (left
factoring often does not improve readability) and speed there.

Cheers,

Ric

From kirschner at inf.unibz.it  Mon Oct  2 05:03:53 2006
From: kirschner at inf.unibz.it (Manuel Kirschner)
Date: Mon, 02 Oct 2006 14:03:53 +0200
Subject: [antlr-interest] How to implement implicit concatenation operator
 (for Regular Expressions)
Message-ID: <45210029.5020001@inf.unibz.it>

Hello,
I'm new to antlr, so please excuse the possibly trivial question.
For parsing Regular Expressions (REs), I need to implement "implicit"
concatenation by juxtaposition. So far, my grammar parses REs
successfully, as long as I insert some explicit concatenation operator
(CONCAT) into the input string. The relevant parsing rule:

basicRE : simpleRE ((CONCAT^) simpleRE)*;

How do I get antlr to introduce the CONCAT operator node into the AST
between every two simpleRE nodes, even though CONCAT has no character
representation in the input text?

Thanks for your hints!

From kirschner at inf.unibz.it  Mon Oct  2 05:44:47 2006
From: kirschner at inf.unibz.it (Manuel Kirschner)
Date: Mon, 2 Oct 2006 14:44:47 +0200
Subject: [antlr-interest] How to implement implicit concatenation
	operator (for Regular Expressions)
In-Reply-To: <f8282bdc0610020315h5af92d0fm1ae272562ed513fe@mail.gmail.com>
References: <f8282bdc0610020315h5af92d0fm1ae272562ed513fe@mail.gmail.com>
Message-ID: <f8282bdc0610020544k2350912eqaac09bfceea861c1@mail.gmail.com>

OK, found the solution by turning off standard tree construction.

> basicRE : simpleRE ((CONCAT^) simpleRE)*;

Now, instead of expecting a CONCAT operator, a CONC node is inserted
into the AST:

basicRE : a:simpleRE (! b:simpleRE {#basicRE = #([CONC,"conc"], #a, #b); } )* ;

From rhill03 at eds.com  Mon Oct  2 07:45:54 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Mon, 2 Oct 2006 15:45:54 +0100
Subject: [antlr-interest] Multiple template rewrites from AST Tree?
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DF872@UKNSM201.emea.corp.eds.com>

Can it be done, if so  what's the syntax?
I've tried comma's ,brackets, braces etc and nothing seems to work..

Can you actually write out more than one template on a re-write rule or
must you revert back to passing templates as parameters?
I hope not since it means passing the template parameter down lots of
rules to be filled in one of the outer leaves of my tree :(
Hmm thinking about it, how would the parent rule know which template to
take on return? Maybe this is a stupid question in that case, so I may
have to pass the template as parameter ... has anyone else done anything
similar? 

Cheers,

Rob




--
ROB HILL
DWP ACW
EDS Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 790 318 5516
E:	rhill03 at eds.com


-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061002/90117556/attachment.html 

From ewbank at gmail.com  Mon Oct  2 09:04:00 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Mon, 2 Oct 2006 12:04:00 -0400
Subject: [antlr-interest] How to implement implicit concatenation
	operator (for Regular Expressions)
In-Reply-To: <f8282bdc0610020544k2350912eqaac09bfceea861c1@mail.gmail.com>
References: <f8282bdc0610020315h5af92d0fm1ae272562ed513fe@mail.gmail.com>
	<f8282bdc0610020544k2350912eqaac09bfceea861c1@mail.gmail.com>
Message-ID: <dd3a065f0610020904g39edba7ahf68384a7d9e40914@mail.gmail.com>

I think there's an issue if there are more than two adjacent regex's
because of the way the rule is written to use "#a" -- which is not
modified.  I think it chops off part of the result.  Try this instead:

   basicRE:!
      a:simpleRE ( b:simpleRE { #a = #([CONC,"conc"], #a,#b); } )*
      { ## = #a; }
      ;

You might also consider allowing CONC to be an n-ary operator, rather
than a binary operator; , and allow an optional user-specified CONCAT
operator:

   basicRE:
      a:simpleRE ( CONCAT! b:simpleRE )*
      { ## = #([CONC,"conc"], ##); }
      ;


On 10/2/06, Manuel Kirschner <kirschner at inf.unibz.it> wrote:
> OK, found the solution by turning off standard tree construction.
>
> > basicRE : simpleRE ((CONCAT^) simpleRE)*;
>
> Now, instead of expecting a CONCAT operator, a CONC node is inserted
> into the AST:
>
> basicRE : a:simpleRE (! b:simpleRE {#basicRE = #([CONC,"conc"], #a, #b); } )* ;
>

From porcelli at uol.com.br  Mon Oct  2 14:17:53 2006
From: porcelli at uol.com.br (Alexandre Porcelli)
Date: Mon, 2 Oct 2006 18:17:53 -0300
Subject: [antlr-interest] Problem building a real parser using v3
Message-ID: <ee873c070610021417y65fb1961r8a01eda34a5f02ca@mail.gmail.com>

Hi All,

I just started to build a COBOL parser from scratch, based on newest
IBM official documentation.

I'm really in the beginning of this job. But when I tried to test and
compile a first part of my job, I got this message:

"The code of method specialStateTransition(int) is exceeding the 65535
bytes limit".

Attached to this e-mail is my grammar file.

And I'd like to ask to all of you what I'm doing wrong. Is there a
better way to do it?

Thanks in advance.

Best Regards,
Alexandre Porcelli
-------------- next part --------------
A non-text attachment was scrubbed...
Name: CobolParser.g
Type: application/octet-stream
Size: 4302 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061002/ae0da25c/attachment.obj 

From kroepke at classdump.org  Mon Oct  2 14:51:39 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Mon, 2 Oct 2006 23:51:39 +0200
Subject: [antlr-interest] Problem building a real parser using v3
In-Reply-To: <ee873c070610021417y65fb1961r8a01eda34a5f02ca@mail.gmail.com>
References: <ee873c070610021417y65fb1961r8a01eda34a5f02ca@mail.gmail.com>
Message-ID: <B5C5BF23-BBE1-4817-9201-AA0D865BFBAF@classdump.org>

Hi!

On 2. Oct 2006, at 23:17 Uhr, Alexandre Porcelli wrote:

> "The code of method specialStateTransition(int) is exceeding the 65535
> bytes limit".

Gotta love Java, huh? *shakes head*

> Attached to this e-mail is my grammar file.
>
> And I'd like to ask to all of you what I'm doing wrong. Is there a
> better way to do it?

A transition becomes special if it either is composed of more 65534  
edges or must check some "special" predicate.
It seems the getCharPositionInLine() test is throwing it off. Looking  
at the generated code, the individual case labels of the switch all  
seem *very* similar. I wonder if we could optimize this a bit.

Sorry if I couldn't offer much help, but it might give you an idea of  
what's going on. I'll look into it further tomorrow, though Ter might  
be of more help, since he is the Master of Things :)

regards,

-k





From kroepke at classdump.org  Mon Oct  2 16:08:49 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Tue, 3 Oct 2006 01:08:49 +0200
Subject: [antlr-interest] Problem building a real parser using v3
In-Reply-To: <ee873c070610021521y584d1ccbl787c7c1e6bb65bb8@mail.gmail.com>
References: <ee873c070610021417y65fb1961r8a01eda34a5f02ca@mail.gmail.com>
	<B5C5BF23-BBE1-4817-9201-AA0D865BFBAF@classdump.org>
	<ee873c070610021521y584d1ccbl787c7c1e6bb65bb8@mail.gmail.com>
Message-ID: <F957CD88-412F-42C7-B9D6-4416F54D7F01@classdump.org>

Hi Alexandre!

On 3. Oct 2006, at 0:21 Uhr, Alexandre Porcelli wrote:

> I just cut off the getCharPositionInLine() test and the problem  
> still.... :(
> In fact... I couldn't see anything really different.

Ok. I just tried again, and the culprit seems to be the semantic  
predicate on COMMENT_ENTRY.
The set afterwards ( (~'.')+ is a huge set!) seems to blow up the DFA  
construction. Maybe you can try something else besides the sempred,  
I'm a bit short on time at the moment, but removing that predicate  
eliminates the special transitions almost completely.
It is pretty logical, when you think about it, since ANTLR has to  
include the sempred for every decision that involves ~'.' at a  
possible edge. That essentially gives you every combination of pair- 
wise different characters in the lookahead, which virtually is every  
token in your grammar. Since the semantic predicate can't go into the  
DFA tables, it must go into specialStateTransitions(int) and that is  
a lot of code :(

My advice, FWIW:
Try to do away with the semantic predicate or more closely specify  
what can constitute a COMMENT_ENTRY, rather than saying ~'.'. That  
should give you fewer special states.

HTH,

-k




From lgcraymer at yahoo.com  Mon Oct  2 16:54:56 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Mon, 2 Oct 2006 16:54:56 -0700 (PDT)
Subject: [antlr-interest] Problem building a real parser using v3
In-Reply-To: <F957CD88-412F-42C7-B9D6-4416F54D7F01@classdump.org>
Message-ID: <20061002235456.76388.qmail@web55911.mail.re3.yahoo.com>

Kay's first suggestion--do away with the sempred--is probably the best.  Change the lexer rules which set comentEntryMode to true to incorporate the COMMENT_ENTRY DOT items and do away with the corresponding parser rules.  If you really need the COMMENT_ENTRY text, you then just need to trim the leading 'SECURITY' ('.')?  (and similar) and trailing '.'  to get it.

--Loring

Kay Roepke <kroepke at classdump.org> wrote: Hi Alexandre!

On 3. Oct 2006, at 0:21 Uhr, Alexandre Porcelli wrote:

> I just cut off the getCharPositionInLine() test and the problem  
> still.... :(
> In fact... I couldn't see anything really different.

Ok. I just tried again, and the culprit seems to be the semantic  
predicate on COMMENT_ENTRY.
The set afterwards ( (~'.')+ is a huge set!) seems to blow up the DFA  
construction. Maybe you can try something else besides the sempred,  
I'm a bit short on time at the moment, but removing that predicate  
eliminates the special transitions almost completely.
It is pretty logical, when you think about it, since ANTLR has to  
include the sempred for every decision that involves ~'.' at a  
possible edge. That essentially gives you every combination of pair- 
wise different characters in the lookahead, which virtually is every  
token in your grammar. Since the semantic predicate can't go into the  
DFA tables, it must go into specialStateTransitions(int) and that is  
a lot of code :(

My advice, FWIW:
Try to do away with the semantic predicate or more closely specify  
what can constitute a COMMENT_ENTRY, rather than saying ~'.'. That  
should give you fewer special states.

HTH,

-k





 				
---------------------------------
Do you Yahoo!?
 Next-gen email? Have it all with the  all-new Yahoo! Mail.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061002/05f33caa/attachment.html 

From parrt at cs.usfca.edu  Mon Oct  2 18:11:21 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 2 Oct 2006 18:11:21 -0700
Subject: [antlr-interest] looking for error case
Message-ID: <C1285E0C-2B9F-4593-911E-EECE0F91E6E8@cs.usfca.edu>

hi,

I am trying to find a simple grammar (or any for that matter) that  
causes an internal error like

DFA 34: (...)* max state num x != max renumbered state y

Can anybody send me a grammar with this error from ANTLR 3.0b4 or so?

Thanks,
Ter

From uladzislau.latynski+antlr at gmail.com  Tue Oct  3 00:27:06 2006
From: uladzislau.latynski+antlr at gmail.com (Uladzislau Latynski)
Date: Tue, 3 Oct 2006 10:27:06 +0300
Subject: [antlr-interest] Simple ANTLR questions
Message-ID: <5355bcc60610030027m2bd727f8n2b27359fb95afd14@mail.gmail.com>

Hello, I'm new to ANTLR and have little question.
Here is the example grammar:

grammar TTT;
ab      :
       AB+
;
bd      :
       BD+
;
AB      :
       'a'..'b'
;
BD      :
       'b'..'d'
;

and I'm trying to parse 'bbb'. When I'm parsing it with "ab" rule all
goes well, but when I'm parsing with "bd" rule, I get exception:
MismatchedTokenException (4!=5). Why? :) (antlr-3.0b4,
antlrworks-1.0b3)

And the second question: does the syntax of the ANTLR v3 grammar files
described anywhere?
-- 
Best regards.
Vlad.

From sameernairi at gmail.com  Tue Oct  3 03:35:09 2006
From: sameernairi at gmail.com (Sameer Nairi)
Date: Tue, 3 Oct 2006 16:05:09 +0530
Subject: [antlr-interest] ANTLR in windows
Message-ID: <f4a178b0610030335j3144144ew7469c694524d10b6@mail.gmail.com>

Hi guys,

This is a perfectly generic question thats likely to be covered before...but
sigh, I just haven't been able to get to a solution despite an entire
morning, the better part of an afternoon, and 3 cups of coffee - so here
goes: I'm new to ANTLR. I'm very interested in what ANTLR offers, but am
facing difficulties in getting ANTLR to work on Windows. I downloaded
2.7.6source, downloaded cygwin, but am unable to get configure & make
to work -
thus unable to install it... unfortunately, i haven't used *nix in years, so
don't know what arcane spells to invoke to get this thing to work... i'm
just addicted to those MSI files that I double click to sort everything out
;-)

Doubtless that some of you probably find this question a little offensive,
but what's the simplest possible route to get getting ANTLR to work on
windows while minimizing the number of downloads? I don't care about getting
the source & building it - i'd just like to use it to type out a grammar,
and get some C# output to feed my .NET addictions.

If i've missed some obvious link on the website, please do be kind enough to
point it out to me. Unlike seasoned ANTLERs, it can be quite difficult for
noob wannabies to to grok the website and find information quickly.

regards,
Sameer
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061003/910a98f1/attachment.html 

From ric.klaren at gmail.com  Tue Oct  3 04:14:33 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Tue, 3 Oct 2006 13:14:33 +0200
Subject: [antlr-interest] ANTLR in windows
In-Reply-To: <f4a178b0610030335j3144144ew7469c694524d10b6@mail.gmail.com>
References: <f4a178b0610030335j3144144ew7469c694524d10b6@mail.gmail.com>
Message-ID: <bc607a4e0610030414x683698d6w566d38806820dd18@mail.gmail.com>

Hi,

On 10/3/06, Sameer Nairi <sameernairi at gmail.com> wrote:
> Doubtless that some of you probably find this question a little offensive,
> but what's the simplest possible route to get getting ANTLR to work on
> windows while minimizing the number of downloads? I don't care about getting
> the source & building it - i'd just like to use it to type out a grammar,
> and get some C# output to feed my .NET addictions.

http://www.antlr.org/download.html

Then scroll down a bit to the msi for 2.7.5 or the windows executable for 2.7.6.

I'm not familiar with the status of the C# bits in 2.7.5, e.g. if
you're missing essential bugfixes or anything. If you download the
mingw compiled executable for 2.7.6 combine it with the C# runtime
stuff from the normal 2.7.6 download.

In the file sharing section of the site are also some mingw/cygwin recipes:

http://www.antlr.org/share/1070254713840/cygwin.txt

Cheers,

Ric

From rhill03 at eds.com  Tue Oct  3 06:42:54 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Tue, 3 Oct 2006 14:42:54 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFA75@UKNSM201.emea.corp.eds.com>

I want to make multiple passes over a tree but only utilise parts of the
tree for each pass so I've duplicated the tree grammar 3 times , adding
actions only for the parts that matter at each pass.

So the question is , how do you ignore (remove) whole branches of a
tree? At the moment if I add a node into the parser output I have to
change all 3 tree walkers in response. If I know that the tokens that
pass 1 will no longer be affected, how can I remove all the unwanted
rules from that grammar so It only looks at the tokens it needs?

Am I approaching this in the correct manner?

Cheers!

Rob








--
ROB HILL
DWP ACW
EDS Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 790 318 5516
E:	rhill03 at eds.com


-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061003/968f8b5a/attachment.html 

From rhill03 at eds.com  Tue Oct  3 23:23:40 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Wed, 4 Oct 2006 07:23:40 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <4522778D.1020002@ntlworld.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>

I've pretty much gone down the multiple tree parser routes, its a real
pain in the ass though, as if you modify your parser, you then have to
modify all the tree parser grammars too. I must be missing something
here. :(
there must be a rule that ignores a whole branch, but i've tried all
sorts and haven't succeeded , 
 
ignoreme : ^(.*) ... if only :)
 
which is why i ended up with 3 tree parse phases. I just get this
nagging feeling im missing the point.
 
i think everyone's gone on holiday, the list is usually way busier than
this.
 
cheers,
Rob
 



-- 
Rob Hill 
EDS - Hallamshire Business Park 
F1E/045 
Sheffield       
T:      +44 (0) 114 291 1928 
M:      +44 (0) 791 732 1227 
E:      rhill03 at eds.com <mailto:rhill03 at eds.com>  

 


________________________________

	From: Henry Butowsky [mailto:henryb at ntlworld.com] 
	Sent: 03 October 2006 15:46
	To: Hill, Robert
	Subject: Re: [antlr-interest] Multiple pass tree walking Q
	
	
	Hi Rob --- 
	    I have a similar problem  -- I Have to parse the tree twice
--- And Im not sure to use a single multipurpose tree walker or
	     use 2 tree parsers --- I will be watching the responses
from the newsgroup !
	
	Regards Henry
	
	Hill, Robert wrote: 

		I want to make multiple passes over a tree but only
utilise parts of the tree for each pass so I've duplicated the tree
grammar 3 times , adding actions only for the parts that matter at each
pass.

		So the question is , how do you ignore (remove) whole
branches of a tree? At the moment if I add a node into the parser output
I have to change all 3 tree walkers in response. If I know that the
tokens that pass 1 will no longer be affected, how can I remove all the
unwanted rules from that grammar so It only looks at the tokens it
needs?

		Am I approaching this in the correct manner? 

		Cheers! 

		Rob 








		-- 
		ROB HILL 
		DWP ACW 
		EDS Hallamshire Business Park 
		F1E/045 
		Sheffield       
		T:      +44 (0) 114 291 1928 
		M:      +44 (0) 790 318 5516 
		E:      rhill03 at eds.com <mailto:rhill03 at eds.com>  



-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061004/329f3465/attachment.html 

From gt54-antlr at cyconix.com  Wed Oct  4 01:12:53 2006
From: gt54-antlr at cyconix.com (Paul Johnson)
Date: Wed, 04 Oct 2006 09:12:53 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
Message-ID: <45236D05.3040306@cyconix.com>

Hill, Robert wrote:
> I've pretty much gone down the multiple tree parser routes, its a real 
> pain in the ass though, as if you modify your parser, you then have to 
> modify all the tree parser grammars too. I must be missing something 
> here. :(
> there must be a rule that ignores a whole branch, but i've tried all 
> sorts and haven't succeeded ,
>  
> ignoreme : ^(.*) ... if only :)
>  
> which is why i ended up with 3 tree parse phases. I just get this 
> nagging feeling im missing the point.

You won't like this reply, but this is why I don't use tree grammars. 
I've got 8 passes, each of which needs to modify the AST. I manually 
parse the tree, and cut out branches when I've finished with them (or 
replace nodes, or whatever).

The recursive tree parse in each pass is (almost) trivial, so a grammar 
would buy me little. I do have occasional complications with having to 
find my context in the tree, parsing node lists right-to-left instead of 
left-to-right, and so on, but no major problems, and certainly nothing 
that would justify maintaining 8 different grammars. One major advantage 
is that I can trivially add extra passes that do almost nothing, except 
maybe some cleaning up for the next pass.

Disclaimer: I've never actually tried the tree grammar route, so I (too) 
may have missed easy ways to do what I'm now doing manually.

There's a lot on this in the archives - have a look. You could start 
with Andy Tripp's reply in the "How much use is ANTLR for manipulating 
ASTs?" thread (18/06/2005).

Paul

From rhill03 at eds.com  Wed Oct  4 01:59:11 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Wed, 4 Oct 2006 09:59:11 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <45236D05.3040306@cyconix.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFBD3@UKNSM201.emea.corp.eds.com>

Yay - a Reply! I was thinking my mails weren't getting through for a
minute there ;)

Hmm, I considered this originally, but I think I only need 3 passes, so
while it's a big hassle, using grammars has take out a huge wodge of
time in getting it up and running , whereas I feel that walking the
tree's manually would probably have taken a fair bit longer. With 8
passes , unless there's another way to skip branches in the tree, then I
think you definitely made the right choice. I think 3 passes with a
grammar isn't all that bad, 4 passes is definitely borderline.

Ahhh mid-email ah-ha moment!.... maybe.. I think I've got it. Grammar
inheritance. (that is if it's working in 3.0b4.) maintain a base class
tree grammar, and then override the relevant branches for each pass. -
unless your parser grammar changes a branch you've overridden, you'll
only have the base class to implement the standard walk in. 
Yeah, I think that should do it.... Off to give it a go now. 

Cheers for the input anyway Paul!

Rob



--
Rob Hill
EDS - Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 791 732 1227
E:	rhill03 at eds.com

 

>-----Original Message-----
>From: Paul Johnson [mailto:gt54-antlr at cyconix.com] 
>Sent: 04 October 2006 09:13
>To: Hill, Robert
>Cc: ANTLR Interest
>Subject: Re: [antlr-interest] Multiple pass tree walking Q
>
>Hill, Robert wrote:
>> I've pretty much gone down the multiple tree parser routes, 
>its a real 
>> pain in the ass though, as if you modify your parser, you 
>then have to 
>> modify all the tree parser grammars too. I must be missing something 
>> here. :( there must be a rule that ignores a whole branch, but I've 
>> tried all sorts and haven't succeeded ,
>>  
>> ignoreme : ^(.*) ... if only :)
>>  
>> which is why i ended up with 3 tree parse phases. I just get this 
>> nagging feeling im missing the point.
>
>You won't like this reply, but this is why I don't use tree grammars. 
>I've got 8 passes, each of which needs to modify the AST. I 
>manually parse the tree, and cut out branches when I've 
>finished with them (or replace nodes, or whatever).
>
>The recursive tree parse in each pass is (almost) trivial, so 
>a grammar would buy me little. I do have occasional 
>complications with having to find my context in the tree, 
>parsing node lists right-to-left instead of left-to-right, and 
>so on, but no major problems, and certainly nothing that would 
>justify maintaining 8 different grammars. One major advantage 
>is that I can trivially add extra passes that do almost 
>nothing, except maybe some cleaning up for the next pass.
>
>Disclaimer: I've never actually tried the tree grammar route, 
>so I (too) may have missed easy ways to do what I'm now doing manually.
>
>There's a lot on this in the archives - have a look. You could 
>start with Andy Tripp's reply in the "How much use is ANTLR 
>for manipulating ASTs?" thread (18/06/2005).
>
>Paul
>

From rhill03 at eds.com  Wed Oct  4 02:19:20 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Wed, 4 Oct 2006 10:19:20 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <45236D05.3040306@cyconix.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFBE2@UKNSM201.emea.corp.eds.com>

I know it's a but odd  to repy to your own emails LOL , but I see
another reason for manually parsing the trees as you do,
For 8 passes, as you say you're optimising/transforming the tree as you
go, I would imagine an inhereted tree grammar parsing a somewhat more
fixed tree, so depending on how large the tree , speed may be an issue
here. - its not for me so I think I'll give the inheritance thing a go
anyway.

Cheers,
Rob



--
Rob Hill
EDS - Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 791 732 1227
E:	rhill03 at eds.com

 

>-----Original Message-----
>From: Paul Johnson [mailto:gt54-antlr at cyconix.com] 
>Sent: 04 October 2006 09:13
>To: Hill, Robert
>Cc: ANTLR Interest
>Subject: Re: [antlr-interest] Multiple pass tree walking Q
>
>Hill, Robert wrote:
>> I've pretty much gone down the multiple tree parser routes, 
>its a real 
>> pain in the ass though, as if you modify your parser, you 
>then have to 
>> modify all the tree parser grammars too. I must be missing something 
>> here. :( there must be a rule that ignores a whole branch, but i've 
>> tried all sorts and haven't succeeded ,
>>  
>> ignoreme : ^(.*) ... if only :)
>>  
>> which is why i ended up with 3 tree parse phases. I just get this 
>> nagging feeling im missing the point.
>
>You won't like this reply, but this is why I don't use tree grammars. 
>I've got 8 passes, each of which needs to modify the AST. I 
>manually parse the tree, and cut out branches when I've 
>finished with them (or replace nodes, or whatever).
>
>The recursive tree parse in each pass is (almost) trivial, so 
>a grammar would buy me little. I do have occasional 
>complications with having to find my context in the tree, 
>parsing node lists right-to-left instead of left-to-right, and 
>so on, but no major problems, and certainly nothing that would 
>justify maintaining 8 different grammars. One major advantage 
>is that I can trivially add extra passes that do almost 
>nothing, except maybe some cleaning up for the next pass.
>
>Disclaimer: I've never actually tried the tree grammar route, 
>so I (too) may have missed easy ways to do what I'm now doing manually.
>
>There's a lot on this in the archives - have a look. You could 
>start with Andy Tripp's reply in the "How much use is ANTLR 
>for manipulating ASTs?" thread (18/06/2005).
>
>Paul
>

From rhill03 at eds.com  Wed Oct  4 07:17:12 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Wed, 4 Oct 2006 15:17:12 +0100
Subject: [antlr-interest] Grammar inheritance?
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFCB7@UKNSM201.emea.corp.eds.com>

Does this work in 3.0b4?
Im trying to create a base class using the grammar option {
superClass=baseGrammar; }
But for the derived grammar file its generating 'null.java' which
contains about 20 lines of code :(

If it is working how do I create a subclass of a base grammer?

Thanks!
Rob



--
ROB HILL
DWP ACW
EDS Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 790 318 5516
E:	rhill03 at eds.com


-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061004/14a84e9a/attachment-0001.html 

From harder at tzi.de  Wed Oct  4 07:18:22 2006
From: harder at tzi.de (Jan Harder)
Date: Wed, 04 Oct 2006 16:18:22 +0200
Subject: [antlr-interest] How to do a specific operation once on every token
	in the _parser_?
Message-ID: <4523C2AE.7000808@tzi.de>

Hello,

I wrote a parser for visual basic using ANTLR 2.7.6 and I want to 
compute the halstead metric for parts of the code. Basically, this means 
that I need to classify all tokens in two groups (identifiers, literals 
vs. everything else) and count the occurrences of tokens with the same 
text. The classification and the counting is very easy to do, but my 
problem is that I am not sure _where_ to do this. The main problem is 
that it must be ensured that each token is counted only once. This 
metric is of interest for each function in the code, so I need to this 
in the parser, where I know where functions start and where they end. 
Unfortunately I can't do the measurement on the AST tree because it does 
not contain all tokens. Things like brackets are not added to the tree. 
It is not an option to change the tree.

Of course I don't want to insert an counting action for every token that 
can appear in a function. What I need is a place where each token comes 
along exactly once and can be counted easily. I thought of using the 
parsers consume() function. My idea was to overwirte it and add the 
classification counting code for the metric there by inspecting LT(1) 
after the consume-implementation from LLKParser was called. I guess this 
way ensures that every token is inspected exactly once, but I'm not sure 
about that. Is it safe to do it that way or is the consume method 
affected be the rewind operation on the token stream so that the same 
token can be handeled by consume() more than once?

Thanks for your help.

Jan Harder

PS: I generate C++ code



From ric.klaren at gmail.com  Wed Oct  4 07:59:23 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed, 4 Oct 2006 16:59:23 +0200
Subject: [antlr-interest] Grammar inheritance?
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4026DFCB7@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFCB7@UKNSM201.emea.corp.eds.com>
Message-ID: <bc607a4e0610040759k196b6e3ai8376481451f50666@mail.gmail.com>

Hi,

On 10/4/06, Hill, Robert <rhill03 at eds.com> wrote:
> Does this work in 3.0b4?
> Im trying to create a base class using the grammar option {
> superClass=baseGrammar; }
> But for the derived grammar file its generating 'null.java' which contains
> about 20 lines of code :(

Last I heart it's not supported. And may even be replaced by something
different. The superclass thing is only to use a different java class
as the superclass for the generated parser.

Is it maybe an idea to use some literate programming tool for you
problem? There should be something in the archives about noweb and
antlr2. Think the cgrammar used it:

http://www.antlr.org/grammar/cgram/

It should let you maintain one 'base' grammar with plugholes for
different actions.

If you only do read only access on your tree you might even get
somewhere by having one main treewalker and call from that one other
tree walkers for nodes/subtrees you find interesting. (at least that
worked with antlr2) Depending on your grammar/needs the subtreewalkers
only need to be subsets of the big one.

Cheers,

Ric

From koen.vanderkimpen+antlr at cs.kuleuven.be  Wed Oct  4 09:06:06 2006
From: koen.vanderkimpen+antlr at cs.kuleuven.be (Koen Vanderkimpen)
Date: Wed, 4 Oct 2006 18:06:06 +0200
Subject: [antlr-interest] parsing java 1.5
Message-ID: <006801c6e7ce$ffd5d1c0$b3273a86@codewalker>

Hello,

I'm having trouble parsing a Java-file with antlr.

I'm using the Java 1.5 grammar by Terence Parr found on http://www.antlr.org/grammar/1152141644268/java.g
I compiled this grammar using antlr 3.0b4 and tried reading in some files in the same way it is done in the antlr v3 sample grammars (java subdirectory).

About 100 files parsed without error, the only exception was a class in which the method below exists.
The error occurs on lines 164 and 166 of the method, and I believe it might have something to do with the generic classcasts.
I looked at the grammar but it seemed ok to me. I included the output by the parser.

Does anyone know what's wrong and how to solve this?



public final <T extends Element> List<T> getDescendants(Class<T> c) {    //this is line 163
        List<Element> tmp = (List<Element>)getChildren();
        new TypePredicate<Element, T>(c).filter(tmp);
        List<T> result = (List<T>)tmp;
        for (Element e : getChildren()) {
            result.addAll(e.getDescendants(c));
        }
        return result;
}


[compilationUnit, typeDeclaration, classOrInterfaceDeclaration, classDeclaration, normalClassDeclaration, classBody, classBodyDeclaration, memberDecl, genericMethodOrConstructorDecl, genericMethodOrConstructorRest, methodDeclaratorRest, methodBody, block, blockStatement, statement]: line 164:23 mismatched token: [@555,3760:3760='=',<44>,164:23]; expecting type ';'
[compilationUnit, typeDeclaration, classOrInterfaceDeclaration, classDeclaration, normalClassDeclaration, classBody, classBodyDeclaration, memberDecl, genericMethodOrConstructorDecl, genericMethodOrConstructorRest, methodDeclaratorRest, methodBody, block, blockStatement, statement, statementExpression, expression, conditionalExpression, conditionalOrExpression, conditionalAndExpression, inclusiveOrExpression, exclusiveOrExpression, andExpression, equalityExpression, instanceOfExpression, relationalExpression, shiftExpression, additiveExpression, multiplicativeExpression, unaryExpression, unaryExpressionNotPlusMinus, primary, parExpression]: line 164:38 mismatched token: [@560,3775:3775='>',<35>,164:38]; expecting type ')'
[compilationUnit, typeDeclaration, classOrInterfaceDeclaration, classDeclaration, normalClassDeclaration, classBody, classBodyDeclaration, memberDecl, genericMethodOrConstructorDecl, genericMethodOrConstructorRest, methodDeclaratorRest, methodBody, block, blockStatement, statement]: line 166:21 mismatched token: [@587,3864:3864='=',<44>,166:21]; expecting type ';'
[compilationUnit, typeDeclaration, classOrInterfaceDeclaration, classDeclaration, normalClassDeclaration, classBody, classBodyDeclaration, memberDecl, genericMethodOrConstructorDecl, genericMethodOrConstructorRest, methodDeclaratorRest, methodBody, block, blockStatement, statement, statementExpression, expression, conditionalExpression, conditionalOrExpression, conditionalAndExpression, inclusiveOrExpression, exclusiveOrExpression, andExpression, equalityExpression, instanceOfExpression, relationalExpression, shiftExpression, additiveExpression, multiplicativeExpression, unaryExpression, unaryExpressionNotPlusMinus, primary, parExpression]: line 166:30 mismatched token: [@592,3873:3873='>',<35>,166:30]; expecting type ')'
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061004/e98fe905/attachment.html 

From parrt at cs.usfca.edu  Wed Oct  4 10:11:00 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 4 Oct 2006 10:11:00 -0700
Subject: [antlr-interest] Grammar inheritance?
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4026DFCB7@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFCB7@UKNSM201.emea.corp.eds.com>
Message-ID: <6FDD8387-64A7-40C2-8BB1-77351FE7567B@cs.usfca.edu>


On Oct 4, 2006, at 7:17 AM, Hill, Robert wrote:

> Does this work in 3.0b4?
> Im trying to create a base class using the grammar option  
> { superClass=baseGrammar; }

That is for specifying the Java class to drive from not the grammar.
> But for the derived grammar file its generating 'null.java' which  
> contains about 20 lines of code :(
>
> If it is working how do I create a subclass of a base grammer?

Currently there is no way.  A way to do so will appear in a future,  
just after the first real release.  There are a number of important  
players that want this and I have some good ideas about how to make  
it better than the mechanism in ANTLR 2. for example, I expect that  
the generated code for sub grammars will inherit not include rules  
from the super grammar.  This will significantly reduce code float  
found in the current version.  I would like to spend some time  
thinking about the  correct model before we jump.

Ter


From parrt at cs.usfca.edu  Wed Oct  4 10:12:32 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 4 Oct 2006 10:12:32 -0700
Subject: [antlr-interest] parsing java 1.5
In-Reply-To: <006801c6e7ce$ffd5d1c0$b3273a86@codewalker>
References: <006801c6e7ce$ffd5d1c0$b3273a86@codewalker>
Message-ID: <1A09F04C-E9FF-4793-B06D-D2F12E5D552B@cs.usfca.edu>


On Oct 4, 2006, at 9:06 AM, Koen Vanderkimpen wrote:

> Hello,
>
> I'm having trouble parsing a Java-file with antlr.
>
> I'm using the Java 1.5 grammar by Terence Parr found on http:// 
> www.antlr.org/grammar/1152141644268/java.g
> I compiled this grammar using antlr 3.0b4 and tried reading in some  
> files in the same way it is done in the antlr v3 sample grammars  
> (java subdirectory).
>
> About 100 files parsed without error, the only exception was a  
> class in which the method below exists.
> The error occurs on lines 164 and 166 of the method, and I believe  
> it might have something to do with the generic classcasts.
> I looked at the grammar but it seemed ok to me. I included the  
> output by the parser.
>
> Does anyone know what's wrong and how to solve this?
>
>
>
> public final <T extends Element> List<T> getDescendants(Class<T> c)  
> {    //this is line 163
>         List<Element> tmp = (List<Element>)getChildren();

Somehow this line is not recognized by the current grammar.  I did  
not test the template part of this grammar very much at all.  You  
will have to figure out why that is not parsed properly.  You can do  
this using ANTLRWorks most effectively.

Ter

From parrt at cs.usfca.edu  Wed Oct  4 10:13:09 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 4 Oct 2006 10:13:09 -0700
Subject: [antlr-interest] How to do a specific operation once on every
	token in the _parser_?
In-Reply-To: <4523C2AE.7000808@tzi.de>
References: <4523C2AE.7000808@tzi.de>
Message-ID: <BE78D3E1-7645-458B-A25A-01152A0CC94B@cs.usfca.edu>


On Oct 4, 2006, at 7:18 AM, Jan Harder wrote:

> Hello,
>
> I wrote a parser for visual basic using ANTLR 2.7.6 and I want to  
> compute the halstead metric for parts of the code. Basically, this  
> means that I need to classify all tokens in two groups  
> (identifiers, literals vs. everything else) and count the  
> occurrences of tokens with the same text. The classification and  
> the counting is very easy to do, but my problem is that I am not  
> sure _where_ to do this.

How about just subclassing the common token stream and adding your  
counting in there?
Ter


From parrt at cs.usfca.edu  Wed Oct  4 10:21:49 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 4 Oct 2006 10:21:49 -0700
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4026DFA75@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFA75@UKNSM201.emea.corp.eds.com>
Message-ID: <2D5A98DE-B24E-40D4-B251-1F535999C7B8@cs.usfca.edu>


On Oct 3, 2006, at 6:42 AM, Hill, Robert wrote:

> I want to make multiple passes over a tree but only utilise parts  
> of the tree for each pass so I've duplicated the tree grammar 3  
> times , adding actions only for the parts that matter at each pass.
  I have already added a wiki entry about this on the to do list:

http://www.antlr.org/wiki/display/ANTLR3/allow+skipping+of+entire 
+subtrees+during+tree+parsing

> So the question is , how do you ignore (remove) whole branches of a  
> tree? At the moment if I add a node into the parser output I have  
> to change all 3 tree walkers in response. If I know that the tokens  
> that pass 1 will no longer be affected, how can I remove all the  
> unwanted rules from that grammar so It only looks at the tokens it  
> needs?
I think what we really need is a filter mode for trees just like we  
have for lexer's.  This would be almost a declarative approach where  
you say what trees you want to match and what actions to execute when  
you see it.  For example,

tree grammar TP;

options {filter=true;}

IDENTITY
	:	^(MULT i:INT j:INT) {$i.text.equals("1")||$j.text.equals("1")}?
		-> i
	;

pretty sweet.   of course I need tree grammars to be able to generate  
trees before I can do this.

The idea will be that it tries all patterns looking for a match in  
the order specified.  An index can be used to speedthings up by only  
attempting rules on nodes in the tree that can possibly match.  For  
example if there is only one MULT node in the entire tree, don't walk  
the entire tree looking for that pattern.

added this is a wiki entry:

http://www.antlr.org/wiki/display/ANTLR3/filter+tree+grammar+mode

Ter

From parrt at cs.usfca.edu  Wed Oct  4 10:28:29 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 4 Oct 2006 10:28:29 -0700
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
Message-ID: <C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>


On Oct 3, 2006, at 11:23 PM, Hill, Robert wrote:

> I've pretty much gone down the multiple tree parser routes, its a  
> real pain in the ass though, as if you modify your parser, you then  
> have to modify all the tree parser grammars too. I must be missing  
> something here. :(

you are not missing anything in that it is a real problem.  But you  
are missing the tool that will make this easier.  I will be making a   
grammar diff tool that will be able to push changes forward from a  
prototypical grammar to all tree phases that derive from it.  This  
will be more of a revision control model rather than an inheritance  
model.  This tool does not exist yet.

> there must be a rule that ignores a whole branch, but i've tried  
> all sorts and haven't succeeded ,
>
> ignoreme : ^(.*) ... if only :)
>
> which is why i ended up with 3 tree parse phases. I just get this  
> nagging feeling im missing the point.

No,  Just implementation is missing this.  See my previous e-mail

> i think everyone's gone on holiday, the list is usually way busier  
> than this.
>
Nah, you are just asking really hard questions. ;)

Here is my new philosophy about translation:

Language L to L':  build a single tree structure and have multiple  
tree phases that use the same grammar but different actions.  Or, as  
we are discussing, you could have something that would skip certain  
pieces that you don't care about.  All of the phases up until last  
one will simply collect information, possibly annotating the tree  
nodes as well.  The last phase walks the tree grammar generating  
string templates that get put together and yield eventually one big  
string.  This is the approach I'm taking for Mantra.

Language L to L: if you are staying within the same language, then  
you will probably have the same AST structure.  In this case, you are  
free to manipulate the tree because the resulting tree structure will  
be identical to the existing structure.  What you want to avoid is  
having n phases each one with a different grammar.  A good example of  
a translation problem that keeps the same tree grammar but allows  
tree transformation is symbolic differentiation of polynomials.   
Every time you do a differentiation, you yield another valid  
polynomial and so your grammar will not have to change.

Ter


From rob.hill at blueyonder.co.uk  Wed Oct  4 11:38:45 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Wed, 4 Oct 2006 19:38:45 +0100
Subject: [antlr-interest] Grammar inheritance?
In-Reply-To: <6FDD8387-64A7-40C2-8BB1-77351FE7567B@cs.usfca.edu>
Message-ID: <20061004183849.C876D1907A2@www.antlr.org>



> -----Original Message-----
> From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-
> bounces at antlr.org] On Behalf Of Terence Parr
> Sent: 04 October 2006 18:11
> To: ANTLR Interest
> Subject: Re: [antlr-interest] Grammar inheritance?
> 
> 
> On Oct 4, 2006, at 7:17 AM, Hill, Robert wrote:
> 
> > Does this work in 3.0b4?
> > Im trying to create a base class using the grammar option
> > { superClass=baseGrammar; }
> 
> That is for specifying the Java class to drive from not the grammar.

Ahh, it all becomes clear ;)

> > But for the derived grammar file its generating 'null.java' which
> > contains about 20 lines of code :(
> >
> > If it is working how do I create a subclass of a base grammer?
> 
> Currently there is no way.  A way to do so will appear in a future,
> just after the first real release.  There are a number of important
> players that want this and I have some good ideas about how to make
> it better than the mechanism in ANTLR 2. for example, I expect that
> the generated code for sub grammars will inherit not include rules
> from the super grammar.  This will significantly reduce code float
> found in the current version.  I would like to spend some time
> thinking about the  correct model before we jump.
> 
> Ter

Ok, no problem. I was going to have a go at generating a base grammer, then
a derived class with fewer rules and manually editing the class decl. yeah
yeah, I know it's a no no editing the generated code..LOL I just want to see
if it would work :)


Cheers Ter.

Rob





From rob.hill at blueyonder.co.uk  Wed Oct  4 11:46:49 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Wed, 4 Oct 2006 19:46:49 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <2D5A98DE-B24E-40D4-B251-1F535999C7B8@cs.usfca.edu>
Message-ID: <20061004184723.CCFF91907FB@www.antlr.org>

> > I want to make multiple passes over a tree but only utilise parts
> > of the tree for each pass so I've duplicated the tree grammar 3
> > times , adding actions only for the parts that matter at each pass.
>   I have already added a wiki entry about this on the to do list:
> 
> http://www.antlr.org/wiki/display/ANTLR3/allow+skipping+of+entire
> +subtrees+during+tree+parsing

That's what I was trying with the  ^(TOKEN .*) -  I tried loads of
combinations, looking at the source to see if I was getting close, but it
was having none of it hehehe.. oh well!

> > So the question is , how do you ignore (remove) whole branches of a
> > tree? At the moment if I add a node into the parser output I have
> > to change all 3 tree walkers in response. If I know that the tokens
> > that pass 1 will no longer be affected, how can I remove all the
> > unwanted rules from that grammar so It only looks at the tokens it
> > needs?
> I think what we really need is a filter mode for trees just like we
> have for lexer's.  This would be almost a declarative approach where
> you say what trees you want to match and what actions to execute when
> you see it.  For example,
> 
> tree grammar TP;
> 
> options {filter=true;}
> 
> IDENTITY
> 	:	^(MULT i:INT j:INT)
> {$i.text.equals("1")||$j.text.equals("1")}?
> 		-> i
> 	;
> 
> pretty sweet.   of course I need tree grammars to be able to generate
> trees before I can do this.

Yup, that would be pretty sweet, at least you wouldn't have to include whole
trees of un-actioned tokens. I like that, for me that would pretty much
solve the whole single tree multiple pass problem.

So then.. When will it be ready? stop that slacking mate & jump to it ;) LOL

> The idea will be that it tries all patterns looking for a match in
> the order specified.  An index can be used to speedthings up by only
> attempting rules on nodes in the tree that can possibly match.  For
> example if there is only one MULT node in the entire tree, don't walk
> the entire tree looking for that pattern.
> 
> added this is a wiki entry:
> 
> http://www.antlr.org/wiki/display/ANTLR3/filter+tree+grammar+mode
> 
> Ter

It would definitely be a useful tool to have, you shouldn't have made the
beta so good, then I wouldn't think it was 100% complete with everything I
want LOL
;)

Cheers,
Rob




From antlr at jazillian.com  Wed Oct  4 13:28:36 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 04 Oct 2006 16:28:36 -0400
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4026DFBD3@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFBD3@UKNSM201.emea.corp.eds.com>
Message-ID: <45241974.8020903@jazillian.com>

Hill, Robert wrote:

>Yay - a Reply! I was thinking my mails weren't getting through for a
>minute there ;)
>
>Hmm, I considered this originally, but I think I only need 3 passes, so
>while it's a big hassle, using grammars has take out a huge wodge of
>time in getting it up and running , whereas I feel that walking the
>tree's manually would probably have taken a fair bit longer. 
>
Things can't get any simpler than walking the tree by hand:

void walk(AST ast) {
  // do stuff
  AST child = ast.getFirstChild();
  while (child != null) {
     walk(child);
     child = child.getNextSibling();
  }
}

I'm using an old version of ANTLR. By now, it's probably:
void walk(AST ast) {
// do stuff
for (AST child: ast.getChildren()) {
   walk(child);
}
}
 


From parrt at cs.usfca.edu  Wed Oct  4 13:49:14 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 4 Oct 2006 13:49:14 -0700
Subject: [antlr-interest] Grammar inheritance?
In-Reply-To: <20061004183849.C876D1907A2@www.antlr.org>
References: <20061004183849.C876D1907A2@www.antlr.org>
Message-ID: <7D4EFB6C-8D94-4BCE-AEFA-0282AAA0C5AB@cs.usfca.edu>


On Oct 4, 2006, at 11:38 AM, Robert Hill wrote:
> Ok, no problem. I was going to have a go at generating a base  
> grammer, then
> a derived class with fewer rules and manually editing the class  
> decl. yeah
> yeah, I know it's a no no editing the generated code..LOL I just  
> want to see
> if it would work :)

only trick is that you have to watch out for rules in supergrammar  
that are affected by changes to rules in subgrammar. ;)
Ter

From rhill03 at eds.com  Wed Oct  4 23:26:50 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Thu, 5 Oct 2006 07:26:50 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFD8C@UKNSM201.emea.corp.eds.com>

>-----Original Message-----
>From: antlr-interest-bounces at antlr.org 
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Terence Parr
>Sent: 04 October 2006 18:28
>To: ANTLR Interest
>Subject: Re: [antlr-interest] Multiple pass tree walking Q

[snip]

>
>> i think everyone's gone on holiday, the list is usually way busier 
>> than this.
>>
>Nah, you are just asking really hard questions. ;)

Lol, I see that now hahah!, ok, I'll go back to n00b mode shortly ;)


Cheers,
Rob

From rhill03 at eds.com  Wed Oct  4 23:33:57 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Thu, 5 Oct 2006 07:33:57 +0100
Subject: [antlr-interest] Multiple pass tree walking Q
In-Reply-To: <45241974.8020903@jazillian.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD4026DFD8E@UKNSM201.emea.corp.eds.com>

Lol, walked into that one ;)
Its not the tree walk per se, as you've demonstrated... Its putting it
all together with the action code, swathes of token comparisons, and
then mountains of getInstance() and setAttributes() for the output
templates. Its sooooo much easier (and cleaner to look at) to use the
tree parser generator, I think. Maybe im just being uber lazy ;)

Cheers
Rob



--
Rob Hill
EDS - Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 791 732 1227
E:	rhill03 at eds.com

 

>-----Original Message-----
>From: antlr-interest-bounces at antlr.org 
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Andy Tripp
>Sent: 04 October 2006 21:29
>Cc: ANTLR Interest
>Subject: Re: [antlr-interest] Multiple pass tree walking Q
>
>Hill, Robert wrote:
>
>>Yay - a Reply! I was thinking my mails weren't getting through for a 
>>minute there ;)
>>
>>Hmm, I considered this originally, but I think I only need 3 
>passes, so 
>>while it's a big hassle, using grammars has take out a huge wodge of 
>>time in getting it up and running , whereas I feel that walking the 
>>tree's manually would probably have taken a fair bit longer.
>>
>Things can't get any simpler than walking the tree by hand:
>
>void walk(AST ast) {
>  // do stuff
>  AST child = ast.getFirstChild();
>  while (child != null) {
>     walk(child);
>     child = child.getNextSibling();
>  }
>}
>
>I'm using an old version of ANTLR. By now, it's probably:
>void walk(AST ast) {
>// do stuff
>for (AST child: ast.getChildren()) {
>   walk(child);
>}
>}
> 
>
>

From antlr at jazillian.com  Thu Oct  5 06:58:39 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 05 Oct 2006 09:58:39 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
Message-ID: <45250F8F.8040001@jazillian.com>


>
> Here is my new philosophy about translation:
>
> Language L to L':  build a single tree structure and have multiple  
> tree phases that use the same grammar but different actions.  Or, as  
> we are discussing, you could have something that would skip certain  
> pieces that you don't care about.  All of the phases up until last  
> one will simply collect information, possibly annotating the tree  
> nodes as well.  The last phase walks the tree grammar generating  
> string templates that get put together and yield eventually one big  
> string.  This is the approach I'm taking for Mantra.

>
> Ter

The problem with this approach is that it will be *very* difficult to
work with only one tree structure. Say you're doing COBOL to
Java (as I am). Sounds like you're saying that all your phases work on a
"COBOL AST", and the last step takes
the annotated "COBOL AST" and produces a "Java AST" (or just "Java
text"). The problem is that a "COBOL AST" looks almost nothing
like a "Java AST", and in the later phases, it will be nearly impossible
to do Java-like processing. For example, my last
phase adds needed "import" statements by looking through the Java code
to see what's needed. To find out what
Java library classes are referenced, you really do need a copy of the
actual Java code to analyze, not
an annotated "COBOL AST". Or how about adding try/catch blocks as
needed. Here, you need to not only look
for references to methods that throw non-Runtime exceptions, but need to
see whether exceptions are already being
caught.

This "single tree structure" approach might work if, at the start of the
last phase,
you essentially have the entire Java program existing in bits and pieces
as annotations on your COBOL tree. But I don't see how you could do
that, because the tree structures are quite
different. For example, In COBOL, you typically have a "variable
representing a file" declared in one place, its mapping to
a filename in another place, an "open" call in a third place. Those
three should map to a single
"FileReader reader = new FileReader("myfile");" Java statement.

You might think "well, I can use multiple AST structures through
inheritence or heterogeneous trees", but that
just seems messy to me. I prefer an approach where you have, say, 100
phases. Each phase translates a small piece
(e.g. a single phase might handle the file-example above). So the code
gradually transforms from COBOL to Java,
one small step at a time.

Andy




From harder at tzi.de  Thu Oct  5 09:18:24 2006
From: harder at tzi.de (Jan Harder)
Date: Thu, 05 Oct 2006 18:18:24 +0200
Subject: [antlr-interest] How to do a specific operation once on every
 token in the _parser_?
In-Reply-To: <BE78D3E1-7645-458B-A25A-01152A0CC94B@cs.usfca.edu>
References: <4523C2AE.7000808@tzi.de>
	<BE78D3E1-7645-458B-A25A-01152A0CC94B@cs.usfca.edu>
Message-ID: <45253050.70406@tzi.de>

Terence Parr schrieb:
>
> On Oct 4, 2006, at 7:18 AM, Jan Harder wrote:
>
>> Hello,
>>
>> I wrote a parser for visual basic using ANTLR 2.7.6 and I want to 
>> compute the halstead metric for parts of the code. Basically, this 
>> means that I need to classify all tokens in two groups (identifiers, 
>> literals vs. everything else) and count the occurrences of tokens 
>> with the same text. The classification and the counting is very easy 
>> to do, but my problem is that I am not sure _where_ to do this.
>
> How about just subclassing the common token stream and adding your 
> counting in there?
> Ter
Hello Terence,

I already discarded the idea of using the token stream because 
identifiers are problematic in visual basic 6. Not all keywords are also 
reserved words - it depends on the context what they are. So I need the 
parser to distinguish identifiers from keywords. But you made me 
reconsider the token stream idea and I think I found a way to solve this 
problem using both a TokenStream and the parser - not nice but it should 
work.

I'm going implement a TokenStream that simply counts every token as an 
operator (and keeps maps for operators and operands with their occurence 
count as its data). When the parser recognizes a token as an identifier, 
it will notify the TokenStream about that, so that the token stream can 
decrement the operator count for that symbol and increment it as an operand.

Regards, and thank you,
Jan Harder

From monty at codetransform.com  Thu Oct  5 12:25:38 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Thu, 5 Oct 2006 12:25:38 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
Message-ID: <598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>

On 10/5/06, Andy Tripp <antlr at jazillian.com> wrote:

> The problem with this approach is that it will be *very* difficult to
> work with only one tree structure. Say you're doing COBOL to
> Java (as I am). Sounds like you're saying that all your phases work on a
> "COBOL AST", and the last step takes
> the annotated "COBOL AST" and produces a "Java AST" (or just "Java
> text"). The problem is that a "COBOL AST" looks almost nothing
> like a "Java AST", and in the later phases, it will be nearly impossible
> to do Java-like processing. For example, my last
> phase adds needed "import" statements by looking through the Java code
> to see what's needed. To find out what
> Java library classes are referenced, you really do need a copy of the
> actual Java code to analyze, not
> an annotated "COBOL AST". Or how about adding try/catch blocks as
> needed. Here, you need to not only look
> for references to methods that throw non-Runtime exceptions, but need to
> see whether exceptions are already being
> caught.
>
> This "single tree structure" approach might work if, at the start of the
> last phase,
> you essentially have the entire Java program existing in bits and pieces
> as annotations on your COBOL tree. But I don't see how you could do
> that, because the tree structures are quite
> different. For example, In COBOL, you typically have a "variable
> representing a file" declared in one place, its mapping to
> a filename in another place, an "open" call in a third place. Those
> three should map to a single
> "FileReader reader = new FileReader("myfile");" Java statement.
>
> You might think "well, I can use multiple AST structures through
> inheritence or heterogeneous trees", but that
> just seems messy to me. I prefer an approach where you have, say, 100
> phases. Each phase translates a small piece
> (e.g. a single phase might handle the file-example above). So the code
> gradually transforms from COBOL to Java,
> one small step at a time.
>

In fact it is quite easy to have multiple languages in the same tree.
I did this for the AREV->VB translator.  The key is to have AREV_PLUS
and VB_PLUS for the '+' tree nodes.  Then you don't have to guess if
you are processing arev addition or vb addition.

I had one super-treegrammar with two complete tree grammars therin.  I
found it convenient to bifurcate at the statement level.  For example:

program: (statement)*;
statement:arevStatement | vbStatement;
...
That both types of statements could co-exist in the same tree, and
even have different types of sub-statements.  Similarly for
expressions--an expression could use either language's operators, and
I could have passes that just dealt with arithmetic or string handling
or whatever, so that in one pass expressions are all arev the next
would have vb arithmetic and arev everything else, etc.

I was raving about this like 7 years ago, it just totally rocks!
Check the archives for my posts about multiple tree grammars, or ask
questions if something isn't clear.

By the last pass, I had a completely vb tree, and then I finally
dumped it to text.

Monty

From rob.hill at blueyonder.co.uk  Thu Oct  5 13:15:50 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Thu, 5 Oct 2006 21:15:50 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45250F8F.8040001@jazillian.com>
Message-ID: <20061005201555.49DBE190744@www.antlr.org>

Oops....

^(WORMS CAN+) -> {%{"Open"}}


Sorry!

lol


/2ob

> -----Original Message-----
> From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-
> bounces at antlr.org] On Behalf Of Andy Tripp
> Sent: 05 October 2006 14:59
> Cc: ANTLR Interest
> Subject: [antlr-interest] philosophy about translation
> 
> 
> >
> > Here is my new philosophy about translation:
> >
> > Language L to L':  build a single tree structure and have multiple
> > tree phases that use the same grammar but different actions.  Or, as
> > we are discussing, you could have something that would skip certain
> > pieces that you don't care about.  All of the phases up until last
> > one will simply collect information, possibly annotating the tree
> > nodes as well.  The last phase walks the tree grammar generating
> > string templates that get put together and yield eventually one big
> > string.  This is the approach I'm taking for Mantra.
> 
> >
> > Ter
> 
> The problem with this approach is that it will be *very* difficult to
> work with only one tree structure. Say you're doing COBOL to
> Java (as I am). Sounds like you're saying that all your phases work on a
> "COBOL AST", and the last step takes
> the annotated "COBOL AST" and produces a "Java AST" (or just "Java
> text"). The problem is that a "COBOL AST" looks almost nothing
> like a "Java AST", and in the later phases, it will be nearly impossible
> to do Java-like processing. For example, my last
> phase adds needed "import" statements by looking through the Java code
> to see what's needed. To find out what
> Java library classes are referenced, you really do need a copy of the
> actual Java code to analyze, not
> an annotated "COBOL AST". Or how about adding try/catch blocks as
> needed. Here, you need to not only look
> for references to methods that throw non-Runtime exceptions, but need to
> see whether exceptions are already being
> caught.
> 
> This "single tree structure" approach might work if, at the start of the
> last phase,
> you essentially have the entire Java program existing in bits and pieces
> as annotations on your COBOL tree. But I don't see how you could do
> that, because the tree structures are quite
> different. For example, In COBOL, you typically have a "variable
> representing a file" declared in one place, its mapping to
> a filename in another place, an "open" call in a third place. Those
> three should map to a single
> "FileReader reader = new FileReader("myfile");" Java statement.
> 
> You might think "well, I can use multiple AST structures through
> inheritence or heterogeneous trees", but that
> just seems messy to me. I prefer an approach where you have, say, 100
> phases. Each phase translates a small piece
> (e.g. a single phase might handle the file-example above). So the code
> gradually transforms from COBOL to Java,
> one small step at a time.
> 
> Andy
> 
> 




From na.zhangzhei at gmail.com  Thu Oct  5 13:17:40 2006
From: na.zhangzhei at gmail.com (na zhang)
Date: Thu, 5 Oct 2006 16:17:40 -0400
Subject: [antlr-interest] Build CFG from ASTs
Message-ID: <124f59f40610051317q6d8e2f76gdcc32d3835ba2c68@mail.gmail.com>

Dear Group,
TinyDT builds upon a pure java nesC parser implemented using antlr. The
output is AST. I wonder if anyone has built the
source level Control Flow Graph (CFG) from those ASTs. I am new here and I
would appreciate a lot if any help is provided.

Regards,
Na
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061005/c3036782/attachment.html 

From antlr at jazillian.com  Thu Oct  5 13:29:24 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 05 Oct 2006 16:29:24 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	<45250F8F.8040001@jazillian.com>	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
Message-ID: <45256B24.40908@jazillian.com>


>
> In fact it is quite easy to have multiple languages in the same tree.
> I did this for the AREV->VB translator.  The key is to have AREV_PLUS
> and VB_PLUS for the '+' tree nodes.  Then you don't have to guess if
> you are processing arev addition or vb addition.
>
> I had one super-treegrammar with two complete tree grammars therin.  I
> found it convenient to bifurcate at the statement level.  For example:
>
> program: (statement)*;
> statement:arevStatement | vbStatement;
> ... 


In COBOL we have statements like:
ADD A TO B    // B += A;
ADD A B TO C D   // C+= A + B;  D+= A + B;
ADD A TO B GIVING C    // C = A + B;

If you bifurcate at the statement level, then you have lots of logic that
says "Here is the COBOL ADD statement, and now I'll generate the 
equivalent Java
statement, and either replace the COBOL AST with the Java one, or just
somehow just attach the Java AST to the COBOL AST."

That's fine, but it just means that (almost) all your logic is there, in 
that processing.
The fact that it's stored in an AST at all is of little help to 
you...you're not doing
many AST manipulations. So the AST just becomes a convenient data structure
for storing the state between phases, as opposed to a convenient data 
structure
for actually performing language translation on.

And I don't think the AST is helping you at all (at least for COBOL to Java)
with that design, because COBOL and Java are at least a little similar at
and below the statement level (as the example above shows, I can typically
map a single COBOL statement to single Java statement). But
above that level, the COBOL AST looks almost nothing like the Java one.
Compare this COBOL grammar to a Java one:
http://www.cs.vu.nl/grammars/vs-cobol-ii

>
> That both types of statements could co-exist in the same tree, and
> even have different types of sub-statements.  Similarly for
> expressions--an expression could use either language's operators, and
> I could have passes that just dealt with arithmetic or string handling
> or whatever, so that in one pass expressions are all arev the next
> would have vb arithmetic and arev everything else, etc.

I did the same for C/C++ and Java: expressions are virtually identical 
in the
two languages. But check out expressions in COBOL:
http://www.cs.vu.nl/grammars/vs-cobol-ii/#gdef:arithmetic-expression

>
> I was raving about this like 7 years ago, it just totally rocks!
> Check the archives for my posts about multiple tree grammars, or ask
> questions if something isn't clear.
>
> By the last pass, I had a completely vb tree, and then I finally
> dumped it to text.

I had looked very carefully at all your stuff when I started 4 years ago.
My feeling is that if you're going to do a "natural" translation - that is:

String hello = "hello";
String world = "world";
printf("%s %s\n", hello, world);

...becomes...

System.out.println("Hello World");

then the "walking the AST" approach doesn't come close to working.
The two ASTs for those two code chunks
have almost nothing in common, and doing that translation
is 1% a "tree-manipulation" problem, and 99% a "code mapping" problem.

I think if tree-walking works for most of the translation work, you either
have two very similar languages, or your output code looks just like your
input code with different syntax. "I don't want 'JOBOL'", as one of my
customers said :)
Andy

>
> Monty
>


From antlr at jazillian.com  Thu Oct  5 13:33:54 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 05 Oct 2006 16:33:54 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061005201555.49DBE190744@www.antlr.org>
References: <20061005201555.49DBE190744@www.antlr.org>
Message-ID: <45256C32.8010303@jazillian.com>

Robert Hill wrote:

>Oops....
>
>^(WORMS CAN+) -> {%{"Open"}}
>
>
>Sorry!
>
>lol
>  
>
void visit(AST ast) {
  if (ast.getFirstChild().type == WORMS) {
    ast.setFirstChild(null);
    Open();
  }
}

More verbose? Yes.
More readable? Depends on the reader, I guess :)

From parrt at cs.usfca.edu  Thu Oct  5 15:20:21 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 5 Oct 2006 15:20:21 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45250F8F.8040001@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
Message-ID: <2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>


On Oct 5, 2006, at 6:58 AM, Andy Tripp wrote:
> The problem with this approach is that it will be *very* difficult to
> work with only one tree structure. Say you're doing COBOL to
> Java (as I am). Sounds like you're saying that all your phases work  
> on a
> "COBOL AST", and the last step takes
> the annotated "COBOL AST" and produces a "Java AST" (or just "Java
> text").

Java text via templates, though building a Java AST at the end would  
work too.  Mainly I'm trying to avoid "union grammars" that have to  
have both languages in there and have phase n slightly different than  
phase n+1 in tree structure.

> The problem is that a "COBOL AST" looks almost nothing
> like a "Java AST", and in the later phases, it will be nearly  
> impossible
> to do Java-like processing.

You can process the Java AST to find needed imports etc...

> For example, my last
> phase adds needed "import" statements by looking through the Java code
> to see what's needed. To find out what
> Java library classes are referenced, you really do need a copy of the
> actual Java code to analyze, not
> an annotated "COBOL AST".

You are correct.  A good reason to build Java ASTs not text at the  
end if you need to do this.

> This "single tree structure" approach might work if, at the start  
> of the
> last phase,
> you essentially have the entire Java program existing in bits and  
> pieces
> as annotations on your COBOL tree. But I don't see how you could do
> that, because the tree structures are quite
> different. For example, In COBOL, you typically have a "variable
> representing a file" declared in one place, its mapping to
> a filename in another place, an "open" call in a third place. Those
> three should map to a single
> "FileReader reader = new FileReader("myfile");" Java statement.

An interesting and difficult problem..thanks for bringing this up.   
I'd have to think more.  Clearly some kind of non-text data structure  
is needed for this.  I guess you'd build the Java template or AST and  
then add the bits as you find them while traversing the COBOL.

My main point is that it's ok to have multiple tree structures, L and  
L', but the union and/or slow morphing of one to the other is a total  
pain I've found.

> You might think "well, I can use multiple AST structures through
> inheritence or heterogeneous trees", but that
> just seems messy to me. I prefer an approach where you have, say, 100
> phases. Each phase translates a small piece
> (e.g. a single phase might handle the file-example above). So the code
> gradually transforms from COBOL to Java,
> one small step at a time.

Yep, I just prefer collecting the info and sticking somewhere that  
doesn't force me to have different tree structures.  A change in one  
phase has so many ripple-effect changes that can't be propagated  
manually.  If grammar is the same throughout then you can auto-ripple  
changes to structure.

What if we have COBOL AST to read from and Java AST to write to and  
update.  THen we walk Java AST at end to find try/catch and import  
needs?

Thanks for your excellent problem statement!

Ter


From gt54-antlr at cyconix.com  Fri Oct  6 02:04:24 2006
From: gt54-antlr at cyconix.com (Paul Johnson)
Date: Fri, 06 Oct 2006 10:04:24 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45250F8F.8040001@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
Message-ID: <45261C18.70509@cyconix.com>

I'm not knocking the single-tree approach; I'm sure it has its uses. 
However, my own opinion is that multiple in-situ tree transformations 
are extremely useful, if not indispensable. Some quick examples, off the 
top of my head, in addition to Andy's:

1 - constant reduction. You've got a subtree of, say, a dozen or more 
nodes which represent something like ((CONSTA << 16) & CONSTB) | (CONSTC 
 >> 2)). There's no point whatever keeping this in the tree and 
redundantly parsing and re-evaluating it on every AST pass. Why not just 
evaluate it once in a constant reduction pass, snip off the branch, and 
replace it with a single CONST node?

2 - if your language has compound assignments (ie. something like 'a += 
b') then it's pointless and confusing to keep this in the tree, and it 
complicates code generation. Why do not just replace the branch with 
another branch that unrolls the assignment? What if your language is 
even worse than this - 'x = a += b, a + c'? I expect you all know what 
language that is.

3 - Similarly, if your language has incr/decr operators, these are 
easily handled by modifying the AST to unroll them.

4 - What if your operators have side-effects, which you can't handle 
till the next sequence point? Doing this in a single static tree is very 
difficult. It's simple if you construct a new expression and insert it 
into the tree at some later point.

5 - what if your language has multiple ways to do the same thing? 
Indirection and array access, for example? It makes little sense to code 
this redundancy into the AST. You can instead have a pass which, for 
example, eliminates indirections and replaces them with array accesses.

And so on. Bottom line - the AST should represent the programmer's 
intent, which is never obvious from the bare syntax of whatever language 
they attempted to code that intent in. Sometimes, it can take you many 
passes to find out what that intent actually was. Why tie one arm behind 
your back by sticking with your first AST till the bitter end?

Paul

From antlr at jazillian.com  Fri Oct  6 06:59:16 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 06 Oct 2006 09:59:16 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	
	<45250F8F.8040001@jazillian.com>	
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>	
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>	
	<45256B24.40908@jazillian.com>
	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
Message-ID: <45266134.8080009@jazillian.com>

Monty Zukowski wrote:

>> In COBOL we have statements like:
>> ADD A TO B    // B += A;
>> ADD A B TO C D   // C+= A + B;  D+= A + B;
>> ADD A TO B GIVING C    // C = A + B;
>>
>> If you bifurcate at the statement level, then you have lots of logic 
>> that
>> says "Here is the COBOL ADD statement, and now I'll generate the
>> equivalent Java
>> statement, and either replace the COBOL AST with the Java one, or just
>> somehow just attach the Java AST to the COBOL AST."
>>
>> That's fine, but it just means that (almost) all your logic is there, in
>> that processing.
>> The fact that it's stored in an AST at all is of little help to
>> you...you're not doing
>> many AST manipulations. So the AST just becomes a convenient data 
>> structure
>> for storing the state between phases, as opposed to a convenient data
>> structure
>> for actually performing language translation on.
>
>
> I guess I don't understand your distinction here because I don't know
> what your alternative is.  I found it very handy to do something like
> that ADD transformation into the target language because I could still
> ignore things like sub-expressions which were still COBOL.  Step by
> step I changed each particular source expression to a target
> expression.

Here's my alternative:
I have hundreds of "transformation rules" where each rule can either be 
a simple mapping like this:
ADD v1 TO v2. --> v2 += v1;
ADD v1 v2 TO v3 v4. --> v3 += v1 + v2; v4 += v1 + v2
ADD v1 TO v2 GIVING v3.  --> v3 = v1 + v2;

...or actual Java code that operates on sequences of tokens, not trees.
I find it easier to think of the source and target languages as 
sequences of tokens
("ADD" followed by a variable followed by "TO"...) rather than trees (an 
"ADD" node
with the first child being a variable and the second child being "TO"...)

>
>> And I don't think the AST is helping you at all (at least for COBOL 
>> to Java)
>> with that design, because COBOL and Java are at least a little 
>> similar at
>> and below the statement level (as the example above shows, I can 
>> typically
>> map a single COBOL statement to single Java statement). But
>> above that level, the COBOL AST looks almost nothing like the Java one.
>> Compare this COBOL grammar to a Java one:
>> http://www.cs.vu.nl/grammars/vs-cobol-ii
>
>
> Oh, right.  You just don't like ASTs.  However, it is still possible
> to represent two completely different languages in one tree, and have
> intermediate phases with a mixture of the two different trees walked
> by the same grammar.


Well, yes, it's possible to represent English and Java in one tree, but
the real question is "is that the best data structure for the task?"

>
>> >
>> > That both types of statements could co-exist in the same tree, and
>> > even have different types of sub-statements.  Similarly for
>> > expressions--an expression could use either language's operators, and
>> > I could have passes that just dealt with arithmetic or string handling
>> > or whatever, so that in one pass expressions are all arev the next
>> > would have vb arithmetic and arev everything else, etc.
>>
>> I did the same for C/C++ and Java: expressions are virtually identical
>> in the
>> two languages. But check out expressions in COBOL:
>> http://www.cs.vu.nl/grammars/vs-cobol-ii/#gdef:arithmetic-expression
>>
>> >
>> > I was raving about this like 7 years ago, it just totally rocks!
>> > Check the archives for my posts about multiple tree grammars, or ask
>> > questions if something isn't clear.
>> >
>> > By the last pass, I had a completely vb tree, and then I finally
>> > dumped it to text.
>>
>> I had looked very carefully at all your stuff when I started 4 years 
>> ago.
>> My feeling is that if you're going to do a "natural" translation - 
>> that is:
>>
>> String hello = "hello";
>> String world = "world";
>> printf("%s %s\n", hello, world);
>>
>> ...becomes...
>>
>> System.out.println("Hello World");
>>
>> then the "walking the AST" approach doesn't come close to working.
>> The two ASTs for those two code chunks
>> have almost nothing in common, and doing that translation
>> is 1% a "tree-manipulation" problem, and 99% a "code mapping" problem.
>>
>
> Well, that problem becomes a "static analysis" problem and a "constant
> expression substitution that is aware of printf args" problem as well.


Right. So I guess my view is just that language translation, at least 
when producing
realistic output, is 99% "static analysis" and 1% "tree transformation".

>
>
>> I think if tree-walking works for most of the translation work, you 
>> either
>> have two very similar languages, or your output code looks just like 
>> your
>> input code with different syntax. "I don't want 'JOBOL'", as one of my
>> customers said :)
>
>
> AREV & VB actually had quite different syntax.  If you have a decent
> tree structure, the difference of syntax of the languages is
> irrelevant.  AREV had some wacky expressions, but once the program was
> parsed the trees for statements and expressions were easy to
> understand and manipulate.

Well, I preferred sequences of tokens over ASTs even for C to Java and 
C++ to Java,
so my views are pretty extreme. On the other hand, of all the language 
translators out there,
I don't see any that (to my eye) produce realistic, "natural" code, 
other than my Jazillian.
It's one thing to produce working Java (source or byte code) code from 
C. It's quite another
to produce code that looks hand-written. The logic to combine those 3 
"printf" statements
into a single, realistic Java one is far harder than just changing to 
Java syntax. Somewhere
in writing that code I came to realize "Hey, the AST is just getting in 
the way here".

>
> I'm not debating you on whether your way is better or not.  I just
> disagree with your statements about where tree walking doesn't work.

That's fair. I don't mean to say tree walking won't work here. Even the 
poster who had
just 8 phases is probably better off with a tree. If he gets to the 
point where he's got 20
phases, and only 5 of the phases are helped by the fact that ASTs are 
being used, then
he's entering my world :)

I guess what I'm doing is more akin to natural language translation. I'm 
sure an English to
Spanish translator has relatively little logic that does tree 
transformation (e.g. putting the
adjectives *after* the nouns).

>
> Monty
>


From antlr at jazillian.com  Fri Oct  6 07:29:23 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 06 Oct 2006 10:29:23 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	<45250F8F.8040001@jazillian.com>
	<2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>
Message-ID: <45266843.7050103@jazillian.com>


>
> An interesting and difficult problem..thanks for bringing this up.   
> I'd have to think more.  Clearly some kind of non-text data structure  
> is needed for this.  I guess you'd build the Java template or AST and  
> then add the bits as you find them while traversing the COBOL.

This is the key to the difference in the two approaches. Using an AST, I 
kept finding myself gathering bits of information from
around the AST. For example, say we're doing C to Java and I see "if 
(a)". We first look for the declaration of a to see whether
it's an int or not (it may not be because our "goto removal" phase 
already ran, and it injects booleans). Next, we look at
all references to "a", to see if it will be possible to change all of 
them from "int" usages to "boolean" usages. If not, just change it
to "if (a != 0)", but if so, go ahead and change the type to boolean, 
and make whatever changes are needed at each reference.

If you try to do that sort of thing in a tree-walking way, it will be a 
mess, I think.

>
> My main point is that it's ok to have multiple tree structures, L and  
> L', but the union and/or slow morphing of one to the other is a total  
> pain I've found.

Yes, it's a royal pain, but if you start with the requirement that you 
will produce "natural" code, there's no choice.

>
>> You might think "well, I can use multiple AST structures through
>> inheritence or heterogeneous trees", but that
>> just seems messy to me. I prefer an approach where you have, say, 100
>> phases. Each phase translates a small piece
>> (e.g. a single phase might handle the file-example above). So the code
>> gradually transforms from COBOL to Java,
>> one small step at a time.
>
>
> Yep, I just prefer collecting the info and sticking somewhere that  
> doesn't force me to have different tree structures.  A change in one  
> phase has so many ripple-effect changes that can't be propagated  
> manually.  If grammar is the same throughout then you can auto-ripple  
> changes to structure.

I think just this simple example that I brought up before actually 
brings the problem to the surface:

String hello = "hello";
String world = "world";
printf("%s %s\n", hello, world);

...becomes...

System.out.println("Hello World");

I can't see how that can be done by treewalking. By the time the code is 
actually written to implement "printf to System.out.println",
there will be almost no "tree-transformation" or even "tree walking" logic.

>
> What if we have COBOL AST to read from and Java AST to write to and  
> update.  THen we walk Java AST at end to find try/catch and import  
> needs?

Yea, now that I think harder about it, I guess try/catch and import 
aren't good examples. By the time you've got a Java AST,
everything's pretty easy.

But look at it this way: on the "import", all the work is in knowing all 
the built-in Java classes and
where they go (I created a doclet to gather that info), and combining 
"java.io.IOException" and "java.io.InputStream"
into "java.io.*", and leaving out "java.lang", and stuff like that. 
Whether the Java is in an AST or a sequence of Tokens
really doesn't matter one way or the other.

As for the try/catch, all the work is in finding a good "level" to 
insert the try/catch. For example, if we have three consecutive
read() calls, best to put them into a single try/catch. If we need to 
catch both FileNotFoundException and IOException
for one statement, and just IOException for the following statement, 
what do we do?

My point being that almost all the logic (in my translator, maybe not 
others')  is non-tree-related, where it doesn't matter
much whether it's in an AST or a sequence of tokens.

>
> Thanks for your excellent problem statement!
>
> Ter

Thanks for your patience - guess I'm a natural contrarian :)
"Better to be provocative than agreeable" is my new motto :)
Andy


From Jim.O'Connor at microfocus.com  Fri Oct  6 08:08:52 2006
From: Jim.O'Connor at microfocus.com (Jim O'Connor)
Date: Fri, 6 Oct 2006 11:08:52 -0400
Subject: [antlr-interest] philosophy about translation
Message-ID: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>

Hi All,
	Cool discussion.  How does the concept of a generic language or
AST fit?  The generic AST is the universe of all possible language
constructs.  
Andy has the transformations like

>>ADD v1 TO v2. --> v2 += v1;
>>ADD v1 v2 TO v3 v4. --> v3 += v1 + v2; v4 += v1 + v2
>>ADD v1 TO v2 GIVING v3.  --> v3 = v1 + v2;

This concentrates on transforming COBOL to Java.  (Ha, ha, "I don't want
JOBOL!")

The generic language would add another step:

COBOL -> generic language -> JAVA. In the general case, any specific
language -> generic language.  Generic language -> any specific
language.


ADD v1 to v2 -> 
(G_ASSIGNMENT (MOD_VAR v2) (OPER_ADD (REF_VAR v1) (REF_VAR v2)))

The "COBOL to generic process" focuses on the "make generic" process.  I
can't make JOBOL because I'm making generic.  The "generic to JAVA"
makes classes, main methods, file reads etc... from generic.  

What if a generic construct cannot be handled by a specific language?
This is tough question.  It is an easier question than "How do I
translate a Java class to COBOL?"

I'll stop there for now.

Generic language == textual object code??

Jim

Microfocus Revolve 


From antlr at jazillian.com  Fri Oct  6 08:49:43 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 06 Oct 2006 11:49:43 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
Message-ID: <45267B17.6060107@jazillian.com>

Jim O'Connor wrote:

>
>COBOL -> generic language -> JAVA. In the general case, any specific
>language -> generic language.  Generic language -> any specific
>language.
>
>  
>
I've thought a lot about this idea of having a generic intermediate 
representation. There are at least
a couple of products that say they do this. I can't see how to make it 
work. Say we have
a generic "add A to B" idea ("ADD A TO B" in COBOL, "B += A" in Java). 
If we're going to
produce "natural" Java code, we'll produce "A++" when B is 1. Or should 
it be "++A"???
No way to know, unless we also store that information, so we add some 
flag to our
generic representation. The guy working on the generic-to-Java part 
demands that the
guy working on the COBOL-to-generic part stores that information, even 
though it's
meaningless to the COBOL guy.

Then, the next day, the generic-to-Java guy realizes that A can be any 
arbitrary expression,
and that the expression must be evaluated first, before the assignment 
is made. He starts
going to make the generic representation more generic, and the COBOL 
sees him and says
"WTF are you doing? You can only add two numbers! I'm not going to deal 
with your
complicated data structure, I just want to store the fact that you're 
adding one number to another.

And then the next day, the problem goes the other way. The COBOL guy 
realizes that
the Java guy is going to need to know that B is 10 digits before the 
decimal, 5 after the decimal,
and a particular precision. The Java guy eventually realizes
that he can't even use "B += A", he's got to use BigDecimal. That 
doesn't bother him so much
as the term "digits".  "You're going to tell me how many 'digits' it 
is???" He screams.
"Don't you mean bytes?" No, he really does mean "digits". And you 
haven't seen nothin' yet,
Java guy. Wait till he tells you how to store those digits on disk in 
packed decimal format.

So in the end, the "generic representation" can't really be "generic". 
The Java guy just wants to know
whether a variable is a "int" or a "long", while the COBOL guy wants to 
say how many digits it is
before and after the decimal. OK, I suppose you could make it generic, 
you can store both,
or have the "generic representation" automatically
convert between the two. But things are going very badly and you just 
got started :)

andy


From johnicholas.hines at gmail.com  Fri Oct  6 10:36:05 2006
From: johnicholas.hines at gmail.com (Johnicholas Hines)
Date: Fri, 6 Oct 2006 13:36:05 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45267B17.6060107@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
	<45267B17.6060107@jazillian.com>
Message-ID: <d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>

Is the deep analysis that Andy Tripp's COBOL to Java project requires
a corner case of ANTLR usage? It seems to me he's building at least a
full dataflow graph, which I believe is more extreme than most
transformations.

My projects with antlr include things like "replicate bash's
brace-expansion in a standalone tool", and "convert pure lambda
calculus to continuation-passing style".

As far as I can tell, these tasks are not "99% static analysis and 1%
tree transformation". Admittedly, I have no working code, so perhaps
you should take my opinions with dash of salt.

Johnicholas

On 10/6/06, Andy Tripp <antlr at jazillian.com> wrote:
> Jim O'Connor wrote:
>
> >
> >COBOL -> generic language -> JAVA. In the general case, any specific
> >language -> generic language.  Generic language -> any specific
> >language.
> >
> >
> >
> I've thought a lot about this idea of having a generic intermediate
> representation. There are at least
> a couple of products that say they do this. I can't see how to make it
> work. Say we have
> a generic "add A to B" idea ("ADD A TO B" in COBOL, "B += A" in Java).
> If we're going to
> produce "natural" Java code, we'll produce "A++" when B is 1. Or should
> it be "++A"???
> No way to know, unless we also store that information, so we add some
> flag to our
> generic representation. The guy working on the generic-to-Java part
> demands that the
> guy working on the COBOL-to-generic part stores that information, even
> though it's
> meaningless to the COBOL guy.
>
> Then, the next day, the generic-to-Java guy realizes that A can be any
> arbitrary expression,
> and that the expression must be evaluated first, before the assignment
> is made. He starts
> going to make the generic representation more generic, and the COBOL
> sees him and says
> "WTF are you doing? You can only add two numbers! I'm not going to deal
> with your
> complicated data structure, I just want to store the fact that you're
> adding one number to another.
>
> And then the next day, the problem goes the other way. The COBOL guy
> realizes that
> the Java guy is going to need to know that B is 10 digits before the
> decimal, 5 after the decimal,
> and a particular precision. The Java guy eventually realizes
> that he can't even use "B += A", he's got to use BigDecimal. That
> doesn't bother him so much
> as the term "digits".  "You're going to tell me how many 'digits' it
> is???" He screams.
> "Don't you mean bytes?" No, he really does mean "digits". And you
> haven't seen nothin' yet,
> Java guy. Wait till he tells you how to store those digits on disk in
> packed decimal format.
>
> So in the end, the "generic representation" can't really be "generic".
> The Java guy just wants to know
> whether a variable is a "int" or a "long", while the COBOL guy wants to
> say how many digits it is
> before and after the decimal. OK, I suppose you could make it generic,
> you can store both,
> or have the "generic representation" automatically
> convert between the two. But things are going very badly and you just
> got started :)
>
> andy
>
>

From monty at codetransform.com  Fri Oct  6 10:36:10 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 10:36:10 -0700
Subject: [antlr-interest] Fwd:  philosophy about translation
In-Reply-To: <598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
	<45256B24.40908@jazillian.com>
	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
Message-ID: <598864c70610061036m38109917pbd118301cc3d9f5b@mail.gmail.com>

I forgot to properly copy antlr-interest on this, so for posterity
here is a message missing from this thread....


> In COBOL we have statements like:
> ADD A TO B    // B += A;
> ADD A B TO C D   // C+= A + B;  D+= A + B;
> ADD A TO B GIVING C    // C = A + B;
>
> If you bifurcate at the statement level, then you have lots of logic that
> says "Here is the COBOL ADD statement, and now I'll generate the
> equivalent Java
> statement, and either replace the COBOL AST with the Java one, or just
> somehow just attach the Java AST to the COBOL AST."
>
> That's fine, but it just means that (almost) all your logic is there, in
> that processing.
> The fact that it's stored in an AST at all is of little help to
> you...you're not doing
> many AST manipulations. So the AST just becomes a convenient data structure
> for storing the state between phases, as opposed to a convenient data
> structure
> for actually performing language translation on.

I guess I don't understand your distinction here because I don't know
what your alternative is.  I found it very handy to do something like
that ADD transformation into the target language because I could still
ignore things like sub-expressions which were still COBOL.  Step by
step I changed each particular source expression to a target
expression.

> And I don't think the AST is helping you at all (at least for COBOL to Java)
> with that design, because COBOL and Java are at least a little similar at
> and below the statement level (as the example above shows, I can typically
> map a single COBOL statement to single Java statement). But
> above that level, the COBOL AST looks almost nothing like the Java one.
> Compare this COBOL grammar to a Java one:
> http://www.cs.vu.nl/grammars/vs-cobol-ii

Oh, right.  You just don't like ASTs.  However, it is still possible
to represent two completely different languages in one tree, and have
intermediate phases with a mixture of the two different trees walked
by the same grammar.

> >
> > That both types of statements could co-exist in the same tree, and
> > even have different types of sub-statements.  Similarly for
> > expressions--an expression could use either language's operators, and
> > I could have passes that just dealt with arithmetic or string handling
> > or whatever, so that in one pass expressions are all arev the next
> > would have vb arithmetic and arev everything else, etc.
>
> I did the same for C/C++ and Java: expressions are virtually identical
> in the
> two languages. But check out expressions in COBOL:
> http://www.cs.vu.nl/grammars/vs-cobol-ii/#gdef:arithmetic-expression
>
> >
> > I was raving about this like 7 years ago, it just totally rocks!
> > Check the archives for my posts about multiple tree grammars, or ask
> > questions if something isn't clear.
> >
> > By the last pass, I had a completely vb tree, and then I finally
> > dumped it to text.
>
> I had looked very carefully at all your stuff when I started 4 years ago.
> My feeling is that if you're going to do a "natural" translation - that is:
>
> String hello = "hello";
> String world = "world";
> printf("%s %s\n", hello, world);
>
> ...becomes...
>
> System.out.println("Hello World");
>
> then the "walking the AST" approach doesn't come close to working.
> The two ASTs for those two code chunks
> have almost nothing in common, and doing that translation
> is 1% a "tree-manipulation" problem, and 99% a "code mapping" problem.
>

Well, that problem becomes a "static analysis" problem and a "constant
expression substitution that is aware of printf args" problem as well.


> I think if tree-walking works for most of the translation work, you either
> have two very similar languages, or your output code looks just like your
> input code with different syntax. "I don't want 'JOBOL'", as one of my
> customers said :)

AREV & VB actually had quite different syntax.  If you have a decent
tree structure, the difference of syntax of the languages is
irrelevant.  AREV had some wacky expressions, but once the program was
parsed the trees for statements and expressions were easy to
understand and manipulate.

I'm not debating you on whether your way is better or not.  I just
disagree with your statements about where tree walking doesn't work.

Monty

From monty at codetransform.com  Fri Oct  6 10:40:52 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 10:40:52 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>
Message-ID: <598864c70610061040n11049498m8a1b8dfffaff1e40@mail.gmail.com>

> My main point is that it's ok to have multiple tree structures, L and
> L', but the union and/or slow morphing of one to the other is a total
> pain I've found.
>

Personally, I didn't find it to be too painful, but I did jump through
hoops to organize my code so that I knew that if I changed expr() in
one tree grammar that I would remember to change it in all of them.
For what I was doing I'd rather be using tree grammars than anything
else I could think of.

Monty

From monty at codetransform.com  Fri Oct  6 10:45:57 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 10:45:57 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45261C18.70509@cyconix.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com> <45261C18.70509@cyconix.com>
Message-ID: <598864c70610061045q4d366063xd8ce9419fedaad4e@mail.gmail.com>

on 10/6/06, Paul Johnson <gt54-antlr at cyconix.com> wrote:
...
> 5 - what if your language has multiple ways to do the same thing?
> Indirection and array access, for example? It makes little sense to code
> this redundancy into the AST. You can instead have a pass which, for
> example, eliminates indirections and replaces them with array accesses.


A great example of an intermediate representation of C that has been
reduced to the essentials is http://manju.cs.berkeley.edu/cil/

For instance, pointer and array access are reduced to one canonical
format.  This reduces the number of cases you have to handle when
translating.  Of course, this is more appropriate for translation to
code that doesn't need to be edited by humans (in this case it is a C
to C translator).  There may be semantics in the actual style used to
represent something that could be important for "natural" translation,
which is what Andy is aiming for, I think.

Monty

From parrt at cs.usfca.edu  Fri Oct  6 11:05:13 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:05:13 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
Message-ID: <B60500C2-8B52-48C5-872B-C281D6E613B7@cs.usfca.edu>


On Oct 5, 2006, at 12:25 PM, Monty Zukowski wrote:
> In fact it is quite easy to have multiple languages in the same tree.
> I did this for the AREV->VB translator.  The key is to have AREV_PLUS
> and VB_PLUS for the '+' tree nodes.  Then you don't have to guess if
> you are processing arev addition or vb addition.

Hi Monty!  Nice to see you pop your head up!

Well, I'm not so much worried about how to differentiate the tree  
nodes per se.  I am concerned about making a union grammar that has  
to have both AREV_PLUS and VB_PLUS rules.  Or, if I'm doing this by  
hand, I have to have code that deals with both kinds of tree nodes.   
Propagating grammatical changes forward from phase n to n+i can be  
challenging even if using a grammar.

> I had one super-treegrammar with two complete tree grammars therin.  I
> found it convenient to bifurcate at the statement level.  For example:
>
> program: (statement)*;
> statement:arevStatement | vbStatement;

   Yes, but what happens when you decide that you need to do a  
transformation sooner than you had it before?  You need to modify all  
of the intermediate transformation phases to deal with new  
grammatical structure.  This cannot really be done automatically.

> I was raving about this like 7 years ago, it just totally rocks!

   I build my Fortran translators this way in the old days, but I  
just remember all of the pain when changing the phase in which I did  
a transformation because it ripples through the remaining phases.

> Check the archives for my posts about multiple tree grammars, or ask
> questions if something isn't clear.
>
> By the last pass, I had a completely vb tree, and then I finally
> dumped it to text.

   Yes, that is the really great feature of this approach.

TXL uses the union grammar approach by the way also.

Ter


From parrt at cs.usfca.edu  Fri Oct  6 11:23:47 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:23:47 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45256B24.40908@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	<45250F8F.8040001@jazillian.com>	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
	<45256B24.40908@jazillian.com>
Message-ID: <30E5071D-094B-4834-8736-40C67E752AF9@cs.usfca.edu>


On Oct 5, 2006, at 1:29 PM, Andy Tripp wrote:
> In COBOL we have statements like:
> ADD A TO B    // B += A;
> ADD A B TO C D   // C+= A + B;  D+= A + B;
> ADD A TO B GIVING C    // C = A + B;
>
> If you bifurcate at the statement level, then you have lots of  
> logic that
> says "Here is the COBOL ADD statement, and now I'll generate the  
> equivalent Java
> statement, and either replace the COBOL AST with the Java one, or just
> somehow just attach the Java AST to the COBOL AST."

Well, logic or alternatives within a rule.

> That's fine, but it just means that (almost) all your logic is  
> there, in that processing.
> The fact that it's stored in an AST at all is of little help to  
> you...you're not doing
> many AST manipulations. So the AST just becomes a convenient data  
> structure
> for storing the state between phases,

Correct.

> as opposed to a convenient data structure
> for actually performing language translation on.

  well you have to store the data in some way and recording the  
grammatical structure by encoding it in the structure the tree seems  
useful regardless of what you're doing.  Better than a linked list of  
the input tokens right?   I guess you are saying you don't really  
care about the data structure because you are doing a declarative  
rule-based translation.

   I agree that the declarative approach works best in many  
situations.  On the other hand, I am not sure that what you say in  
your article is that bad: "part of your work is being done with  
treewalking, and part is done at the end."

  one of my big problems though with the declarative approach is that  
you can easily generate an infinite loop.  I believe this is nicely  
formalized in many of the papers done by the declarative approach  
people and is the raison d'etre for Stratego that tries to let you  
specify what the order of evaluation is for applying rules.  You can  
clearly get a situation where you loop forever.  Of course, I suppose  
that you can simply look for where the loop is by tracing the rule  
applications, but anyone who is programmed in prolog says that it's  
very difficult to debug when your list of rules doesn't work.

>> I was raving about this like 7 years ago, it just totally rocks!
>> Check the archives for my posts about multiple tree grammars, or ask
>> questions if something isn't clear.
>>
>> By the last pass, I had a completely vb tree, and then I finally
>> dumped it to text.
>
> I had looked very carefully at all your stuff when I started 4  
> years ago.
> My feeling is that if you're going to do a "natural" translation -  
> that is:
>
> String hello = "hello";
> String world = "world";
> printf("%s %s\n", hello, world);
>
> ...becomes...
>
> System.out.println("Hello World");
>
> then the "walking the AST" approach doesn't come close to working.
> The two ASTs for those two code chunks
> have almost nothing in common, and doing that translation
> is 1% a "tree-manipulation" problem, and 99% a "code mapping" problem.

I think I disagree.  Somehow  you have to find these patterns whether  
you're looking at the symbol table that was previously populated or  
you're walking looking at the flow trying to figure out the variables  
are.  Just for the record I am opposed to the translation you show  
here.  That is not at all what I would expect unless it's clear that  
those variables are always constants.

> I think if tree-walking works for most of the translation work, you  
> either
> have two very similar languages, or your output code looks just  
> like your
> input code with different syntax. "I don't want 'JOBOL'", as one of my
> customers said :)

heh heh heh...yes, very interesting point.  I was very happy with my  
annotate the tree approach for mantra which yields like

     mlist c = mArrayList.of((
     new Object() {
       public mstream value(final mstream _input) {
         mint i = new mint(0);
         mlist _data = new mArrayList();
         _input.start();
         while (_input.more()) {
           mstring n = (mstring)_input.next();
           if ( (n).notEquals((new mstring("Tom"))) ) {
           mobject _result = null;
           _data.add(_result);
           }
           i = new mint(i.v+1); // huge waste
         }
         _input.stop(); // put this in a finally
         mstream _str = new mListStream(_data);
         return _str;
       }
     }
     )
     .value(((mobject)names).toStream()));

from the simple looking:

list c = names:{string n, n!="Tom"};

  naturally, this was easy because even though it's big it's still a  
one-to-one mapping, albeit with a complicated template.

I am very much warming to your ideas about the declarative approach,  
although the pure declarative approach is not something that has  
proven popular with users.  All of the large tools that do this sort  
of thing are so collocated that programmers won't use it.  Your  
specific declarative system seems very nice and I would like to see  
more of it some time.

Ter



From parrt at cs.usfca.edu  Fri Oct  6 11:27:41 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:27:41 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45261C18.70509@cyconix.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com> <45261C18.70509@cyconix.com>
Message-ID: <0BD6F495-2464-42ED-A91E-854939ECD569@cs.usfca.edu>


On Oct 6, 2006, at 2:04 AM, Paul Johnson wrote:

> I'm not knocking the single-tree approach; I'm sure it has its  
> uses. However, my own opinion is that multiple in-situ tree  
> transformations are extremely useful, if not indispensable. Some  
> quick examples, off the top of my head, in addition to Andy's:
>
> 1 - constant reduction. You've got a subtree of, say, a dozen or  
> more nodes which represent something like ((CONSTA << 16) & CONSTB)  
> | (CONSTC >> 2)). There's no point whatever keeping this in the  
> tree and redundantly parsing and re-evaluating it on every AST  
> pass. Why not just evaluate it once in a constant reduction pass,  
> snip off the branch, and replace it with a single CONST node?

Hi Paul,

   Yes as long as the language (i.e., structure) is the same, in-line  
transformation is good.

> 2 - if your language has compound assignments (ie. something like  
> 'a += b') then it's pointless and confusing to keep this in the  
> tree, and it complicates code generation. Why do not just replace  
> the branch with another branch that unrolls the assignment? What if  
> your language is even worse than this - 'x = a += b, a + c'? I  
> expect you all know what language that is.

   Again the language is the same.  No problem.

> 3 - Similarly, if your language has incr/decr operators, these are  
> easily handled by modifying the AST to unroll them.

   Same language.

   Same answer to all of the below...

Ter
> 4 - What if your operators have side-effects, which you can't  
> handle till the next sequence point? Doing this in a single static  
> tree is very difficult. It's simple if you construct a new  
> expression and insert it into the tree at some later point.
>
> 5 - what if your language has multiple ways to do the same thing?  
> Indirection and array access, for example? It makes little sense to  
> code this redundancy into the AST. You can instead have a pass  
> which, for example, eliminates indirections and replaces them with  
> array accesses.
>
> And so on. Bottom line - the AST should represent the programmer's  
> intent, which is never obvious from the bare syntax of whatever  
> language they attempted to code that intent in. Sometimes, it can  
> take you many passes to find out what that intent actually was. Why  
> tie one arm behind your back by sticking with your first AST till  
> the bitter end?
>
> Paul


From parrt at cs.usfca.edu  Fri Oct  6 11:33:14 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:33:14 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45266134.8080009@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	
	<45250F8F.8040001@jazillian.com>	
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>	
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>	
	<45256B24.40908@jazillian.com>
	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
	<45266134.8080009@jazillian.com>
Message-ID: <A99B9CD9-877E-4591-A744-7316DB4F6B52@cs.usfca.edu>


On Oct 6, 2006, at 6:59 AM, Andy Tripp wrote:
> Here's my alternative:
> I have hundreds of "transformation rules" where each rule can  
> either be a simple mapping like this:
> ADD v1 TO v2. --> v2 += v1;
> ADD v1 v2 TO v3 v4. --> v3 += v1 + v2; v4 += v1 + v2
> ADD v1 TO v2 GIVING v3.  --> v3 = v1 + v2;
>
> ...or actual Java code that operates on sequences of tokens, not  
> trees.
> I find it easier to think of the source and target languages as  
> sequences of tokens
> ("ADD" followed by a variable followed by "TO"...) rather than  
> trees (an "ADD" node
> with the first child being a variable and the second child being  
> "TO"...)

  interesting.  What happens when you need to use structure not just  
token sequence?

>> Well, that problem becomes a "static analysis" problem and a  
>> "constant
>> expression substitution that is aware of printf args" problem as  
>> well.
>
> Right. So I guess my view is just that language translation, at  
> least when producing
> realistic output, is 99% "static analysis" and 1% "tree  
> transformation".

Interesting... I really must have a look at all of your rules sometime.

> Well, I preferred sequences of tokens over ASTs even for C to Java  
> and C++ to Java,
> so my views are pretty extreme. On the other hand, of all the  
> language translators out there,
> I don't see any that (to my eye) produce realistic, "natural" code,  
> other than my Jazillian.
> It's one thing to produce working Java (source or byte code) code  
> from C. It's quite another
> to produce code that looks hand-written. The logic to combine those  
> 3 "printf" statements
> into a single, realistic Java one is far harder than just changing  
> to Java syntax. Somewhere
> in writing that code I came to realize "Hey, the AST is just  
> getting in the way here".

  how did you decide that you could replace those variables with  
strings?  Did you do flow analysis?  If so how did you do it on a  
linked list of tokens?

> I guess what I'm doing is more akin to natural language  
> translation. I'm sure an English to
> Spanish translator has relatively little logic that does tree  
> transformation (e.g. putting the
> adjectives *after* the nouns).

  an interesting analogy.  You are saying that language translation  
is mostly word for word change and some grammatical changes such as  
you would see from English to German where the verb's at the end.

Hmm....  Do you have multiple phases also, just declarative rule  
replacement style?

Ter

From antlr at jazillian.com  Fri Oct  6 11:35:36 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 06 Oct 2006 14:35:36 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
Message-ID: <4526A1F8.4050900@jazillian.com>

Johnicholas Hines wrote:

> Is the deep analysis that Andy Tripp's COBOL to Java project requires
> a corner case of ANTLR usage? It seems to me he's building at least a
> full dataflow graph, which I believe is more extreme than most
> transformations.
>
> My projects with antlr include things like "replicate bash's
> brace-expansion in a standalone tool", and "convert pure lambda
> calculus to continuation-passing style".
>
> As far as I can tell, these tasks are not "99% static analysis and 1%
> tree transformation". Admittedly, I have no working code, so perhaps
> you should take my opinions with dash of salt.
>
> Johnicholas

Yes, I agree mine is a "corner case" - but I think it's the case that 
deserves
the name "one source programming language to another source programming 
language translator".
and maybe even the shorthand "language translator". I think most people 
using ANTLR
are doing stuff like you are, which is more "parsing and generating 
source code".

The distinction because I think a lot of people mistakenly believe that 
tools like ANTLR and
ASTs will "scale up" from simple stuff to real, complete translation. I 
especially remember
the TXL documentation seeming to say basically "here's how you replace a 
node in an AST,
and now you have what you need to translate one language to another". I 
was quite unhappy
to discover that I got almost nowhere with that approach. Now I think 
that's like saying
"To convert English to Spanish, replace 'Hello' with 'Hola', but the 
adjectives after the nouns,
and so on". Meanwhile, people are spending their whole lives writing 
English to Spanish
translators, an the simple "replace words with equivalents and put 
adjectives after nouns"
got them about 0.00001% of the way there.

And yes, I do have to understand control flow, but not just that. I have 
to understand
that when the format string of printf() ends with '\n', it's replaced 
with println(), not print().
I have to be able to parse a printf() format string and know what 
"%4.2d" means. And lots
more.

I don't want people to get the wrong impression when they hear
"look at how well this work for C- to Java"
that the same technique will be reasonable for C to Java.

Andy
p.s. or the other way to look at it is "I sure hope I haven't strayed 
down the wrong track
a long time ago, so I'll keep explaining what I did and why, and see if 
someone can tell me
where I went wrong".

From parrt at cs.usfca.edu  Fri Oct  6 11:39:35 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:39:35 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45266843.7050103@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	<45250F8F.8040001@jazillian.com>
	<2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>
	<45266843.7050103@jazillian.com>
Message-ID: <EEBED01A-3297-4E17-A4E1-6459427D06ED@cs.usfca.edu>


On Oct 6, 2006, at 7:29 AM, Andy Tripp wrote:

>
>>
>> An interesting and difficult problem..thanks for bringing this  
>> up.   I'd have to think more.  Clearly some kind of non-text data  
>> structure  is needed for this.  I guess you'd build the Java  
>> template or AST and  then add the bits as you find them while  
>> traversing the COBOL.
>
> This is the key to the difference in the two approaches. Using an  
> AST, I kept finding myself gathering bits of information from
> around the AST. For example, say we're doing C to Java and I see  
> "if (a)". We first look for the declaration of a to see whether
> it's an int or not (it may not be because our "goto removal" phase  
> already ran, and it injects booleans). Next, we look at
> all references to "a", to see if it will be possible to change all  
> of them from "int" usages to "boolean" usages. If not, just change it
> to "if (a != 0)", but if so, go ahead and change the type to  
> boolean, and make whatever changes are needed at each reference.
>
> If you try to do that sort of thing in a tree-walking way, it will  
> be a mess, I think.

   Aren't these standard operations and data structures?    Symbol  
table, use-def chains, flow analysis.  The tree walk can simply ask  
questions of these data structures.

>> My main point is that it's ok to have multiple tree structures, L  
>> and  L', but the union and/or slow morphing of one to the other is  
>> a total  pain I've found.
>
> Yes, it's a royal pain, but if you start with the requirement that  
> you will produce "natural" code, there's no choice.

   Well, I suppose anything is possible, it's just a matter of how  
convenient.  And you are saying it's inconvenient really not impossible.

> I think just this simple example that I brought up before actually  
> brings the problem to the surface:
>
> String hello = "hello";
> String world = "world";
> printf("%s %s\n", hello, world);
>
> ...becomes...
>
> System.out.println("Hello World");
>
> I can't see how that can be done by treewalking. By the time the  
> code is actually written to implement "printf to System.out.println",
> there will be almost no "tree-transformation" or even "tree  
> walking" logic.

   The logic is identifying that you have entered a list of  
statements and you see a print statement.  The translation logic is a  
simple one-to-one mapping from printf to println just as you would do  
in a rule right?  The only problem is discovering what should be the  
expression.  Either in a previous phase I would have done constant  
propagation or in your case you ask the question or something in one  
of your declaration rules.  Do you insert actions in your rules to go  
check data structures?  Surely you don't write a rule that has a   
context-sensitive pattern  asking if there have been all possible  
variable declarations before the print, right?

> As for the try/catch, all the work is in finding a good "level" to  
> insert the try/catch. For example, if we have three consecutive
> read() calls, best to put them into a single try/catch. If we need  
> to catch both FileNotFoundException and IOException
> for one statement, and just IOException for the following  
> statement, what do we do?

  how do you handle that?  I very is to to learn more about your  
approach; I see you talking about how the tree walking won't work,  
but I don't see how yours will work.  It is very interesting and I  
want to learn more.

> Thanks for your patience - guess I'm a natural contrarian :)

   Always good for an excellent discussion and to shake things up...
Ter

From parrt at cs.usfca.edu  Fri Oct  6 11:44:13 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:44:13 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
	<45267B17.6060107@jazillian.com>
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
Message-ID: <CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>


On Oct 6, 2006, at 10:36 AM, Johnicholas Hines wrote:

> Is the deep analysis that Andy Tripp's COBOL to Java project requires
> a corner case of ANTLR usage? It seems to me he's building at least a
> full dataflow graph, which I believe is more extreme than most
> transformations.
>
> My projects with antlr include things like "replicate bash's
> brace-expansion in a standalone tool", and "convert pure lambda
> calculus to continuation-passing style".

Yes, you are right.  My simple polynomial differentiation translator  
worked great.  One could argue however that showing declarative rules  
in this case would be easy also:

<a=int><id><c=int> --> <a*c><id><c-1>

Andy: how do you deal with references to grammatical constructs such  
as <expr>? ANTLR you only work with tokens, period?    How do you  
deal with extreme context like you need to do a translation on this  
expression but only if it's the expression within a while within a  
particular function?

Ter

From parrt at cs.usfca.edu  Fri Oct  6 11:48:06 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 6 Oct 2006 11:48:06 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <4526A1F8.4050900@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
	<4526A1F8.4050900@jazillian.com>
Message-ID: <1CFCE264-6395-44EB-B8E9-1CA5DABC81DF@cs.usfca.edu>


On Oct 6, 2006, at 11:35 AM, Andy Tripp wrote:
> The distinction because I think a lot of people mistakenly believe  
> that tools like ANTLR and
> ASTs will "scale up" from simple stuff to real, complete translation.

I have done some nasty translators, but none on the scale of your  
COBOL to Java translator.  Gary Funck and I worked on a Pascal like  
language to C translator (he did the work) that use tree  
transformation and it had lots of nasty things to do like  
topologically sorting the declarations so that C was happy with them.  
so clearly it's possible--we are only talking about convenience in  
this thread probably. of course that can make the difference between  
finishing something and not. ;)

Ter


From antlr at jazillian.com  Fri Oct  6 12:08:58 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 06 Oct 2006 15:08:58 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <30E5071D-094B-4834-8736-40C67E752AF9@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	<45250F8F.8040001@jazillian.com>	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>	<45256B24.40908@jazillian.com>
	<30E5071D-094B-4834-8736-40C67E752AF9@cs.usfca.edu>
Message-ID: <4526A9CA.80502@jazillian.com>


>
>  well you have to store the data in some way and recording the  
> grammatical structure by encoding it in the structure the tree seems  
> useful regardless of what you're doing.  Better than a linked list of  
> the input tokens right?   I guess you are saying you don't really  
> care about the data structure because you are doing a declarative  
> rule-based translation.

Right. I'm using a List of Tokens, and it works great for me. I think of 
"public static void main(String[] args)" as a sequence
of 8 tokens. That's a much simpler mental picture (at least for me) than 
whatever AST that parses to.

>
>   I agree that the declarative approach works best in many  
> situations.  On the other hand, I am not sure that what you say in  
> your article is that bad: "part of your work is being done with  
> treewalking, and part is done at the end."

I just know that for my app, the treewalking almost always seems more 
difficult than the alternative (which is sometimes
declarative, and sometime just "code that does the job"). One exception 
is expressions: when I need to parse a
conditional expression to change it from a "int" type to a "boolean" 
type, I use an AST, for example.

>
>  one of my big problems though with the declarative approach is that  
> you can easily generate an infinite loop.  I believe this is nicely  
> formalized in many of the papers done by the declarative approach  
> people and is the raison d'etre for Stratego that tries to let you  
> specify what the order of evaluation is for applying rules.  You can  
> clearly get a situation where you loop forever.  Of course, I suppose  
> that you can simply look for where the loop is by tracing the rule  
> applications, but anyone who is programmed in prolog says that it's  
> very difficult to debug when your list of rules doesn't work.

Yes, that's a problem. Ordering of phases is a huge problem too.
But at least I can deal with these problems...I couldn't seem to even 
get going with initial design/development
using the treewalking approach.

>
>>> I was raving about this like 7 years ago, it just totally rocks!
>>> Check the archives for my posts about multiple tree grammars, or ask
>>> questions if something isn't clear.
>>>
>>> By the last pass, I had a completely vb tree, and then I finally
>>> dumped it to text.
>>
>>
>> I had looked very carefully at all your stuff when I started 4  years 
>> ago.
>> My feeling is that if you're going to do a "natural" translation -  
>> that is:
>>
>> String hello = "hello";
>> String world = "world";
>> printf("%s %s\n", hello, world);
>>
>> ...becomes...
>>
>> System.out.println("Hello World");
>>
>> then the "walking the AST" approach doesn't come close to working.
>> The two ASTs for those two code chunks
>> have almost nothing in common, and doing that translation
>> is 1% a "tree-manipulation" problem, and 99% a "code mapping" problem.
>
>
> I think I disagree.  Somehow  you have to find these patterns whether  
> you're looking at the symbol table that was previously populated or  
> you're walking looking at the flow trying to figure out the variables  
> are.  

But the problem is that many phases can update the symbol table. Every 
time you move a variable declaration
from one place to another, rename a variable, change its type or its 
initial value or modifiers. So I've found that
generally, instead of a symbol table, it's better to just have code that 
can search through the code as it currently
stands and find the variable declaration and examine it.

I don't mean to come out against symbol tables in general, just in this 
case.

> Just for the record I am opposed to the translation you show  here.  
> That is not at all what I would expect unless it's clear that  those 
> variables are always constants.


Ahh...and therein lies the difference in our approaches. It's not what 
you'd *expect* because of your background
in language tools. But is it what you'd *want* as a customer who wants 
to replace C code with Java? Answer: customers
don't want "JOBOL", and they don't want "Cava". (Although, if they do 
want C in Java clothes, there's
a tool for that: http://ovid.tigris.org/Ephedra/)

>
>
>> I think if tree-walking works for most of the translation work, you  
>> either
>> have two very similar languages, or your output code looks just  like 
>> your
>> input code with different syntax. "I don't want 'JOBOL'", as one of my
>> customers said :)
>
>
> heh heh heh...yes, very interesting point.  I was very happy with my  
> annotate the tree approach for mantra which yields like
>
>     mlist c = mArrayList.of((
>     new Object() {
>       public mstream value(final mstream _input) {
>         mint i = new mint(0);
>         mlist _data = new mArrayList();
>         _input.start();
>         while (_input.more()) {
>           mstring n = (mstring)_input.next();
>           if ( (n).notEquals((new mstring("Tom"))) ) {
>           mobject _result = null;
>           _data.add(_result);
>           }
>           i = new mint(i.v+1); // huge waste
>         }
>         _input.stop(); // put this in a finally
>         mstream _str = new mListStream(_data);
>         return _str;
>       }
>     }
>     )
>     .value(((mobject)names).toStream()));
>
> from the simple looking:
>
> list c = names:{string n, n!="Tom"};

Hehehe...yup. A large part of my time is spent going the other way. 
Many, many times,
you have 20 lines of C code that should (in my view) be replaced with 
one line of Java.
Actually getting that to work in a general way is fun but close to 
impossible.

>
>  naturally, this was easy because even though it's big it's still a  
> one-to-one mapping, albeit with a complicated template.
>
> I am very much warming to your ideas about the declarative approach,  
> although the pure declarative approach is not something that has  
> proven popular with users.  All of the large tools that do this sort  
> of thing are so collocated that programmers won't use it.  Your  
> specific declarative system seems very nice and I would like to see  
> more of it some time.

Cool. Keep up the great work! I'm a slow adopter, but I am looking 
forward to v3.
COBOL seems to have been built for infinite lookahead :(

Andy

>
>
> Ter
>
>


From monty at codetransform.com  Fri Oct  6 12:24:40 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 12:24:40 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45266843.7050103@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>
	<45266843.7050103@jazillian.com>
Message-ID: <598864c70610061224s3da48372r71c75ae866365ab6@mail.gmail.com>

Andy Tripp wrote:
> I think just this simple example that I brought up before actually
> brings the problem to the surface:
>
> String hello = "hello";
> String world = "world";
> printf("%s %s\n", hello, world);
>
> ...becomes...
>
> System.out.println("Hello World");
>
> I can't see how that can be done by treewalking. By the time the code is
> actually written to implement "printf to System.out.println",
> there will be almost no "tree-transformation" or even "tree walking" logic.
>

Well, I would have one pass that replaced all variable references of
variables that are defined and used before being modified with the
value from the declaration.  That would leave a printf("%s %s\n",
"hello", "world");

In a later pass I would check for and eliminate any variables that are
never referenced.

Also later I would have a printf rewrite rule that does string
substitution for any constant arguments.

Treewalking is just a handy way for me to do pattern matching.

Monty

From monty at codetransform.com  Fri Oct  6 12:28:09 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 12:28:09 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45266134.8080009@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
	<45256B24.40908@jazillian.com>
	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
	<45266134.8080009@jazillian.com>
Message-ID: <598864c70610061228t7a69abbds86fa12176bc49eea@mail.gmail.com>

>
> Here's my alternative:
> I have hundreds of "transformation rules" where each rule can either be
> a simple mapping like this:
> ADD v1 TO v2. --> v2 += v1;
> ADD v1 v2 TO v3 v4. --> v3 += v1 + v2; v4 += v1 + v2
> ADD v1 TO v2 GIVING v3.  --> v3 = v1 + v2;
>
> ...or actual Java code that operates on sequences of tokens, not trees.
> I find it easier to think of the source and target languages as
> sequences of tokens
> ("ADD" followed by a variable followed by "TO"...) rather than trees (an
> "ADD" node
> with the first child being a variable and the second child being "TO"...)
>

Interesting.  So do you actually work directly with tokens, or do you
write grammars to parse your token streams and emit yet another token
stream, or do you have your own token matching language you write your
rules in?

Monty

From monty at codetransform.com  Fri Oct  6 12:52:54 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 12:52:54 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610061236v71e8cc72sfe1fe87176b3df47@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
	<B60500C2-8B52-48C5-872B-C281D6E613B7@cs.usfca.edu>
	<598864c70610061236v71e8cc72sfe1fe87176b3df47@mail.gmail.com>
Message-ID: <598864c70610061252l73c9008fo93d26508bf407f6e@mail.gmail.com>

On 10/6/06, Terence Parr <parrt at cs.usfca.edu> wrote:

> Well, I'm not so much worried about how to differentiate the tree
> nodes per se.  I am concerned about making a union grammar that has
> to have both AREV_PLUS and VB_PLUS rules.  Or, if I'm doing this by
> hand, I have to have code that deals with both kinds of tree nodes.
> Propagating grammatical changes forward from phase n to n+i can be
> challenging even if using a grammar.
>
> > I had one super-treegrammar with two complete tree grammars therin.  I
> > found it convenient to bifurcate at the statement level.  For example:
> >
> > program: (statement)*;
> > statement:arevStatement | vbStatement;
>
>    Yes, but what happens when you decide that you need to do a
> transformation sooner than you had it before?  You need to modify all
> of the intermediate transformation phases to deal with new
> grammatical structure.  This cannot really be done automatically.

The thing is I don't need to remember which grammars to modify,
because I modify them all!  Most passes only subclass the rules they
care about, so if I add a new expression type, I only have to modify
the grammars with expression rules in them, etc.  My tree supergrammar
is the definitive grammar, the union of all steps.  I don't have any
way to have "ADD" mean two different things based on which pass I'm
at.

There's no way I could keep it straight if each pass had it's own
special grammar.

Monty

From antlr at jazillian.com  Fri Oct  6 13:15:27 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 06 Oct 2006 16:15:27 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <A99B9CD9-877E-4591-A744-7316DB4F6B52@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>		<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>		<45250F8F.8040001@jazillian.com>		<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>		<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>		<45256B24.40908@jazillian.com>	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>	<45266134.8080009@jazillian.com>
	<A99B9CD9-877E-4591-A744-7316DB4F6B52@cs.usfca.edu>
Message-ID: <4526B95F.5070801@jazillian.com>

Terence Parr wrote:

>
> On Oct 6, 2006, at 6:59 AM, Andy Tripp wrote:
>
>> Here's my alternative:
>> I have hundreds of "transformation rules" where each rule can  either 
>> be a simple mapping like this:
>> ADD v1 TO v2. --> v2 += v1;
>> ADD v1 v2 TO v3 v4. --> v3 += v1 + v2; v4 += v1 + v2
>> ADD v1 TO v2 GIVING v3.  --> v3 = v1 + v2;
>>
>> ...or actual Java code that operates on sequences of tokens, not  trees.
>> I find it easier to think of the source and target languages as  
>> sequences of tokens
>> ("ADD" followed by a variable followed by "TO"...) rather than  trees 
>> (an "ADD" node
>> with the first child being a variable and the second child being  
>> "TO"...)
>
>
>  interesting.  What happens when you need to use structure not just  
> token sequence?

I have a large library of methods that work on token streams. Methods like:
getContainingFunction, getNextScope, findNextToken("foo"), etc. As for
"knowing where you are in the tree", such as "look for this pattern of 
function declaration
(but of course don't look for it *within* another function)", I just 
don't do that. i.e.
I might look for pattern "f(...) {" anywhere.

>
>  how did you decide that you could replace those variables with  
> strings?  Did you do flow analysis?  If so how did you do it on a  
> linked list of tokens?

Actually, in this case, now that I think about it, I lied...I would generate
System.out.println(hello + world);
But In some places, I do look at all references to a variable, see that 
none of them are setting the value, and so make it
"final static" if it's at the class level, and sometimes get rid of the 
variable declaration altogether. Ad hoc, I know :(

>
>> I guess what I'm doing is more akin to natural language  translation. 
>> I'm sure an English to
>> Spanish translator has relatively little logic that does tree  
>> transformation (e.g. putting the
>> adjectives *after* the nouns).
>
>
>  an interesting analogy.  You are saying that language translation  is 
> mostly word for word change and some grammatical changes such as  you 
> would see from English to German where the verb's at the end.

I had spent just as much time investigating natural language processing 
systems as programming language processing systems
when I started. My impression is that all the work in NPL is in 
understanding context and handling exceptions, not word
replacement. "white house" becomes "casa blanca" (not "casa blanco"). 
But "The White House" in Spanish is still "The White House"!
I saw an poster for a NLP conference once and I noted that a newpaper 
headline in the back said "Woods Eyes Masters".
Talk about context! Try parsing that sentence if it's not the headline 
of a sports page!

>
>
> Hmm....  Do you have multiple phases also, just declarative rule  
> replacement style?

Not sure what you mean. I have a couple hundred "rules", each really a 
"phase". Each rule is either
simple declarative or actual Java code.

>
>
> Ter
>


From monty at codetransform.com  Fri Oct  6 13:34:26 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Fri, 6 Oct 2006 13:34:26 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <4526A9CA.80502@jazillian.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>
	<45250F8F.8040001@jazillian.com>
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>
	<45256B24.40908@jazillian.com>
	<30E5071D-094B-4834-8736-40C67E752AF9@cs.usfca.edu>
	<4526A9CA.80502@jazillian.com>
Message-ID: <598864c70610061334pb5a7453xf0144bb3c52e7a2c@mail.gmail.com>

...
> > Just for the record I am opposed to the translation you show  here.
> > That is not at all what I would expect unless it's clear that  those
> > variables are always constants.
>
>
> Ahh...and therein lies the difference in our approaches. It's not what
> you'd *expect* because of your background
> in language tools. But is it what you'd *want* as a customer who wants
> to replace C code with Java? Answer: customers
> don't want "JOBOL", and they don't want "Cava". (Although, if they do
> want C in Java clothes, there's
> a tool for that: http://ovid.tigris.org/Ephedra/)

Note, you missed the fact that it has to be clear that those variables
are constants.  Obviously, if they are not, then you can't do the
substitution.

Also as I was thinking about it, I don't like eliminating the
variables just because they are constants.  Sometimes programmers do
things like that to make the code more readable, and crunching it into
one line again makes it less readable.  Without knowing the intent of
the programmer I would say it should not do such fancy things as
variable substitution.  Worse yet, if the string is overridden later,
or tested against, or things like that, then you've made the code
harder to maintain by putting the constant everywhere (perhaps
embedded in other strings).

Monty

From rob.hill at blueyonder.co.uk  Sat Oct  7 03:35:16 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Sat, 7 Oct 2006 11:35:16 +0100
Subject: [antlr-interest] minor 3.0b4 bug?
Message-ID: <20061007103519.AD6171907FA@www.antlr.org>


service	:  LParen  RParen	;
paramList	: 	;

and 

service	:  LParen  paramList RParen	;
paramList	: 	;

compile ok, but if you add a kleene star to the paramlist

service	:  LParen paramList* RParen ;
paramList
	: 
	;
I get the following error :

ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: Decision can
match input such as "RParen" using multiple alternatives: 1, 2
As a result, alternative(s) 2 were disabled for that input
D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: The following
alternatives are unreachable: 2

Where is Alt 2?

Ok, I know that having an empty rule is a bit daft, but I was half way
through writing it, and the old habit of save/build every 10 seconds is
still alive and kicking.. at least it stops me typing too much guff in and
not knowing where the errors are coming from LOL..

Cheers,
Rob





From jbb at acm.org  Sat Oct  7 06:35:14 2006
From: jbb at acm.org (John B. Brodie)
Date: Sat, 07 Oct 2006 09:35:14 -0400
Subject: [antlr-interest] minor 3.0b4 bug?
In-Reply-To: <20061007103519.AD6171907FA@www.antlr.org> (message from Robert
	Hill on Sat, 07 Oct 2006 11:35:16 +0100)
References: <20061007103519.AD6171907FA@www.antlr.org>
Message-ID: <E1GWCKg-00084X-00@gecko>

>...snipped...
>
>service	:  LParen paramList* RParen ;
>paramList
>	: 
>	;
>I get the following error :
>
>ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
>D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: Decision can
>match input such as "RParen" using multiple alternatives: 1, 2
>As a result, alternative(s) 2 were disabled for that input
>D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: The following
>alternatives are unreachable: 2
>
>Where is Alt 2?
>
>...snipped...

think of the above two rules as this equivalent

service : LParen aUniqueRuleName RParen ;

aUniqueRuleName : /*empty*/ | paramList aUniqueRuleName ;

paramList : /*empty*/ ;

the rule introduced by the transformation has two alternatives which, in this
case, are both empty.  leading to the reported ambiguity problems.

Hope this helps...
   -jbb

From parrt at cs.usfca.edu  Sat Oct  7 09:38:20 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 7 Oct 2006 09:38:20 -0700
Subject: [antlr-interest] minor 3.0b4 bug?
In-Reply-To: <20061007103519.AD6171907FA@www.antlr.org>
References: <20061007103519.AD6171907FA@www.antlr.org>
Message-ID: <A3462E22-F74F-4BCF-A0B7-8934B22989D1@cs.usfca.edu>

Hi. :)  The error is valid.  Two paths can reach the RPAREN.  One is  
via the alt in the loop and the other is the exit branch.  ANTLR is  
asking: upon ')', should I re-enter loop or exit. :)

Ter
On Oct 7, 2006, at 3:35 AM, Robert Hill wrote:

>
> service	:  LParen  RParen	;
> paramList	: 	;
>
> and
>
> service	:  LParen  paramList RParen	;
> paramList	: 	;
>
> compile ok, but if you add a kleene star to the paramlist
>
> service	:  LParen paramList* RParen ;
> paramList
> 	:
> 	;
> I get the following error :
>
> ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)   
> 1989-2006
> D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12:  
> Decision can
> match input such as "RParen" using multiple alternatives: 1, 2
> As a result, alternative(s) 2 were disabled for that input
> D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: The  
> following
> alternatives are unreachable: 2
>
> Where is Alt 2?
>
> Ok, I know that having an empty rule is a bit daft, but I was half way
> through writing it, and the old habit of save/build every 10  
> seconds is
> still alive and kicking.. at least it stops me typing too much guff  
> in and
> not knowing where the errors are coming from LOL..
>
> Cheers,
> Rob
>
>
>
>


From antlr at jazillian.com  Sat Oct  7 10:32:58 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 07 Oct 2006 13:32:58 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <EEBED01A-3297-4E17-A4E1-6459427D06ED@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	<45250F8F.8040001@jazillian.com>	<2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>	<45266843.7050103@jazillian.com>
	<EEBED01A-3297-4E17-A4E1-6459427D06ED@cs.usfca.edu>
Message-ID: <4527E4CA.5080505@jazillian.com>

Terence Parr wrote:

>
> On Oct 6, 2006, at 7:29 AM, Andy Tripp wrote:
>
>>
>>>
>>> An interesting and difficult problem..thanks for bringing this  
>>> up.   I'd have to think more.  Clearly some kind of non-text data  
>>> structure  is needed for this.  I guess you'd build the Java  
>>> template or AST and  then add the bits as you find them while  
>>> traversing the COBOL.
>>
>>
>> This is the key to the difference in the two approaches. Using an  
>> AST, I kept finding myself gathering bits of information from
>> around the AST. For example, say we're doing C to Java and I see  "if 
>> (a)". We first look for the declaration of a to see whether
>> it's an int or not (it may not be because our "goto removal" phase  
>> already ran, and it injects booleans). Next, we look at
>> all references to "a", to see if it will be possible to change all  
>> of them from "int" usages to "boolean" usages. If not, just change it
>> to "if (a != 0)", but if so, go ahead and change the type to  
>> boolean, and make whatever changes are needed at each reference.
>>
>> If you try to do that sort of thing in a tree-walking way, it will  
>> be a mess, I think.
>
>
>   Aren't these standard operations and data structures?    Symbol  
> table, use-def chains, flow analysis.  The tree walk can simply ask  
> questions of these data structures.

Yes. Sorry. My mistake. I shouldn't have said the treewalker way would
be a mess, just
that I don't think it's helping. So the treewalk approach looks
something like:

void doTheCheck() {
// here I am at the conditional node of an "if", "while", or "for"
if (symbolTable.getType(varName) != "boolean") {
   boolean canBeChanged = true;
   for (Use use: UseDefChains.getAllUsagesOf(varName)) {
         if (!use.canBeChangedToBoolean()) {
             canBeChanged = false;
        }
    }
   if (canBeChanged) {
      SymbolTable.changeType(varName, "boolean");
      for (Use use: UseDefChains.getAllUsagesOf(varName)) {
           use.change();
     }
   }
}
}

The thing is, you'll need to write this code whether you're doing
treewalking or "token-stream-matching".
All the treewalking does for you is to have this code kick-in in the
right place. And that's just as easy to
do with "token-stream-matching". In my case, it looks something like:

public boolean match(Source source) {
    if (source.currentToken.getText().equals("if") ||
source.currentToken.getText().equals("while")) {
       doTheCheck(source.getTokenAt(+2));
  } else if (source.currentToken.getText().equals("for")) {
       Token semi = source.findToken(";");
       doTheCheck(source.getTokenAt(semi, +1));
  }
}


>
>>> My main point is that it's ok to have multiple tree structures, L  
>>> and  L', but the union and/or slow morphing of one to the other is  
>>> a total  pain I've found.
>>
>>
>> Yes, it's a royal pain, but if you start with the requirement that  
>> you will produce "natural" code, there's no choice.
>
>
>   Well, I suppose anything is possible, it's just a matter of how  
> convenient.  And you are saying it's inconvenient really not impossible.


Right. I found I just couldn't get cranking on writing transformation
"rules" because I was spending all my time
trying to picture AST mappings in my head. Spending all my time on "how"
to do it, not "what" do to.

>
>> I think just this simple example that I brought up before actually  
>> brings the problem to the surface:
>>
>> String hello = "hello";
>> String world = "world";
>> printf("%s %s\n", hello, world);
>>
>> ...becomes...
>>
>> System.out.println("Hello World");
>>
>> I can't see how that can be done by treewalking. By the time the  
>> code is actually written to implement "printf to System.out.println",
>> there will be almost no "tree-transformation" or even "tree  walking" 
>> logic.
>
>
>   The logic is identifying that you have entered a list of  statements 
> and you see a print statement.  The translation logic is a  simple 
> one-to-one mapping from printf to println just as you would do  in a 
> rule right?  

It may map to println() or print(), and I don't recall whether I
actually may combine several printf() calls into a single println() call,
but that's certainly the type of thing that I do.

> The only problem is discovering what should be the  expression.  
> Either in a previous phase I would have done constant  propagation or 
> in your case you ask the question or something in one  of your 
> declaration rules.  Do you insert actions in your rules to go  check 
> data structures?  Surely you don't write a rule that has a   
> context-sensitive pattern  asking if there have been all possible  
> variable declarations before the print, right?

Right, I just "write code" to go ahead and parse the format string,
match it up with the printf() arguments, and replace it
all with a single "+"-separated Java expression.

>
>> As for the try/catch, all the work is in finding a good "level" to  
>> insert the try/catch. For example, if we have three consecutive
>> read() calls, best to put them into a single try/catch. If we need  
>> to catch both FileNotFoundException and IOException
>> for one statement, and just IOException for the following  statement, 
>> what do we do?
>
>
>  how do you handle that?  I very is to to learn more about your  
> approach; I see you talking about how the tree walking won't work,  
> but I don't see how yours will work.  It is very interesting and I  
> want to learn more.

I just decide what the most "natural" thing to do is, and then "just
write code" to do it. I can't remember exactly how I
do it for exceptions, but I'd do something like "If two consecutive
calls throw exactly the same set of exceptions, put
them both in the same try block, otherwise, each call is in its own try
block". Then, if that produces fairly ugly code in
lots of cases, I might make it more complicated.

>
>> Thanks for your patience - guess I'm a natural contrarian :)
>
>
>   Always good for an excellent discussion and to shake things up...
> Ter
>
Thanks,
Andy



From antlr at jazillian.com  Sat Oct  7 10:40:07 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 07 Oct 2006 13:40:07 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	<45267B17.6060107@jazillian.com>	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>
Message-ID: <4527E677.5070504@jazillian.com>

Terence Parr wrote:

>
> Andy: how do you deal with references to grammatical constructs such  
> as <expr>? ANTLR you only work with tokens, period?    How do you  
> deal with extreme context like you need to do a translation on this  
> expression but only if it's the expression within a while within a  
> particular function?


I've built up a nice library of functionality that works on token 
sequences. My Source class represents
all the (evolving through phases) source code, and has all this 
functionality. Something like:

boolean match(Source source) {
  if (source.isWithinWhile(source.currentToken)) {
      Token func = getContainingFunction(source.currentToken);
      if (func.getText().equals("foo")) {
         ....
      }
  }
}

Here, the isWithinWhile() method is something I just made up...I haven't 
had a need for it yet, but
would create it if needed. The getContainingFunction() method is real. 
It looks backwards
(while balancing matching braces) for something that looks like a 
function declaration: a "{"
preceeded by a ")", with a matching "(" that's preceeded by an ID.

Crazy, I know :)

Andy

From antlr at jazillian.com  Sat Oct  7 10:44:34 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 07 Oct 2006 13:44:34 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <1CFCE264-6395-44EB-B8E9-1CA5DABC81DF@cs.usfca.edu>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>		<45267B17.6060107@jazillian.com>	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	<4526A1F8.4050900@jazillian.com>
	<1CFCE264-6395-44EB-B8E9-1CA5DABC81DF@cs.usfca.edu>
Message-ID: <4527E782.2030905@jazillian.com>

Terence Parr wrote:

>
> On Oct 6, 2006, at 11:35 AM, Andy Tripp wrote:
>
>> The distinction because I think a lot of people mistakenly believe  
>> that tools like ANTLR and
>> ASTs will "scale up" from simple stuff to real, complete translation.
>
>
> I have done some nasty translators, but none on the scale of your  
> COBOL to Java translator.  Gary Funck and I worked on a Pascal like  
> language to C translator (he did the work) that use tree  
> transformation and it had lots of nasty things to do like  
> topologically sorting the declarations so that C was happy with them.  
> so clearly it's possible--we are only talking about convenience in  
> this thread probably. of course that can make the difference between  
> finishing something and not. ;)
>
> Ter
>
I've found that, at least for C to Java, I spend most of my time mapping 
the library calls, not the core language itself.
And most of the core language work seems to be in getting rid of pointers.
The libraries are where a lot - probably most- of the hard cases are.
memset() and memcpy() are not my friends :(


From antlr at jazillian.com  Sat Oct  7 10:51:05 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 07 Oct 2006 13:51:05 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610061224s3da48372r71c75ae866365ab6@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	
	<45250F8F.8040001@jazillian.com>	
	<2791821A-D56E-4361-8A55-A4F4C4C311F8@cs.usfca.edu>	
	<45266843.7050103@jazillian.com>
	<598864c70610061224s3da48372r71c75ae866365ab6@mail.gmail.com>
Message-ID: <4527E909.5070801@jazillian.com>

Monty Zukowski wrote:

> Andy Tripp wrote:
>
>> I think just this simple example that I brought up before actually
>> brings the problem to the surface:
>>
>> String hello = "hello";
>> String world = "world";
>> printf("%s %s\n", hello, world);
>>
>> ...becomes...
>>
>> System.out.println("Hello World");
>>
>> I can't see how that can be done by treewalking. By the time the code is
>> actually written to implement "printf to System.out.println",
>> there will be almost no "tree-transformation" or even "tree walking" 
>> logic.
>>
>
> Well, I would have one pass that replaced all variable references of
> variables that are defined and used before being modified with the
> value from the declaration.  That would leave a printf("%s %s\n",
> "hello", "world");

By the time you can handle...
printf("d=%3.2lf n=%d\n s=%s c=%c\n\n", d, n, s, c);
....you've got a lot of code and very little treewalking.
I've got 150 lines of code, including this one:

    // the valid characters that could follow "%" in a printf() format 
string:
    // See section 7.19.6.1, item 6, of the C98 standard.
    private static String CONVERSION_CHARACTERS = 
"-+#0123456789.*diouxXcCseEfFgGlaAhljztLpn";

>
> In a later pass I would check for and eliminate any variables that are
> never referenced.

Yup, that's what I do.

>
> Also later I would have a printf rewrite rule that does string
> substitution for any constant arguments.

Yup, me too. Also, an earlier rule that lets you handle printf, sprintf, 
and fprintf
all with the same logic.

>
>
> Treewalking is just a handy way for me to do pattern matching.

And I just do "token sequence walking" to do the same. Here's my actual
pattern matching code:
    public boolean match(Source source) {
        return source.currentToken.getText().equals("fprintf");
    }

Andy


>
> Monty
>


From antlr at jazillian.com  Sat Oct  7 10:55:59 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 07 Oct 2006 13:55:59 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610061228t7a69abbds86fa12176bc49eea@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	
	<45250F8F.8040001@jazillian.com>	
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>	
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>	
	<45256B24.40908@jazillian.com>	
	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>	
	<45266134.8080009@jazillian.com>
	<598864c70610061228t7a69abbds86fa12176bc49eea@mail.gmail.com>
Message-ID: <4527EA2F.6050507@jazillian.com>

Monty Zukowski wrote:

>>
>> Here's my alternative:
>> I have hundreds of "transformation rules" where each rule can either be
>> a simple mapping like this:
>> ADD v1 TO v2. --> v2 += v1;
>> ADD v1 v2 TO v3 v4. --> v3 += v1 + v2; v4 += v1 + v2
>> ADD v1 TO v2 GIVING v3.  --> v3 = v1 + v2;
>>
>> ...or actual Java code that operates on sequences of tokens, not trees.
>> I find it easier to think of the source and target languages as
>> sequences of tokens
>> ("ADD" followed by a variable followed by "TO"...) rather than trees (an
>> "ADD" node
>> with the first child being a variable and the second child being 
>> "TO"...)
>>
>
> Interesting.  So do you actually work directly with tokens, or do you
> write grammars to parse your token streams and emit yet another token
> stream, or do you have your own token matching language you write your
> rules in?

For simple text matching rules like those shown above, I lex (but not 
parse) the
"from" and "to" patterns (which are separated by "-->"). I then have a 
pattern-matching
engine that, starting at a particular location in a List of Tokens, 
tells whether the "from"
is matched or not. If it is matched, then the matcher also provide the 
"to" pattern
with the appropriate substitutions made.
So given this rule:
ADD v1 TO v2. --> v2 += v1;

the token squence "ADD A TO B." does match the "ADD v1 to v2." pattern, 
and "B += A;"
is the appropriate replacement.

Andy

>
> Monty
>


From antlr at jazillian.com  Sat Oct  7 11:04:39 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 07 Oct 2006 14:04:39 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610061334pb5a7453xf0144bb3c52e7a2c@mail.gmail.com>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	
	<45250F8F.8040001@jazillian.com>	
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>	
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>	
	<45256B24.40908@jazillian.com>	
	<30E5071D-094B-4834-8736-40C67E752AF9@cs.usfca.edu>	
	<4526A9CA.80502@jazillian.com>
	<598864c70610061334pb5a7453xf0144bb3c52e7a2c@mail.gmail.com>
Message-ID: <4527EC37.40907@jazillian.com>

Monty Zukowski wrote:

> ...
>
>> > Just for the record I am opposed to the translation you show  here.
>> > That is not at all what I would expect unless it's clear that  those
>> > variables are always constants.
>>
>>
>> Ahh...and therein lies the difference in our approaches. It's not what
>> you'd *expect* because of your background
>> in language tools. But is it what you'd *want* as a customer who wants
>> to replace C code with Java? Answer: customers
>> don't want "JOBOL", and they don't want "Cava". (Although, if they do
>> want C in Java clothes, there's
>> a tool for that: http://ovid.tigris.org/Ephedra/)
>
>
> Note, you missed the fact that it has to be clear that those variables
> are constants.  Obviously, if they are not, then you can't do the
> substitution.

Right.

>
> Also as I was thinking about it, I don't like eliminating the
> variables just because they are constants.  

Right. And thinking about it more, I think I lied, and I'd produce
System.out.println("hello" + " " + "world");
I do, however, attempt to do what real programmers would do.
Like I might see that a single println() call contains a bunch
of constants, all used only once, and so I should combine them.
I don't do that for C to Java, but I do for COBOL, where the nature of
how you declare variables make that a common occurance.

In COBOL, you very often see roughly:
01  MESSAGE
                05 HELLO PIC XXXXX VALUE "HELLO"
                05               PIC X VALUE SPACE
                05 WORLD PIC XXXXXX VALUE "WORLD"
...
WRITE MESSAGE

Here, not only are they constants, but in fact one of them (the space) 
doesn't
even have a name!

> Sometimes programmers do
> things like that to make the code more readable, and crunching it into
> one line again makes it less readable.  Without knowing the intent of
> the programmer I would say it should not do such fancy things as
> variable substitution.  Worse yet, if the string is overridden later,
> or tested against, or things like that, then you've made the code
> harder to maintain by putting the constant everywhere (perhaps
> embedded in other strings).

Yea, this is the sort of thing I struggle with every day.

>
> Monty
>


From rob.hill at blueyonder.co.uk  Sat Oct  7 11:38:09 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Sat, 7 Oct 2006 19:38:09 +0100
Subject: [antlr-interest] minor 3.0b4 bug?
In-Reply-To: <E1GWCKg-00084X-00@gecko>
Message-ID: <20061007183831.2FB9F190A3B@www.antlr.org>

Ahh, I see now. I knew it wasn't a 'real' error since if I added a token
into the paramList rule, the error went away, I just didn't understand where
Alt 2 was coming from.

Thanks!

Rob


> -----Original Message-----
> From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-
> bounces at antlr.org] On Behalf Of John B. Brodie
> Sent: 07 October 2006 14:35
> To: antlr-interest at antlr.org
> Subject: Re: [antlr-interest] minor 3.0b4 bug?
> 
> >...snipped...
> >
> >service	:  LParen paramList* RParen ;
> >paramList
> >	:
> >	;
> >I get the following error :
> >
> >ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
> >D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: Decision
> can
> >match input such as "RParen" using multiple alternatives: 1, 2
> >As a result, alternative(s) 2 were disabled for that input
> >D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g:86:12: The
> following
> >alternatives are unreachable: 2
> >
> >Where is Alt 2?
> >
> >...snipped...
> 
> think of the above two rules as this equivalent
> 
> service : LParen aUniqueRuleName RParen ;
> 
> aUniqueRuleName : /*empty*/ | paramList aUniqueRuleName ;
> 
> paramList : /*empty*/ ;
> 
> the rule introduced by the transformation has two alternatives which, in
> this
> case, are both empty.  leading to the reported ambiguity problems.
> 
> Hope this helps...
>    -jbb



From na.zhangzhei at gmail.com  Sat Oct  7 15:24:45 2006
From: na.zhangzhei at gmail.com (na zhang)
Date: Sat, 7 Oct 2006 18:24:45 -0400
Subject: [antlr-interest] Build CFG from ASTs
Message-ID: <124f59f40610071524t293b21b8q8c6a2ca09a9a7036@mail.gmail.com>

Dear Group,
TinyDT builds upon a pure java nesC parser implemented using antlr. The
output is AST. I wonder if anyone has built the
source level Control Flow Graph (CFG) from those ASTs. I am new here and I
would appreciate a lot if any help is provided.

Regards,
Na
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061007/3c702d35/attachment.html 

From lgcraymer at yahoo.com  Sat Oct  7 15:42:45 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sat, 7 Oct 2006 15:42:45 -0700 (PDT)
Subject: [antlr-interest] Build CFG from ASTs
In-Reply-To: <124f59f40610071524t293b21b8q8c6a2ca09a9a7036@mail.gmail.com>
Message-ID: <20061007224245.73198.qmail@web55901.mail.re3.yahoo.com>

This is easy to do--in building CFGs, you only have to worry about control flow statements--do, for, if/else, while.  You can find code solving an analogous problem--"railroad track" diagrams for grammars--in the ANTLRWorks source.
   
  --Loring

na zhang <na.zhangzhei at gmail.com> wrote:
      Dear Group,
  TinyDT builds upon a pure java nesC parser implemented using antlr. The output is AST. I wonder if anyone has built the 
  source level Control Flow Graph (CFG) from those ASTs. I am new here and I would appreciate a lot if any help is provided. 
   
  Regards,
  Na 



 				
---------------------------------
Do you Yahoo!?
 Next-gen email? Have it all with the  all-new Yahoo! Mail.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061007/3c736c39/attachment.html 

From lgcraymer at yahoo.com  Sat Oct  7 16:12:39 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sat, 7 Oct 2006 16:12:39 -0700 (PDT)
Subject: [antlr-interest] First Yggdrasil release
Message-ID: <20061007231239.44156.qmail@web55908.mail.re3.yahoo.com>

I have posted the first early release of ANTLR Yggdrasil to the "file sharing" area of antlr.org.  This release requires Java 5; I have not gotten around to writing the templates and grammar mods to do the messy typecasting needed to support earlier versions of Java.  This version provides features missing from the baseline ANTLR 3--lexer editing and heterogeneous AST support--but is also a work in progress (user-level error handling, for example, is not yet supported).  I plan to set up a sourceforge project for Yggdrasil in the next few days.
   
  ANTLR Yggdrasil is an ANTLR variant built on the ANTLR 3 recognition engine and (for the near term) StringTemplate.  It has the following features:
 
1.) Strongly typed attributes:  Yggdrasil supports definition of attribute types and attribute variables and provides a very simple attribute algebra.  Attributes are first class syntactic elements of Yggdrasil:  that is, attribute manipulations are primarily done through the attribute algebra and rarely through actions.  Base attribute types include Carrier and Payload for tree manipulation; Payloads (Tokens) are passed intact from input to output tree. 
  2.) Code generation for attribute types:  Yggdrasil generates code for user-defined attribute types, without hindering the user's ability to define classes in the target language.  Yggdrasil also generates a Payload factory to support heterogeneous tree construction. 
  3.) Tree rewrite through attribute manipulations.  Any element in a tree can be assigned to an attribute variable and later instantiated in the tree by referencing the attribute variable.  Attributes--including the type field in payloads--can be set or referenced using Yggdrasil syntax.  This makes a difference for tree grammar generation--perhaps the commonest attribute manipulation in ANTLR 2 was to change the type field of an AST node in an action, where it was essentially invisible and the generated tree recognized the original type, not the modified one. 
  4.) Predicated tree construction.  Construction predicates direct tree construction much the same way that (matching) semantic predicated direct recognition of semantic constructs. 
  5.) Full model/view separation of grammar and target.  All actions (and semantic predicates) are templates; output can be retargeted by replacing the template definition files used by the grammar.  It should be possible to "develop in Java, deliver in C" once Yggdrasil supports a C target.
  6.) Lexical editing (! on characters), keyword and string support (keywords have types, strings are matched by text to provide "keyword in context" support, heterogeneous ASTs (Payload types may vary).
 
Later versions will provide automatic tree grammar generation and "compiled" StringTemplates (to improve retargetability of Yggdrasil and reduce memory usage).
  For more information, check out the manual in the doc directory.
 
Yggdrasil is an outgrowth of my experiences with ANTLR 2.8 and the concepts I presented at the last ANTLR workshop.  Some of those concepts--notably attribute variables and dynamic scoping--in turn grew out of the Oregon ANTLR Cabal discussions.  Thanks, Ter, Monty!
 
--Loring

 		
---------------------------------
 All-new Yahoo! Mail - Fire up a more powerful email and get things done faster.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061007/ed4505ee/attachment.html 

From sohail at taggedtype.net  Sat Oct  7 19:26:36 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Sat, 07 Oct 2006 19:26:36 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <4527E677.5070504@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
	<45267B17.6060107@jazillian.com>
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>
	<4527E677.5070504@jazillian.com>
Message-ID: <1160274396.7022.3.camel@localhost.localdomain>

On Sat, 2006-10-07 at 13:40 -0400, Andy Tripp wrote:
> The getContainingFunction() method is real. 
> It looks backwards
> (while balancing matching braces) for something that looks like a 
> function declaration: a "{"
> preceeded by a ")", with a matching "(" that's preceeded by an ID.
> 
> Crazy, I know :)

Yikes! For me its something like:

functionDefn : <function_defn_syntax>
{setCurrentFunction(function_name);}

Why you need to parse the thing umpteen times, I don't know, but you
might have a valid reason!

Sohail


From kroepke at classdump.org  Sat Oct  7 19:29:53 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sun, 8 Oct 2006 04:29:53 +0200
Subject: [antlr-interest] First Yggdrasil release
In-Reply-To: <20061007231239.44156.qmail@web55908.mail.re3.yahoo.com>
References: <20061007231239.44156.qmail@web55908.mail.re3.yahoo.com>
Message-ID: <0A4FF303-D0B7-42D1-9B55-1CE3141623D8@classdump.org>


On 8. Oct 2006, at 1:12 Uhr, Loring Craymer wrote:

>  6.) Lexical editing (! on characters),

Hi Loring!

Because the file isn't visible yet, a question since I'm impatient:  
How did you implement that? Did you modify the v2 grammars for ANTLR  
and implement the necessary stuff in the runtime, or is it completely  
different and not applicable to v3 main?

cheers,
-k




From lgcraymer at yahoo.com  Sat Oct  7 20:47:58 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sat, 7 Oct 2006 20:47:58 -0700 (PDT)
Subject: [antlr-interest] First Yggdrasil release
In-Reply-To: <0A4FF303-D0B7-42D1-9B55-1CE3141623D8@classdump.org>
Message-ID: <20061008034758.372.qmail@web55905.mail.re3.yahoo.com>

Kay--

Basically, I modified CharStream to implement the Java CharSequence interface and have another CharSequence class to which data can be copied (I need to clean up CharStream to make this a little more seamless).  There are then mods to build Payloads (Tokens) with a reference to the stream, other mods to Lexer, the codegen grammar, and Java.stg.  (i. e., mostly a bunch of small changes that could be moved into the baseline).

The current implementation has a couple of weaknesses.  The output buffer size is fixed at 20KB, and I don't test for overflow and reallocate (easy enough to do, I just haven't yet).  Character copying code should only appear in rules that have edits; I don't do the analysis to detect that yet so the edit code appears with all character matches--I figure that since I am going to overhaul the grammars when I shift to Yggdrasil in Yggdrasil, it makes the most sense to wait until then to add any analysis support.

--Loring

Kay Roepke <kroepke at classdump.org> wrote: 
On 8. Oct 2006, at 1:12 Uhr, Loring Craymer wrote:

>  6.) Lexical editing (! on characters),

Hi Loring!

Because the file isn't visible yet, a question since I'm impatient:  
How did you implement that? Did you modify the v2 grammars for ANTLR  
and implement the necessary stuff in the runtime, or is it completely  
different and not applicable to v3 main?

cheers,
-k





 		
---------------------------------
Do you Yahoo!?
 Get on board. You're invited to try the new Yahoo! Mail.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061007/867b48dd/attachment.html 

From iamhere2 at gmail.com  Sun Oct  8 10:43:13 2006
From: iamhere2 at gmail.com (Igor Trofimov)
Date: Sun, 8 Oct 2006 21:43:13 +0400
Subject: [antlr-interest] ANTLR3 and C# 2.0 Lexer troubles
Message-ID: <e642c6be0610081043x3844f5e2jf1ca2dfecf3da6a0@mail.gmail.com>

Hi, All!

I'm newbie in syntax analysis / lexers / parsers / etc.
Nevertheless, i try build C# lexer/parser with ANTLR. ;)

For a start, i describe _lexer_ grammar from C# language specification in
ANTLR3 grammar syntax, including Unciode classes definitions.
I remove some left-recursion, simplify some definitions using java.g as
template.
ANTLRWorks reports no invalid rules itself (without Cgrammar Check command).

And now, i have some troubles/questions with this LEXER grammar. I hope, you
help me with it.

1. There are some rules in specification in informal form:
    <single-character> ::= Any character except ' (U+0027), \ (U+005C), and
<new-line-character>

    I try define such rules, using '~' syntax:

    SINGLE_CHARACTER :  ~ (NOT_SINGLE_CHARACTER);
    NOT_SINGLE_CHARACTER : '\u0027' | '\u005c' | NEW_LINE_CHARACTER;

    But it dont work properly :(
    Fortunately, expanded version seems to be worked:
     SINGLE_CHARACTER :  ~( '\u000D' | '\u000A' | '\u0085' | '\u2028' |
'\u2029');

    Why the first variant not works? Is it invalid grammar syntax or ANTLR
bug?

2.  There are some rules in specification, which requires some additional
logic to be difined, e.g:

     DECIMAL_DIGIT_CHARACTER
              : UNICODE_CATEGORY_DECIMALDIGITNUMBER  // A Unicode character
of the class Nd
              | UNICODE_CHARACTER_ESCAPE_SEQUENCE    // representing a
character of the class Nd -- ??? How to check this ???

     CONDITIONAL_SYMBOL
               : IDENTIFIER_OR_KEYWORD        // Any identifier-or-keyword
except true or false ??? How to check this ???

3. C# target seems unfinished? It miss some evident "override" keywords, and
some DFA definitions :(

4. And, the last, but most important. My grammar dont works absolutely :(
    And there are no errors reported in grammar, but in ANTLR itself.
   ANTLR tool prints the message:
=====================================================
ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
internal error: org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral(
Grammar.java:1519): invalid char literal: ''
internal error: org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral(
Grammar.java:1519): invalid char literal: ''

internal error: CSharp.g : java.lang.NullPointerException
org.antlr.analysis.NFAToDFAConverter.convertToAcceptState(
NFAToDFAConverter.java:989)
org.antlr.analysis.NFAToDFAConverter.addDFAStateToWorkList(
NFAToDFAConverter.java:953)
org.antlr.analysis.NFAToDFAConverter.findNewDFAStatesAndAddDFATransitions(
NFAToDFAConverter.java:291)
org.antlr.analysis.NFAToDFAConverter.convert(NFAToDFAConverter.java:101)
org.antlr.analysis.DFA.<init>(DFA.java:214)
org.antlr.tool.Grammar.createLookaheadDFA(Grammar.java:763)
org.antlr.tool.Grammar.createLookaheadDFAs(Grammar.java:711)
org.antlr.codegen.Target.performGrammarAnalysis(Target.java:111)
org.antlr.codegen.CodeGenerator.genRecognizer(CodeGenerator.java:284)
org.antlr.Tool.processGrammar(Tool.java:320)
org.antlr.Tool.process(Tool.java:251)
org.antlr.Tool.main(Tool.java:70)

=====================================================

I attach my grammar to this post. May be, i have some terrible fundamental
errors in grammar?
Please, give me the direction to further progress...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061008/a9dca816/attachment-0001.html 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: grammar.zip
Type: application/zip
Size: 12305 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061008/a9dca816/attachment-0001.zip 

From rob.hill at blueyonder.co.uk  Sun Oct  8 12:39:13 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Sun, 8 Oct 2006 20:39:13 +0100
Subject: [antlr-interest] V3.0 error handling..
Message-ID: <20061008193918.CF09E190724@www.antlr.org>

Hi all :)

I want to bomb out of a rule immediately on a fatal condition how do I do it
gracefully in V3? (java code..)

Cheers!

Rob

 



From antlr at jazillian.com  Sun Oct  8 16:51:23 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sun, 08 Oct 2006 19:51:23 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <1160274396.7022.3.camel@localhost.localdomain>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>
	<1160274396.7022.3.camel@localhost.localdomain>
Message-ID: <45298EFB.9040104@jazillian.com>

Sohail Somani wrote:

>On Sat, 2006-10-07 at 13:40 -0400, Andy Tripp wrote:
>  
>
>>The getContainingFunction() method is real. 
>>It looks backwards
>>(while balancing matching braces) for something that looks like a 
>>function declaration: a "{"
>>preceeded by a ")", with a matching "(" that's preceeded by an ID.
>>
>>Crazy, I know :)
>>    
>>
>
>Yikes! For me its something like:
>
>functionDefn : <function_defn_syntax>
>{setCurrentFunction(function_name);}
>
>Why you need to parse the thing umpteen times, I don't know, but you
>might have a valid reason!
>  
>
I have a function that tells me which function I'm in, rather than 
setting a variable
while walking the code, because...

a) I have hundreds of "rules"/"phases", and only a couple need to know 
what function I'm in.
Given that it's not trivial to know when I'm at a function declaration 
(because I'm "walking"
token streams rather than ASTs), it would be a huge waste to keep track 
of that. Basically,
for each token in each file, I'd be checking to figure out if it's a 
function declaration.

b) It's not actually clear, in COBOL, what a function *is*. There are 
paragraphs, which
typically map to a function, but there can also be "stray code" at the 
top of a file that's
not in a paragraph but needs to be in a function.

c) I have a feeling there might be a problem if I move code around. I 
can't think of a specific
example right now, but that's my general thinking for avoiding symbol 
table use if I can - better
to have a single data structure (in my case a token stream) rather than 
two (a token stream
and a symbol table) that need to be kept in sync.

But I agree with your general point: if you really often need to "know 
where you are" then
an AST helps alot. I've found that I rarely need to know "where I am" in 
the source.

Andy

>Sohail
>
>  
>


From parrt at cs.usfca.edu  Sun Oct  8 19:02:03 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 8 Oct 2006 19:02:03 -0700
Subject: [antlr-interest] V3.0 error handling..
In-Reply-To: <20061008193918.CF09E190724@www.antlr.org>
References: <20061008193918.CF09E190724@www.antlr.org>
Message-ID: <0B16A332-5F5C-4BF3-9520-74C064CB4CE6@cs.usfca.edu>

use action @rulecatch {...} and say catch(RecognitionException e)  
{ throw e; }.  Or that should work ;)
Ter
On Oct 8, 2006, at 12:39 PM, Robert Hill wrote:

> Hi all :)
>
> I want to bomb out of a rule immediately on a fatal condition how  
> do I do it
> gracefully in V3? (java code..)
>
> Cheers!
>
> Rob
>
>
>
>


From sohail at taggedtype.net  Sun Oct  8 20:44:02 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Sun, 08 Oct 2006 20:44:02 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45298EFB.9040104@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
	<45267B17.6060107@jazillian.com>
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>
	<4527E677.5070504@jazillian.com>
	<1160274396.7022.3.camel@localhost.localdomain>
	<45298EFB.9040104@jazillian.com>
Message-ID: <1160365442.18004.14.camel@localhost.localdomain>

On Sun, 2006-10-08 at 19:51 -0400, Andy Tripp wrote:
> Sohail Somani wrote:
> 
> I have a function that tells me which function I'm in, rather than 
> setting a variable
> while walking the code, because...
> 
> a) I have hundreds of "rules"/"phases", and only a couple need to know 
> what function I'm in.
> Given that it's not trivial to know when I'm at a function declaration 
> (because I'm "walking"
> token streams rather than ASTs), it would be a huge waste to keep track 
> of that. Basically,
> for each token in each file, I'd be checking to figure out if it's a 
> function declaration.

Its weird that you're walking token streams, but what it seems it that
you're implementing the recursive descent parser by hand...

> b) It's not actually clear, in COBOL, what a function *is*. There are 
> paragraphs, which
> typically map to a function, but there can also be "stray code" at the 
> top of a file that's
> not in a paragraph but needs to be in a function.

I believe there is an unspoken rule that all bets are off with COBOL?

> c) I have a feeling there might be a problem if I move code around. I 
> can't think of a specific
> example right now, but that's my general thinking for avoiding symbol 
> table use if I can - better
> to have a single data structure (in my case a token stream) rather than 
> two (a token stream
> and a symbol table) that need to be kept in sync.

Well, in your case you're managing both. In my case, I just worry about
telling antlr the grammar and managing the symbol table appropriately.

For my compiler, I needed to spit out lots of warnings since it was
basically a cfront type deal, albeit not for C++ (thankfully!) I found
that having a crude symbol table was very easy and natural. I couldn't
imagine re-parsing the token stream just to determine the type of a
variable, something I might need to do more than once. For example, if
you see:

	a.b();

You might need to know if a is a class (this making b a static function
call) or an object. Once you have decided that a is one or the other, I
don't see why you'd do it again...

Since the compiler has been in regular use for about 7-8 months, there
have been a few bug fixes and lots of feature requests. I've found that
having a symbol table available is a great help.

> But I agree with your general point: if you really often need to "know 
> where you are" then
> an AST helps alot. I've found that I rarely need to know "where I am" in 
> the source.

Hmm... I guess I understand.

Thanks,

Sohail


From peter.paulus at nerocmediaware.nl  Mon Oct  9 01:37:00 2006
From: peter.paulus at nerocmediaware.nl (Peter Paulus)
Date: Mon, 9 Oct 2006 10:37:00 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <A99B9CD9-877E-4591-A744-7316DB4F6B52@cs.usfca.edu>
References: <2E909902FD3A03419E3A905908AE3DD4026DFB70@UKNSM201.emea.corp.eds.com>	
	<C5DE89B1-6540-4615-9A75-49564FC05F64@cs.usfca.edu>	
	<45250F8F.8040001@jazillian.com>	
	<598864c70610051221p1248c48dnf070e40aca7e4d0@mail.gmail.com>	
	<598864c70610051225u5062c0bfj34fbd89eb11c4bf2@mail.gmail.com>	
	<45256B24.40908@jazillian.com>
	<598864c70610051423r45a9e3fan6453d6300f5e165b@mail.gmail.com>
	<45266134.8080009@jazillian.com>
	<A99B9CD9-877E-4591-A744-7316DB4F6B52@cs.usfca.edu>
Message-ID: <60E68D32-2297-4539-AC1C-9E4E3A5FC3C8@nerocmediaware.nl>

Hi Terence and Andy,

Just as an annotation of natural language transformations.

Not that I'm an expert on this - just an interested layman - but it  
could be interesting to read up on X-bar theory (http:// 
en.wikipedia.org/wiki/X-bar_theory, http://en.wikipedia.org/wiki/ 
Category:Syntactic_relationships), Government and binding theory  
(http://www.amazon.com/Introduction-Government-Blackwell-Textbooks- 
Linguistics/dp/0631190678) and Principles and Parameters (http:// 
en.wikipedia.org/wiki/Principles_and_parameters, http:// 
www.amazon.com/Introducing-Transformational-Grammar-Principles- 
Parameters/dp/0340740361, Cullicover, Peter W. 1997. Principles and  
Parameters: An Introduction to Syntactic Theory. Oxford: Oxford  
University Press., http://www.oup.com/uk/catalogue/? 
ci=9780198700142). I've read parts of the last book.

With kind regards,
Peter Paulus

On Oct 6, 2006, at 8:33 PM, Terence Parr wrote:
>
>> I guess what I'm doing is more akin to natural language  
>> translation. I'm sure an English to
>> Spanish translator has relatively little logic that does tree  
>> transformation (e.g. putting the
>> adjectives *after* the nouns).
>>
>
>  an interesting analogy.  You are saying that language translation  
> is mostly word for word change and some grammatical changes such as  
> you would see from English to German where the verb's at the end.
>
> Hmm....  Do you have multiple phases also, just declarative rule  
> replacement style?
>
> Ter
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061009/af16d6a6/attachment.html 

From lgcraymer at yahoo.com  Mon Oct  9 01:52:19 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Mon, 9 Oct 2006 01:52:19 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45298EFB.9040104@jazillian.com>
Message-ID: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>

This looks like a good place to jump in.  My experience is that language processing with involves:
1.)  Recognition
2.)  Tree construction
3.)  Constructing data structures for analysis
4.)  Analysis
5.)  Post-analysis tree restructuring
6.)  Output

Steps 3 through 6 are often repeated in complex language processing problems; some steps may be skipped, depending on the problem addressed.  Not all language processors have an output stage--reading config files is an example--and many analyses can be done without special data structures.  A full optimizing compiler will go through all of the steps (including multiple analyses), but we have all written processors that do only steps 1 and 6.

Tree restructuring, in my experience, often makes analysis easier; it is also helpful (and possibly critical) when dealing with languages that deal with very different problem domains.  Yet the recurring discussion in this news group goes something like "real men build trees in actions" (actually, more like "writing action code to build trees is easy (you wimps)") and "no problem needs tree walkers--visitors are more than sufficient".  I came to the conclusion some time ago that the real messages are that "ANTLR 2 rewrite support is inadequate" and "writing tree grammars is painful"--both valid points.

A while back I put together a version of ANTLR with native tree rewrite support and automatic tree grammar generation (I needed a paper for a conference I wanted to go to, and Ter was going to be coauthor--unfortunately, I did not get the work done in time to go the the conference) and released it as ANTLR 2.8.  It did not get widespread use--the licensing terms agreed to by JPL did not sit well with the community--but I have gotten used to rapid turnaround on tree restructuring and tree grammar generation.  That makes a very big difference in how I perceive the cost of working with restructured trees--minimal--and in my willingness to do multi-pass transformations.  I used to find writing tree grammars painfully slow; now I find the problem to be refactoring generated grammars and propagating changes to refactored grammars so mostly I do that by hand.  I need a new tool for the next step, but can live with refactoring and propagating by hand for the moment.  If you are
 working without automatic tree grammar generation, though, demand better:  you are being crippled by a lack of proper tools.

One of the problems I had with ANTLR 2.8 was a lack of an attribute syntax.  If I changed a token type manually, I had to edit the generated grammar to match.  That was annoying; also, I could see that having some sort of syntax to structure data would be very helpful in building data structures for analysis passes.  Then, too, I often find it awkward for grammars to be target-dependent; very often, a grammar that was written for a Java app would be very useful for a C++ app--except for the cost of editing all of the actions and then having the two grammars diverge in the syntax that they recognize (another instance of the maintenance problem).  Then there was the annoyance of writing print statements in actions for output--very inelegant.  Fortunately, Ter solved that problem with StringTemplate.  The others--except for refactoring--are addressed by Yggdrasil (or will be--it will still be a while before I have tree grammar generation properly supported).

The take home message?  It makes a lot more sense to improve the tools than to develop a warped perspective because of their current shortcomings.

--Loring

Andy Tripp <antlr at jazillian.com> wrote: Sohail Somani wrote:

>On Sat, 2006-10-07 at 13:40 -0400, Andy Tripp wrote:
>  
>
>>The getContainingFunction() method is real. 
>>It looks backwards
>>(while balancing matching braces) for something that looks like a 
>>function declaration: a "{"
>>preceeded by a ")", with a matching "(" that's preceeded by an ID.
>>
>>Crazy, I know :)
>>    
>>
>
>Yikes! For me its something like:
>
>functionDefn : 
>{setCurrentFunction(function_name);}
>
>Why you need to parse the thing umpteen times, I don't know, but you
>might have a valid reason!
>  
>
I have a function that tells me which function I'm in, rather than 
setting a variable
while walking the code, because...

a) I have hundreds of "rules"/"phases", and only a couple need to know 
what function I'm in.
Given that it's not trivial to know when I'm at a function declaration 
(because I'm "walking"
token streams rather than ASTs), it would be a huge waste to keep track 
of that. Basically,
for each token in each file, I'd be checking to figure out if it's a 
function declaration.

b) It's not actually clear, in COBOL, what a function *is*. There are 
paragraphs, which
typically map to a function, but there can also be "stray code" at the 
top of a file that's
not in a paragraph but needs to be in a function.

c) I have a feeling there might be a problem if I move code around. I 
can't think of a specific
example right now, but that's my general thinking for avoiding symbol 
table use if I can - better
to have a single data structure (in my case a token stream) rather than 
two (a token stream
and a symbol table) that need to be kept in sync.

But I agree with your general point: if you really often need to "know 
where you are" then
an AST helps alot. I've found that I rarely need to know "where I am" in 
the source.

Andy

>Sohail
>
>  
>



 		
---------------------------------
Do you Yahoo!?
 Get on board. You're invited to try the new Yahoo! Mail.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061009/09989f7f/attachment-0001.html 

From fhinfo at freenet.de  Mon Oct  9 02:02:11 2006
From: fhinfo at freenet.de (Fridi)
Date: Mon, 09 Oct 2006 11:02:11 +0200
Subject: [antlr-interest] Get parent of current AST node
Message-ID: <452A1013.7040108@freenet.de>

I'm new to antlr and sorry, if this is a stupid question...
Is there a way to get the parent of a current AST node?

From dave at badgers-in-foil.co.uk  Mon Oct  9 02:30:00 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Mon, 9 Oct 2006 09:30:00 +0000
Subject: [antlr-interest] Get parent of current AST node
In-Reply-To: <452A1013.7040108@freenet.de>
References: <452A1013.7040108@freenet.de>
Message-ID: <20061009093000.GA9142@badgers-in-foil.co.uk>

On Mon, Oct 09, 2006 at 11:02:11AM +0200, Fridi wrote:
> I'm new to antlr and sorry, if this is a stupid question...
> Is there a way to get the parent of a current AST node?

For antlr v3; supply your own implementation of TreeAdaptor customized
to return instances of DoubleLinkTree (which has the getParent() /
setParent() methods you want).

If you want to access these methods from actions, then you'll also want
to put ASTLabelType=DoubleLinkTree in your grammar's options{} section
to save lots of type-casts.


For antlr v2, I don't remember.  Sorry.  Probably you need to do a
similar trick; make an AST subclass including a 'parent' property and
lots of entries like MY_TOKEN<AST=com.example.MyASTImpl>; in your
grammar's tokens{} section.


ta,
dave

-- 
http://david.holroyd.me.uk/

From Abhijit_Ghonge at infosys.com  Mon Oct  9 02:58:40 2006
From: Abhijit_Ghonge at infosys.com (Abhijit Nandkumar Ghonge)
Date: Mon, 9 Oct 2006 15:28:40 +0530
Subject: [antlr-interest] Token
Message-ID: <D72A054DF5002D4FA6CF14252F7997B8D97E4C@BLRKECMSG13.ad.infosys.com>


Hi people,

            Can anybody help me with this: How can I extract token from
any of the exceptions - RecognitionException, TokenStreamException and
CharStreamException etc? Or do I have to extract it from the exception
string?

           



Abhijit.









**************** CAUTION - Disclaimer *****************
This e-mail contains PRIVILEGED AND CONFIDENTIAL INFORMATION intended solely for the use of the addressee(s). If you are not the intended recipient, please notify the sender by e-mail and delete the original message. Further, you are not to copy, disclose, or distribute this e-mail or its contents to any other person and any such actions are unlawful. This e-mail may contain viruses. Infosys has taken every reasonable precaution to minimize this risk, but is not liable for any damage you may sustain as a result of any virus in this e-mail. You should carry out your own virus checks before opening the e-mail or attachment. Infosys reserves the right to monitor and review the content of all messages sent to or from this e-mail address. Messages sent to or from this e-mail address may be stored on the Infosys e-mail system.
***INFOSYS******** End of Disclaimer ********INFOSYS***
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061009/f211aac2/attachment.html 

From Michiel_Vermandel at axi.be  Mon Oct  9 03:01:40 2006
From: Michiel_Vermandel at axi.be (Michiel Vermandel)
Date: Mon, 9 Oct 2006 12:01:40 +0200
Subject: [antlr-interest] AST nodes in v3
Message-ID: <OF9264BDEF.3DC4FBE6-ONC1257202.0036E09B-C1257202.0037158E@Axi.be>

Hi,

In my Antlr v2.x parser I have something like

directive_statement:
   AXI_DIRECTIVE identifier
   { ## = #([DIRECTIVE_STATEMENT, 'directive_statement'], ##); }

with DIRECTIVE_STATEMENT in my token section.

How do I add such a node to the AST in Antlr v3?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061009/13b33b69/attachment.html 

From dave at badgers-in-foil.co.uk  Mon Oct  9 03:16:40 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Mon, 9 Oct 2006 10:16:40 +0000
Subject: [antlr-interest] AST nodes in v3
In-Reply-To: <OF9264BDEF.3DC4FBE6-ONC1257202.0036E09B-C1257202.0037158E@Axi.be>
References: <OF9264BDEF.3DC4FBE6-ONC1257202.0036E09B-C1257202.0037158E@Axi.be>
Message-ID: <20061009101640.GB9142@badgers-in-foil.co.uk>

On Mon, Oct 09, 2006 at 12:01:40PM +0200, Michiel Vermandel wrote:
> Hi,
> 
> In my Antlr v2.x parser I have something like
> 
> directive_statement:
>    AXI_DIRECTIVE identifier
>    { ## = #([DIRECTIVE_STATEMENT, 'directive_statement'], ##); }
> 
> with DIRECTIVE_STATEMENT in my token section.
> 
> How do I add such a node to the AST in Antlr v3?

directive_statement
	:	AXI_DIRECTIVE identifier
		-> ^(DIRECTIVE_STATEMENT AXI_DIRECTIVE identifier)
	;


ta,
dave

-- 
http://david.holroyd.me.uk/

From kroepke at classdump.org  Mon Oct  9 03:42:11 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Mon, 9 Oct 2006 12:42:11 +0200
Subject: [antlr-interest] AST nodes in v3
In-Reply-To: <20061009101640.GB9142@badgers-in-foil.co.uk>
References: <OF9264BDEF.3DC4FBE6-ONC1257202.0036E09B-C1257202.0037158E@Axi.be>
	<20061009101640.GB9142@badgers-in-foil.co.uk>
Message-ID: <562E6E58-1AC5-4ED2-9255-2D6E9A15D273@classdump.org>


On 9. Oct 2006, at 12:16 Uhr, David Holroyd wrote:

> On Mon, Oct 09, 2006 at 12:01:40PM +0200, Michiel Vermandel wrote:
>>
>> directive_statement:
>>    AXI_DIRECTIVE identifier
>>    { ## = #([DIRECTIVE_STATEMENT, 'directive_statement'], ##); }
>>
>> with DIRECTIVE_STATEMENT in my token section.
>>
>> How do I add such a node to the AST in Antlr v3?
>
> directive_statement
> 	:	AXI_DIRECTIVE identifier
> 		-> ^(DIRECTIVE_STATEMENT AXI_DIRECTIVE identifier)
> 	;

To elaborate a bit:

You can use any combination of
	* copy the information from another token to the imaginary token
	* just set the text of an imaginary token

Suppose you have the rule

directive_statement
	:	ad=AXI_DIRECTIVE identifier
	;

and want to

1) Just copy the info (type, line, column):
	-> (DIRECTIVE_STATEMENT[$ad] AXI_DIRECTIVE identifier)
	(this isn't too useful in this example, as you could just make the  
AXI_DIRECTIVE the root node, but you'd use it to set the type of the  
imaginary token to the type of a different real token, e.g. the  
opening '{' of a block)
2) Just set the text but keep the token type of DIRECTIVE_STATEMENT  
(I guess this is what you actually wanted to know ;):
	-> (DIRECTIVE_STATEMENT["directive statement"] AXI_DIRECTIVE  
identifier)
3) Set both:
	-> (DIRECTIVE_STATEMENT[$ad, "directive statement"] AXI_DIRECTIVE  
identifier)

HTH,
-k




From kroepke at classdump.org  Mon Oct  9 03:47:20 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Mon, 9 Oct 2006 12:47:20 +0200
Subject: [antlr-interest] AST nodes in v3
In-Reply-To: <562E6E58-1AC5-4ED2-9255-2D6E9A15D273@classdump.org>
References: <OF9264BDEF.3DC4FBE6-ONC1257202.0036E09B-C1257202.0037158E@Axi.be>
	<20061009101640.GB9142@badgers-in-foil.co.uk>
	<562E6E58-1AC5-4ED2-9255-2D6E9A15D273@classdump.org>
Message-ID: <3AC17732-BBB0-4190-8C51-9BB6CD81C2D9@classdump.org>


On 9. Oct 2006, at 12:42 Uhr, Kay Roepke wrote:

> 1) Just copy the info (type, line, column):
> 	-> (DIRECTIVE_STATEMENT[$ad] AXI_DIRECTIVE identifier)
> 	(this isn't too useful in this example, as you could just make the  
> AXI_DIRECTIVE the root node, but you'd use it to set the type of  
> the imaginary token to the type of a different real token, e.g. the  
> opening '{' of a block)
> 2) Just set the text but keep the token type of DIRECTIVE_STATEMENT  
> (I guess this is what you actually wanted to know ;):
> 	-> (DIRECTIVE_STATEMENT["directive statement"] AXI_DIRECTIVE  
> identifier)
> 3) Set both:
> 	-> (DIRECTIVE_STATEMENT[$ad, "directive statement"] AXI_DIRECTIVE  
> identifier)

Oops, I'm missing the ^ in front of the rewrites, of course. Just to  
be complete.

-k




From fhinfo at freenet.de  Mon Oct  9 04:23:44 2006
From: fhinfo at freenet.de (Fridi)
Date: Mon, 09 Oct 2006 13:23:44 +0200
Subject: [antlr-interest] Get parent of current AST node
In-Reply-To: <20061009093000.GA9142@badgers-in-foil.co.uk>
References: <452A1013.7040108@freenet.de>
	<20061009093000.GA9142@badgers-in-foil.co.uk>
Message-ID: <452A3140.7070505@freenet.de>

An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061009/4841a812/attachment.html 

From kroepke at classdump.org  Mon Oct  9 05:03:48 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Mon, 9 Oct 2006 14:03:48 +0200
Subject: [antlr-interest] Token
In-Reply-To: <D72A054DF5002D4FA6CF14252F7997B8D97E4C@BLRKECMSG13.ad.infosys.com>
References: <D72A054DF5002D4FA6CF14252F7997B8D97E4C@BLRKECMSG13.ad.infosys.com>
Message-ID: <A32DA6AA-1F1B-42DE-B6F2-A77D26B3B209@classdump.org>


On 9. Oct 2006, at 11:58 Uhr, Abhijit Nandkumar Ghonge wrote:

>  Can anybody help me with this: How can I extract token from
> any of the exceptions - RecognitionException, TokenStreamException and
> CharStreamException etc? Or do I have to extract it from the exception
> string?

For ANTLR v2 I don't think the token is stored in the exceptions,  
unfortunately. You might have to extract it manually.
In v3 the token itself is passed to the exception making the whole  
thing a lot easier.

-k




From dave at badgers-in-foil.co.uk  Mon Oct  9 05:36:51 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Mon, 9 Oct 2006 12:36:51 +0000
Subject: [antlr-interest] Get parent of current AST node
In-Reply-To: <452A3140.7070505@freenet.de>
References: <452A1013.7040108@freenet.de>
	<20061009093000.GA9142@badgers-in-foil.co.uk>
	<452A3140.7070505@freenet.de>
Message-ID: <20061009123651.GA11499@badgers-in-foil.co.uk>

On Mon, Oct 09, 2006 at 01:23:44PM +0200, Fridi wrote:
> Dave, thanks for the answer.
> 
> I use v2.7.
> If I would sublcass AST, how can I tell ANTLR to create instances of my
> implementation?

I just found the docs that I think will help:

  http://www.antlr.org/doc/trees.html#_bb11


ta,
dave

-- 
http://david.holroyd.me.uk/

From Abhijit_Ghonge at infosys.com  Mon Oct  9 06:15:54 2006
From: Abhijit_Ghonge at infosys.com (Abhijit Nandkumar Ghonge)
Date: Mon, 9 Oct 2006 18:45:54 +0530
Subject: [antlr-interest] (no subject)
Message-ID: <D72A054DF5002D4FA6CF14252F7997B8D97E50@BLRKECMSG13.ad.infosys.com>


Hi Kay,

      The RecognitionException does require the token to be passed as
argument. But there is no method as to get the token, just as we have
getColumn() and getLine() methods on RecognitionException object.



      Its ok I may extract it from localized message of
RecognitionException.



Thank you.



Abhijit.







-----Original Message-----

On 9. Oct 2006, at 11:58 Uhr, Abhijit Nandkumar Ghonge wrote:



>  Can anybody help me with this: How can I extract token from any of

> the exceptions - RecognitionException, TokenStreamException and

> CharStreamException etc? Or do I have to extract it from the exception


> string?



For ANTLR v2 I don't think the token is stored in the exceptions,
unfortunately. You might have to extract it manually.

In v3 the token itself is passed to the exception making the whole thing
a lot easier.



-k















**************** CAUTION - Disclaimer *****************
This e-mail contains PRIVILEGED AND CONFIDENTIAL INFORMATION intended solely for the use of the addressee(s). If you are not the intended recipient, please notify the sender by e-mail and delete the original message. Further, you are not to copy, disclose, or distribute this e-mail or its contents to any other person and any such actions are unlawful. This e-mail may contain viruses. Infosys has taken every reasonable precaution to minimize this risk, but is not liable for any damage you may sustain as a result of any virus in this e-mail. You should carry out your own virus checks before opening the e-mail or attachment. Infosys reserves the right to monitor and review the content of all messages sent to or from this e-mail address. Messages sent to or from this e-mail address may be stored on the Infosys e-mail system.
***INFOSYS******** End of Disclaimer ********INFOSYS***
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061009/ea834aed/attachment-0001.html 

From sohail at taggedtype.net  Mon Oct  9 09:48:54 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Mon, 09 Oct 2006 09:48:54 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
Message-ID: <1160412534.8914.4.camel@localhost.localdomain>

On Mon, 2006-10-09 at 01:52 -0700, Loring Craymer wrote:
> The take home message?  It makes a lot more sense to improve the tools
> than to develop a warped perspective because of their current
> shortcomings.

I think Andy's (warped?) views have stirred up a lot of interesting
threads!


From rob.hill at blueyonder.co.uk  Mon Oct  9 13:41:44 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Mon, 9 Oct 2006 21:41:44 +0100
Subject: [antlr-interest] V3.0b Internal Error...
Message-ID: <20061009204145.7DF631906BB@www.antlr.org>

I have a rule in my grammar:

sqlTransfer[Service s]
	:   ( Select |  Update | Insert | Delete )
		param=Identifier Using mapping=Identifier Semi 	
	{
			//some Java Code...
	}  
	-> ^(SQLCODE )

Which generates the following

ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
internal error: D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g :
java.lang.IllegalArgumentException: Can't find template matchSetTrack.st
org.antlr.stringtemplate.StringTemplateGroup.lookupTemplate(StringTemplateGr
oup.java:485)
......

however if I remove the brackets round the first set (select..Delete) the
error goes away.
I'm just trying to get it to emit a branch for this rule, it doesn't matter
what I put in the re-write, I still get the error if the brackets are there.
Also, if I remove the rewrite , the error goes away.
Am I doing something wrong?
Cheers,
Rob





From dave at badgers-in-foil.co.uk  Mon Oct  9 14:53:48 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Mon, 9 Oct 2006 21:53:48 +0000
Subject: [antlr-interest] V3.0b Internal Error...
In-Reply-To: <20061009204145.7DF631906BB@www.antlr.org>
References: <20061009204145.7DF631906BB@www.antlr.org>
Message-ID: <20061009215347.GA18000@badgers-in-foil.co.uk>

Hi,

On Mon, Oct 09, 2006 at 09:41:44PM +0100, Robert Hill wrote:
> I have a rule in my grammar:
> 
> sqlTransfer[Service s]
> 	:   ( Select |  Update | Insert | Delete )
> 		param=Identifier Using mapping=Identifier Semi 	
> 	{
> 			//some Java Code...
> 	}  
> 	-> ^(SQLCODE )
> 
> Which generates the following
> 
> ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
> internal error: D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g :
> java.lang.IllegalArgumentException: Can't find template matchSetTrack.st
> org.antlr.stringtemplate.StringTemplateGroup.lookupTemplate(StringTemplateGr
> oup.java:485)
> ......
> 
> however if I remove the brackets round the first set (select..Delete) the
> error goes away.
> I'm just trying to get it to emit a branch for this rule, it doesn't matter
> what I put in the re-write, I still get the error if the brackets are there.
> Also, if I remove the rewrite , the error goes away.

Ter has said something about this in the past...

  http://www.antlr.org/pipermail/antlr-interest/2006-August/017341.html

...seems it's something unfinished in current the v3 releases.

You may be able to work around it by putting Select|Update|Insert|Delete
into a subrule (I've not tried it, so sorry if it doesn't actually work).


ta,
dave

-- 
http://david.holroyd.me.uk/

From dave at badgers-in-foil.co.uk  Mon Oct  9 14:56:17 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Mon, 9 Oct 2006 21:56:17 +0000
Subject: [antlr-interest] V3.0b Internal Error...
In-Reply-To: <20061009215347.GA18000@badgers-in-foil.co.uk>
References: <20061009204145.7DF631906BB@www.antlr.org>
	<20061009215347.GA18000@badgers-in-foil.co.uk>
Message-ID: <20061009215617.GB18000@badgers-in-foil.co.uk>

Oops,

On Mon, Oct 09, 2006 at 09:53:48PM +0000, David Holroyd wrote:
> On Mon, Oct 09, 2006 at 09:41:44PM +0100, Robert Hill wrote:
> > I have a rule in my grammar:
> > 
> > sqlTransfer[Service s]
> > 	:   ( Select |  Update | Insert | Delete )
> > 		param=Identifier Using mapping=Identifier Semi 	
> > 	{
> > 			//some Java Code...
> > 	}  
> > 	-> ^(SQLCODE )
> > 
> > Which generates the following
> > 
> > ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006
> > internal error: D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g :
> > java.lang.IllegalArgumentException: Can't find template matchSetTrack.st
> > org.antlr.stringtemplate.StringTemplateGroup.lookupTemplate(StringTemplateGr
> > oup.java:485)
> > ......
> > 
> > however if I remove the brackets round the first set (select..Delete) the
> > error goes away.
> > I'm just trying to get it to emit a branch for this rule, it doesn't matter
> > what I put in the re-write, I still get the error if the brackets are there.
> > Also, if I remove the rewrite , the error goes away.
> 
> Ter has said something about this in the past...
> 
>   http://www.antlr.org/pipermail/antlr-interest/2006-August/017341.html
> 
> ...seems it's something unfinished in current the v3 releases.
> 
> You may be able to work around it by putting Select|Update|Insert|Delete
> into a subrule (I've not tried it, so sorry if it doesn't actually work).

I should have said 'another rule', not 'a subrule'.


ta,
dave

-- 
http://david.holroyd.me.uk/

From rob.hill at blueyonder.co.uk  Mon Oct  9 15:06:32 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Mon, 9 Oct 2006 23:06:32 +0100
Subject: [antlr-interest] V3.0b Internal Error...
In-Reply-To: <20061009215617.GB18000@badgers-in-foil.co.uk>
Message-ID: <20061009220632.5D02F1906F1@www.antlr.org>

Thanks for the link David.. I'd already done a work around which was just as
you'd said :)

sqlTransfer[Service s]
	: Select sqlParams[s] 		-> ^(SQLSELECT sqlParams)
	| Update sqlParams[s] 		-> ^(SQLUPDATE sqlParams)
	| Insert sqlParams[s] 		-> ^(SQLINSERT sqlParams)
	| Delete sqlParams[s] 		-> ^(SQLDELETE sqlParams)
	;
sqlParams[Service s]
	:	Identifier Using! Identifier Semi! 	
	{.....}
	;

Which is working fine, I didn't know whether anyone had come across this
before. Also I seem to remember Ter trying to produce an internal error,
though I don't think it was this one! 

Cheers!

Rob




> -----Original Message-----
> From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-
> bounces at antlr.org] On Behalf Of David Holroyd
> Sent: 09 October 2006 22:56
> To: antlr-interest at antlr.org
> Subject: Re: [antlr-interest] V3.0b Internal Error...
> 
> Oops,
> 
> On Mon, Oct 09, 2006 at 09:53:48PM +0000, David Holroyd wrote:
> > On Mon, Oct 09, 2006 at 09:41:44PM +0100, Robert Hill wrote:
> > > I have a rule in my grammar:
> > >
> > > sqlTransfer[Service s]
> > > 	:   ( Select |  Update | Insert | Delete )
> > > 		param=Identifier Using mapping=Identifier Semi
> > > 	{
> > > 			//some Java Code...
> > > 	}
> > > 	-> ^(SQLCODE )
> > >
> > > Which generates the following
> > >
> > > ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-
> 2006
> > > internal error: D:\ActiveProjects\IdeaProjects\Jtest1\src\SGenParser.g
> :
> > > java.lang.IllegalArgumentException: Can't find template
> matchSetTrack.st
> > >
> org.antlr.stringtemplate.StringTemplateGroup.lookupTemplate(StringTemplate
> Gr
> > > oup.java:485)
> > > ......
> > >
> > > however if I remove the brackets round the first set (select..Delete)
> the
> > > error goes away.
> > > I'm just trying to get it to emit a branch for this rule, it doesn't
> matter
> > > what I put in the re-write, I still get the error if the brackets are
> there.
> > > Also, if I remove the rewrite , the error goes away.
> >
> > Ter has said something about this in the past...
> >
> >   http://www.antlr.org/pipermail/antlr-interest/2006-
> August/017341.html
> >
> > ...seems it's something unfinished in current the v3 releases.
> >
> > You may be able to work around it by putting Select|Update|Insert|Delete
> > into a subrule (I've not tried it, so sorry if it doesn't actually
> work).
> 
> I should have said 'another rule', not 'a subrule'.
> 
> 
> ta,
> dave
> 
> --
> http://david.holroyd.me.uk/



From r_balaji82 at yahoo.com  Tue Oct 10 04:11:24 2006
From: r_balaji82 at yahoo.com (Balaji Ramasubbu)
Date: Tue, 10 Oct 2006 04:11:24 -0700 (PDT)
Subject: [antlr-interest] Undefined first referenced symbol
	__start_cp_handler ANTLRException.o
Message-ID: <20061010111125.33471.qmail@web57706.mail.re3.yahoo.com>

Hi All,
       I'm using antlr 2.6.0. I'm getting the following ld error. Could anyone pls help me.
   
  ld: warning: symbol `TokenStream virtual table' has differing sizes:
        (file Main.o value=0x18; file /users/balaji/antlr/cpp/CharScanner.o value=0x20);
        Main.o definition taken
ld: warning: symbol `TokenStream virtual table' has differing sizes:
        (file Main.o value=0x18; file /users/balaji/antlr/cpp/TokenStreamBasicFilter.o value=0x20);
        Main.o definition taken
ld: warning: symbol `TokenStream virtual table' has differing sizes:
        (file Main.o value=0x18; file /users/balaji/antlr/cpp/TokenStreamHiddenTokenFilter.o value=0x20);
        Main.o definition taken
ld: warning: symbol `TokenStream virtual table' has differing sizes:
        (file Main.o value=0x18; file /users/balaji/antlr/cpp/TokenStreamSelector.o value=0x20);
        Main.o definition taken
Undefined                       first referenced
 symbol                             in file
__start_cp_handler                  /users/balaji/antlr/cpp/ANTLRException.o
ld: fatal: Symbol referencing errors. No output written to srcwrap_20
collect2: ld returned 1 exit status
make: *** [srcwrap_20] Error 1


 		
---------------------------------
Get your email and more, right on the  new Yahoo.com 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/34eeedb0/attachment.html 

From ric.klaren at gmail.com  Tue Oct 10 04:17:01 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Tue, 10 Oct 2006 13:17:01 +0200
Subject: [antlr-interest] Undefined first referenced symbol
	__start_cp_handler ANTLRException.o
In-Reply-To: <20061010111125.33471.qmail@web57706.mail.re3.yahoo.com>
References: <20061010111125.33471.qmail@web57706.mail.re3.yahoo.com>
Message-ID: <bc607a4e0610100417wf7feed5wec3737d9dc6c3ca9@mail.gmail.com>

Hi,

On 10/10/06, Balaji Ramasubbu <r_balaji82 at yahoo.com> wrote:
> ld: warning: symbol `TokenStream virtual table' has differing sizes:
>         (file Main.o value=0x18; file
> /users/balaji/antlr/cpp/CharScanner.o value=0x20);
>         Main.o definition taken

Looks like you have stale files lying around your build environment.
Or you're linking a library compiled with another compiler or compiler
settings to your project. Rebuild everything (support library and
project) with the same compiler and the same compiler settings, that
should probably solve it.

Cheers,

Ric

From kristian.marinkovic at porsche.co.at  Tue Oct 10 04:43:09 2006
From: kristian.marinkovic at porsche.co.at (Kristian Marinkovic)
Date: Tue, 10 Oct 2006 13:43:09 +0200
Subject: [antlr-interest] rules with parameters are not equivalent to rules
	without parameters
Message-ID: <OFFA141966.BE7F5AA3-ONC1257203.003EC7E5-C1257203.004029FA@porsche.co.at>


Hello,

i'm trying to understand why antlr is generating different code for rules
with parameters and rules without parameters.

I assumed that the 2 examples below are equivalent?!

example without parameter:

a : "AAA";
b : "BBB";
c : "CCC";

startRule : (body)*;

body : (a | b) COL c SEMIC {//do sth};


example with parameter:

startRule : (body)*;

body
{
      String a = null;
      String b = null;
}
:
( {a = a_sub();} | {b = b_sub();} ) COL c SEMIC {//do sth};;

a_sub returns [String a] : a { a = "AAA"; //alt. get it from token};
b_sub returns [String b] : b { b =" BBB"; //alt. get it from token};

Is there another way i can solve this? Because the parser with the
parameter is not deterministic! I'm using Antlr 2.7.5

g,
kris


From jbb at acm.org  Tue Oct 10 06:56:46 2006
From: jbb at acm.org (John B. Brodie)
Date: Tue, 10 Oct 2006 09:56:46 -0400
Subject: [antlr-interest] rules with parameters are not equivalent to
	rules	without parameters
In-Reply-To: <OFFA141966.BE7F5AA3-ONC1257203.003EC7E5-C1257203.004029FA@porsche.co.at>
	(message from Kristian Marinkovic on Tue, 10 Oct 2006 13:43:09 +0200)
References: <OFFA141966.BE7F5AA3-ONC1257203.003EC7E5-C1257203.004029FA@porsche.co.at>
Message-ID: <E1GXI6A-0004Xk-00@gecko>

>( {a = a_sub();} | {b = b_sub();} ) COL c SEMIC {//do sth};;
>
>a_sub returns [String a] : a { a = "AAA"; /*alt. get it from token*/};
>b_sub returns [String b] : b { b =" BBB"; /*alt. get it from token*/};

do not bury the reference to a_sub (| b_sub) in actions - remove the {}'s

body : { String a=null; String b=null; }
   ( a=a_sub | b=b_sub ) COL c SEMIC {/*do something*/};

Hope this helps...
   -jbb

From kristian.marinkovic at porsche.co.at  Tue Oct 10 07:07:46 2006
From: kristian.marinkovic at porsche.co.at (Kristian Marinkovic)
Date: Tue, 10 Oct 2006 16:07:46 +0200
Subject: [antlr-interest] WG: RE: RE: rules with parameters are not
 equivalent to ruleswithout parameters
Message-ID: <OF1A481A00.F55C0FA3-ONC1257203.004D957C-C1257203.004D6782@porsche.co.at>


Hi Remco and John,

thank you very much!!!

a=a_sub did the trick! :)

g,
kris


                                                                           
             "Remco van                                                    
             Engelen"                                                      
             <Remco.van.Engele                                          An 
             n at asml.com>                "Kristian Marinkovic"              
                                        <kristian.marinkovic at porsche.co.at 
             10.10.2006 14:07           >                                  
                                                                     Kopie 
                                                                           
                                                                     Thema 
                                        RE: RE: [antlr-interest] rules     
                                        with parameters are not equivalent 
                                        to ruleswithout parameters         
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           




Hi Kristian,

Sorry, my bad ;-) It should be:

( a=a_sub | b=b_sub) COL c SEMIC {//do sth};


With the notation a:a_sub you assign to a the AST that is returned by the
rule a_sub, not the return value. If a_sub were a lexer rule, a:a_sub would
return the token of a_sub into a, and you could use the getText() method to
access the token text (this is also a typical idiom to use; but it only
work for lexer rules, not parser rules).


Regards


Remco,
From: Kristian Marinkovic [mailto:kristian.marinkovic at porsche.co.at]
Sent: Tue 10/10/2006 2:05 PM
To: Remco van Engelen
Subject: RE: RE: [antlr-interest] rules with parameters are not equivalent
to ruleswithout parameters



Hi Remco,

the problem is indeed, that ANTLR can't 'see' the rule.
I already tried to change the rules as you suggested
but a and b are not assigned with the desired value.
ANTLR just reports: warning:Rule 'a_sub' returns a value

generated code:
String a = null;
String b = null;
...
switch ( LA(1)) {
   case LITERAL_AAA:
  {
   a_sub();
   break;
                  }



             "Remco van
             Engelen"
             <Remco.van.Engele                                          An
             n at asml.com>                "Kristian Marinkovic"
                                        <kristian.marinkovic at porsche.co.at
             10.10.2006 13:53           >
                                                                     Kopie

                                                                     Thema
                                        RE: [antlr-interest] rules with
                                        parameters are not equivalent to
                                        ruleswithout parameters










It seems to me you are calling the subrules directly from within action
code blocks, where ANTLR cannot 'see' them (ANTLR does not look into your
action code). You should be fine if you rewrite it as follows:

body
{
      String a = null;
      String b = null;
}
:
( a:a_sub | b: b_sub) COL c SEMIC {//do sth};

Regards,

Remco,

From: antlr-interest-bounces at antlr.org on behalf of Kristian Marinkovic
Sent: Tue 10/10/2006 1:43 PM
To: antlr-interest at antlr.org
Subject: [antlr-interest] rules with parameters are not equivalent to
ruleswithout parameters




Hello,

i'm trying to understand why antlr is generating different code for rules
with parameters and rules without parameters.

I assumed that the 2 examples below are equivalent?!

example without parameter:

a : "AAA";
b : "BBB";
c : "CCC";

startRule : (body)*;

body : (a | b) COL c SEMIC {//do sth};


example with parameter:

startRule : (body)*;

body
{
      String a = null;
      String b = null;
}
:
( {a = a_sub();} | {b = b_sub();} ) COL c SEMIC {//do sth};;

a_sub returns [String a] : a { a = "AAA"; //alt. get it from token};
b_sub returns [String b] : b { b =" BBB"; //alt. get it from token};

Is there another way i can solve this? Because the parser with the
parameter is not deterministic! I'm using Antlr 2.7.5

g,
kris





-- The information contained in this communication and any attachments is
confidential and may be privileged, and is for the sole use of the intended
recipient(s). Any unauthorized review, use, disclosure or distribution is
prohibited. If you are not the intended recipient, please notify the sender
immediately by replying to this message and destroy all copies of this
message and any attachments. ASML is neither liable for the proper and
complete transmission of the information contained in this communication,
nor for any delay in its receipt.







-- The information contained in this communication and any attachments is
confidential and may be privileged, and is for the sole use of the intended
recipient(s). Any unauthorized review, use, disclosure or distribution is
prohibited. If you are not the intended recipient, please notify the sender
immediately by replying to this message and destroy all copies of this
message and any attachments. ASML is neither liable for the proper and
complete transmission of the information contained in this communication,
nor for any delay in its receipt.




From ric.klaren at gmail.com  Tue Oct 10 07:06:55 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Tue, 10 Oct 2006 16:06:55 +0200
Subject: [antlr-interest] rules with parameters are not equivalent to
	rules without parameters
In-Reply-To: <OFFA141966.BE7F5AA3-ONC1257203.003EC7E5-C1257203.004029FA@porsche.co.at>
References: <OFFA141966.BE7F5AA3-ONC1257203.003EC7E5-C1257203.004029FA@porsche.co.at>
Message-ID: <bc607a4e0610100706h25011916gf2b1421e7724d275@mail.gmail.com>

On 10/10/06, Kristian Marinkovic <kristian.marinkovic at porsche.co.at> wrote:
> i'm trying to understand why antlr is generating different code for rules
> with parameters and rules without parameters.

I assume you pruned your example a bit? E.g. removed the lexer and
parser definitions?

> I assumed that the 2 examples below are equivalent?!
>
> example without parameter:
>
> a : "AAA";
> b : "BBB";
> c : "CCC";

I assume you have a lexer that supplies the tokens "AAA" etc.? If
these are meant to be lexer rules then the name should be in upper
case. (and in that case you should reference the tokens in the parser
rules below)

> startRule : (body)*;

It's best to add an EOF check after the start rule:

startRule : (body)* EOF;

> body : (a | b) COL c SEMIC {//do sth};

> example with parameter:
>
> startRule : (body)*;
>
> body
> {
>       String a = null;
>       String b = null;
> }
> :
> ( {a = a_sub();} | {b = b_sub();} ) COL c SEMIC {//do sth};;

I think you meant:

( a = a_sub | b = b_sub ) COL c SEMIC {//do sth};;

The way you wrote it down you're calling the parser rules from the
action code which is probably not what you want.

> a_sub returns [String a] : a { a = "AAA"; //alt. get it from token};
> b_sub returns [String b] : b { b =" BBB"; //alt. get it from token};

Shouldn't these read:

a_sub returns [String a] : t:AAA { a = t.getText(); //alt. get it from token};
b_sub returns [String b] : t:BBB { b = t.getText(); //alt. get it from token};

Or alternatively:

body
{
      String the_string = null;
}
:
( t1:AAA { the_string = t1.getText();}
| t2:BBB { the_string = t2.getText();}
) COL c SEMIC {//do sth};;

Cheers,

Ric

From Abhijit_Ghonge at infosys.com  Tue Oct 10 04:28:36 2006
From: Abhijit_Ghonge at infosys.com (Abhijit Nandkumar Ghonge)
Date: Tue, 10 Oct 2006 16:58:36 +0530
Subject: [antlr-interest] interpretation '\t'
Message-ID: <D72A054DF5002D4FA6CF14252F7997B8D97E51@BLRKECMSG13.ad.infosys.com>


Hi all,

            If there is any "parsing exception", it gives me the column
information in the console. However, the column number erroneous since
it interprets \t to be certain number of characters. Can I, by any
means, set the number of columns for the \t. For example, can I set \t
as 10 spaces or 4 spaces in my grammer file.



            Please help.



Regards,

Abhijit.







**************** CAUTION - Disclaimer *****************
This e-mail contains PRIVILEGED AND CONFIDENTIAL INFORMATION intended solely for the use of the addressee(s). If you are not the intended recipient, please notify the sender by e-mail and delete the original message. Further, you are not to copy, disclose, or distribute this e-mail or its contents to any other person and any such actions are unlawful. This e-mail may contain viruses. Infosys has taken every reasonable precaution to minimize this risk, but is not liable for any damage you may sustain as a result of any virus in this e-mail. You should carry out your own virus checks before opening the e-mail or attachment. Infosys reserves the right to monitor and review the content of all messages sent to or from this e-mail address. Messages sent to or from this e-mail address may be stored on the Infosys e-mail system.
***INFOSYS******** End of Disclaimer ********INFOSYS***
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/0da78538/attachment.html 

From antlr at jazillian.com  Tue Oct 10 08:12:35 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Tue, 10 Oct 2006 11:12:35 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <1160365442.18004.14.camel@localhost.localdomain>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>
	<1160365442.18004.14.camel@localhost.localdomain>
Message-ID: <452BB863.1040103@jazillian.com>

Sohail Somani wrote:

>
>>Its weird that you're walking token streams, but what it seems it that
>>you're implementing the recursive descent parser by hand...
>>    
>>
But a parser converts a token stream to an AST, I'm not using an AST, 
but dealing with
the stream directly because that seems easier to me. I find it easier to 
search for
pattern "f(...) {" to look for a function, rather than search a tree for 
a node of type
FUNCTION_DECLARATION.

>>    
>>
>>b) It's not actually clear, in COBOL, what a function *is*. There are 
>>paragraphs, which
>>typically map to a function, but there can also be "stray code" at the 
>>top of a file that's
>>not in a paragraph but needs to be in a function.
>>    
>>
>
>I believe there is an unspoken rule that all bets are off with COBOL?
>  
>
Yes, I suppose. But even with C and C++, what seems simple may not be. 
For example, you'd think that
struct person p[100];
might correspond to a single line of Java, but it doesn't (you need to 
initialize the
array). So suddenly, out of nowhere, you may have to add a static block 
of code. That's
a typical one-to-many type of thing.

>  
>
>>c) I have a feeling there might be a problem if I move code around. I 
>>can't think of a specific
>>example right now, but that's my general thinking for avoiding symbol 
>>table use if I can - better
>>to have a single data structure (in my case a token stream) rather than 
>>two (a token stream
>>and a symbol table) that need to be kept in sync.
>>    
>>
>
>Well, in your case you're managing both. In my case, I just worry about
>telling antlr the grammar and managing the symbol table appropriately.
>
>For my compiler, I needed to spit out lots of warnings since it was
>basically a cfront type deal, albeit not for C++ (thankfully!) I found
>that having a crude symbol table was very easy and natural. I couldn't
>imagine re-parsing the token stream just to determine the type of a
>variable, something I might need to do more than once. For example, if
>you see:
>
>	a.b();
>
>You might need to know if a is a class (this making b a static function
>call) or an object. Once you have decided that a is one or the other, I
>don't see why you'd do it again...
>  
>
because it may certainly have changed since you last looked at it..in 
other words, the symbol
table can be a mess to maintain. In my case, the return type of b() may 
have change, the name of it
may have changed, its argument types may have changed.

Also, my tool does not have to be fast - if it takes an hour to 
translate some code, when it could
have taken 2 seconds if I had designed it "right", that's ok.



From j.stovin at zoo-tech.com  Tue Oct 10 08:42:45 2006
From: j.stovin at zoo-tech.com (John Stovin)
Date: Tue, 10 Oct 2006 16:42:45 +0100
Subject: [antlr-interest] (no subject)
Message-ID: <176AB0A0ADC4734B8FE888D53E75D9D502022135@s15shefsrv.zoodigitalgroup.com>

Hi,

I'm a bit of an ANTLR newbie, and I'm trying to put together a parser for my
Domain Specific Language. 

I'm not sure if this is a bug in ANTLR 3b4. I'm using language=CSharp.

Here's a snippet of my grammar file:

	scope_block [SymbolTable s] :
		id = IDENTIFIER block[s, $id.Text] |
		block[s, ""]
		;
	
	block [SymbolTable s, string name] :
		'{' { s.PushScope(name); } 
		element[s]* 
		'}' { s.PopScope(); } 
		;

A scope block is series of elements surrounded by curly braces. It can
optionally be preceded by an identifier. I want the parser to call
PushScope() with a name argument on the SymbolTable object when it finds an
open brace, and PopScope() when it finds a closing brace.

However, the C# code emitted looks like this. It does the right thing for
the empty string case, but it mangles the reference to $id.Text. Any
suggestions about what I might be doing wrong here, or any workarounds.
	

            switch (alt2) 
            {
                case 1 :
                    // DVD_DSL.g:22:2: id= IDENTIFIER block[s, $id.Text]
                    {
                    	root_0 = (object)adaptor.GetNilNode();
                    
                    	id = (Token)input.LT(1);
 
Match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_scope_block87); 
                    	id_tree = (object)adaptor.Create(id);
                    	adaptor.AddChild(root_0, id_tree);

                    	PushFollow(FOLLOW_block_in_scope_block89);
----------------------->block3 = block(s,  , id, .Text);
                    	followingStackPointer_--;
                    	
                    	adaptor.AddChild(root_0, block3.Tree);
                    
                    }
                    break;
                case 2 :
                    // DVD_DSL.g:23:2: block[s, \"\"]
                    {
                    	root_0 = (object)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_block_in_scope_block95);
----------------------->block4 = block(s,  "");
                    	followingStackPointer_--;
                    	
                    	adaptor.AddChild(root_0, block4.Tree);
                    
                    }
                    break;
            
            }

Thanks in advance.

______________________
John Stovin
Senior Software Engineer

mailto:j.stovin at zoo-tech.com   http://www.zoo-tech.com
t: +44 (0)114 274 3660                  f: +44 (0)114 274 3699	

ZOOtech Ltd., 20 Furnival Street, Sheffield, S1 4QT, United Kingdom. 
Company Registration Number: 4197951

NOTE: This email is private and confidential to the named recipients. Any
information provided is given in good faith. However, unless specifically
stated to the contrary, ZOOtech Ltd. accepts no liability for the content of
this email, or for the consequences of any actions taken on the basis of the
information provided, unless that information is subsequently confirmed in
writing.
? 2006 ZOOtech Ltd.



From antlr at jazillian.com  Tue Oct 10 09:21:39 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Tue, 10 Oct 2006 12:21:39 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
Message-ID: <452BC893.3040204@jazillian.com>

Loring,

I tend to think of the issue as one of "what's the best overall approach 
for what you're doing?".
I feel like for what I'm doing, I find a token sequence easier to work 
with than a tree structure.
I did start out using AST transformation, but about 3 months into it, I 
rewrote everything I
had to get rid of the ASTs. I can easily picture "<type> f(<args>) {" as 
a sequence of tokens,
but I can't easily picture it as a tree.

I certainly don't mean to say "no problem needs treewalkers". But I do 
think that as the
size of the task grows, the treewalker/AST approach gets less and less 
useful. I think if
you started out naively writing a natural language translator, you'd do 
a  tree structure.
But after a few months of trying to picture sentences as trees, you'd 
get frustrated.
On day, you'd spend 24 hours straight staring at the sentence "Woods 
Eyes Masters" and realize
it's hopeless.

I feel like that's what I went through with C to Java. To convert a 
typical "printf" call
into it's java equivalent, I'm just going to have to write a bunch of 
code to do that,
and having my input in a tree structure doesn't help me write that code.

I think there's too much "conventional thinking" going on that assumes 
that a language-to-language
(from one high-level language to another, including libraries, and 
producing "natural" code)
translator is similar to a compiler. It's as if we assumed that an 
English-to-Spanish translator
is best designed in the same way as an English-to-MorseCode translator.

I do agree that the tree transformation tools seem to be way too 
limited. TXL came as close
to doing what I needed as an English-to-Spanish dictionary comes close 
to what a UN
interpreter does. Not only that, an AST lets me easily find out what 
function I'm in. That's
as useful as the professional interpreter knowing that "house" is 
"casa"...yes, its necessary, but
if you think it's insignificant. Knowing the "house to casa" mappings is 
maybe 0.01% of the
work. And knowing where you are in the tree is also 0.01% of the work.

So I prefer these steps:
1) Lexing (input to token stream)
2) Search-and-replace (altering the token stream)
3) Repeat step 2, many times
4) Output (pretty-print token stream).

I think my unconventional approach comes from an unconventional starting 
point: the goal
of converting C, C++, COBOL to "natural" Java. Given that goal, the 
problem isn't a matter
of "walk a tree and be sure to do something with every node". It's far 
more complicated than
that. For starters, consider "what do I do at a FUNCTION_CALL node with 
text 'memset'? And
repeat that for each of the standard C library functions.

I agree I have a warped perspective :) Whether any term-rewrite system 
could ever be good
enough to make me reconsider, I don't know. I had looked into TXL and 
SemanticDesign's DMS,
and of course ANTLR. I had your typical 20-year programmer background 
with BS and MS in CS
degrees, experience with Lex and Yacc and similar tools, and I guess a 
health disrespect for
conventional approaches :)

Andy


From parrt at cs.usfca.edu  Tue Oct 10 11:11:43 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 10 Oct 2006 11:11:43 -0700
Subject: [antlr-interest] ANTLR v3 source in FishEye by Cenqua
Message-ID: <605FE36E-0F48-4C70-B117-5852C708411E@cs.usfca.edu>

Folks,

The hip cats at Cenqua (makers of Clover code coverage) have loaded  
up ANTLR into their cool FishEye repository sniffer.  Check it out!

http://fisheye2.cenqua.com/browse/antlr

Ter

From parrt at cs.usfca.edu  Tue Oct 10 13:11:57 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 10 Oct 2006 13:11:57 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452BC893.3040204@jazillian.com>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<452BC893.3040204@jazillian.com>
Message-ID: <D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>

Hi Andy et al,

Andy and I had a nice chat on the phone the other day and so I have a  
much better idea of how his system works.  He and I will be meeting  
next week and will no doubt have a great conversation about  
translation!    I am hoping that he will correct many of my  
misconceptions.  I think I have a lot to learn from him.

In the meantime, I think that there are some high-level issues that  
can be raised that might help someone choose one path over the  
other.  I will try to summarize my thoughts on overall issues here,  
and others can correct me.

* Speed.  If you need your translator to run in seconds/minutes not  
hours then most declarative purely rule-based systems will not be  
what you want.  For moving legacy code forward, however, there is no  
time pressure; so declarative systems work great for legacy code.     
I note that that is the area they focus on (TXL, DMS, ...).  This  
neatly slices off a huge fraction of the applications that must  
operate quickly.

* The nature of translation.  Andy refers to the difficulty of  
translating COBOL because scattered pieces of the input need to be  
collected into one location of the output language.  This is true and  
COBOL is nasty--perhaps the personification of nasty, so I do not  
want to trivialize this translation problem. But, Andy made a  
distinction I believe between a translator and a compiler, which I  
don't think I can agree with.  A compiler also needs to see  
declarations and other files and collect pieces from many different  
areas to do a translation.  I fail to see the distinction.   Also  
note that ANTLR has the exact same problem that it must collect  
information from many areas of your grammar so it can determine how  
to generate code.  There is a well-established mechanism for building  
data structures such as symbol tables, use-def chains, trees,  etc.  
for implementing these translators/compilers.   I am finding it hard  
to believe that a symbol table is the wrong approach to resolve  
symbols to their declaration, for example.  I believe no one will  
suggest that listing a bunch of rules is the right way to build a  
compiler or ANTLR.  Because I cannot see the fundamental distinction  
between those two and the translations done by Andy, I cannot agree  
that for large translations a rule-based system is the right  
approach.  Previously I mentioned that I had not done as nasty a  
translator, but in retrospect I must consider ANTLR a translator and  
after 3.5 years of work on that single tool I think I have a good  
understanding of a translation process of similar magnitude.  [You  
would not believe the crazy stuff I have to do in the area of  
nonlocal code-generation; when confronted with ID on the right hand  
side of a rewrite rule, code generation for ID is highly context- 
sensitive.  Information must be taken from the options area at the  
top of the file, at the start of the rule, and to the left of ->  
symbol but only at the appropriate grammatical level (which requires  
flow analysis and structure information).]

* Ease of specification.  Rules are clearly easier than a tree walker  
when they are clean and there are few of them.  How can one beat the  
following?

ADD v1 TO v2. --> v2 += v1;

Though with trees, one could perhaps auto translate that text to  
trees.   Or, just use raw:

^(ADD v1 v2) -> ^(PLUS_EQUAL v2 v1)

Anyway, now make it 400 of those rules.  Now, add a bunch of  
arbitrary actions that test "am I in this function and did I see this  
variable defined before by walking backwards?" in addition to these  
syntactic rules and I am certain that your brain must be very large  
to figure out the emergent behavior of all of these rules.   This is  
the standard Prolog programming problem.  Andy confirmed for me on  
the phone that debugging why the huge list of rules is not giving you  
the right translation requires tools that generate nice HTML reports  
and lots of thinking sometimes.  Further, the constant threat of  
infinite rule-application loops frightens me.    Perhaps he can give  
us a better idea of how often he hits a landmine.  I may be incorrect  
to focus on this problem.

One way to look at this problem is: do you want to drive the  
translation based upon the input stream or based upon a set of  
rules.  Even if I have to collect information along the way, I  
preferred to drive my translations based upon seeing input  
constructs.  I can step through easily with a debugger as it relates  
directly to the input.  Driving things from the abstract set of  
rules, just doesn't feel natural to me.  But that could be a personal  
choice.

Perhaps one can look at this as ease of specification versus ease of  
debugging and getting it right with all of these rules.   Rules are  
easier for smaller systems, but I don't think they scale very well  
(not in functionality of course just in ease of understanding the  
entire system).  On the other hand, doing all of the work to get the  
trees and the tree parser together can be a very high transaction  
cost to get started.  In the long run though, I am thinking that  
manipulating internal data structures, collecting information you  
need, and then ultimately generating code is the best approach for  
large systems.  That is not to say that we should not use the system  
that makes us the most comfortable.  Clearly Andy is an exceptional  
developer and has produced some amazing translators. no one can argue  
with Andy's results.

Personally,  I think that a hybrid system that does most of the work  
in a tree walker but with rules, for all of the special cases that  
Andy has pointed out, would be great!

* Generality.  From Andy's descriptions, he has many hand-built  
functions asking questions about context.  As Sohail has pointed out,  
this is the same as building parsers by hand and they are very  
specific to the language being translated.  At this point, I am not  
sure for what Andy uses ANTLR.  Probably to build the rule-based  
system he has.

In summary, I think that a rule-based system has its place and I  
would like to try my hand at building one learning from Andy's  
experience.   For myself, I would limit its use to quick and dirty  
translators that I need to build that have less than say 40 rules and  
of course only in cases where I'm not concerned with speed.

I'm perfectly willing to be wrong on this, just as I felt others were  
wrong about the LL parsing approach back in the days when LR was king  
in the early 90s.

This is one of the best discussions we have ever had on this mailing  
list a thing.  Hooray!

Ter

From monty at codetransform.com  Tue Oct 10 13:38:20 2006
From: monty at codetransform.com (Monty Zukowski)
Date: Tue, 10 Oct 2006 13:38:20 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<452BC893.3040204@jazillian.com>
	<D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
Message-ID: <598864c70610101338y1c696f91scfb6cd4ddf8f50eb@mail.gmail.com>

> * Ease of specification.  Rules are clearly easier than a tree walker
> when they are clean and there are few of them.  How can one beat the
> following?
>
> ADD v1 TO v2. --> v2 += v1;
>
> Though with trees, one could perhaps auto translate that text to
> trees.   Or, just use raw:
>
> ^(ADD v1 v2) -> ^(PLUS_EQUAL v2 v1)
>

Note that the E language guys came up with a nice shorthand described
tersely here:  http://www.erights.org/elang/grammar/quasi-terms.html
and http://www.erights.org/elang/grammar/quasi-xml.html.  Basically it
lets you parse something like ADD @v1:expr TO @v2:expr into a tree
that can be matched against your source tree.  Then you can write the
--> @v2 += @v1 on the other side, which is parsed into a tree and it
will substitute the AST nodes appropriately,   So basically you are
specifying in text yet working in trees.

Ter, I think we discussed this at the Cabal.  The trick is that the
parser and lexer needs to know how to just return a generic EXPR token
for @v1:expr -- and build a tree with that as a placeholder.

> Personally,  I think that a hybrid system that does most of the work
> in a tree walker but with rules, for all of the special cases that
> Andy has pointed out, would be great!
>

Yes, I agree.  This is quite an interesting discussion.

Monty

From parrt at cs.usfca.edu  Tue Oct 10 13:58:04 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 10 Oct 2006 13:58:04 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610101338y1c696f91scfb6cd4ddf8f50eb@mail.gmail.com>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<452BC893.3040204@jazillian.com>
	<D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
	<598864c70610101338y1c696f91scfb6cd4ddf8f50eb@mail.gmail.com>
Message-ID: <BD77AD4A-0322-4C6D-B407-FFB08D9FD33F@cs.usfca.edu>

On Oct 10, 2006, at 1:38 PM, Monty Zukowski wrote:
> Note that the E language guys came up with a nice shorthand described
> tersely here:  http://www.erights.org/elang/grammar/quasi-terms.html
> and http://www.erights.org/elang/grammar/quasi-xml.html.  Basically it

cool.

> lets you parse something like ADD @v1:expr TO @v2:expr into a tree
> that can be matched against your source tree.  Then you can write the
> --> @v2 += @v1 on the other side, which is parsed into a tree and it
> will substitute the AST nodes appropriately,   So basically you are
> specifying in text yet working in trees.
>
> Ter, I think we discussed this at the Cabal.  The trick is that the
> parser and lexer needs to know how to just return a generic EXPR token
> for @v1:expr -- and build a tree with that as a placeholder.

Correct.  We discussed and I remember your excellent trick of doing  
that EXPR node well!  Been thinking about it ever since :)

>> Personally,  I think that a hybrid system that does most of the work
>> in a tree walker but with rules, for all of the special cases that
>> Andy has pointed out, would be great!
>>
>
> Yes, I agree.  This is quite an interesting discussion.

Heh heh heh...hopefully the current ANTLR book (in prep) or next will  
be able to delve into these questions!

Ter

From hnine at isis.vanderbilt.edu  Tue Oct 10 15:24:06 2006
From: hnine at isis.vanderbilt.edu (Harmon Nine)
Date: Tue, 10 Oct 2006 17:24:06 -0500
Subject: [antlr-interest] Bug that wasn't present in 2.7.1
Message-ID: <7AB1C26C64423249964AB392C6EBF0E0601CE5@discovery.isis.vanderbilt.edu>

Hello.  I'm not sure where to submit bug reports, and the antlr home
page, as well as some cursory google searches, didn't seem to provide
any information.

 

I've found a bug in antlr 2.7.5 that is still present in 2.7.6.  How can
I submit a bug report?

 

Thanks.

-- Harmon

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/7035e006/attachment.html 

From prashant.deva at gmail.com  Tue Oct 10 15:25:13 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Tue, 10 Oct 2006 15:25:13 -0700
Subject: [antlr-interest] Bug that wasn't present in 2.7.1
In-Reply-To: <7AB1C26C64423249964AB392C6EBF0E0601CE5@discovery.isis.vanderbilt.edu>
References: <7AB1C26C64423249964AB392C6EBF0E0601CE5@discovery.isis.vanderbilt.edu>
Message-ID: <41fed8f80610101525o7d1d7336r5ab78ad3865446ea@mail.gmail.com>

Just post it here.

-- 
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com

On 10/10/06, Harmon Nine <hnine at isis.vanderbilt.edu> wrote:
>
> Hello.  I'm not sure where to submit bug reports, and the antlr home page,
> as well as some cursory google searches, didn't seem to provide any
> information.
>
>
>
> I've found a bug in antlr 2.7.5 that is still present in 2.7.6.  How can I
> submit a bug report?
>
>
>
> Thanks.
>
> -- Harmon
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/45acc472/attachment.html 

From hnine at isis.vanderbilt.edu  Tue Oct 10 15:39:54 2006
From: hnine at isis.vanderbilt.edu (Harmon Nine)
Date: Tue, 10 Oct 2006 17:39:54 -0500
Subject: [antlr-interest] Bug report: 2.7.5 and 2.7.6
Message-ID: <7AB1C26C64423249964AB392C6EBF0E0601CEA@discovery.isis.vanderbilt.edu>

The bug exists in versions 2.7.5 and 2.7.6 of antlr.

It didn't appear in 2.7.1.

 

The attached "gif" file is actually a "zip" file, and was so renamed to
get around mail filters.

 

After renaming the file to have a "zip" extension, unzipping it renders
3 files:

Makefile

main.cpp

CExprParser.g

 

The Makefile isn't perfect (it runs antlr 4 times to build the Parser
and Lexer C files), but it does the trick.

Also, the Makefile needs to be modified to give the ANTLR_JAR and
ANTLR_LIB_HOME variables the appropriate values.

 

The bug results in a segmentation fault.  Just run:

 

make

./antlrbug.exe

 

and a segfault should occur.

 

Thanks.

-- Harmon

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/cf23a165/attachment-0001.html 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Bug.gif
Type: image/gif
Size: 2850 bytes
Desc: Bug.gif
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/cf23a165/attachment-0001.gif 

From lgcraymer at yahoo.com  Tue Oct 10 16:29:41 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 10 Oct 2006 16:29:41 -0700 (PDT)
Subject: [antlr-interest] Bug report: 2.7.5 and 2.7.6
In-Reply-To: <7AB1C26C64423249964AB392C6EBF0E0601CEA@discovery.isis.vanderbilt.edu>
Message-ID: <20061010232941.44182.qmail@web55908.mail.re3.yahoo.com>

Most likely, this has to do with not setting the ASTFactory and is not a bug per se.  (I haven't looked at the contents of the zip).  This is a change between 2.7.1 and either 2.7.2 or 2.7.3--I forget which.  Check the manual under the C++ runtime section--it is documented there.

Harmon Nine <hnine at isis.vanderbilt.edu> wrote:              The bug exists in versions 2.7.5 and 2.7.6 of antlr.
  It didn?t appear in 2.7.1.
   
  The attached ?gif? file is actually a ?zip? file, and was so renamed to get around mail filters.
   
  After renaming the file to have a ?zip? extension, unzipping it renders 3 files:
  Makefile
  main.cpp
  CExprParser.g
   
  The Makefile isn?t perfect (it runs antlr 4 times to build the Parser and Lexer C files), but it does the trick.
  Also, the Makefile needs to be modified to give the ANTLR_JAR and ANTLR_LIB_HOME variables the appropriate values.
   
  The bug results in a segmentation fault.  Just run:
   
  make
  ./antlrbug.exe
   
  and a segfault should occur.
   
  Thanks.
  -- Harmon
  
  

 		
---------------------------------
Stay in the know. Pulse on the new Yahoo.com.  Check it out. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/9028a234/attachment.html 

From kroepke at classdump.org  Tue Oct 10 16:35:38 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Wed, 11 Oct 2006 01:35:38 +0200
Subject: [antlr-interest] interpretation '\t'
In-Reply-To: <D72A054DF5002D4FA6CF14252F7997B8D97E51@BLRKECMSG13.ad.infosys.com>
References: <D72A054DF5002D4FA6CF14252F7997B8D97E51@BLRKECMSG13.ad.infosys.com>
Message-ID: <29F58182-A9F6-4396-A6C4-FB11D5F8D514@classdump.org>


On 10. Oct 2006, at 13:28 Uhr, Abhijit Nandkumar Ghonge wrote:

>  If there is any "parsing exception", it gives me the column
> information in the console. However, the column number erroneous since
> it interprets \t to be certain number of characters. Can I, by any
> means, set the number of columns for the \t. For example, can I set \t
> as 10 spaces or 4 spaces in my grammer file.

I don't think that you can specify the tab-width. I *think* it always  
is counted as 4 spaces in the code,
but I might be mistaken. It should be found in the code somewhere,  
though.
If this is bothering you badly, you could try to "preprocess" the  
grammars, but I'd advise against it.
Or instruct your editor to always use spaces instead of tabs.

This discussion of course is a popular means of igniting a long flame  
war ;)

But thanks for reminding me of this, I haven't thought of that  
pitfall yet, as I'm going to redo message output for
v3 soon. Maybe I can figure out a way around (probably not...).

-k
-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From parrt at cs.usfca.edu  Tue Oct 10 17:29:45 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 10 Oct 2006 17:29:45 -0700
Subject: [antlr-interest] tweaking input files
Message-ID: <E760020D-7CC5-4C74-8C87-496720C0BA17@cs.usfca.edu>

Hi,

In case you weren't aware of the TokenRewriteStream (or  
TokenStreamRewriteEngine in v2), it kicks butt.  For example, I'm  
experimenting with a v2 to v3 converter and so I built a v2  
recognizer in v3 by manually converting the grammar to v3 syntax.   
Then I decided to start flipping keywords that have changed like  
protected->fragment in the lexer.  I added a simple action to the  
rule rule:

rule:	DOC_COMMENT?
		(	p='protected' {tokens.replace($p,"fragment");}
		|	'public'
		|	'private'
		)?
		id BANG? ARG_ACTION? ( 'returns' ARG_ACTION )?
		throwsSpec?
		ruleOptionsSpec?
		ACTION?
		COLON block ';'
		exceptionGroup?
	;

When I call toString() on the buffer it shows me the modified  
buffer.  All comments/whitespace come through unharmed. :)

Cool.  This TokenRewriteStream works really well when you want to  
tweak a file rather than completely modify it, though it will work  
just as well when I move the "header {...}" stream of tokens from  
before the class def to after the grammar def and call it @header.

Ter

From lgcraymer at yahoo.com  Tue Oct 10 19:32:10 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 10 Oct 2006 19:32:10 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452BC893.3040204@jazillian.com>
Message-ID: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>

Andy--

I deliberately chose your message to respond to because it captured the pragmatic viewpoint--"I had a problem; I solved it; I did not need to use trees"--quite effectively.  That is quite a bit different from the more usual "I tried to use ANTLR's tree facilities and discovered that writing them by hand and using a visitor is easy and clearly is the ONE TRUE SOLUTION to language processing" that appears in the group every so often.  (Although, truth be told, some of your early messages to the group were along that vein, but you have since worked on problems that require multi-pass recognition support and have broadened your horizons.)

"Thinking in trees" does not come automatically.  It is like learning LISP or Forth or one of the functional languages (and, for that matter, object-oriented programming:  there is a lot of badly designed and implemented C++ code out there).  For a time, working with trees is like slogging through molasses, and then you get the "Aha!" experience and things become easy.  It usually is not about designing the perfect tree structure; instead, it is about simplifying the recognition problem and expressing target language constructs in tree form.

If I were working on a natural language problem, would I use trees?  Sure!  Trees are a very convenient way of capturing semantics into syntactic form.  Would I generate output with a visitor?  For Esperanto or one of the Romance languages, possibly (for these languages, simple syntactic principles apply); for English, that is unlikely--too much "peephole" substitution is necessary to handle special cases.  Instead, I would most likely process the input into a canonical tree with a regular structure (converting input to tree form is about transforming the special cases) and do some form of rule-based substitution for all of the nasty colloquialisms and other special cases.  (In compiler parlance, that is called "peephole optimization", often an essential for generating good code.)

As to compilers and compiler technology:  you might be surprised.  "Compiler technology" and "language translation technology" are effectively synonyms, and the technical term for the translators you have discussed in this group is "cascading compiler" (or used to be; the term has pretty much disappeared from the literature as compiler technology research has declined in popularity).  Most language translation problems are much simpler than a conventional compiler and are solved using a subset of the algorithms that go into building an optimizing compiler.  Nothing that you have described doing is out of place in a conventional compiler environment.  You might find it interesting to take a look at GNU RTL, used to generate the peephole optimizer for the gcc toolset.

As to your "unconventional" approach:  I hate to say this, but everything that you have described doing is well documented in the literature.  I have noticed that "healthy disrespect for conventional approaches" usually translates to "I never check to see if I am reinventing the wheel or not".  One of the great resources on the web is Citeseer:  <http://citeseer.ist.psu.edu/>.  It has some of the good early papers on pattern matching and transformation systems.

Cheers!

--Loring

Andy Tripp <antlr at jazillian.com> wrote: Loring,

I tend to think of the issue as one of "what's the best overall approach 
for what you're doing?".
I feel like for what I'm doing, I find a token sequence easier to work 
with than a tree structure.
I did start out using AST transformation, but about 3 months into it, I 
rewrote everything I
had to get rid of the ASTs. I can easily picture " f() {" as 
a sequence of tokens,
but I can't easily picture it as a tree.

I certainly don't mean to say "no problem needs treewalkers". But I do 
think that as the
size of the task grows, the treewalker/AST approach gets less and less 
useful. I think if
you started out naively writing a natural language translator, you'd do 
a  tree structure.
But after a few months of trying to picture sentences as trees, you'd 
get frustrated.
On day, you'd spend 24 hours straight staring at the sentence "Woods 
Eyes Masters" and realize
it's hopeless.

I feel like that's what I went through with C to Java. To convert a 
typical "printf" call
into it's java equivalent, I'm just going to have to write a bunch of 
code to do that,
and having my input in a tree structure doesn't help me write that code.

I think there's too much "conventional thinking" going on that assumes 
that a language-to-language
(from one high-level language to another, including libraries, and 
producing "natural" code)
translator is similar to a compiler. It's as if we assumed that an 
English-to-Spanish translator
is best designed in the same way as an English-to-MorseCode translator.

I do agree that the tree transformation tools seem to be way too 
limited. TXL came as close
to doing what I needed as an English-to-Spanish dictionary comes close 
to what a UN
interpreter does. Not only that, an AST lets me easily find out what 
function I'm in. That's
as useful as the professional interpreter knowing that "house" is 
"casa"...yes, its necessary, but
if you think it's insignificant. Knowing the "house to casa" mappings is 
maybe 0.01% of the
work. And knowing where you are in the tree is also 0.01% of the work.

So I prefer these steps:
1) Lexing (input to token stream)
2) Search-and-replace (altering the token stream)
3) Repeat step 2, many times
4) Output (pretty-print token stream).

I think my unconventional approach comes from an unconventional starting 
point: the goal
of converting C, C++, COBOL to "natural" Java. Given that goal, the 
problem isn't a matter
of "walk a tree and be sure to do something with every node". It's far 
more complicated than
that. For starters, consider "what do I do at a FUNCTION_CALL node with 
text 'memset'? And
repeat that for each of the standard C library functions.

I agree I have a warped perspective :) Whether any term-rewrite system 
could ever be good
enough to make me reconsider, I don't know. I had looked into TXL and 
SemanticDesign's DMS,
and of course ANTLR. I had your typical 20-year programmer background 
with BS and MS in CS
degrees, experience with Lex and Yacc and similar tools, and I guess a 
health disrespect for
conventional approaches :)

Andy



 		
---------------------------------
Stay in the know. Pulse on the new Yahoo.com.  Check it out. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/d48dc385/attachment.html 

From lgcraymer at yahoo.com  Tue Oct 10 21:50:54 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 10 Oct 2006 21:50:54 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <598864c70610101338y1c696f91scfb6cd4ddf8f50eb@mail.gmail.com>
Message-ID: <20061011045055.92247.qmail@web55914.mail.re3.yahoo.com>

I have off and on put a fair amount of thought into rule-based pattern match-and-replace systems and how they might relate to ANTLR.  ANTLR trees with transformations are like a surgeon's scalpel:  you can locate precisely which parts of a tree need to be changed and change them in situ.  On the other hand, trees can be a pain when you really do want to replace all instances of a given pattern. Pattern-match-and-replace systems are more of a "shotgun" approach.  Every instance of a pattern is changed, and the order in which transformations are made affects the end result.  For example

A B C -> C B A
B C D -> C B D

operating on A B C D will produce either
C B A D or A C B D depending on which rule is used.  Probstang's BURG algorithm provides an approach for finding the "best" transformation from a set of possible transformations, but figuring out how to integrate BURG with ANTLR is a challenge.

As larger and larger rule sets are built, it becomes harder and harder to be sure that you are getting the results that you want--unless you can make sure that the rules do not overlap.  I think that that is one of the reasons that interactive refactoring tools are gaining wide acceptance, but batch transformation systems have had limited acceptance.

For ANTLR use, there is an additional problem:  what if you want to follow rule-based transformation with grammar-based tree manipulation/analysis?

There is one possible solution:  instead of transforming the tree generated by ANTLR, do a pattern-match-and-replace on the grammar instead.  Of course, what would really be done is is to generate an annotated grammar that would produce the same transformation on an input tree that would be achieved by the match-and-replace algorithm as well as the output grammar.  (It would actually be a bit more complicated because some of the matches would cross rule boundaries.)  Then it is at least possible to examine the grammars to see if the transformations are free of "accidents".  A useful side effect:  runtime transformation does not involve "iterate until no further transformations can be applied".

I have yet to work on a problem where multi-pass rule-based replacement was a clear win, so I have not gone further than thinking about this.

--Loring

Monty Zukowski <monty at codetransform.com> wrote: > * Ease of specification.  Rules are clearly easier than a tree walker
> when they are clean and there are few of them.  How can one beat the
> following?
>
> ADD v1 TO v2. --> v2 += v1;
>
> Though with trees, one could perhaps auto translate that text to
> trees.   Or, just use raw:
>
> ^(ADD v1 v2) -> ^(PLUS_EQUAL v2 v1)
>

Note that the E language guys came up with a nice shorthand described
tersely here:  http://www.erights.org/elang/grammar/quasi-terms.html
and http://www.erights.org/elang/grammar/quasi-xml.html.  Basically it
lets you parse something like ADD @v1:expr TO @v2:expr into a tree
that can be matched against your source tree.  Then you can write the
--> @v2 += @v1 on the other side, which is parsed into a tree and it
will substitute the AST nodes appropriately,   So basically you are
specifying in text yet working in trees.

Ter, I think we discussed this at the Cabal.  The trick is that the
parser and lexer needs to know how to just return a generic EXPR token
for @v1:expr -- and build a tree with that as a placeholder.

> Personally,  I think that a hybrid system that does most of the work
> in a tree walker but with rules, for all of the special cases that
> Andy has pointed out, would be great!
>

Yes, I agree.  This is quite an interesting discussion.

Monty


 		
---------------------------------
Do you Yahoo!?
 Get on board. You're invited to try the new Yahoo! Mail.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061010/8697b10c/attachment-0001.html 

From sohail at taggedtype.net  Tue Oct 10 22:06:17 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Tue, 10 Oct 2006 22:06:17 -0700
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452BB863.1040103@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
	<45267B17.6060107@jazillian.com>
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>
	<4527E677.5070504@jazillian.com>
	<1160274396.7022.3.camel@localhost.localdomain>
	<45298EFB.9040104@jazillian.com>
	<1160365442.18004.14.camel@localhost.localdomain>
	<452BB863.1040103@jazillian.com>
Message-ID: <1160543177.6126.10.camel@localhost.localdomain>

On Tue, 2006-10-10 at 11:12 -0400, Andy Tripp wrote:
> Sohail Somani wrote:
> >>Its weird that you're walking token streams, but what it seems it that
> >>you're implementing the recursive descent parser by hand...
> >>    
> >>
> But a parser converts a token stream to an AST, I'm not using an AST, 
> but dealing with
> the stream directly because that seems easier to me. I find it easier to 
> search for
> pattern "f(...) {" to look for a function, rather than search a tree for 
> a node of type
> FUNCTION_DECLARATION.

A parser doesn't *have* to create an AST. For example, consider a syntax
directed translation. That is something that simply recognizes token
structure and performs some actions.

> >I believe there is an unspoken rule that all bets are off with COBOL?
> >  
> >
> Yes, I suppose. But even with C and C++, what seems simple may not be. 
> For example, you'd think that
> struct person p[100];
> might correspond to a single line of Java, but it doesn't (you need to 
> initialize the
> array). So suddenly, out of nowhere, you may have to add a static block 
> of code. That's
> a typical one-to-many type of thing.

I'm not sure how an AST a la antlr prevents you from doing this. 

> because it may certainly have changed since you last looked at it..in 
> other words, the symbol
> table can be a mess to maintain. In my case, the return type of b() may 
> have change, the name of it
> may have changed, its argument types may have changed.

Changed from what to what? And how the heck can they change in a single
run of the compiler? I'm confused.

> Also, my tool does not have to be fast - if it takes an hour to 
> translate some code, when it could
> have taken 2 seconds if I had designed it "right", that's ok.

I don't think anyone is telling you that you didn't design it right! I
myself would like to have the power of:

v1 = v1 + v2 => v1 += v2

transformations. Myself, I'm only trying to figure out what the big deal
is that prevents you from using antlr. Personally, I know I wouldn't
want to write token matching code.

Please don't think I am attacking your translator. We all know how
difficult the problem is you're trying to solve. All I'm trying to
understand is how you solved it.


From gt54-antlr at cyconix.com  Wed Oct 11 01:35:37 2006
From: gt54-antlr at cyconix.com (Paul Johnson)
Date: Wed, 11 Oct 2006 09:35:37 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
Message-ID: <452CACD9.3080203@cyconix.com>

Loring Craymer wrote:
> Andy--
> 
> I deliberately chose your message to respond to because it captured the 
> pragmatic viewpoint--"I had a problem; I solved it; I did not need to 
> use trees"--quite effectively.  That is quite a bit different from the 
> more usual "I tried to use ANTLR's tree facilities and discovered that 
> writing them by hand and using a visitor is easy and clearly is the ONE 
> TRUE SOLUTION to language processing" that appears in the group every so 
> often.  

Perhaps I'm being thick here, or I haven't been paying attention, but I 
haven't noticed anyone making this argument (and certainly not myself).

I use ANTLR's tree facilities all the time. What I don't do is to use 
tree *grammars*, and it is the argument against grammars that I have 
occasionally seen in this list. This specific AST/tree argument, as I 
understand it (and *not* the translation philosophy argument) is about 
whether the advantages of having a tree grammar outweigh the disadvantages.

The ease of using visitors is not central to that argument. The problem 
is that tree grammars are (currently?) inflexible, but visitors are both 
flexible and trivial, so you should use visitors where appropriate.

Paul

From lgcraymer at yahoo.com  Wed Oct 11 02:11:57 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Wed, 11 Oct 2006 02:11:57 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452CACD9.3080203@cyconix.com>
Message-ID: <20061011091157.18422.qmail@web55911.mail.re3.yahoo.com>

There is a 2-3 year cycle on these discussions; you may not have been around for the last one.  Visitors have their uses; however, they lack the recognition capabilities of grammars.  They also become irrelevant for ANTLR 3--it is easier to iterate over a TreeNodeStream.

--Loring

Paul Johnson <gt54-antlr at cyconix.com> wrote: Loring Craymer wrote:
> Andy--
> 
> I deliberately chose your message to respond to because it captured the 
> pragmatic viewpoint--"I had a problem; I solved it; I did not need to 
> use trees"--quite effectively.  That is quite a bit different from the 
> more usual "I tried to use ANTLR's tree facilities and discovered that 
> writing them by hand and using a visitor is easy and clearly is the ONE 
> TRUE SOLUTION to language processing" that appears in the group every so 
> often.  

Perhaps I'm being thick here, or I haven't been paying attention, but I 
haven't noticed anyone making this argument (and certainly not myself).

I use ANTLR's tree facilities all the time. What I don't do is to use 
tree *grammars*, and it is the argument against grammars that I have 
occasionally seen in this list. This specific AST/tree argument, as I 
understand it (and *not* the translation philosophy argument) is about 
whether the advantages of having a tree grammar outweigh the disadvantages.

The ease of using visitors is not central to that argument. The problem 
is that tree grammars are (currently?) inflexible, but visitors are both 
flexible and trivial, so you should use visitors where appropriate.

Paul


 		
---------------------------------
Do you Yahoo!?
 Everyone is raving about the  all-new Yahoo! Mail.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061011/e21eddaf/attachment.html 

From gt54-antlr at cyconix.com  Wed Oct 11 03:43:41 2006
From: gt54-antlr at cyconix.com (Paul Johnson)
Date: Wed, 11 Oct 2006 11:43:41 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061011091157.18422.qmail@web55911.mail.re3.yahoo.com>
References: <20061011091157.18422.qmail@web55911.mail.re3.yahoo.com>
Message-ID: <452CCADD.30801@cyconix.com>

Loring Craymer wrote:
> There is a 2-3 year cycle on these discussions; you may not have been 
> around for the last one.  Visitors have their uses; however, they lack 
> the recognition capabilities of grammars.  They also become irrelevant 
> for ANTLR 3--it is easier to iterate over a TreeNodeStream.

There is, if I can quote, no "one true solution". Visitors will never 
become irrelevant, however much the tool evolves. As for ANTLR 3, which 
I haven't tried yet - if it removes the need for me to code and maintain 
5 different tree grammars, which is what I need for my 8 passes, then 
I'm all ears.

Paul

From ric.klaren at gmail.com  Wed Oct 11 04:11:40 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed, 11 Oct 2006 13:11:40 +0200
Subject: [antlr-interest] Bug report: 2.7.5 and 2.7.6
In-Reply-To: <7AB1C26C64423249964AB392C6EBF0E0601CEA@discovery.isis.vanderbilt.edu>
References: <7AB1C26C64423249964AB392C6EBF0E0601CEA@discovery.isis.vanderbilt.edu>
Message-ID: <bc607a4e0610110411qb216832g545e18ad4e72a598@mail.gmail.com>

Hi,

On 10/11/06, Harmon Nine <hnine at isis.vanderbilt.edu> wrote:
> The bug results in a segmentation fault.  Just run:

I checked the zip, it's indeed as Loring suspected: no ASTFactory
initialization. Check the docs/examples on how to do this.

Cheers,

Ric

From hnine at isis.vanderbilt.edu  Wed Oct 11 07:57:56 2006
From: hnine at isis.vanderbilt.edu (Harmon Nine)
Date: Wed, 11 Oct 2006 09:57:56 -0500
Subject: [antlr-interest] Bug report: 2.7.5 and 2.7.6
Message-ID: <7AB1C26C64423249964AB392C6EBF0E0601D32@discovery.isis.vanderbilt.edu>

Thanks much for the info.  I was using the "An Introduction to ANTLR"
section.

One thing:  is there a means of automatically determining, perhaps
through a precompiler macro, what version of antlr is being used during
a compile?

I'd like to use the latest version of antlr in a software port (to
linux), but the original software uses antlr-2.7.1, and that is pretty
much cast in stone.  Is there a way of doing something like the
following?

#include "CExprLexer.hpp"
#include "CExprParser.hpp"
#include <sstream>

int main( void ) {

  std::istringstream cexprStream( "entryMode <= -2" );

  CExprLexer cExprLexer( cexprStream );
  CExprParser cExprParser( cExprLexer );

///////////////////////////////////////
#if ANTLR_VERSION != 2.7.1
  antlr::ASTFactory astFactory;
  CExprParser.initializeASTFactory( astFactory );
  CExprParser.setASTFactory( &astFactory );
#endif
///////////////////////////////////////

  cExprParser.expr();

  antlr::RefAST refAST( cExprParser.getAST() );
  std::cerr << "tree = " << refAST->toStringTree() << std::endl;

return 0;
}

Thanks.

-- Harmon

> -----Original Message-----
> From: Ric Klaren [mailto:ric.klaren at gmail.com]
> Sent: Wednesday, October 11, 2006 6:12 AM
> To: Harmon Nine
> Cc: antlr-interest at antlr.org
> Subject: Re: [antlr-interest] Bug report: 2.7.5 and 2.7.6
> 
> Hi,
> 
> On 10/11/06, Harmon Nine <hnine at isis.vanderbilt.edu> wrote:
> > The bug results in a segmentation fault.  Just run:
> 
> I checked the zip, it's indeed as Loring suspected: no ASTFactory
> initialization. Check the docs/examples on how to do this.
> 
> Cheers,
> 
> Ric


From antlr at jazillian.com  Wed Oct 11 09:48:59 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 12:48:59 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>	<452BC893.3040204@jazillian.com>
	<D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
Message-ID: <452D207B.3080408@jazillian.com>

Terence Parr wrote:

>
> * The nature of translation.  Andy refers to the difficulty of  
> translating COBOL because scattered pieces of the input need to be  
> collected into one location of the output language.  This is true and  
> COBOL is nasty--perhaps the personification of nasty, so I do not  
> want to trivialize this translation problem.

In addition to this "many-to-one" problem, we have "one-to-many" 
problems. The single COBOL code:
AGE PIX 9(2) VALUE 3.
...not only becomes a single Java variable declaration:
int age = 3;
...it also contributes to file format information (from that COBOL 
statement, we know that this field is
stored in "DISPLAY" format on disk). And this line of code can affect 
what we do with other fields that contain it.

> But, Andy made a  distinction I believe between a translator and a 
> compiler, which I  don't think I can agree with.  A compiler also 
> needs to see  declarations and other files and collect pieces from 
> many different  areas to do a translation.  I fail to see the 
> distinction.   

Then I'm not being clear :(  Take me literally when I say prog. lang. 
translation can be (if you have the goals that I have) is
like NLP (natural language processing). It's not a "closed, finite" 
solution, but rather it's open-ended. Suppose you build
your C to Java translator in the conventional way. You've built an C AST 
and transformed it into a Java AST. That took you
let's say a month. If you want realistic "natural" Java code, you're not 
even close to done. It's not just trivial things like
changing "!(i == 1)" to "i != 1". It's looking at how real people use 
memset() and doing the best you can to replace it.
Doing that for C pointer usage, and doing it well, could be a full-time 
job for many years.

I'm not just complaining that the problem is hard. I'm saying that it's 
so hard that the nature of the solution changes as it grows.
After that month, you had maybe 90% "tree-walking" code and 10% "other 
stuff". After a year or two, you now have
1% "tree-walking" code, and 99% "other stuff". Whether its a C-to-Java 
or an English-to-Spanish translator, what started out
as a tree-walking architecture with a fair amount of other stuff, is now 
just a lot of other stuff with a little treewalking in there.
Not only is it not a treewalking architecture, but you've spent all your 
time figuring out the best way to structure the "other stuff",
and an AST was not the best answer.

Go to someone who's spent years on real-world NLP and suggest that he 
first parse the input language into a tree. He'll tell you
that you're missing the whole problem. That there are more exceptions 
than rules. He'll challenge you to take 100 lines of
real-world English, get a professional to translate it to Spanish, and 
see how well your approach works. I'll throw out the
same challenge. Here is some code that has hand-written C, C#, Java, and 
COBOL versions:
http://www2.hursley.ibm.com/decimal/telco.html
Go through a mental treewalk approach on that C code and produce the 
Java version. NOT the C version with Java syntax,
not a Java version that works the same as the C version, the ACTUAL Java 
code that looks as a person would write it.
It doesn't have to pass a "diff" perfectly, but it should be close 
enough that it look hand-written. Then repeat for COBOL to Java.
I have done this, and I'm pretty sure that simply walking the input AST 
will get you 1% of the way there.

> Also  note that ANTLR has the exact same problem that it must collect  
> information from many areas of your grammar so it can determine how  
> to generate code.  There is a well-established mechanism for building  
> data structures such as symbol tables, use-def chains, trees,  etc.  
> for implementing these translators/compilers.   I am finding it hard  
> to believe that a symbol table is the wrong approach to resolve  
> symbols to their declaration, for example.  

I do use symbol tables, but I avoid them. Once you have lots of phases, 
you end up spending more effort keeping the symbol table up
to date than it's worth. I want to be able to pretty much just write:
long v[x];  --> int[] v = new int[x];
...without having to touch the symbol table.

> I believe no one will  suggest that listing a bunch of rules is the 
> right way to build a  compiler or ANTLR.  Because I cannot see the 
> fundamental distinction  between those two and the translations done 
> by Andy, I cannot agree  that for large translations a rule-based 
> system is the right  approach.  Previously I mentioned that I had not 
> done as nasty a  translator, but in retrospect I must consider ANTLR a 
> translator and  after 3.5 years of work on that single tool I think I 
> have a good  understanding of a translation process of similar magnitude.

The difference is that ANTLR's input is a language of your own choosing, 
and the output is very much one-to-one with the input.
Imagine if you had to deal with, say, plain BNF input. You'd say "OK, 
BNF is limited, so how does anyone specify actions?" and the
answer is some ad-hoc solution. That's how things are: everything in 
COBOL is ad-hoc, even C doesn't have features that
you wish it had (classes, exceptions, etc). How do you handle that? 
Well, my answer is "do what a person would do." I
look for patterns of code that check library call return values, and map 
them to Java exception usage, for example. C (and especially
COBOL) was not designed to be translated to Java, but ANTLR syntax was 
explicitly designed to be translated to
ANTLR-generated code.

>   [You  would not believe the crazy stuff I have to do in the area of  
> nonlocal code-generation; when confronted with ID on the right hand  
> side of a rewrite rule, code generation for ID is highly context- 
> sensitive.  Information must be taken from the options area at the  
> top of the file, at the start of the rule, and to the left of ->  
> symbol but only at the appropriate grammatical level (which requires  
> flow analysis and structure information).]
>
> * Ease of specification.  Rules are clearly easier than a tree walker  
> when they are clean and there are few of them.  How can one beat the  
> following?
>
> ADD v1 TO v2. --> v2 += v1;
>
> Though with trees, one could perhaps auto translate that text to  
> trees.   Or, just use raw:
>
> ^(ADD v1 v2) -> ^(PLUS_EQUAL v2 v1)
>
> Anyway, now make it 400 of those rules.  

I think it's more like: add 300 of those rules, and 50 rules that are
going to require a fair amount of code (e.g. remove gotos, remove pointers).
And another 50 that are almost simple enough to express as one-liners, 
but not quite.

> Now, add a bunch of  arbitrary actions that test "am I in this 
> function and did I see this  variable defined before by walking 
> backwards?" in addition to these  syntactic rules and I am certain 
> that your brain must be very large  to figure out the emergent 
> behavior of all of these rules.   

I still don't think you're seeing the problem as I do. I have a paper - 
no longer public, but avail on request - that list most of the
things a person would need to do to change C to Java. That's what needs 
to be done. Even if you just look at goto removal, for
example, you'll see it's far more complicated than "what actions should 
fire at certain places in the AST?". Or look at
all the handling of preprocessor stuff like "#DEFINE A 1" becoming 
"public final static A = 1;".

> This is  the standard Prolog programming problem.  Andy confirmed for 
> me on  the phone that debugging why the huge list of rules is not 
> giving you  the right translation requires tools that generate nice 
> HTML reports  and lots of thinking sometimes.  Further, the constant 
> threat of  infinite rule-application loops frightens me.    Perhaps he 
> can give  us a better idea of how often he hits a landmine.  I may be 
> incorrect  to focus on this problem.

When something goes wrong - a bug in a rule - it can be a mess to track 
back to which rule was really at fault.
The ordering of rules is also tough to get right. And I have hit 
problems with infinite loops, but that hasn't been a major heachache.
My approach has its drawbacks, but I couldn't even "get going" with the 
AST approach.

>
> One way to look at this problem is: do you want to drive the  
> translation based upon the input stream or based upon a set of  rules.  

Exactly.

> Even if I have to collect information along the way, I  preferred to 
> drive my translations based upon seeing input  constructs.  I can step 
> through easily with a debugger as it relates  directly to the input.  
> Driving things from the abstract set of  rules, just doesn't feel 
> natural to me.  But that could be a personal  choice.

I think it's all based on the scope of what you're trying to solve.
Implement a goto removal algorithm like this one: 
http://citeseer.ist.psu.edu/22521.html
and I think you'll find that the having the ability to fire some action 
at a "goto" and a "label" node in an AST is
just insignificant. It's not really a "do the following AST change at 
each goto" problem. And
changing a #define to a constant, or a function, or a variable, or just 
doing a direct replacement...it's the same thing.
By the time you've written all that code, who cares whether you're in 
the middle of walking an AST or
simply matched a token that started with "#define"?

>
> Perhaps one can look at this as ease of specification versus ease of  
> debugging and getting it right with all of these rules.   Rules are  
> easier for smaller systems, but I don't think they scale very well  
> (not in functionality of course just in ease of understanding the  
> entire system).  On the other hand, doing all of the work to get the  
> trees and the tree parser together can be a very high transaction  
> cost to get started.  In the long run though, I am thinking that  
> manipulating internal data structures, collecting information you  
> need, and then ultimately generating code is the best approach for  
> large systems.  That is not to say that we should not use the system  
> that makes us the most comfortable.  Clearly Andy is an exceptional  
> developer and has produced some amazing translators. no one can argue  
> with Andy's results.

The key is in the problem definition. If you take it as a given that 
you'll produce "natural" Java, then you have to decide how
to best do that. The fact that there is literally no other software 
other than Jazillian that produces "natural" code, says to me
that everyone who's approached it has taken the AST approach and hit a 
dead-end. IBM tried a COBOL-to-Java translator
and failed. How could that be? My guess is that they put a group of 
compiler-type people on it and said "make it work", rather than
put a group of NLP people on it, and said "do the best you can".

>
> Personally,  I think that a hybrid system that does most of the work  
> in a tree walker but with rules, for all of the special cases that  
> Andy has pointed out, would be great!

Me too. Or, as we discussed, let me write rules the way I think about 
them - as sequences of tokens. But you, internally, make it
into a tree. TXL does that, IIRC, but doesn't go far enough.

>
> * Generality.  From Andy's descriptions, he has many hand-built  
> functions asking questions about context.  As Sohail has pointed out,  
> this is the same as building parsers by hand and they are very  
> specific to the language being translated.

Not really - a parser builds an AST. It's more like providing a library 
to work on the lexer output.


> At this point, I am not  sure for what Andy uses ANTLR.  Probably to 
> build the rule-based  system he has.

No, I use it for the lexer, and also I do use ASTs for various 
operations on expressions (e.g. what type does
this expression return? Change this expression so it returns a boolean 
rather than an int).

>
>
> In summary, I think that a rule-based system has its place and I  
> would like to try my hand at building one learning from Andy's  
> experience.   For myself, I would limit its use to quick and dirty  
> translators that I need to build that have less than say 40 rules and  
> of course only in cases where I'm not concerned with speed.

I actually think the rule-based approach really shows its value at the 
high end of the scale - when you've already written
an AST-walking C-to-Java translator, and now it's time to try to produce 
realistic Java code. My code base is constantly
growing as I look and replace new patterns. Just this week, I've added 
two new rules to produce more realistic code
when replacing gotos. That's, of course, after a perfectly good 
goto-removal rule has been working fine for years.

>
> I'm perfectly willing to be wrong on this, just as I felt others were  
> wrong about the LL parsing approach back in the days when LR was king  
> in the early 90s.

I appreciate your openness, and I'm not saying I'm always right. Just 
trying to express what I've seen.

>
> This is one of the best discussions we have ever had on this mailing  
> list a thing.  Hooray!
>
> Ter
>
I've enjoyed it too. It's always fun to try to build something that 
seems to be impossible.
And even more fun for me to be able to have a good discussion about 
unconventional approaches
with people who are a lot smarter and more experienced than I am :)

Andy


From antlr at jazillian.com  Wed Oct 11 11:01:36 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 14:01:36 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
Message-ID: <452D3180.2070907@jazillian.com>

Loring Craymer wrote:

> Andy--
>
> I deliberately chose your message to respond to because it captured 
> the pragmatic viewpoint--"I had a problem; I solved it; I did not need 
> to use trees"--quite effectively.  That is quite a bit different from 
> the more usual "I tried to use ANTLR's tree facilities and discovered 
> that writing them by hand and using a visitor is easy and clearly is 
> the ONE TRUE SOLUTION to language processing" that appears in the 
> group every so often.  (Although, truth be told, some of your early 
> messages to the group were along that vein, but you have since worked 
> on problems that require multi-pass recognition support and have 
> broadened your horizons.)
>
> "Thinking in trees" does not come automatically.  It is like learning 
> LISP or Forth or one of the functional languages (and, for that 
> matter, object-oriented programming:  there is a lot of badly designed 
> and implemented C++ code out there).  For a time, working with trees 
> is like slogging through molasses, and then you get the "Aha!" 
> experience and things become easy.  It usually is not about designing 
> the perfect tree structure; instead, it is about simplifying the 
> recognition problem and expressing target language constructs in tree 
> form.

For the record, I had no trouble "getting" LISP when I learned it 25 
years ago. When I started with C++, I don't think I
really "got" OOD, and only started writing real OO code when learning 
Java forced me to. I think the fact that LISP never
became "mainstream" means that it failed to be easy enough to grasp. 
Regardless of how inherently beautiful it is,
if a lot of programmers don't easily "get it", then it's not that great.

As for tree structures, the AST shapes are pretty arbitrary. Monty's C 
grammar and the two java.g grammars build
similar trees, but there are differences where the only reason for the 
difference is "just because it was designed that way".
With a one dimensional token stream, we don't have that problem. There's 
one less level obstraction between what's
on the screen and the mental picture in my head. To this day, I'm not 
sure off the top of my head what the AST
is for, say, "public static void main(String[] args) {". I have trouble 
keeping the C AST, the Java AST, and the mapping
between the two in my head all at once. And this is the most trivial case!
And yet, as a sequence of tokens, there's no mental work at all. What I 
"see" is the same as my mental image.
(And what I "see" is a sequence of tokens, not a sequence of chars).

>
> If I were working on a natural language problem, would I use trees?  
> Sure!  Trees are a very convenient way of capturing semantics into 
> syntactic form.  Would I generate output with a visitor?  For 
> Esperanto or one of the Romance languages, possibly (for these 
> languages, simple syntactic principles apply); for English, that is 
> unlikely--too much "peephole" substitution is necessary to handle 
> special cases.  Instead, I would most likely process the input into a 
> canonical tree with a regular structure (converting input to tree form 
> is about transforming the special cases) and do some form of 
> rule-based substitution for all of the nasty colloquialisms and other 
> special cases.  (In compiler parlance, that is called "peephole 
> optimization", often an essential for generating good code.)

And yet, from what my admitedly feeble research found is that NLP 
systems generally don't use a tree.
If they do, it's not at the heart of the system - they are not "tree 
processors".

>
> As to compilers and compiler technology:  you might be surprised.  
> "Compiler technology" and "language translation technology" are 
> effectively synonyms, and the technical term for the translators you 
> have discussed in this group is "cascading compiler" (or used to be; 
> the term has pretty much disappeared from the literature as compiler 
> technology research has declined in popularity).  Most language 
> translation problems are much simpler than a conventional compiler and 
> are solved using a subset of the algorithms that go into building an 
> optimizing compiler.  

I always thought a "compiler" was just a translator that happened to 
have an output that's at a lower level than the input - typically
machine code, or byte code. But then, I guess I'm just remembering an 
undergrad compiler class from 20 years ago, and the
dragon book, so I guess I'm no expert.

> Nothing that you have described doing is out of place in a 
> conventional compiler environment.  You might find it interesting to 
> take a look at GNU RTL, used to generate the peephole optimizer for 
> the gcc toolset.

Huh??? That makes no sense to me. I've described lots of things that are 
completely out of place in
a conventional compiler. A conventional compiler doesn't translate 
library calls, like "printf" to "System.out.println".
I do stuff like "strcpy(v1, v2) --> v1 = v2", replacing a C strcpy() 
call with a Java assignment.
No conventional compiler does anything like that, because technically, 
it's wrong!
I rename files, methods, and variables based on user-specified mappings. 
Compilers don't do that.
I could go on.

>
> As to your "unconventional" approach:  I hate to say this, but 
> everything that you have described doing is well documented in the 
> literature.

Maybe you could point me to something specific. Today I'm adding smarts 
to my GotoRemoverRule that generates code that
is not faster or more compact than what it was producing before, but it 
looks better to the human eye. I doubt that
there's any literature on that.

> I have noticed that "healthy disrespect for conventional approaches" 
> usually translates to "I never check to see if I am reinventing the 
> wheel or not".  One of the great resources on the web is Citeseer:  
> <http://citeseer.ist.psu.edu/>.  It has some of the good early papers 
> on pattern matching and transformation systems.

I've looked at many, many papers on those. Can you point me to anything 
specific that you
think I'm missing?

I've also noticed that the person who feels like they're "breaking new 
ground" just hasn't done his homework. That's why
I spend so much time typing here - worried that I might be doing that. 
So I'm not just being defensive,
I really am looking for pointers.

Thanks,
Andy


From antlr at jazillian.com  Wed Oct 11 11:11:48 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 14:11:48 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061011045055.92247.qmail@web55914.mail.re3.yahoo.com>
References: <20061011045055.92247.qmail@web55914.mail.re3.yahoo.com>
Message-ID: <452D33E4.7070106@jazillian.com>

Loring Craymer wrote:

> I have off and on put a fair amount of thought into rule-based pattern 
> match-and-replace systems and how they might relate to ANTLR.  ANTLR 
> trees with transformations are like a surgeon's scalpel:  you can 
> locate precisely which parts of a tree need to be changed and change 
> them in situ.

What is the in situ Java replacement for "memcpy(a, b, c);"?
How about "char *p"? Is the replacement a String, an array of chars, a 
LinkedList of Character,
or maybe an integer index into an array?
How about replacing 10 lines of C code that clearly can be replaced by a 
single call to Collections.sort()?

If you're going to have a translation that "works" - has identical 
functionality as the original, the
answers may be straightforward. But if you are going to produce code 
that looks "hand-written"
(whether identical functionality or not), you're
going to have to take a good look around at the code in order to decide 
what should be produced.

If someone's covered these issues in the literature and I just missed 
it, let me know.

Andy



From antlr at jazillian.com  Wed Oct 11 11:29:46 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 14:29:46 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <1160543177.6126.10.camel@localhost.localdomain>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
Message-ID: <452D381A.50407@jazillian.com>

Sohail Somani wrote:

>On Tue, 2006-10-10 at 11:12 -0400, Andy Tripp wrote:
>  
>
>>Sohail Somani wrote:
>>    
>>
>>>>Its weird that you're walking token streams, but what it seems it that
>>>>you're implementing the recursive descent parser by hand...
>>>>   
>>>>
>>>>        
>>>>
>>But a parser converts a token stream to an AST, I'm not using an AST, 
>>but dealing with
>>the stream directly because that seems easier to me. I find it easier to 
>>search for
>>pattern "f(...) {" to look for a function, rather than search a tree for 
>>a node of type
>>FUNCTION_DECLARATION.
>>    
>>
>
>A parser doesn't *have* to create an AST. For example, consider a syntax
>directed translation. That is something that simply recognizes token
>structure and performs some actions.
>  
>
I realize that. I'm just saying that I wouldn't consider my library of 
functions on token-streams to
be "implementing a recursive descent parser by hand" as you said. Not 
even close.

>  
>
>>>I believe there is an unspoken rule that all bets are off with COBOL?
>>> 
>>>
>>>      
>>>
>>Yes, I suppose. But even with C and C++, what seems simple may not be. 
>>For example, you'd think that
>>struct person p[100];
>>might correspond to a single line of Java, but it doesn't (you need to 
>>initialize the
>>array). So suddenly, out of nowhere, you may have to add a static block 
>>of code. That's
>>a typical one-to-many type of thing.
>>    
>>
>
>I'm not sure how an AST a la antlr prevents you from doing this.
>
I'm not saying using an AST prevents you from doing this, just that it's 
not helping. I've found that
for over 99% of what I'm doing, an AST is not helping. Therefore, I 
don't have an AST-centric
architecture.

> 
>
>  
>
>>because it may certainly have changed since you last looked at it..in 
>>other words, the symbol
>>table can be a mess to maintain. In my case, the return type of b() may 
>>have change, the name of it
>>may have changed, its argument types may have changed.
>>    
>>
>
>Changed from what to what? And how the heck can they change in a single
>run of the compiler? I'm confused.
>  
>
It's not a compiler, it's a translator! "if (1)" works in C, but not 
Java. So when we have
"if (a)" and "a" is type "int", we need to change its type to boolean. 
(And no, I'm not just going
to change it to "if (a != 0)"  ).

>  
>
>>Also, my tool does not have to be fast - if it takes an hour to 
>>translate some code, when it could
>>have taken 2 seconds if I had designed it "right", that's ok.
>>    
>>
>
>I don't think anyone is telling you that you didn't design it right! I
>myself would like to have the power of:
>
>v1 = v1 + v2 => v1 += v2
>
>transformations. Myself, I'm only trying to figure out what the big deal
>is that prevents you from using antlr. Personally, I know I wouldn't
>want to write token matching code.
>  
>
Nothing preventing me from using ANTLR. Just saying that I've found that 
walking an AST is
not the best architecture for what I'm doing. I use ANTLR for lexing, 
and even for AST generation
for expressions. It's just that my translator is not in any way "a 
treewalker" approach, either using
ANTLR treewalkers or just a Visitor pattern.

>Please don't think I am attacking your translator. We all know how
>difficult the problem is you're trying to solve. All I'm trying to
>understand is how you solved it.
>  
>
No problem. I have thick skin :)

I feel like I'm always "talking past" people on this list, and I think 
it's the "compiler mindset".
I really do think that C-to-Java and COBOL-to-Java, where you produce 
"natural" Java code,
is more like English-to-Spanish than it is like Java-to-bytecode. Sure, 
the input and output
are structured and treelike, but to emulate what a person does, simply 
"walking the tree"
isn't going to work for English-to-Spanish or COBOL-to-Java. Go ahead 
and and put
"Woods Eyes Masters" into a tree and then convert to Spanish. You'll 
come back later
and say "...but my program would have to know the context to even see 
that it's talking
about Tiger!" and I'll grin and say "that's right."


From antlr at jazillian.com  Wed Oct 11 11:42:58 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 14:42:58 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452CACD9.3080203@cyconix.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
	<452CACD9.3080203@cyconix.com>
Message-ID: <452D3B32.5020805@jazillian.com>

Paul Johnson wrote: 

>
> I use ANTLR's tree facilities all the time. What I don't do is to use 
> tree *grammars*, and it is the argument against grammars that I have 
> occasionally seen in this list. This specific AST/tree argument, as I 
> understand it (and *not* the translation philosophy argument) is about 
> whether the advantages of having a tree grammar outweigh the 
> disadvantages.

In this thread, I'm just arguing against a tree-walking-based 
architecture for language translation where
the generated code is "natural" - looks hand-written. I haven't seen 
anyone else build a tool with that
as a basic requirement - my Jazillian tool is the only one I've seen. 
Probably everyone else here is
using ANTLR for some other goal, so I'm not really suggesting anyone 
else change what they're doing.

Just trying to justify my design. My guess is that everyone else who's 
tried to build something like
a COBOL-to-Java or C-to-Java tools has ended up giving up on the 
"produce natural code" goal
to preserve the "produce working code" goal (see 
http://ovid.tigris.org/Ephedra/ for example).

>
> The ease of using visitors is not central to that argument. The 
> problem is that tree grammars are (currently?) inflexible, but 
> visitors are both flexible and trivial, so you should use visitors 
> where appropriate.

Right. I expand on my thoughts in this article:
http://antlr.org/article/1136917339929/stringTemplate.html

And I'm more a fan of "just walk the tree by hand" or "use visitors" 
than I am of the whole ANTLR treewalker thing.
But that's a separate discussion, which I cover here:
http://www.jazillian.com/articles/treewalkers.html

Andy

>
> Paul
>


From kroepke at classdump.org  Wed Oct 11 12:10:36 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Wed, 11 Oct 2006 21:10:36 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452D381A.50407@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
Message-ID: <A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>


On 11. Oct 2006, at 20:29 Uhr, Andy Tripp wrote:

>  Go ahead and and put
> "Woods Eyes Masters" into a tree and then convert to Spanish.  
> You'll come back later
> and say "...but my program would have to know the context to even  
> see that it's talking
> about Tiger!" and I'll grin and say "that's right."

sorry, but I cannot refrain:

	Lexer	     ->	    Parser     ->		AST
"Woods Eyes Masters" -> NOUN VERB NOUN -> (VERB["Eyes"] SUBJECT 
["Woods"] OBJECT["Masters"])
	Lexer	     ->	 Token stream  ->	Translation ("Las maderas echan  
miradas a los amos")
"Woods Eyes Masters" -> NOUN VERB NOUN ->	Translation ("Las maderas  
echan miradas a los amos")

Even if you do not consider my horrible spanish, I fail to see how  
any approach could do this without knowing the context.

I agree with you that the mechanics of how you organize your  
translation become minor the farther you are into the project.
You will eventually have to build up a lot of support code to do the  
job (take a look at compilers, most often the actual
lexing/parsing is the least part in generating the output. Much more  
work has to be put into the type system, building up
graphs to do optimizations, semantic checks, checking for invalid  
operations etc.)

Don't you have to know the types of the variables used in the source  
and destination language? Can you actually do without
a type system and/or symbol table? I find it hard to picture doing  
the right thing without trees, but then again I might
be missing a lot.
I would expect to have the structure of the input (tree vs. flat  
stream) to not have much influence on your ability to produce
"natural" code. Both approaches force you to look all over the place  
to determine the usage of, say the malloc() family, e.g.
is it used to reallocing an array, to buffer up some characters etc.  
These would obviously be coded quite differently in Java.

When I see a "rule" like
	v1 = v1 + v2 => v1 += v2
I cannot help but seeing a tree. In the end, it's just another way to  
specify a transformation, is it not? I mean, what is the
fundamental difference? Tokens that are close to each other in a  
token stream most often end up close to each other in a tree for
some metric, aren't they? Ok, they might end up in different branches  
from a common interior node, but for really nasty stuff like
variable decl vs. usage you have symbol tables. I feel like I'm  
missing some important information here.

Like the others, I don't want to pick on your approach, but am very  
interested in seeing it from a different angle. Your success
with your translators points that you have found something that  
works, and seems to work quite well.
Though I must add, I'm also worrying about implicit loops in the  
rules. While they seem to be pretty simple algebraically, detecting
infinite loops is a surprisingly hard problem. Proving them to be  
well-formed and closed can be non-trivial to say the least.

cheers,

-k




From ric.klaren at gmail.com  Wed Oct 11 13:22:48 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed, 11 Oct 2006 22:22:48 +0200
Subject: [antlr-interest] interpretation '\t'
In-Reply-To: <29F58182-A9F6-4396-A6C4-FB11D5F8D514@classdump.org>
References: <D72A054DF5002D4FA6CF14252F7997B8D97E51@BLRKECMSG13.ad.infosys.com>
	<29F58182-A9F6-4396-A6C4-FB11D5F8D514@classdump.org>
Message-ID: <bc607a4e0610111322y40d80fe2ta60a063f9a5edc25@mail.gmail.com>

Hi,

There's getTabSize/setTabSize methods in the CharScanner class. You
can use that to set the size. Although you still have to call tab()
from within your lexer to 'count' the tabs.

Cheers,

Ric

From antlr at jazillian.com  Wed Oct 11 13:33:03 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 16:33:03 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
Message-ID: <452D54FF.1080101@jazillian.com>

Kay Roepke wrote:

>
> On 11. Oct 2006, at 20:29 Uhr, Andy Tripp wrote:
>
>>  Go ahead and and put
>> "Woods Eyes Masters" into a tree and then convert to Spanish.  You'll 
>> come back later
>> and say "...but my program would have to know the context to even  
>> see that it's talking
>> about Tiger!" and I'll grin and say "that's right."
>
>
> sorry, but I cannot refrain:
>
>     Lexer         ->        Parser     ->        AST
> "Woods Eyes Masters" -> NOUN VERB NOUN -> (VERB["Eyes"] SUBJECT 
> ["Woods"] OBJECT["Masters"])
>     Lexer         ->     Token stream  ->    Translation ("Las maderas 
> echan  miradas a los amos")
> "Woods Eyes Masters" -> NOUN VERB NOUN ->    Translation ("Las 
> maderas  echan miradas a los amos")
>
> Even if you do not consider my horrible spanish, I fail to see how  
> any approach could do this without knowing the context.

Right.

>
>
> I agree with you that the mechanics of how you organize your  
> translation become minor the farther you are into the project.
> You will eventually have to build up a lot of support code to do the  
> job (take a look at compilers, most often the actual
> lexing/parsing is the least part in generating the output. Much more  
> work has to be put into the type system, building up
> graphs to do optimizations, semantic checks, checking for invalid  
> operations etc.)

Right. So now you've got 100,000 lines of support code that was 
triggered by a single AST action:
"Here is a sentence, translate it by looking at the whole context".
At that point, is it even a "tree-walking architecture".

>
> Don't you have to know the types of the variables used in the source  
> and destination language? Can you actually do without
> a type system and/or symbol table? 

Sure, if you can just call a library function that searches a token 
stream to figure out a variable's type, then you don't
need to keep a separate table.

> I find it hard to picture doing  the right thing without trees, but 
> then again I might
> be missing a lot.

As I said, you've got maybe 100,000 lines of code that does all kinds of 
stuff to be able to translate sentences like
"Woods Eyes Masters". It knows that "Woods" is a person, it knows that 
"Masters" is an upcoming golf tournament.
I knows that this "Woods" person might actually be "eyeing" this 
particular tournament. It knows this is a sports page
headline. It would be able to handle "Andy Masters Woods", too (assuming 
it knows that I'm working on
my driving skills).

By the time you've got all that code working, the fact that you're using 
a tree structure is just a very minor footnote.
Your translation above is horribly wrong, and the AST didn't help you 
make it right one bit.

> I would expect to have the structure of the input (tree vs. flat  
> stream) to not have much influence on your ability to produce
> "natural" code. Both approaches force you to look all over the place  
> to determine the usage of, say the malloc() family, e.g.
> is it used to reallocing an array, to buffer up some characters etc.  
> These would obviously be coded quite differently in Java.
>
> When I see a "rule" like
>     v1 = v1 + v2 => v1 += v2
> I cannot help but seeing a tree. 

That's because it's too trivial of an example, and I think that's the 
trap that people keep falling into.
Try:
ADD A B TO C D GIVING E.
NAME PIX 9(5)V99 VALUE ALL SPACES.

or
main(int argc, char *argv[]);

The first ones is hard for you picture as a tree because it's COBOL and 
you don't even know right off
what they MEAN. As for the C example, I have trouble remembering what 
the tree is for "*argv[]",
and I'm frustrated that I'll have to deal with "char *argv[]", "char 
**argv", "char argv[][]", etc. individually.
I'd rather just once map them all to a single form by doing stuff like:
char **v --> char *v[]

> In the end, it's just another way to  specify a transformation, is it 
> not? I mean, what is the
> fundamental difference? Tokens that are close to each other in a  
> token stream most often end up close to each other in a tree for
> some metric, aren't they? Ok, they might end up in different branches  
> from a common interior node, but for really nasty stuff like
> variable decl vs. usage you have symbol tables. I feel like I'm  
> missing some important information here.

I think one thing that maybe you're missing is the scope of the problem 
that I'm dealing with.
You refer to "variable decl vs. usage" as "really nasty stuff". Using 
token streams, I find a declaration
by looking backwards for pattern "<type> v;" or "<type> v =". If I don't 
find that pattern, I search other files
for that pattern. That's pretty trivial code to search for that pattern, 
starting at a given token. That's not the
"nasty stuff", that's the trivial stuff!

The nasty stuff is things like looking at a variable that's an "int" or 
"long"
type, looking at every reference to see if it will be possible to change 
the variable type to "boolean", and then
doing so. Or looking at a pointer declaration and all its usages to see 
what the Java equivalent really is:
is it used solely as an array index? (if so, we'll replace the pointer 
by an "int", change the thing it points to
into an array, and change the syntax of every reference) Or is it a real 
pointer type, such
as in a LinkedList? Or is it just a pointer
so that we can pass an address to a function and have the function 
change the value? This kind of analysis
needs lots of heuristics and lots of work. So I sometimes feel like I'm 
just getting started when everyone else
has already given up.

I think most people here would get to "memset()" and simply say "sorry, 
there's no
Java equivalent", whereas I would then get going listing out the common 
cases: is memset being
used to initialize a variable which will automatically be guaranteed to 
be initialized in Java? Or do I need to
generate some initialization code? Can it just be replaced by a single 
"new" call? And so on.

>
> Like the others, I don't want to pick on your approach, but am very  
> interested in seeing it from a different angle. Your success
> with your translators points that you have found something that  
> works, and seems to work quite well.
> Though I must add, I'm also worrying about implicit loops in the  
> rules. While they seem to be pretty simple algebraically, detecting
> infinite loops is a surprisingly hard problem. Proving them to be  
> well-formed and closed can be non-trivial to say the least.
>
> cheers,
>
> -k

Thanks for the input. I think your response to translating "Woods Eyes 
Masters" illustrates my point perfectly.
That is, for real NLP, treewalking solves nothing. It's simply one way 
to start approaching the problem,
and by the time you tackle all the hard issues, treewalking is just a 
tiny piece of the work, and it's not clear (to me)
that it's even adding anything. To me, saying "high-level language 
translation is mostly a matter of walking an AST"
is like saying "Getting from NYC to LA is mostly a matter of getting on 
a plane". Yea, that may be true. But if
you're going to program a robot to get from NYC to LA, getting on the 
plane will be just one tiny piece. To the
point where it doesn't really matter whether the robot takes a plane or 
a car.

Andy :)

>
>
>


From ric.klaren at gmail.com  Wed Oct 11 13:38:12 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Wed, 11 Oct 2006 22:38:12 +0200
Subject: [antlr-interest] Bug report: 2.7.5 and 2.7.6
In-Reply-To: <7AB1C26C64423249964AB392C6EBF0E0601D32@discovery.isis.vanderbilt.edu>
References: <7AB1C26C64423249964AB392C6EBF0E0601D32@discovery.isis.vanderbilt.edu>
Message-ID: <bc607a4e0610111338x6a6439bdwfc2fbaec391455b9@mail.gmail.com>

Hi,

On 10/11/06, Harmon Nine <hnine at isis.vanderbilt.edu> wrote:
> One thing:  is there a means of automatically determining, perhaps
> through a precompiler macro, what version of antlr is being used during
> a compile?

The runtime doesn't have a version variable of it's own. Yet in normal
(unix) installs there's the antlr-config script, that can be used to
query things like the version include and lib locations.

So you could do things like :

gcc -DANTLRVERSION=`antlr-config --version` .. etc.

And then use preprocessor macros.

If you got antlr in some vendor branch in source control then you
might even introduce a local patch with a version number in the header
file.

> I'd like to use the latest version of antlr in a software port (to
> linux), but the original software uses antlr-2.7.1, and that is pretty
> much cast in stone.  Is there a way of doing something like the
> following?

Upgrading is pretty much recommended. If you're really fixed on 2.7.1
then you can get a bugfix version from before the ASTFactory reworks
from

http://pts14043.pts.nl/antlr/

Cheers,

Ric

From kroepke at classdump.org  Wed Oct 11 14:56:27 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Wed, 11 Oct 2006 23:56:27 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452D54FF.1080101@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
	<452D54FF.1080101@jazillian.com>
Message-ID: <53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org>


On 11. Oct 2006, at 22:33 Uhr, Andy Tripp wrote:

> Kay Roepke wrote:
>
>> On 11. Oct 2006, at 20:29 Uhr, Andy Tripp wrote:
>>
>> Don't you have to know the types of the variables used in the  
>> source  and destination language? Can you actually do without
>> a type system and/or symbol table?
>
> Sure, if you can just call a library function that searches a token  
> stream to figure out a variable's type, then you don't
> need to keep a separate table.

Ok, then it simply boils down to you not being concerned with redoing  
that every time you'd need to know a variable's type, right?
You could of course do the same thing in a tree, traversing it every  
time you find a reference to a variable. I think this is bothering me  
the most, I find it hard to grasp why you would like to do the  
searching over and over, instead of simply recording the fact that  
`foo' was declared as `int' and then use that information further  
down the line. But I agree that from a functionality point of view it  
doesn't matter how you end up knowing the type of something as long  
as you can discover it.

>> I find it hard to picture doing  the right thing without trees,  
>> but then again I might
>> be missing a lot.
>
> As I said, you've got maybe 100,000 lines of code that does all  
> kinds of stuff to be able to translate sentences like
> "Woods Eyes Masters". It knows that "Woods" is a person, it knows  
> that "Masters" is an upcoming golf tournament.
> I knows that this "Woods" person might actually be "eyeing" this  
> particular tournament. It knows this is a sports page
> headline. It would be able to handle "Andy Masters Woods", too  
> (assuming it knows that I'm working on
> my driving skills).
>
> By the time you've got all that code working, the fact that you're  
> using a tree structure is just a very minor footnote.
> Your translation above is horribly wrong, and the AST didn't help  
> you make it right one bit.

heh heh. I never said that I actually know any Spanish ;) But I could  
argue along the same lines: With a flat stream approach, you'd still  
build up a hierarchical data structure of some sort to discover the  
structure of sentences. You would have to able to distinguish various  
grammatical structures (of which I simply don't know the proper  
english terms, unfortunately. I'd need to look them up, which I'm too  
lazy right now...), in order to retain the logical structure of a  
sentence. You might not start from an AST, but you still would  
implicitely build one.

>> When I see a "rule" like
>>     v1 = v1 + v2 => v1 += v2
>> I cannot help but seeing a tree.
>
> That's because it's too trivial of an example, and I think that's  
> the trap that people keep falling into.
> Try:
> ADD A B TO C D GIVING E.
> NAME PIX 9(5)V99 VALUE ALL SPACES.
>
> or
> main(int argc, char *argv[]);
>
> The first ones is hard for you picture as a tree because it's COBOL  
> and you don't even know right off
> what they MEAN. As for the C example, I have trouble remembering  
> what the tree is for "*argv[]",
> and I'm frustrated that I'll have to deal with "char *argv[]",  
> "char **argv", "char argv[][]", etc. individually.
> I'd rather just once map them all to a single form by doing stuff  
> like:
> char **v --> char *v[]

True enough, things can get complicated real quick. But isn't the  
value of an AST that you can formulate "rules" on the basis of the  
_abstract_ structure of the input? How would you model something like  
this with your rule based system? E.g.:
char **v vs. int **v vs. id *someObject (id being the generic  
_pointer_ to an object in Objective-C) ?
Would you need one rule for each supported type instead of one rule  
for all non-pointer types and one exception for pointer types?

>> In the end, it's just another way to  specify a transformation, is  
>> it not? I mean, what is the
>> fundamental difference? Tokens that are close to each other in a   
>> token stream most often end up close to each other in a tree for
>> some metric, aren't they? Ok, they might end up in different  
>> branches  from a common interior node, but for really nasty stuff  
>> like
>> variable decl vs. usage you have symbol tables. I feel like I'm   
>> missing some important information here.
>
> I think one thing that maybe you're missing is the scope of the  
> problem that I'm dealing with.
> You refer to "variable decl vs. usage" as "really nasty stuff".  
> Using token streams, I find a declaration
> by looking backwards for pattern "<type> v;" or "<type> v =". If I  
> don't find that pattern, I search other files
> for that pattern. That's pretty trivial code to search for that  
> pattern, starting at a given token. That's not the
> "nasty stuff", that's the trivial stuff!

Sorry, I wasn't clear. Simply recording the type of a variable is  
trivial. I was referring to the proximity of those nodes in the tree,
which could make it "nasty" in terms of traversal needed to find the  
declaration when you see a usage.

> The nasty stuff is things like looking at a variable that's an  
> "int" or "long"
> type, looking at every reference to see if it will be possible to  
> change the variable type to "boolean", and then
> doing so. Or looking at a pointer declaration and all its usages to  
> see what the Java equivalent really is:
> is it used solely as an array index? (if so, we'll replace the  
> pointer by an "int", change the thing it points to
> into an array, and change the syntax of every reference) Or is it a  
> real pointer type, such
> as in a LinkedList? Or is it just a pointer
> so that we can pass an address to a function and have the function  
> change the value? This kind of analysis
> needs lots of heuristics and lots of work. So I sometimes feel like  
> I'm just getting started when everyone else
> has already given up.
>
> I think most people here would get to "memset()" and simply say  
> "sorry, there's no
> Java equivalent", whereas I would then get going listing out the  
> common cases: is memset being
> used to initialize a variable which will automatically be  
> guaranteed to be initialized in Java? Or do I need to
> generate some initialization code? Can it just be replaced by a  
> single "new" call? And so on.

I think this where it gets interesting, too. Actually the lack of  
tools that produce natural code in the target language is probably  
the most important reason why many people wouldn't even consider  
using a language translator for any sizable codebase, which has to be  
maintained thereafter.
Myself included. I have never considered even to look for a Java to  
Objective-C translator to port StringTemplate, for instance. Not that  
I'd think there is anything like that, but still.

> Thanks for the input. I think your response to translating "Woods  
> Eyes Masters" illustrates my point perfectly.
> That is, for real NLP, treewalking solves nothing. It's simply one  
> way to start approaching the problem,
> and by the time you tackle all the hard issues, treewalking is just  
> a tiny piece of the work, and it's not clear (to me)
> that it's even adding anything. To me, saying "high-level language  
> translation is mostly a matter of walking an AST"
> is like saying "Getting from NYC to LA is mostly a matter of  
> getting on a plane".

I'm not an expert in linguistics, far from it, so I can't really say  
anything for NLP. But for artificial languages I think it helps  
solving real problems. I don't think it is an accident that trees are  
in use for these things for such a long time (scale: comp.sci.).  
Surely, it is a silver bullet, as you have demonstrated. If it was  
the only way to get things done, you couldn't have built what you  
have built.

> Yea, that may be true. But if
> you're going to program a robot to get from NYC to LA, getting on  
> the plane will be just one tiny piece. To the
> point where it doesn't really matter whether the robot takes a  
> plane or a car.

:D

cheers,
-k


From antlr at jazillian.com  Wed Oct 11 16:12:11 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 19:12:11 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org> 
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
	<452D54FF.1080101@jazillian.com>
	<53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org> 
Message-ID: <452D7A4B.2040704@jazillian.com>

Andy Tripp wrote:

> Kay Roepke wrote:
>
>>
>> On 11. Oct 2006, at 22:33 Uhr, Andy Tripp wrote:
>>
>>> Kay Roepke wrote:
>>>
>>>> On 11. Oct 2006, at 20:29 Uhr, Andy Tripp wrote:
>>>>
>>>> Don't you have to know the types of the variables used in the  
>>>> source  and destination language? Can you actually do without
>>>> a type system and/or symbol table?
>>>
>>>
>>>
>>> Sure, if you can just call a library function that searches a token  
>>> stream to figure out a variable's type, then you don't
>>> need to keep a separate table.
>>
>>
>>
>> Ok, then it simply boils down to you not being concerned with 
>> redoing  that every time you'd need to know a variable's type, right?
>
>
> Right. It's just that my getVariableType() method searches a token 
> stream rather than a symbol table, that's all.
>
>> You could of course do the same thing in a tree, traversing it every  
>> time you find a reference to a variable. I think this is bothering 
>> me  the most, I find it hard to grasp why you would like to do the  
>> searching over and over, instead of simply recording the fact that  
>> `foo' was declared as `int' and then use that information further  
>> down the line. 
>
>
> As I've said before, the reason is that I'd end up making lots of 
> calls to keep the symbol table up to date. By "lots of calls"
> I mean, writing lines of code. Assuming that it's just as easy to 
> write code (and call it) that looks at the token stream as to look
> at a symbol table, the only reason for a symbol table would be 
> performance, which I'm not concerned about.
>
>> But I agree that from a functionality point of view it  doesn't 
>> matter how you end up knowing the type of something as long  as you 
>> can discover it.
>>
>>>> I find it hard to picture doing  the right thing without trees,  
>>>> but then again I might
>>>> be missing a lot.
>>>
>>>
>>>
>>> As I said, you've got maybe 100,000 lines of code that does all  
>>> kinds of stuff to be able to translate sentences like
>>> "Woods Eyes Masters". It knows that "Woods" is a person, it knows  
>>> that "Masters" is an upcoming golf tournament.
>>> I knows that this "Woods" person might actually be "eyeing" this  
>>> particular tournament. It knows this is a sports page
>>> headline. It would be able to handle "Andy Masters Woods", too  
>>> (assuming it knows that I'm working on
>>> my driving skills).
>>>
>>> By the time you've got all that code working, the fact that you're  
>>> using a tree structure is just a very minor footnote.
>>> Your translation above is horribly wrong, and the AST didn't help  
>>> you make it right one bit.
>>
>>
>>
>> heh heh. I never said that I actually know any Spanish ;) But I 
>> could  argue along the same lines: With a flat stream approach, you'd 
>> still  build up a hierarchical data structure of some sort to 
>> discover the  structure of sentences. You would have to able to 
>> distinguish various  grammatical structures (of which I simply don't 
>> know the proper  english terms, unfortunately. I'd need to look them 
>> up, which I'm too  lazy right now...), in order to retain the logical 
>> structure of a  sentence. You might not start from an AST, but you 
>> still would  implicitely build one.
>
>
>
> Yea, maybe. But it's one thing to use a tree-like data structure as 
> one of many data structures during processing.
> It's quite another to architect the whole thing as a "tree-walking 
> approach".
>
>>
>>>> When I see a "rule" like
>>>>     v1 = v1 + v2 => v1 += v2
>>>> I cannot help but seeing a tree.
>>>
>>>
>>>
>>> That's because it's too trivial of an example, and I think that's  
>>> the trap that people keep falling into.
>>> Try:
>>> ADD A B TO C D GIVING E.
>>> NAME PIX 9(5)V99 VALUE ALL SPACES.
>>>
>>> or
>>> main(int argc, char *argv[]);
>>>
>>> The first ones is hard for you picture as a tree because it's COBOL  
>>> and you don't even know right off
>>> what they MEAN. As for the C example, I have trouble remembering  
>>> what the tree is for "*argv[]",
>>> and I'm frustrated that I'll have to deal with "char *argv[]",  
>>> "char **argv", "char argv[][]", etc. individually.
>>> I'd rather just once map them all to a single form by doing stuff  
>>> like:
>>> char **v --> char *v[]
>>
>>
>>
>> True enough, things can get complicated real quick. But isn't the  
>> value of an AST that you can formulate "rules" on the basis of the  
>> _abstract_ structure of the input? How would you model something 
>> like  this with your rule based system? E.g.:
>> char **v vs. int **v vs. id *someObject (id being the generic  
>> _pointer_ to an object in Objective-C) ?
>
>
> In my pattern matching system, I have simple "placeholders". I'd say:
> v1 **v2 --> v1 v2[][];
> The "v1" and "v2" will match only simple single-ID tokens (like "int") 
> and things that look like variable references
> (like foo[3].bar). I also have an "x" placeholder that matches "zero 
> or more characters" and handles
> nesting of braces like this:
>
> if (true) {x2} --> x2
>
>> Would you need one rule for each supported type instead of one rule  
>> for all non-pointer types and one exception for pointer types?
>
>
> If things get non-trivial, I can mix this pattern language with code. 
> For example, to verify that
> the "v1" in v1 **v2 --> v1 v2[][];" really is a type, I could say 
> something like:
>
> class StarChecker extends PatternRule {
>    StarChecker() {
>         super("v1 ** v2", "v1 v2[][]");
>   }
>   boolean match(Source source) {
>        if (super.match(source)) {
>            String v1 = results.get("v1");    // get the text that "v1" 
> placeholder matched
>            if (source.isType(v1)) {           // verify that it's 
> really a type (e.g. using symbol table)
>                return true;
>            }
>         }
>         return false;
> }
>
>>
>>>> In the end, it's just another way to  specify a transformation, is  
>>>> it not? I mean, what is the
>>>> fundamental difference? Tokens that are close to each other in a   
>>>> token stream most often end up close to each other in a tree for
>>>> some metric, aren't they? Ok, they might end up in different  
>>>> branches  from a common interior node, but for really nasty stuff  
>>>> like
>>>> variable decl vs. usage you have symbol tables. I feel like I'm   
>>>> missing some important information here.
>>>
>>>
>>>
>>> I think one thing that maybe you're missing is the scope of the  
>>> problem that I'm dealing with.
>>> You refer to "variable decl vs. usage" as "really nasty stuff".  
>>> Using token streams, I find a declaration
>>> by looking backwards for pattern "<type> v;" or "<type> v =". If I  
>>> don't find that pattern, I search other files
>>> for that pattern. That's pretty trivial code to search for that  
>>> pattern, starting at a given token. That's not the
>>> "nasty stuff", that's the trivial stuff!
>>
>>
>>
>> Sorry, I wasn't clear. Simply recording the type of a variable is  
>> trivial. I was referring to the proximity of those nodes in the tree,
>> which could make it "nasty" in terms of traversal needed to find the  
>> declaration when you see a usage.
>
>
> Seems pretty trivial to find the variable declaration either way.
>
>>
>>> The nasty stuff is things like looking at a variable that's an  
>>> "int" or "long"
>>> type, looking at every reference to see if it will be possible to  
>>> change the variable type to "boolean", and then
>>> doing so. Or looking at a pointer declaration and all its usages to  
>>> see what the Java equivalent really is:
>>> is it used solely as an array index? (if so, we'll replace the  
>>> pointer by an "int", change the thing it points to
>>> into an array, and change the syntax of every reference) Or is it a  
>>> real pointer type, such
>>> as in a LinkedList? Or is it just a pointer
>>> so that we can pass an address to a function and have the function  
>>> change the value? This kind of analysis
>>> needs lots of heuristics and lots of work. So I sometimes feel like  
>>> I'm just getting started when everyone else
>>> has already given up.
>>>
>>> I think most people here would get to "memset()" and simply say  
>>> "sorry, there's no
>>> Java equivalent", whereas I would then get going listing out the  
>>> common cases: is memset being
>>> used to initialize a variable which will automatically be  
>>> guaranteed to be initialized in Java? Or do I need to
>>> generate some initialization code? Can it just be replaced by a  
>>> single "new" call? And so on.
>>
>>
>>
>> I think this where it gets interesting, too. Actually the lack of  
>> tools that produce natural code in the target language is probably  
>> the most important reason why many people wouldn't even consider  
>> using a language translator for any sizable codebase, which has to 
>> be  maintained thereafter.
>
>
> Right. I'm trying to change the dynamics on that and get people to 
> believe that it can be done.
> I believe my product does it, but it's still a tough sell. About 1/3 
> of the people who come up to our booth
> at tradeshows are "skeptics". They come up, take a quick look, and 
> then ask "how do you handle unions?" or
> "...memset?" or "multiple inheritence." By the time I've started 
> explaining about how memset is almost always
> used to initialize a struct to zero, and we check for that sort of 
> thing, they walk away. It's how we programmers
> naturally are: we sure want our compilers to work 100%, and it seems 
> like a translator should, too. So since
> it's impossible, in theory, we go back and do it by hand (or don't do 
> it). It never occurs to us that someone could simply
> automate the stuff that everyone's doing by hand and save everyone 90% 
> of the time and effort.
>
> The traveling salesman problem is NP-complete, and yet we have no 
> problem using algorithms that are less than
> perfect do the best they can because they're so much better than 
> humans. It's a shame we can't seem to take
> the same approach with rewriting code to a new language.
>
>> Myself included. I have never considered even to look for a Java to  
>> Objective-C translator to port StringTemplate, for instance. Not 
>> that  I'd think there is anything like that, but still.
>>
>>> Thanks for the input. I think your response to translating "Woods  
>>> Eyes Masters" illustrates my point perfectly.
>>> That is, for real NLP, treewalking solves nothing. It's simply one  
>>> way to start approaching the problem,
>>> and by the time you tackle all the hard issues, treewalking is just  
>>> a tiny piece of the work, and it's not clear (to me)
>>> that it's even adding anything. To me, saying "high-level language  
>>> translation is mostly a matter of walking an AST"
>>> is like saying "Getting from NYC to LA is mostly a matter of  
>>> getting on a plane".
>>
>>
>>
>> I'm not an expert in linguistics, far from it, so I can't really say  
>> anything for NLP. 
>
>
> Yea, me neither. I was pretty shocked at how different the NLP 
> approaches are from "compiler" approaches.
> Seemed like zero overlap. I'm still pretty shocked at how bad NLP 
> seems to be, but I guess I have just
> one data point: babelfish.
>
>> But for artificial languages I think it helps  solving real problems. 
>> I don't think it is an accident that trees are  in use for these 
>> things for such a long time (scale: comp.sci.).  Surely, it is a 
>> silver bullet, as you have demonstrated. If it was  the only way to 
>> get things done, you couldn't have built what you  have built.
>>
>>> Yea, that may be true. But if
>>> you're going to program a robot to get from NYC to LA, getting on  
>>> the plane will be just one tiny piece. To the
>>> point where it doesn't really matter whether the robot takes a  
>>> plane or a car.
>>
>>
>>
>> :D
>>
>> cheers,
>> -k
>>
>
>


From kroepke at classdump.org  Wed Oct 11 16:54:25 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Thu, 12 Oct 2006 01:54:25 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452D7A4B.2040704@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
	<452D54FF.1080101@jazillian.com>
	<53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org>
	<452D7A4B.2040704@jazillian.com>
Message-ID: <DEAD2FB3-2E86-46D4-99BE-E8843B488479@classdump.org>


On 12. Oct 2006, at 1:12 Uhr, Andy Tripp wrote:

Andy Tripp wrote:

> Yea, maybe. But it's one thing to use a tree-like data structure as  
> one of many data structures during processing.
> It's quite another to architect the whole thing as a "tree-walking  
> approach".

I see what you mean. I don't have the experience to judge whether a  
tree-walking approach would actually be feasible in this case (esp.  
considering Cobol), though I still think I'd go the tree way. This is  
not to say that some sort of rule system wouldn't solve some things  
easier. The example you give below still strikes me being  
implementable with trees, though. I guess it's just that I haven't  
seen an example that is really convoluted with trees.

>> Would you need one rule for each supported type instead of one  
>> rule  for all non-pointer types and one exception for pointer types?
>
> If things get non-trivial, I can mix this pattern language with  
> code. For example, to verify that
> the "v1" in v1 **v2 --> v1 v2[][];" really is a type, I could say  
> something like:
>
> class StarChecker extends PatternRule {
>    StarChecker() {
>         super("v1 ** v2", "v1 v2[][]");
>   }
>   boolean match(Source source) {
>        if (super.match(source)) {
>            String v1 = results.get("v1");    // get the text that  
> "v1" placeholder matched
>            if (source.isType(v1)) {           // verify that it's  
> really a type (e.g. using symbol table)
>                return true;
>            }
>         }
>         return false;
> }

Ok, so a sort of semantic predicates in grammars, only that it is not  
in a grammar, but in hand-written code. Of course, it is using some  
sort of grammar anyway, because your rule engine still uses a kind of  
language.

> Seems pretty trivial to find the variable declaration either way.

Yeah, probably I did too much maths...I always start to think in  
terms of metrics measuring some value for things. I was thinking of a  
"distance" metric in the tree or token stream as an indicator for  
complexity. But as you said, for your application speed is not of  
paramount concern, so this is simply not applicable.

> Right. I'm trying to change the dynamics on that and get people to  
> believe that it can be done.
> I believe my product does it, but it's still a tough sell. About  
> 1/3 of the people who come up to our booth
> at tradeshows are "skeptics". They come up, take a quick look, and  
> then ask "how do you handle unions?" or
> "...memset?" or "multiple inheritence." By the time I've started  
> explaining about how memset is almost always
> used to initialize a struct to zero, and we check for that sort of  
> thing, they walk away. It's how we programmers
> naturally are: we sure want our compilers to work 100%, and it  
> seems like a translator should, too. So since
> it's impossible, in theory, we go back and do it by hand (or don't  
> do it). It never occurs to us that someone could simply
> automate the stuff that everyone's doing by hand and save everyone  
> 90% of the time and effort.
>
> The traveling salesman problem is NP-complete, and yet we have no  
> problem using algorithms that are less than
> perfect do the best they can because they're so much better than  
> humans. It's a shame we can't seem to take
> the same approach with rewriting code to a new language.

I totally agree with you on that point. Having a tool available is so  
much better in any craft. It's hard to understand why some people  
cannot see the value of that. I mean having a compiler still doesn't  
write programs for you, but it saves you from all the nitty gritty  
details you don't want to bother with. Funnily enough, in other areas  
they do accept that: see garbage collection for one thing. Nowadays  
everyone jumps onto that train. It ain't perfect in many cases, but  
it will help you to get your work done sooner. Same applies to your  
project. And incidentally the same applies to IDE's, too. At least  
that's slowly changing. I don't want to go back to vi to edit my  
projects. Too. Much. Hassle.

Kudos for trying to change that!

>> I'm not an expert in linguistics, far from it, so I can't really  
>> say  anything for NLP.
>
> Yea, me neither. I was pretty shocked at how different the NLP  
> approaches are from "compiler" approaches.
> Seemed like zero overlap. I'm still pretty shocked at how bad NLP  
> seems to be, but I guess I have just
> one data point: babelfish.

I think the real problem with NLP vs. most artificial languages is:  
You do not need to declare objects before usage in natural languages.  
We don't go around pre-declaring everything we want to talk or write  
about. Also, natural languages are much more ambiguous and highly  
context sensitive. Furthermore, the semantics of a word or phrase can  
depend highly of intonation if you are dealing with speech. And last  
but not least, natural language can grossly violate grammatical rules  
and still be understood. This is not generally the case with  
artificial languages.

-k



From lgcraymer at yahoo.com  Wed Oct 11 18:00:10 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Wed, 11 Oct 2006 18:00:10 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452D3180.2070907@jazillian.com>
Message-ID: <20061012010010.28749.qmail@web55915.mail.re3.yahoo.com>



--- Andy Tripp <antlr at jazillian.com> wrote:
> As for tree structures, the AST shapes are pretty
> arbitrary. Monty's C 
> grammar and the two java.g grammars build
> similar trees, but there are differences where the
> only reason for the 
> difference is "just because it was designed that
> way".
> With a one dimensional token stream, we don't have
> that problem. There's 
> one less level obstraction between what's
> on the screen and the mental picture in my head. To
> this day, I'm not 
> sure off the top of my head what the AST
> is for, say, "public static void main(String[] args)
> {". I have trouble 
> keeping the C AST, the Java AST, and the mapping
> between the two in my head all at once. And this is
> the most trivial case!

There are simpler cases, but this is a pretty fair
example of the conceptual problem.  Visualizing the
tree is usually a distraction; you are a lot closer to
thinking effectively with your "stream of tokens"
model.  The point of the tree structure is to simplify
the recognition problem:  "down" and "right" can be
used to capture distinctions.  ANTLR always does an
inorder traversal of the tree, which translates to a
token sequence.  Ter actually formalized this in the
ANTLR 3 TreeNodeStream:  "DOWN" and "UP" are generated
tokens.

> And yet, as a sequence of tokens, there's no mental
> work at all. What I 
> "see" is the same as my mental image.
> (And what I "see" is a sequence of tokens, not a
> sequence of chars).
> 
> >
> > If I were working on a natural language problem,
> would I use trees?  
> > Sure!  Trees are a very convenient way of
> capturing semantics into 
> > syntactic form.  Would I generate output with a
> visitor?  For 
> > Esperanto or one of the Romance languages,
> possibly (for these 
> > languages, simple syntactic principles apply); for
> English, that is 
> > unlikely--too much "peephole" substitution is
> necessary to handle 
> > special cases.  Instead, I would most likely
> process the input into a 
> > canonical tree with a regular structure
> (converting input to tree form 
> > is about transforming the special cases) and do
> some form of 
> > rule-based substitution for all of the nasty
> colloquialisms and other 
> > special cases.  (In compiler parlance, that is
> called "peephole 
> > optimization", often an essential for generating
> good code.)
> 
> And yet, from what my admitedly feeble research
> found is that NLP 
> systems generally don't use a tree.
> If they do, it's not at the heart of the system -
> they are not "tree 
> processors".

NLP (neuro-linguistic processing) is done by wetware. 
Natural language processing, however, is almost always
done with trees masked by "Attribute Grammars".  [That
is post-parsing; GLR and "Corner Parsing" algorithms
are usually used for recognition, and Europe seems to
be the hotbed for published research in the area.]



> I always thought a "compiler" was just a translator
> that happened to 
> have an output that's at a lower level than the
> input - typically
> machine code, or byte code. But then, I guess I'm
> just remembering an 
> undergrad compiler class from 20 years ago, and the
> dragon book, so I guess I'm no expert.

I was careful to specify "compiler technology" as
distinguished from production compilers.  Research
compilers often do some very strange (and wonderful)
things.  Also, "lower level" is a subjective
judgement.

> 
> > Nothing that you have described doing is out of
> place in a 
> > conventional compiler environment.  You might find
> it interesting to 
> > take a look at GNU RTL, used to generate the
> peephole optimizer for 
> > the gcc toolset.
> 
> Huh??? That makes no sense to me. I've described
> lots of things that are 
> completely out of place in
> a conventional compiler. A conventional compiler
> doesn't translate 
> library calls, like "printf" to
> "System.out.println".
> I do stuff like "strcpy(v1, v2) --> v1 = v2",
> replacing a C strcpy() 
> call with a Java assignment.
> No conventional compiler does anything like that,
> because technically, 
> it's wrong!

Check out memcpy for gcc targeting an x86 for an
example of a compiler-translated library call.  As for
the assignment, I see nothing wrong; you have added
the restrictions that all strings are read-only.  That
would cause errors if naively translated statements
like "v1[5] = ' ';", but I assume that you do the
right thing.

> I rename files, methods, and variables based on
> user-specified mappings. 
> Compilers don't do that.
> I could go on.

Most of the translations are not user-specified, true.
 But any C/C++ compiler renames methods and variables
according to user specifications (macros), and
supports file renaming for output.  

> 
> >
> > As to your "unconventional" approach:  I hate to
> say this, but 
> > everything that you have described doing is well
> documented in the 
> > literature.
> 
> Maybe you could point me to something specific.
> Today I'm adding smarts 
> to my GotoRemoverRule that generates code that
> is not faster or more compact than what it was
> producing before, but it 
> looks better to the human eye. I doubt that
> there's any literature on that.

That sort of thing is usually isolated to "see what I
can do" claims in papers.  Compiler-generated
assembler files are usually quite readable (well, for
assembly language) and that dates back to the days
when it was necessary to claim that "FORTRAN-generated
assembler is as good as (or nearly as good as)
programmer-generated code".

> 
> > I have noticed that "healthy disrespect for
> conventional approaches" 
> > usually translates to "I never check to see if I
> am reinventing the 
> > wheel or not".  One of the great resources on the
> web is Citeseer:  
> > <http://citeseer.ist.psu.edu/>.  It has some of
> the good early papers 
> > on pattern matching and transformation systems.
> 
> I've looked at many, many papers on those. Can you
> point me to anything 
> specific that you
> think I'm missing?

No, sorry, you'll have to do your own research.  I
never have enough time to do as much as I would like
for myself!

> 
> I've also noticed that the person who feels like
> they're "breaking new 
> ground" just hasn't done his homework. That's why
> I spend so much time typing here - worried that I
> might be doing that. 
> So I'm not just being defensive,
> 

This is a user group, not a theory group, so it is not
the ideal forum for this sort of sanity check
(although it is certainly better than none).  I do
have to think that dragging Monty out of  the woodwork
for this discussion was a significant achievement! I
only jumped in after I thought that sanity had
prevailed to make the point that "it's really not the
methodology that's at issue, it's the level of tool
support".

--Loring
=== message truncated ===


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From antlr at jazillian.com  Wed Oct 11 18:56:20 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 21:56:20 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <DEAD2FB3-2E86-46D4-99BE-E8843B488479@classdump.org>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
	<452D54FF.1080101@jazillian.com>
	<53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org>
	<452D7A4B.2040704@jazillian.com>
	<DEAD2FB3-2E86-46D4-99BE-E8843B488479@classdump.org>
Message-ID: <452DA0C4.2050000@jazillian.com>

>
> Ok, so a sort of semantic predicates in grammars, only that it is not  
> in a grammar, but in hand-written code. Of course, it is using some  
> sort of grammar anyway, because your rule engine still uses a kind of  
> language.


Yes, but a simple one: the "v" and "x" placeholders are all there is to 
it. Everything else
is matched literally. So far simpler (and more limited) than ANTLR or 
even regular expressions.

>
> I totally agree with you on that point. Having a tool available is so  
> much better in any craft. It's hard to understand why some people  
> cannot see the value of that. I mean having a compiler still doesn't  
> write programs for you, but it saves you from all the nitty gritty  
> details you don't want to bother with. Funnily enough, in other areas  
> they do accept that: see garbage collection for one thing. Nowadays  
> everyone jumps onto that train. It ain't perfect in many cases, but  
> it will help you to get your work done sooner. Same applies to your  
> project. And incidentally the same applies to IDE's, too. At least  
> that's slowly changing. I don't want to go back to vi to edit my  
> projects. Too. Much. Hassle.
>
> Kudos for trying to change that!

The problem is that people value program correctness over readability. 
Crazy as it sounds, I prefer this program:
System.out.println("hello, world")
...over this one...
System.out.print("he" + 'l' + "l"); System.out.println("o");

The first one is clean but incorrect, the second one is correct but not 
clean.
The first one will be much easier to maintain over time. Same for 
million-line programs...I think it's better
to have something that's well written than something that's completely 
bug-free!

>
>>> I'm not an expert in linguistics, far from it, so I can't really  
>>> say  anything for NLP.
>>
>>
>> Yea, me neither. I was pretty shocked at how different the NLP  
>> approaches are from "compiler" approaches.
>> Seemed like zero overlap. I'm still pretty shocked at how bad NLP  
>> seems to be, but I guess I have just
>> one data point: babelfish.
>
>
> I think the real problem with NLP vs. most artificial languages is:  
> You do not need to declare objects before usage in natural languages.  
> We don't go around pre-declaring everything we want to talk or write  
> about. Also, natural languages are much more ambiguous and highly  
> context sensitive. Furthermore, the semantics of a word or phrase can  
> depend highly of intonation if you are dealing with speech. And last  
> but not least, natural language can grossly violate grammatical rules  
> and still be understood. 

It's even worse than that. There may not exist a "correct" solution 
("who does the 'he' refer to in some sentence...no
way to know for sure"). And there can be exceptions that no one would 
ever think of until they hit them
("the White House" is still "the White House" in Spanish, not "Casa 
Blanca", and to know that you need to now political-type things!).
Not to mention wackyness like "Go" is a valid sentence, with an implied 
"You" as the verb.
Or "this is a sentence, but the period goes OUTSIDE the quotes".

> This is not generally the case with  artificial languages.

Generally, but then again, it's 10pm, and my officemate is looking at a 
line of code like this:
typedef char MYCHAR[25];
...which of course tells us replace any occurances of "MYCHAR" with 
"char[25]".
The good news is that it turns out we already saw that once, and handle 
it :)

Andy

>
> -k
>
>


From antlr at jazillian.com  Wed Oct 11 19:20:49 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Wed, 11 Oct 2006 22:20:49 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061012010010.28749.qmail@web55915.mail.re3.yahoo.com>
References: <20061012010010.28749.qmail@web55915.mail.re3.yahoo.com>
Message-ID: <452DA681.7040601@jazillian.com>


>>>the gcc toolset.
>>>      
>>>
>>Huh??? That makes no sense to me. I've described
>>lots of things that are 
>>completely out of place in
>>a conventional compiler. A conventional compiler
>>doesn't translate 
>>library calls, like "printf" to
>>"System.out.println".
>>I do stuff like "strcpy(v1, v2) --> v1 = v2",
>>replacing a C strcpy() 
>>call with a Java assignment.
>>No conventional compiler does anything like that,
>>because technically, 
>>it's wrong!
>>    
>>
>
>Check out memcpy for gcc targeting an x86 for an
>example of a compiler-translated library call. 
>
I don't need to check what gcc does for memcpy() calls. I know it does the
same thing that it does for all function calls: generates low-level code
to call a function. You're missing my point entirely: I don't "compile"
a memcpy() and all other calls down to a lower level - I treat each
one individually. For memcpy(), for example, I do all that checking
to see what a reasonable replacement is.

>As for
>the assignment, I see nothing wrong; you have added
>the restrictions that all strings are read-only.  That
>would cause errors if naively translated statements
>like "v1[5] = ' ';", but I assume that you do the
>right thing.
>  
>
strcpy() actually makes a copy, while assignment does not. That
can introduce a bug. A compiler would never do that type of replacement
because it may introduce a bug. Yet a person doing a rewrite would.

And no, don't assume that I do "the right thing". Your idea of the 
"right thing" is, I'm
sure, to generate code that always works. And that's not what I do. If I 
did that,
I would end up with Ephedra, allocating a huge array in memory, and having
every variable reference go through that array.

>  
>
>>I rename files, methods, and variables based on
>>user-specified mappings. 
>>Compilers don't do that.
>>I could go on.
>>    
>>
>
>Most of the translations are not user-specified, true.
> But any C/C++ compiler renames methods and variables
>according to user specifications (macros), and
>supports file renaming for output.
>
Yea, but that's different. If you convert 1000 files from C to Java, you
want to specify a mapping from each input file name to the package that
the Java class should go into.

>  
>
>  
>
>>>As to your "unconventional" approach:  I hate to
>>>      
>>>
>>say this, but 
>>    
>>
>>>everything that you have described doing is well
>>>      
>>>
>>documented in the 
>>    
>>
>>>literature.
>>>      
>>>
>>Maybe you could point me to something specific.
>>Today I'm adding smarts 
>>to my GotoRemoverRule that generates code that
>>is not faster or more compact than what it was
>>producing before, but it 
>>looks better to the human eye. I doubt that
>>there's any literature on that.
>>    
>>
>
>That sort of thing is usually isolated to "see what I
>can do" claims in papers.  Compiler-generated
>assembler files are usually quite readable (well, for
>assembly language) and that dates back to the days
>when it was necessary to claim that "FORTRAN-generated
>assembler is as good as (or nearly as good as)
>programmer-generated code".
>  
>
All I can say is that every time I've tried any language-to-language 
translator on
"hello, world", the output always comes to about 50 lines of code. In the
grammar-to-parser-generator field,
lex and yacc produce awful code, and ANTLR produces quite readable code.
If anyone knows of any language-to-language translators that produce
"readable" code, I'd love to hear about them.

>  
>
>>>I have noticed that "healthy disrespect for
>>>      
>>>
>>conventional approaches" 
>>    
>>
>>>usually translates to "I never check to see if I
>>>      
>>>
>>am reinventing the 
>>    
>>
>>>wheel or not".  One of the great resources on the
>>>      
>>>
>>web is Citeseer:  
>>    
>>
>>><http://citeseer.ist.psu.edu/>.  It has some of
>>>      
>>>
>>the good early papers 
>>    
>>
>>>on pattern matching and transformation systems.
>>>      
>>>
>>I've looked at many, many papers on those. Can you
>>point me to anything 
>>specific that you
>>think I'm missing?
>>    
>>
>
>No, sorry, you'll have to do your own research.  I
>never have enough time to do as much as I would like
>for myself!
>  
>
OK, well, you're telling me that every issue I raise has been covered
"in the literature", and I think I've made a reasonable attempt to find it,
and haven't found anything.

>  
>
>>I've also noticed that the person who feels like
>>they're "breaking new 
>>ground" just hasn't done his homework. That's why
>>I spend so much time typing here - worried that I
>>might be doing that. 
>>So I'm not just being defensive,
>>
>>    
>>
>
>This is a user group, not a theory group, so it is not
>the ideal forum for this sort of sanity check
>(although it is certainly better than none).  I do
>have to think that dragging Monty out of  the woodwork
>for this discussion was a significant achievement! I
>only jumped in after I thought that sanity had
>prevailed to make the point that "it's really not the
>methodology that's at issue, it's the level of tool
>support".
>
>--Loring
>=== message truncated ===
>  
>
Thanks for the discussion. If you can suggest a better place for me to bring
stuff like this up, let me know and I'll take it elsewhere.

Andy

>
>__________________________________________________
>Do You Yahoo!?
>Tired of spam?  Yahoo! Mail has the best spam protection around 
>http://mail.yahoo.com 
>
>  
>


From kroepke at classdump.org  Wed Oct 11 19:52:25 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Thu, 12 Oct 2006 04:52:25 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452DA0C4.2050000@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
	<452D54FF.1080101@jazillian.com>
	<53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org>
	<452D7A4B.2040704@jazillian.com>
	<DEAD2FB3-2E86-46D4-99BE-E8843B488479@classdump.org>
	<452DA0C4.2050000@jazillian.com>
Message-ID: <10DBC86A-323A-4E88-AD92-9A69C696D87B@classdump.org>


On 12. Oct 2006, at 3:56 Uhr, Andy Tripp wrote:

> The problem is that people value program correctness over  
> readability. Crazy as it sounds, I prefer this program:
> System.out.println("hello, world")
> ...over this one...
> System.out.print("he" + 'l' + "l"); System.out.println("o");
>
> The first one is clean but incorrect, the second one is correct but  
> not clean.
> The first one will be much easier to maintain over time. Same for  
> million-line programs...I think it's better
> to have something that's well written than something that's  
> completely bug-free!

I don't see why the first one is incorrect, but ok, I buy it ;)
One thing I cannot on agree on, is that a translator is allowed to  
introduce subtle bugs in my code. I think there's a tradeoff between  
readability and correctness. Granted, I can live with border cases,  
where the vendor says "Listen, for constructs like malloc you have  
triple-check the translation, because we don't have malloc in Java  
and have to make assumptions." but these cases should be well defined  
and clearly stated. OTOH I assume you do that sort of thing with your  
customers.
That said, I value code cleanliness a lot, having worked on quite  
large projects, cleaned them up and seen them deteriorate again in  
the span of a couple of months. So I think I know what you mean.

>> This is not generally the case with  artificial languages.
>
> Generally, but then again, it's 10pm, and my officemate is looking  
> at a line of code like this:
> typedef char MYCHAR[25];
> ...which of course tells us replace any occurances of "MYCHAR" with  
> "char[25]".

Yes? That's the way typedefs work. Am I missing anything? How's that  
violating the grammar?

-k

From lgcraymer at yahoo.com  Wed Oct 11 21:52:19 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Wed, 11 Oct 2006 21:52:19 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452DA681.7040601@jazillian.com>
Message-ID: <20061012045219.36702.qmail@web55901.mail.re3.yahoo.com>



--- Andy Tripp <antlr at jazillian.com> wrote:


> >Check out memcpy for gcc targeting an x86 for an
> >example of a compiler-translated library call. 
> >
> I don't need to check what gcc does for memcpy()
> calls. I know it does the
> same thing that it does for all function calls:
> generates low-level code
> to call a function. You're missing my point
> 

Right.  You "know".  gcc actually translates memcpy
into a short sequence of assembler instructions that
optimally copy.  There are a few other builtin
functions supported by gcc.

> entirely: I don't "compile"
> a memcpy() and all other calls down to a lower level
> - I treat each
> one individually. For memcpy(), for example, I do
> all that checking
> to see what a reasonable replacement is.
> 
> >As for
> >the assignment, I see nothing wrong; you have added
> >the restrictions that all strings are read-only. 
> That
> >would cause errors if naively translated statements
> >like "v1[5] = ' ';", but I assume that you do the
> >right thing.
> >  
> >
> strcpy() actually makes a copy, while assignment
> does not. That
> can introduce a bug. A compiler would never do that
> type of replacement
> because it may introduce a bug. Yet a person doing a
> rewrite would.

Compilers tend to do very interesting things with
registers, bypass assignments (intermediate values are
not stored to memory), reuse registers that are no
longer "live", etc.  As long as input and output
semantics are equivalent, the intermediate values
"don't matter".  Without that freedom, optimization
would be impossible.

> 
> And no, don't assume that I do "the right thing".
> Your idea of the 
> "right thing" is, I'm
> sure, to generate code that always works. And that's
> not what I do. If I 
> did that,
> I would end up with Ephedra, allocating a huge array
> in memory, and having
> every variable reference go through that array.
> 
> >  
> >
> >>I rename files, methods, and variables based on
> >>user-specified mappings. 
> >>Compilers don't do that.
> >>I could go on.
> >>    
> >>
> >
> >Most of the translations are not user-specified,
> true.
> > But any C/C++ compiler renames methods and
> variables
> >according to user specifications (macros), and
> >supports file renaming for output.
> >
> Yea, but that's different. If you convert 1000 files
> from C to Java, you
> want to specify a mapping from each input file name
> to the package that
> the Java class should go into.

And you made the particular design decision not to use
an external build system ...


> >This is a user group, not a theory group, so it is
> not
> >the ideal forum for this sort of sanity check
> >(although it is certainly better than none).  I do
> >have to think that dragging Monty out of  the
> woodwork
> >for this discussion was a significant achievement!
I
> >only jumped in after I thought that sanity had
> >prevailed to make the point that "it's really not
the
> >methodology that's at issue, it's the level of tool
> >support".
> >
> >--Loring
> >=== message truncated ===
> >  
> >
>Thanks for the discussion. If you can suggest a
better >place for me to bring
>stuff like this up, let me know and I'll take it
>elsewhere.

My point wasn't "go somewhere else", it was more
"don't necessarily expect definitive answers".

--Loring

>
>Andy



__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From contingencyplan at gmail.com  Thu Oct 12 01:07:33 2006
From: contingencyplan at gmail.com (Brian DeVries)
Date: Thu, 12 Oct 2006 03:07:33 -0500
Subject: [antlr-interest] Exception when running compiled ANTLR on all
	grammars
Message-ID: <a3db01e90610120107w42c2d1eehebec6f17a32513a9@mail.gmail.com>

Hello,

I have compiled ANTLR 3.0b4 from source, since Gentoo hasn't added the
beta version to portage. I haven't changed any of the source code,
except for the version number value in org.antlr.Tool (which I did to
make sure of which version I was running).

I also have a script in my ~/bin directory to make it easier to run
ANTLR (so I don't have to run the whole java command):

----- antlr ------
#!/bin/sh

MYCLASSPATH=$CLASSPATH
CLASSPATH=${HOME}/classpath/antlr_mine.jar:${HOME}/classpath/stringtemplate-2.3b9.jar:$CLASSPATH
java org.antlr.Tool $*
CLASSPATH=${MYCLASSSPATH}


Whenever I try to run ANTLR on a grammar (even ones included in the
examples file), I get the following error:

% antlr c.g
ANTLR Parser Generator   Early Access Version 3.0b4-BWD2 (??, 2006)  1989-2006
Exception in thread "main" java.lang.NoSuchMethodError:
antlr.TokenStreamRewriteEngine.size()I
        at org.antlr.tool.Grammar.defineLexerRuleFoundInParser(Grammar.java:977)
        at org.antlr.tool.DefineGrammarItemsWalker.rule(DefineGrammarItemsWalker.java:771)
        at org.antlr.tool.DefineGrammarItemsWalker.rules(DefineGrammarItemsWalker.java:478)
        at org.antlr.tool.DefineGrammarItemsWalker.grammarSpec(DefineGrammarItemsWalker.java:323)
        at org.antlr.tool.DefineGrammarItemsWalker.grammar(DefineGrammarItemsWalker.java:179)
        at org.antlr.tool.Grammar.setGrammarContent(Grammar.java:491)
        at org.antlr.tool.Grammar.<init>(Grammar.java:409)
        at org.antlr.Tool.process(Tool.java:246)
        at org.antlr.Tool.main(Tool.java:70)

Any ideas on what I'm doing wrong? I'm using Gentoo Linux with the Sun
Java5 compiler and environment.

Thanks!
~Brian DeVries

From peter.paulus at nerocmediaware.nl  Thu Oct 12 01:22:24 2006
From: peter.paulus at nerocmediaware.nl (Peter Paulus)
Date: Thu, 12 Oct 2006 10:22:24 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452D54FF.1080101@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>	
	<45267B17.6060107@jazillian.com>	
	<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>	
	<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>	
	<4527E677.5070504@jazillian.com>	
	<1160274396.7022.3.camel@localhost.localdomain>	
	<45298EFB.9040104@jazillian.com>	
	<1160365442.18004.14.camel@localhost.localdomain>	
	<452BB863.1040103@jazillian.com>
	<1160543177.6126.10.camel@localhost.localdomain>
	<452D381A.50407@jazillian.com>
	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>
	<452D54FF.1080101@jazillian.com>
Message-ID: <FAD9773F-FF5A-4501-93EF-29DE2EE992D5@nerocmediaware.nl>

Hello all,

As I said on october 9 in this thread. There is some real interesting  
theory on syntax and syntax tree transformations in natural  
languages. See my message for pointers on that.

With kind regards,
Peter Paulus

On Oct 11, 2006, at 10:33 PM, Andy Tripp wrote:
>
> Thanks for the input. I think your response to translating "Woods  
> Eyes Masters" illustrates my point perfectly.
> That is, for real NLP, treewalking solves nothing. It's simply one  
> way to start approaching the problem,
> and by the time you tackle all the hard issues, treewalking is just  
> a tiny piece of the work, and it's not clear (to me)
> that it's even adding anything. To me, saying "high-level language  
> translation is mostly a matter of walking an AST"
> is like saying "Getting from NYC to LA is mostly a matter of  
> getting on a plane". Yea, that may be true. But if
> you're going to program a robot to get from NYC to LA, getting on  
> the plane will be just one tiny piece. To the
> point where it doesn't really matter whether the robot takes a  
> plane or a car.
>


From antlr at jazillian.com  Thu Oct 12 07:12:55 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 10:12:55 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <10DBC86A-323A-4E88-AD92-9A69C696D87B@classdump.org>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>		<45267B17.6060107@jazillian.com>		<d092c2300610061036j652deba1qcc433a913ff50f2e@mail.gmail.com>		<CB79DD64-9605-482E-93ED-F7CD2F16930E@cs.usfca.edu>		<4527E677.5070504@jazillian.com>		<1160274396.7022.3.camel@localhost.localdomain>		<45298EFB.9040104@jazillian.com>		<1160365442.18004.14.camel@localhost.localdomain>		<452BB863.1040103@jazillian.com>	<1160543177.6126.10.camel@localhost.localdomain>	<452D381A.50407@jazillian.com>	<A9F3DC65-BC7C-48BF-941D-838A91B44B92@classdump.org>	<452D54FF.1080101@jazillian.com>	<53D973C8-5EFB-4933-9361-DCE9B9521279@classdump.org>	<452D7A4B.2040704@jazillian.com>	<DEAD2FB3-2E86-46D4-99BE-E8843B488479@classdump.org>	<452DA0C4.2050000@jazillian.com>
	<10DBC86A-323A-4E88-AD92-9A69C696D87B@classdump.org>
Message-ID: <452E4D67.5000303@jazillian.com>

Kay Roepke wrote:

>
> On 12. Oct 2006, at 3:56 Uhr, Andy Tripp wrote:
>
>> The problem is that people value program correctness over  
>> readability. Crazy as it sounds, I prefer this program:
>> System.out.println("hello, world")
>> ...over this one...
>> System.out.print("he" + 'l' + "l"); System.out.println("o");
>>
>> The first one is clean but incorrect, the second one is correct but  
>> not clean.
>> The first one will be much easier to maintain over time. Same for  
>> million-line programs...I think it's better
>> to have something that's well written than something that's  
>> completely bug-free!
>
>
> I don't see why the first one is incorrect, but ok, I buy it ;)

It's missing the semicolon :)

> One thing I cannot on agree on, is that a translator is allowed to  
> introduce subtle bugs in my code. 

This is the mindset I'm trying to change...it's at the heart of what I'm
doing.
Every translator that I know of other than Jazillian goes for
correctness, and every one (that I've seen)
produces something like 50 lines of code from the one-line "hello,
world" program.
I could talk all day about why it's perfectly reasonable to allow bugs
to be introduced (as is done
every time a human writes or rewrites anything), but I'll spare you :)

> I think there's a tradeoff between  readability and correctness. 
> Granted, I can live with border cases,  where the vendor says "Listen, 
> for constructs like malloc you have  triple-check the translation, 
> because we don't have malloc in Java  and have to make assumptions." 
> but these cases should be well defined  and clearly stated. OTOH I 
> assume you do that sort of thing with your  customers.
> That said, I value code cleanliness a lot, having worked on quite  
> large projects, cleaned them up and seen them deteriorate again in  
> the span of a couple of months. So I think I know what you mean.

In our case, we'll see if, say, a memset() call matches any patterns of
usage that we've seen before and have some
Java equivalent. If not, we'll leave it in the code, give a warning, and
you'll have a memset() call in the middle of your Java code.
So, obviously, our translator works much better on "vanilla business
logic" code than it does on low-level library code.

>
>>> This is not generally the case with  artificial languages.
>>
>>
>> Generally, but then again, it's 10pm, and my officemate is looking  
>> at a line of code like this:
>> typedef char MYCHAR[25];
>> ...which of course tells us replace any occurances of "MYCHAR" with  
>> "char[25]".
>
>
> Yes? That's the way typedefs work. Am I missing anything? How's that  
> violating the grammar?

typedefs are usually of the form:
typedef THIS IS THE REPLACEMENT    THING_TO_BE_REPLACED;
this one is of the form:
typedef PART_OF_REPLACEMENT THING_TO_BE_REPLACED REST_OF_REPLACEMENT.

This illustrates the AST vs. token stream mentality really well. The "oh
no!" moment that I get when
I see this out-of-wack-token-sequence-meaning is a bad one. But  this
"I'm going to
now have to think a bit to make sure I understand this" thinking that
I'm experiencing here is very similar
to the "I'm going to have to think now about what the AST looks like"
feeling that I'd have to do ALL THE TIME
with ASTs.

Andy.

>
> -k
>



From prashant.deva at gmail.com  Thu Oct 12 07:15:44 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Thu, 12 Oct 2006 07:15:44 -0700
Subject: [antlr-interest] The 'Philosophy about translation' thread....
Message-ID: <41fed8f80610120715q420d6161k947956e49a18b055@mail.gmail.com>

Guys, please break up the 'pihlosophy about translation' thread. I dont mean
to stop the discussion, I just mean start a second part.
The original thread is at '68' mails rights now.

For those people using gmail to access the mailing list, we cant even reply
to a message, cause since gmail tries to attach the text of *all* the
messages in the thread while replying, it takes about 1-2 mins waiting time
after clicking on the reply button. Also the mem consumption on firefox goes
super high rendering all those mails in one page.

So please start a new 'Philooshopy about translation - II' thread.
-- 
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061012/44071e9b/attachment.html 

From antlr at jazillian.com  Thu Oct 12 07:24:47 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 10:24:47 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061012045219.36702.qmail@web55901.mail.re3.yahoo.com>
References: <20061012045219.36702.qmail@web55901.mail.re3.yahoo.com>
Message-ID: <452E502F.6080604@jazillian.com>

Loring Craymer wrote:

>--- Andy Tripp <antlr at jazillian.com> wrote:
>
>
>  
>
>>>Check out memcpy for gcc targeting an x86 for an
>>>example of a compiler-translated library call. 
>>>
>>>      
>>>
>>I don't need to check what gcc does for memcpy()
>>calls. I know it does the
>>same thing that it does for all function calls:
>>generates low-level code
>>to call a function. You're missing my point
>>
>>    
>>
>
>Right.  You "know".  gcc actually translates memcpy
>into a short sequence of assembler instructions that
>optimally copy.  There are a few other builtin
>functions supported by gcc.
>  
>
Geez. You think I don't know that compilers do optimizations like this?
*sigh* Yes, I'm taking a shortcut when I say memcpy() translates to a 
function call.
And yes, I'm going to just say "a function call" rather than "a push 
operation on
the stack frame". When I'm imprecise like that,
you can take that to mean I don't know what I'm talking about,
or you can try to see my real point: that gcc, and no other compiler, 
looks at
the memcpy() call, and then looks at the arguments, and then goes back and
looks at the argument type and other usages, and then sees that, in 
fact, this
memcpy() call is doing nothing more than re-initializing memory to zeros,
and is operating on an entire object, and
so can be replaced by a Java new call. And, by the way, then also go and 
create
a no-arg constructor for the object if it doesn't already have one.

Yes, I do think I "know" that gcc doesn't do that.

Sheesh. There really is a point there.

>  
>
>>entirely: I don't "compile"
>>a memcpy() and all other calls down to a lower level
>>- I treat each
>>one individually. For memcpy(), for example, I do
>>all that checking
>>to see what a reasonable replacement is.
>>
>>    
>>
>>>As for
>>>the assignment, I see nothing wrong; you have added
>>>the restrictions that all strings are read-only. 
>>>      
>>>
>>That
>>    
>>
>>>would cause errors if naively translated statements
>>>like "v1[5] = ' ';", but I assume that you do the
>>>right thing.
>>> 
>>>
>>>      
>>>
>>strcpy() actually makes a copy, while assignment
>>does not. That
>>can introduce a bug. A compiler would never do that
>>type of replacement
>>because it may introduce a bug. Yet a person doing a
>>rewrite would.
>>    
>>
>
>Compilers tend to do very interesting things with
>registers, bypass assignments (intermediate values are
>not stored to memory), reuse registers that are no
>longer "live", etc.  As long as input and output
>semantics are equivalent, the intermediate values
>"don't matter".  Without that freedom, optimization
>would be impossible.
>  
>
I know compilers do interesting things. Generating incorrect code on purpose
is not one of them.

>  
>
>>And no, don't assume that I do "the right thing".
>>Your idea of the 
>>"right thing" is, I'm
>>sure, to generate code that always works. And that's
>>not what I do. If I 
>>did that,
>>I would end up with Ephedra, allocating a huge array
>>in memory, and having
>>every variable reference go through that array.
>>
>>    
>>
>>> 
>>>
>>>      
>>>
>>>>I rename files, methods, and variables based on
>>>>user-specified mappings. 
>>>>Compilers don't do that.
>>>>I could go on.
>>>>   
>>>>
>>>>        
>>>>
>>>Most of the translations are not user-specified,
>>>      
>>>
>>true.
>>    
>>
>>>But any C/C++ compiler renames methods and
>>>      
>>>
>>variables
>>    
>>
>>>according to user specifications (macros), and
>>>supports file renaming for output.
>>>
>>>      
>>>
>>Yea, but that's different. If you convert 1000 files
>>from C to Java, you
>>want to specify a mapping from each input file name
>>to the package that
>>the Java class should go into.
>>    
>>
>
>And you made the particular design decision not to use
>an external build system ...
>  
>
Yes. I don't see how that relates. I don't see how an external build system
would help. And I think this is a valid example of things that I do and
compilers do not do.

>
>  
>
>>>This is a user group, not a theory group, so it is
>>>      
>>>
>>not
>>    
>>
>>>the ideal forum for this sort of sanity check
>>>(although it is certainly better than none).  I do
>>>have to think that dragging Monty out of  the
>>>      
>>>
>>woodwork
>>    
>>
>>>for this discussion was a significant achievement!
>>>      
>>>
>I
>  
>
>>>only jumped in after I thought that sanity had
>>>prevailed to make the point that "it's really not
>>>      
>>>
>the
>  
>
>>>methodology that's at issue, it's the level of tool
>>>support".
>>>
>>>--Loring
>>>=== message truncated ===
>>> 
>>>
>>>      
>>>
>>Thanks for the discussion. If you can suggest a
>>    
>>
>better >place for me to bring
>  
>
>>stuff like this up, let me know and I'll take it
>>elsewhere.
>>    
>>
>
>My point wasn't "go somewhere else", it was more
>"don't necessarily expect definitive answers".
>  
>

OK.

>--Loring
>
>  
>
>>Andy
>>    
>>
>
>
>
>__________________________________________________
>Do You Yahoo!?
>Tired of spam?  Yahoo! Mail has the best spam protection around 
>http://mail.yahoo.com 
>
>  
>


From sohail at taggedtype.net  Thu Oct 12 07:30:38 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Thu, 12 Oct 2006 07:30:38 -0700
Subject: [antlr-interest] The 'Philosophy about translation' thread....
In-Reply-To: <41fed8f80610120715q420d6161k947956e49a18b055@mail.gmail.com>
References: <41fed8f80610120715q420d6161k947956e49a18b055@mail.gmail.com>
Message-ID: <1160663438.5592.0.camel@localhost.localdomain>

On Thu, 2006-10-12 at 07:15 -0700, Prashant Deva wrote:
> Guys, please break up the 'pihlosophy about translation' thread. I
> dont mean to stop the discussion, I just mean start a second part.
> The original thread is at '68' mails rights now.
> 
> For those people using gmail to access the mailing list, we cant even
> reply to a message, cause since gmail tries to attach the text of
> *all* the messages in the thread while replying, it takes about 1-2
> mins waiting time after clicking on the reply button. Also the mem
> consumption on firefox goes super high rendering all those mails in
> one page. 

Thats pretty stupid!

Don't use gmail :)


From prashant.deva at gmail.com  Thu Oct 12 07:37:56 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Thu, 12 Oct 2006 07:37:56 -0700
Subject: [antlr-interest] The 'Philosophy about translation' thread....
In-Reply-To: <1160663438.5592.0.camel@localhost.localdomain>
References: <41fed8f80610120715q420d6161k947956e49a18b055@mail.gmail.com>
	<1160663438.5592.0.camel@localhost.localdomain>
Message-ID: <41fed8f80610120737n1df9c41ai24884ebf2d171526@mail.gmail.com>

Thats pretty stupid!


Whats so stupid?




-- 
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061012/a196b641/attachment.html 

From harsha.nagesh at credit-suisse.com  Thu Oct 12 07:41:08 2006
From: harsha.nagesh at credit-suisse.com (Nagesh, Harsha)
Date: Thu, 12 Oct 2006 15:41:08 +0100
Subject: [antlr-interest] philosophy about translation
Message-ID: <FDFBED0CBC3CA04BB7F633CC85ADDA5B3BF12530@enyc12p32001.corpny.csfb.com>



Andy,

    In one of the previous mails you mentioned about using Collections.Sort routine of java to replace an equivalent piece of code in C. I am really curious how would you go about doing this ? There can be any number of ways one could write a sorting algorithm and I am wondering if you really try to do some fancy token matching to determine that "Aha this is indeed the xyz sorting algorithm" and then replace it with one function call

Harsha

-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Andy Tripp
Sent: Thursday, October 12, 2006 10:25 AM
Cc: ANTLR Interest
Subject: Re: [antlr-interest] philosophy about translation

Loring Craymer wrote:

>--- Andy Tripp <antlr at jazillian.com> wrote:
>
>
>  
>
>>>Check out memcpy for gcc targeting an x86 for an example of a 
>>>compiler-translated library call.
>>>
>>>      
>>>
>>I don't need to check what gcc does for memcpy() calls. I know it does 
>>the same thing that it does for all function calls:
>>generates low-level code
>>to call a function. You're missing my point
>>
>>    
>>
>
>Right.  You "know".  gcc actually translates memcpy into a short 
>sequence of assembler instructions that optimally copy.  There are a 
>few other builtin functions supported by gcc.
>  
>
Geez. You think I don't know that compilers do optimizations like this?
*sigh* Yes, I'm taking a shortcut when I say memcpy() translates to a function call.
And yes, I'm going to just say "a function call" rather than "a push operation on the stack frame". When I'm imprecise like that, you can take that to mean I don't know what I'm talking about, or you can try to see my real point: that gcc, and no other compiler, looks at the memcpy() call, and then looks at the arguments, and then goes back and looks at the argument type and other usages, and then sees that, in fact, this
memcpy() call is doing nothing more than re-initializing memory to zeros, and is operating on an entire object, and so can be replaced by a Java new call. And, by the way, then also go and create a no-arg constructor for the object if it doesn't already have one.

Yes, I do think I "know" that gcc doesn't do that.

Sheesh. There really is a point there.

>  
>
>>entirely: I don't "compile"
>>a memcpy() and all other calls down to a lower level
>>- I treat each
>>one individually. For memcpy(), for example, I do all that checking to 
>>see what a reasonable replacement is.
>>
>>    
>>
>>>As for
>>>the assignment, I see nothing wrong; you have added the restrictions 
>>>that all strings are read-only.
>>>      
>>>
>>That
>>    
>>
>>>would cause errors if naively translated statements like "v1[5] = ' 
>>>';", but I assume that you do the right thing.
>>> 
>>>
>>>      
>>>
>>strcpy() actually makes a copy, while assignment does not. That can 
>>introduce a bug. A compiler would never do that type of replacement 
>>because it may introduce a bug. Yet a person doing a rewrite would.
>>    
>>
>
>Compilers tend to do very interesting things with registers, bypass 
>assignments (intermediate values are not stored to memory), reuse 
>registers that are no longer "live", etc.  As long as input and output 
>semantics are equivalent, the intermediate values "don't matter".  
>Without that freedom, optimization would be impossible.
>  
>
I know compilers do interesting things. Generating incorrect code on purpose is not one of them.

>  
>
>>And no, don't assume that I do "the right thing".
>>Your idea of the
>>"right thing" is, I'm
>>sure, to generate code that always works. And that's not what I do. If 
>>I did that, I would end up with Ephedra, allocating a huge array in 
>>memory, and having every variable reference go through that array.
>>
>>    
>>
>>> 
>>>
>>>      
>>>
>>>>I rename files, methods, and variables based on user-specified 
>>>>mappings.
>>>>Compilers don't do that.
>>>>I could go on.
>>>>   
>>>>
>>>>        
>>>>
>>>Most of the translations are not user-specified,
>>>      
>>>
>>true.
>>    
>>
>>>But any C/C++ compiler renames methods and
>>>      
>>>
>>variables
>>    
>>
>>>according to user specifications (macros), and supports file renaming 
>>>for output.
>>>
>>>      
>>>
>>Yea, but that's different. If you convert 1000 files from C to Java, 
>>you want to specify a mapping from each input file name to the package 
>>that the Java class should go into.
>>    
>>
>
>And you made the particular design decision not to use an external 
>build system ...
>  
>
Yes. I don't see how that relates. I don't see how an external build system would help. And I think this is a valid example of things that I do and compilers do not do.

>
>  
>
>>>This is a user group, not a theory group, so it is
>>>      
>>>
>>not
>>    
>>
>>>the ideal forum for this sort of sanity check (although it is 
>>>certainly better than none).  I do have to think that dragging Monty 
>>>out of  the
>>>      
>>>
>>woodwork
>>    
>>
>>>for this discussion was a significant achievement!
>>>      
>>>
>I
>  
>
>>>only jumped in after I thought that sanity had prevailed to make the 
>>>point that "it's really not
>>>      
>>>
>the
>  
>
>>>methodology that's at issue, it's the level of tool support".
>>>
>>>--Loring
>>>=== message truncated ===
>>> 
>>>
>>>      
>>>
>>Thanks for the discussion. If you can suggest a
>>    
>>
>better >place for me to bring
>  
>
>>stuff like this up, let me know and I'll take it elsewhere.
>>    
>>
>
>My point wasn't "go somewhere else", it was more "don't necessarily 
>expect definitive answers".
>  
>

OK.

>--Loring
>
>  
>
>>Andy
>>    
>>
>
>
>
>__________________________________________________
>Do You Yahoo!?
>Tired of spam?  Yahoo! Mail has the best spam protection around 
>http://mail.yahoo.com
>
>  
>


==============================================================================
Please access the attached hyperlink for an important electronic communications disclaimer: 

http://www.credit-suisse.com/legal/en/disclaimer_email_ib.html
==============================================================================


From kroepke at classdump.org  Thu Oct 12 08:02:53 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Thu, 12 Oct 2006 17:02:53 +0200
Subject: [antlr-interest] Token Stream vs. AST
Message-ID: <B7E07EB6-0B76-4E50-BDC1-628114D67E82@classdump.org>

(not replied as per Prashant's request)

On 12. Oct 2006, at 16:12 Uhr, Andy Tripp wrote:
> It's missing the semicolon :)

Ok, to my defense, it was about 4 am ;)

>> One thing I cannot on agree on, is that a translator is allowed  
>> to  introduce subtle bugs in my code.
>
> This is the mindset I'm trying to change...it's at the heart of  
> what I'm
> doing.
> Every translator that I know of other than Jazillian goes for
> correctness, and every one (that I've seen)
> produces something like 50 lines of code from the one-line "hello,
> world" program.
> I could talk all day about why it's perfectly reasonable to allow bugs
> to be introduced (as is done
> every time a human writes or rewrites anything), but I'll spare you :)

Hmm, to me, this really depends. I fully expect to have to read the  
translated code closely. I'm just not sure of what kind of bugs  
you're talking about here. The really glaring stuff that won't even  
compile is not the issue I think, it's more the really subtle  
behavior changing type of bug I'm wary about. Please don't spare me,  
as I'm really interested in your experiences with this stuff.

> In our case, we'll see if, say, a memset() call matches any  
> patterns of
> usage that we've seen before and have some
> Java equivalent. If not, we'll leave it in the code, give a  
> warning, and
> you'll have a memset() call in the middle of your Java code.
> So, obviously, our translator works much better on "vanilla business
> logic" code than it does on low-level library code.

That sounds like a good approach to me, because it will definitely  
stand out. Most low-level things are specific to one language anyway,  
so it's sensible to leave that alone if there's no good conversion  
available, IMHO.

> typedefs are usually of the form:
> typedef THIS IS THE REPLACEMENT    THING_TO_BE_REPLACED;
> this one is of the form:
> typedef PART_OF_REPLACEMENT THING_TO_BE_REPLACED REST_OF_REPLACEMENT.

Well, for array types it definitely always is
typedef char MYCHAR[25];
This won't work (and it shouldn't, too):
typedef char[25] MYCHAR;
There's no surprise, is there?

> This illustrates the AST vs. token stream mentality really well.  
> The "oh
> no!" moment that I get when
> I see this out-of-wack-token-sequence-meaning is a bad one. But  this
> "I'm going to
> now have to think a bit to make sure I understand this" thinking that
> I'm experiencing here is very similar
> to the "I'm going to have to think now about what the AST looks like"
> feeling that I'd have to do ALL THE TIME
> with ASTs.

mmh. The typedef example is a pretty good indicator that ASTs are a  
good way to abstract, isn't it?
It's the parsers job to produce a helpful tree for translations and  
this would look like
(TYPEDEF MYCHAR char[25]) in this case, making it easy to replace  
MYCHAR. The tokenstream would lose this information and would scatter  
the knowledge of how this is to be done in other places, rather than  
to keep the knowledge about the source language together in one place.
E.g. for ANTLR, when I want to find out how something works in  
syntactic terms, I go looking at the grammars and the trees they  
procude.
Then I know for sure what is legal and what is not.
That's what I like about trees. Once done, they give me information  
about structure in clear terms. If I look at token streams, that  
information
is hidden and I have to do the parsing in my head. YMMV.


-k

From andy at exchange.voelkel.us  Thu Oct 12 09:03:07 2006
From: andy at exchange.voelkel.us (Andy Voelkel)
Date: Thu, 12 Oct 2006 09:03:07 -0700
Subject: [antlr-interest] acceptance of new ideas (was philosophy about
	translation)
Message-ID: <7AE2E53336B37440A20C9590DB11BCB905119B6F@EXVS01.ex.dslextreme.net>

> I totally agree with you on that point. Having a tool available is so

> much better in any craft. It's hard to understand why some people  
> cannot see the value of that. I mean having a compiler still doesn't  
> write programs for you, but it saves you from all the nitty gritty  
> details you don't want to bother with. Funnily enough, in other areas

> they do accept that: see garbage collection for one thing. Nowadays  
> everyone jumps onto that train. It ain't perfect in many cases, but  
> it will help you to get your work done sooner. Same applies to your  
> project. And incidentally the same applies to IDE's, too. At least  
> that's slowly changing. I don't want to go back to vi to edit my  
> projects. Too. Much. Hassle.

Remember how long it took to accept garbage collection, and IDEs, and
rapid prototyping. After using those concepts on LISP machines in the
early eighties, I was convinced that the mainstream programming world
would be on top of these ideas within a couple of years. Not so! And it
wasn't fundamentally because of lack of MIPs or memory, it was because
of calcified mindsets. 

Another idea that I encountered back then was the idea of code writing
code, which was facilitated by the LISP language. It was primitive,
particularly in regards to debugging the process and also in the
readability of the code. But that is one of the things that attracted me
to a program like ANTLR, even though I really haven't been able to use
it much yet. It is an intelligently designed piece of code designed to
write code. I sincerely feel that much of the future of programming lies
in this domain.

I was recently inspired by a talk at a LISP conference where the author
used LISP as a tool to auto-generate reams of C# code. This isn't a new
idea in itself, but what was remarkable was the readability of the C#
code. It was completely acceptable as a code deliverable. It didn't look
like auto-generated gobblity-gook. It changed my whole view of this kind
of approach. 

If one can take this idea one step further into the world of automated
code maintenance or modification, while not adversely affecting
readability, one will really be onto something, IMO.

It seems to me that Andy's approach is to be admired, simply because it
takes a different and innovative approach to a problem. That doesn't
mean that all language translation should take this approach. For some
applications, correctness is more important that readability. But most
of the time, his approach would yield what I would want.

- Andy

From parrt at cs.usfca.edu  Thu Oct 12 09:56:38 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 12 Oct 2006 09:56:38 -0700
Subject: [antlr-interest] Exception when running compiled ANTLR on all
	grammars
In-Reply-To: <a3db01e90610120107w42c2d1eehebec6f17a32513a9@mail.gmail.com>
References: <a3db01e90610120107w42c2d1eehebec6f17a32513a9@mail.gmail.com>
Message-ID: <B5761022-1067-46BF-ADA2-4C214B1EE5A9@cs.usfca.edu>

Make sure you have 2.7.6 or 2.7.7 ANTLR  In your path as well.  Look  
for old versions that do not have the latest TokenStreamRewriteEngine.
Ter
On Oct 12, 2006, at 1:07 AM, Brian DeVries wrote:

> Hello,
>
> I have compiled ANTLR 3.0b4 from source, since Gentoo hasn't added the
> beta version to portage. I haven't changed any of the source code,
> except for the version number value in org.antlr.Tool (which I did to
> make sure of which version I was running).
>
> I also have a script in my ~/bin directory to make it easier to run
> ANTLR (so I don't have to run the whole java command):
>
> ----- antlr ------
> #!/bin/sh
>
> MYCLASSPATH=$CLASSPATH
> CLASSPATH=${HOME}/classpath/antlr_mine.jar:${HOME}/classpath/ 
> stringtemplate-2.3b9.jar:$CLASSPATH
> java org.antlr.Tool $*
> CLASSPATH=${MYCLASSSPATH}
>
>
> Whenever I try to run ANTLR on a grammar (even ones included in the
> examples file), I get the following error:
>
> % antlr c.g
> ANTLR Parser Generator   Early Access Version 3.0b4-BWD2 (??,  
> 2006)  1989-2006
> Exception in thread "main" java.lang.NoSuchMethodError:
> antlr.TokenStreamRewriteEngine.size()I
>        at org.antlr.tool.Grammar.defineLexerRuleFoundInParser 
> (Grammar.java:977)
>        at org.antlr.tool.DefineGrammarItemsWalker.rule 
> (DefineGrammarItemsWalker.java:771)
>        at org.antlr.tool.DefineGrammarItemsWalker.rules 
> (DefineGrammarItemsWalker.java:478)
>        at org.antlr.tool.DefineGrammarItemsWalker.grammarSpec 
> (DefineGrammarItemsWalker.java:323)
>        at org.antlr.tool.DefineGrammarItemsWalker.grammar 
> (DefineGrammarItemsWalker.java:179)
>        at org.antlr.tool.Grammar.setGrammarContent(Grammar.java:491)
>        at org.antlr.tool.Grammar.<init>(Grammar.java:409)
>        at org.antlr.Tool.process(Tool.java:246)
>        at org.antlr.Tool.main(Tool.java:70)
>
> Any ideas on what I'm doing wrong? I'm using Gentoo Linux with the Sun
> Java5 compiler and environment.
>
> Thanks!
> ~Brian DeVries


From rob.hill at blueyonder.co.uk  Thu Oct 12 12:12:08 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Thu, 12 Oct 2006 20:12:08 +0100
Subject: [antlr-interest] V3.0 error handling..
In-Reply-To: <0B16A332-5F5C-4BF3-9520-74C064CB4CE6@cs.usfca.edu>
Message-ID: <20061012191225.70CD1190743@www.antlr.org>

Ok I've tried adding this, but I get lots of errors saying that my exception
is never thrown in the corresponding try statements.
I looked at the Mantra grammars as to where to put the rulecatch statement ,
so I placed it at the top of my grammar...
If I place it below the @init section of the rule that throws, the error is
that the exception must be caught or declared.

I want 1 rule to throw an exception, how/where do I place the @rulecatch?
(any pointers in the wiki would be good too!)

Cheers
Rob



> -----Original Message-----
> From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-
> bounces at antlr.org] On Behalf Of Terence Parr
> Sent: 09 October 2006 03:02
> To: ANTLR Interest
> Subject: Re: [antlr-interest] V3.0 error handling..
> 
> use action @rulecatch {...} and say catch(RecognitionException e)
> { throw e; }.  Or that should work ;)
> Ter
> On Oct 8, 2006, at 12:39 PM, Robert Hill wrote:
> 
> > Hi all :)
> >
> > I want to bomb out of a rule immediately on a fatal condition how
> > do I do it
> > gracefully in V3? (java code..)
> >
> > Cheers!
> >
> > Rob
> >
> >
> >
> >




From antlr at jazillian.com  Thu Oct 12 12:24:44 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 15:24:44 -0400
Subject: [antlr-interest] philosophy - part 2
In-Reply-To: <FDFBED0CBC3CA04BB7F633CC85ADDA5B3BF12530@enyc12p32001.corpny.csfb.com>
References: <FDFBED0CBC3CA04BB7F633CC85ADDA5B3BF12530@enyc12p32001.corpny.csfb.com>
Message-ID: <452E967C.6070307@jazillian.com>

Nagesh, Harsha wrote:

>Andy,
>
>    In one of the previous mails you mentioned about using Collections.Sort routine of java to replace an equivalent piece of code in C. I am really curious how would you go about doing this ? There can be any number of ways one could write a sorting algorithm and I am wondering if you really try to do some fancy token matching to determine that "Aha this is indeed the xyz sorting algorithm" and then replace it with one function call
>
>Harsha
>  
>
I've done just a little of this, but yea, it does seem to be pretty 
impractical.
Here's one example where I map a couple of alternatives to a single 
function call:

for (v1=0; (v2 = getc(v3)) != '\n';)
        v1 = v1 * 10 + (v2 - '0');
---
for (v1=0; (v2 = getc(v3)) != EOF && v2 != '\n';)
        v1 = v1 * 10 + (v2 - '0');
-->
v1 = v3.readIntChars();

In this case, I think maybe it's useful - we may actually come across 
one of those patterns
of code in the future. On the other hand, here's a ridiculous rule that 
is so specific that it
will surely never match anything ever again:

while (true) {
        while (true) {
                printf(v5);
                v4 = 0;
                v1 = v2.readLine();
                break;
        }
        if (v3 == v1) {
                continue;
        }
        for (v3 = v1; isspace(*v3); v3++) {
                continue;
        }
        for (;isdigit(*v3); v3++) {
                v4 *= 10 + *v3 - '0';
        }
        if (*v3 == '\n') {
                return v4;
        }
        else {
                x2
        }
}

-->
while (true) {
        System.out.print(v5);
        v1 = v2.readLine().trim();
        try {
                return Integer.parseInt(v1);
        }
        catch (NumberFormatException e) {
                x2
        }
}

The two rules above are both "text-based" rules, but I do have lots of 
rules that are not so simple
and so are written with Java code. Here, we're a lot more flexible. For 
example, I have a
TemporaryVariableRule that look for patterns things like:

String s = a;
s += " ";
s += c;
a = s;

...and removes the temporary variable s:
a += " ";
a += c;

(of course, there can be no other references to s). Since we're writing 
code, we have the
flexibility to say "look for a variable that's assigned to some other 
value ("s = a;"), and later
an assignment back ("a = s"). Make sure the "a" never changes in 
between, and all assignments
to "s" can be combined. Make sure that "s" is never referenced anywhere 
else.

So all that is just capturing what a real person would do: notice cases 
where a temporary
variable is just making the code more complicated, and simplifying.

Andy

From parrt at cs.usfca.edu  Thu Oct 12 12:40:40 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 12 Oct 2006 12:40:40 -0700
Subject: [antlr-interest] V3.0 error handling..
In-Reply-To: <20061012191225.70CD1190743@www.antlr.org>
References: <20061012191225.70CD1190743@www.antlr.org>
Message-ID: <E3FD250F-E512-466C-B93D-1C8AB48C59C5@cs.usfca.edu>


On Oct 12, 2006, at 12:12 PM, Robert Hill wrote:

> Ok I've tried adding this, but I get lots of errors saying that my  
> exception
> is never thrown in the corresponding try statements.
> I looked at the Mantra grammars as to where to put the rulecatch  
> statement ,
> so I placed it at the top of my grammar...
> If I place it below the @init section of the rule that throws, the  
> error is
> that the exception must be caught or declared.
>
> I want 1 rule to throw an exception, how/where do I place the  
> @rulecatch?
> (any pointers in the wiki would be good too!)


Weird.  If you have a rule that doesn't match anything like:

a : ;

  if so, adding a try catch the generated air because it cannot throw  
the exception.

Ter

From rob.hill at blueyonder.co.uk  Thu Oct 12 12:45:49 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Thu, 12 Oct 2006 20:45:49 +0100
Subject: [antlr-interest] V3.0 error handling..
In-Reply-To: <E3FD250F-E512-466C-B93D-1C8AB48C59C5@cs.usfca.edu>
Message-ID: <20061012194556.5999319075A@www.antlr.org>

> Weird.  If you have a rule that doesn't match anything like:
> 
> a : ;
> 

Nope, I don't have any rules empty rules, but im not getting just the one
error
I'm getting an error for all the rules that don't throw that exception
about...13 or so.

>   if so, adding a try catch the generated air because it cannot throw
> the exception.
> 
Im sorry Ter, im trying to make sense of that , but my grammar's falling
over ! can you elaborate/rephrase?


Ta!

Rob



> Ter



From antlr at jazillian.com  Thu Oct 12 13:03:58 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 16:03:58 -0400
Subject: [antlr-interest] Token Stream vs. AST
In-Reply-To: <B7E07EB6-0B76-4E50-BDC1-628114D67E82@classdump.org>
References: <B7E07EB6-0B76-4E50-BDC1-628114D67E82@classdump.org>
Message-ID: <452E9FAE.6040106@jazillian.com>

Kay Roepke wrote:

>
> Hmm, to me, this really depends. I fully expect to have to read the  
> translated code closely. I'm just not sure of what kind of bugs  
> you're talking about here. The really glaring stuff that won't even  
> compile is not the issue I think, it's more the really subtle  
> behavior changing type of bug I'm wary about. Please don't spare me,  
> as I'm really interested in your experiences with this stuff.

One good example was a 5000-line JPEG processing library that we 
converted. 
IIRC, there was just one nasty runtime bug. It was similar to the issue 
of "strcpy(a, b)" not being
the same as "a = b;". I think it was a case where the C code was 
duplicating an array of
objects, and a real-world programmer (and Jazillian) would have just 
replaced it with a
simple Java assignment, and someplace the code really did need two 
distinct copies of the array,
and behavior changed subtly. Fortunately, there was a nice test suite, 
and it was just a matter
of time to track down the root cause.

So the compiler crowd is probably cringing to hear that, but it was 
still a big win.
We'd ported a C (BREW) app to Java. 10 minutes to run it through 
Jazillian, and few hours
hours to debug. Compare that to rewriting in Java by hand, and you've 
saved at least 90%
in time and effort, probably a lot more.

In all our other cases, the code seemed to always be very generic, 
high-level, business-logic stuff.
No unions, no bit twiddling, and very little pointer trickery. Subtle 
behavior changes are one of those
things that seem like they'd happen all the time, but actually don't 
seem to in practice.

In our most recent project, we converted 740,000 lines of C code to 
Java, and after a few weeks
of testing we still hadn't seen any subtle runtime bugs. I just IM'ed 
that customer and he confirmed
that he can't think of any subtle runtime errors that we introduced. It 
all depends on the app.
A Python person was wondering about converting the python interpreter to 
Java. Trying to
automatically convert that was clearly a lost cause.

>
>> In our case, we'll see if, say, a memset() call matches any  patterns of
>> usage that we've seen before and have some
>> Java equivalent. If not, we'll leave it in the code, give a  warning, 
>> and
>> you'll have a memset() call in the middle of your Java code.
>> So, obviously, our translator works much better on "vanilla business
>> logic" code than it does on low-level library code.
>
>
> That sounds like a good approach to me, because it will definitely  
> stand out. Most low-level things are specific to one language anyway,  
> so it's sensible to leave that alone if there's no good conversion  
> available, IMHO.


Yup, nothing stands out like a compilation error! So far, the "just let 
any pattern that you don't recognize flow through
from the C to Java" has worked really well in practice. Customers always 
ask for you to be sure to "flag" stuff that
you can't handle, and we do (in a log file). But then it seems like the 
developer who gets the Java code just
tries to compile it, and doesn't even bother looking at the log file. He 
sees a memset() or some call to his
old C-based library, and he knows what's going on.

>
>> typedefs are usually of the form:
>> typedef THIS IS THE REPLACEMENT    THING_TO_BE_REPLACED;
>> this one is of the form:
>> typedef PART_OF_REPLACEMENT THING_TO_BE_REPLACED REST_OF_REPLACEMENT.
>
>
> Well, for array types it definitely always is
> typedef char MYCHAR[25];
> This won't work (and it shouldn't, too):
> typedef char[25] MYCHAR;
> There's no surprise, is there?


Just to my Java-trained token-stream-focued eye. It's a really screwed 
up syntax, this C array declaration:
char mychar[25];
...and it did always bother me, even before Java. It actually "popped 
out" to my officemate last night.
He was looking in a book and saying "can you do that?", so it's not just 
me :)

>
>
>> This illustrates the AST vs. token stream mentality really well.  The 
>> "oh
>> no!" moment that I get when
>> I see this out-of-wack-token-sequence-meaning is a bad one. But  this
>> "I'm going to
>> now have to think a bit to make sure I understand this" thinking that
>> I'm experiencing here is very similar
>> to the "I'm going to have to think now about what the AST looks like"
>> feeling that I'd have to do ALL THE TIME
>> with ASTs.
>
>
> mmh. The typedef example is a pretty good indicator that ASTs are a  
> good way to abstract, isn't it?
> It's the parsers job to produce a helpful tree for translations and  
> this would look like
> (TYPEDEF MYCHAR char[25]) in this case, making it easy to replace  
> MYCHAR. The tokenstream would lose this information and would scatter  
> the knowledge of how this is to be done in other places, rather than  
> to keep the knowledge about the source language together in one place.
> E.g. for ANTLR, when I want to find out how something works in  
> syntactic terms, I go looking at the grammars and the trees they  
> procude.
> Then I know for sure what is legal and what is not.
> That's what I like about trees. Once done, they give me information  
> about structure in clear terms. If I look at token streams, that  
> information
> is hidden and I have to do the parsing in my head. YMMV.

Yea, this is what I was thinking at first too. But now I think...it's 
not that the AST is
"hiding the ugly token-sequence details from you". What the AST is doing 
is replacing
token-sequence-ugliness with AST-uglyness. Yes, you know longer care 
about "token structure",
but you do now have to care about "AST structure". Not only that, the 
"token structure" is usually
quite clean and intuitive (this typedef example is a rare exception). 
But the AST structure
is pretty arbitrary - we've got a C AST and a Java AST, and they're 
sometimes different for
identical constructs. Not only that, we actually have two java.g 
grammars, and they're
building different AST structures!

How am I supposed to easily convert a token stream to an AST in my head, 
when probably any
two people who write their own java.g's each come up with their own AST 
structure? When we
have "public final static void main(String[] args)", is there a 
MODIFIERS node in there?
What's the type of the "[" node again? I can't remember all that - I 
keep having to look back
at the grammar.

I'd much rather just remember that typedef looks like this:
typedef ....one or more replacement tokens... token_to_replace;
...and then get surprised by the syntax for typedefs involving arrays.
That's much easier (for me) than remembering what the TYPEDEF part of an 
AST looks like.

Andy.


From antlr at jazillian.com  Thu Oct 12 13:17:56 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 16:17:56 -0400
Subject: [antlr-interest] acceptance of new ideas (was philosophy about
 translation)
In-Reply-To: <7AE2E53336B37440A20C9590DB11BCB905119B6F@EXVS01.ex.dslextreme.net>
References: <7AE2E53336B37440A20C9590DB11BCB905119B6F@EXVS01.ex.dslextreme.net>
Message-ID: <452EA2F4.7080909@jazillian.com>

Andy,

Thanks for the support. Just to add a little to what you said...

I think the "it's ok to generate less-than-perfect code" mindset is 
especially hard to get
for someone in the compiler crowd. Lex and Yacc where around for, what? 
20 years
before ANTLR came along? 20 years of people using lex and yacc, and 
getting things
to work by trial-and-error because the generated code was unreadable? 
That's crazy!
Thank goodness Terence came along and saw the value in generating 
readable code.

But the compiler crowd is so used to generating assembly, machine code, 
and byte code,
none of which gets any benefit from readability. And of course, it must 
work, 100%.
There's absolutely no question about it.

That's a huge mindset leap to the NLP mindset, which is "Of course 
English to Spanish
is impossible, we'll just do the best we can. The airline software 
developers say
"Of course the problem is NP-complete and our input is massive, that's 
not going to
stop us from doing the best we can to schedule the airplanes." And the 
chess crowd
says "of course the perfect game of chess is impossible, that doesn't 
mean we can't
do better than any human."

The airline software has always been better than humans. The chess 
software has just
passed humans. The natural language translators are still not as good as 
humans, but with
a bit of work, they will be.

Sorry for the ramble :)
Andy

From kroepke at classdump.org  Thu Oct 12 13:41:48 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Thu, 12 Oct 2006 22:41:48 +0200
Subject: [antlr-interest] Token Stream vs. AST
In-Reply-To: <452E9FAE.6040106@jazillian.com>
References: <B7E07EB6-0B76-4E50-BDC1-628114D67E82@classdump.org>
	<452E9FAE.6040106@jazillian.com>
Message-ID: <1134D704-8318-4A6E-9ABC-DCBBA2C3E5C4@classdump.org>


On 12. Oct 2006, at 22:03 Uhr, Andy Tripp wrote:

> In all our other cases, the code seemed to always be very generic,  
> high-level, business-logic stuff.
> No unions, no bit twiddling, and very little pointer trickery.  
> Subtle behavior changes are one of those
> things that seem like they'd happen all the time, but actually  
> don't seem to in practice.
>
> In our most recent project, we converted 740,000 lines of C code to  
> Java, and after a few weeks
> of testing we still hadn't seen any subtle runtime bugs. I just  
> IM'ed that customer and he confirmed
> that he can't think of any subtle runtime errors that we  
> introduced. It all depends on the app.

That's my experience, too (albeit with conversion by hand). A half- 
well written program will try to confine the low-level stuff as much  
as possible. Of course, things can get out of hand, but in the  
general case...your work (and its apparent successes) continues to  
impress me!

> A Python person was wondering about converting the python  
> interpreter to Java. Trying to
> automatically convert that was clearly a lost cause.

icky stuff ;) take a look at the perl source code and you know what a  
lost cause is :P


> Yup, nothing stands out like a compilation error! So far, the "just  
> let any pattern that you don't recognize flow through
> from the C to Java" has worked really well in practice. Customers  
> always ask for you to be sure to "flag" stuff that
> you can't handle, and we do (in a log file). But then it seems like  
> the developer who gets the Java code just
> tries to compile it, and doesn't even bother looking at the log  
> file. He sees a memset() or some call to his
> old C-based library, and he knows what's going on.

I second that. Log files are good for debugging if nothing else (my  
experience). Real problems should always be like a smack in the face,  
so they won't be swept under the carpet. My first try would be to  
compile it, too. If nothing else to point me to the problems quickly.

> Just to my Java-trained token-stream-focued eye. It's a really  
> screwed up syntax, this C array declaration:
> char mychar[25];
> ...and it did always bother me, even before Java. It actually  
> "popped out" to my officemate last night.
> He was looking in a book and saying "can you do that?", so it's not  
> just me :)

:) Here's another one:
typedef void (*func)(int);

> Yea, this is what I was thinking at first too. But now I  
> think...it's not that the AST is
> "hiding the ugly token-sequence details from you". What the AST is  
> doing is replacing
> token-sequence-ugliness with AST-uglyness. Yes, you know longer  
> care about "token structure",
> but you do now have to care about "AST structure". Not only that,  
> the "token structure" is usually
> quite clean and intuitive (this typedef example is a rare  
> exception). But the AST structure
> is pretty arbitrary - we've got a C AST and a Java AST, and they're  
> sometimes different for
> identical constructs. Not only that, we actually have two java.g  
> grammars, and they're
> building different AST structures!

Yeah, the structure of an AST is heavily influenced by what you want  
to achieve. Choosing a suitable intermediate representation (IR) is  
crucial. While I probably wouldn't choose the token stream as an IR,  
it surely is an option. But then I find it more natural to look at  
trees than at streams. Your mileage obviously varies...:)

> How am I supposed to easily convert a token stream to an AST in my  
> head, when probably any
> two people who write their own java.g's each come up with their own  
> AST structure? When we
> have "public final static void main(String[] args)", is there a  
> MODIFIERS node in there?
> What's the type of the "[" node again? I can't remember all that -  
> I keep having to look back
> at the grammar.

Wouldn't you yourself be the author of the grammar/AST? I cannot  
imagine that you'd switch grammars like socks during a project, so  
I'd assume that you know the structure pretty much off the top of  
your hat, except maybe in a few border cases which you seldom  
encounter. But for visualization there are tools available (like  
graphviz, or custom made tree viewers) that make checking trees easy.  
I find pen and paper useful, too ;)

> I'd much rather just remember that typedef looks like this:
> typedef ....one or more replacement tokens... token_to_replace;
> ...and then get surprised by the syntax for typedefs involving arrays.
> That's much easier (for me) than remembering what the TYPEDEF part  
> of an AST looks like.

My approach would be to shape the tree to be uniform for all typedefs  
in the parser and then let later stages work on that, instead of  
propagating the special cases further down the stages. That's the  
reason syntax trees are referred to as being abstract. I love  
abstraction, since it lets you talk/take care of things in  
generalized manner, as long as you follow a certain terminology.  
That's why mathematical notation is so incredibly powerful: it let's  
you built new things in terms of existing things. Whenever a notation  
gets messy, you look at it and try to come up with a suitable set of  
abstractions, to maximize your power of expressing things. Same way  
with intermediate representations.
Ok, granted, you have already said that you have found it very hard,  
if not impossible, to find a IR suitable for both Cobol and C to  
Java, so your case might be an exception.
Still, the power of having a translation engine (which suddenly  
sounds a lot like a compiler, doesn't it) that has different front- 
ends, an IR, and a back-end, is something that is very desirable. At  
least to me. It appears you cannot share much code/many rules between  
your C->Java and Cobol->Java products, or am I mistaken?

-k
-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From kroepke at classdump.org  Thu Oct 12 14:04:01 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Thu, 12 Oct 2006 23:04:01 +0200
Subject: [antlr-interest] acceptance of new ideas (was philosophy about
	translation)
In-Reply-To: <452EA2F4.7080909@jazillian.com>
References: <7AE2E53336B37440A20C9590DB11BCB905119B6F@EXVS01.ex.dslextreme.net>
	<452EA2F4.7080909@jazillian.com>
Message-ID: <0C5FA3C4-6F29-4FD8-B7F9-8BDA268C4031@classdump.org>


On 12. Oct 2006, at 22:17 Uhr, Andy Tripp wrote:

> I think the "it's ok to generate less-than-perfect code" mindset is  
> especially hard to get
> for someone in the compiler crowd.

Of course it depends. Clearly, no one can expect a code translator  
that can convert huge programs
flawlessly, in every instance. Those who expect that probably have no  
inkling about the problem domain,
even if they are successful compiler engineers. The sad thing is,  
most of the time they are just pointing to
the really hard stuff and ignore the 90% of the work you can take off  
their shoulders. Stupid behavior, if you ask
me.

What really interests me are automatic code refactoring (how I hate  
that word) tools for a variety of languages (including
script languages that have a very implicit type system, like Perl).
In particular for Objective-C, since that has the immensely  
fascinating mixture of both early and late binding,
the latter inherited from Smalltalk.
In that problem domain, accuracy is a must and it is a hard problem  
to prove correctness of transformation, if you
cannot completely rely on types. You don't want to mess with code  
that will be failing in obscure ways at runtime.
The effects of rearranging code can be hard to visualize so there  
must not be any foul surprises lurking behind the corner.
Coming from that direction, your work interests me immensely, and  
your success gives me the hint that it indeed is
feasible to try for something like I'm aiming at.
In that respect, it is of course valuable to know your motivations  
for avoiding a tree based approach, and be it just
for seeing a different approach which causes me to reflect my  
presuppositions, which is always good.

> Lex and Yacc where around for, what? 20 years
> before ANTLR came along? 20 years of people using lex and yacc, and  
> getting things
> to work by trial-and-error because the generated code was  
> unreadable? That's crazy!
> Thank goodness Terence came along and saw the value in generating  
> readable code.

All hail the chief! :) BTW, I totally agree.

-k





From contingencyplan at gmail.com  Thu Oct 12 15:02:58 2006
From: contingencyplan at gmail.com (Brian DeVries)
Date: Thu, 12 Oct 2006 17:02:58 -0500
Subject: [antlr-interest] Exception when running compiled ANTLR on all
	grammars
In-Reply-To: <E1GY1Qv-0000x7-00@gecko>
References: <a3db01e90610120107w42c2d1eehebec6f17a32513a9@mail.gmail.com>
	<E1GY1Qv-0000x7-00@gecko>
Message-ID: <a3db01e90610121502p4ba0d386kc2f2327a011f090e@mail.gmail.com>

Both of y'all said the same thing, and both of y'all are right - no
more exceptions.

Thanks!
~Brian DeVries

On 10/12/06, John B. Brodie <jbb at acm.org> wrote:
> Your script:
> >----- antlr ------
> >#!/bin/sh
> >
> >MYCLASSPATH=$CLASSPATH
> >CLASSPATH=${HOME}/classpath/antlr_mine.jar:${HOME}/classpath/stringtemplate-2.3b9.jar:$CLASSPATH
> >java org.antlr.Tool $*
> >CLASSPATH=${MYCLASSSPATH}
>
> does not seem to include the v2 antlr jar (v3 needs v2 at the moment)
> here is the script i use (note i have not compiled a new version, just
> placed the jar files in /usr/local):
>
> #!/bin/bash
>
> # directory containing the unpacked ANTLR v3 distribution:
> V3=/usr/local/antlr-3.0b4/lib/
>
> LIBS=${V3}/antlr-2.7.6.jar:${V3}/antlr-3.0b4.jar:${V3}/stringtemplate-2.3b9.jar
> CP=${LIBS}:${CLASSPATH}
>
> java -cp ${CP} org.antlr.Tool $*
>
>
> hope this helps...
>    -jbb
>

On 10/12/06, Terence Parr <parrt at cs.usfca.edu> wrote:

> Make sure you have 2.7.6 or 2.7.7 ANTLR  In your path as well.  Look
> for old versions that do not have the latest TokenStreamRewriteEngine.
> Ter
> On Oct 12, 2006, at 1:07 AM, Brian DeVries wrote:

> > Hello,
> >
> > I have compiled ANTLR 3.0b4 from source, since Gentoo hasn't added the
> > beta version to portage. I haven't changed any of the source code,
> > except for the version number value in org.antlr.Tool (which I did to
> > make sure of which version I was running).
> >
> > I also have a script in my ~/bin directory to make it easier to run
> > ANTLR (so I don't have to run the whole java command):
> >
> > ----- antlr ------
> > #!/bin/sh
> >
> > MYCLASSPATH=$CLASSPATH
> > CLASSPATH=${HOME}/classpath/antlr_mine.jar:${HOME}/classpath/
> > stringtemplate-2.3b9.jar:$CLASSPATH
> > java org.antlr.Tool $*
> > CLASSPATH=${MYCLASSSPATH}
> >
> >
> > Whenever I try to run ANTLR on a grammar (even ones included in the
> > examples file), I get the following error:
> >
> > % antlr c.g
> > ANTLR Parser Generator   Early Access Version 3.0b4-BWD2 (??,
> > 2006)  1989-2006
> > Exception in thread "main" java.lang.NoSuchMethodError:
> > antlr.TokenStreamRewriteEngine.size()I
> >        at org.antlr.tool.Grammar.defineLexerRuleFoundInParser
> > (Grammar.java:977)
> >        at org.antlr.tool.DefineGrammarItemsWalker.rule
> > (DefineGrammarItemsWalker.java:771)
> >        at org.antlr.tool.DefineGrammarItemsWalker.rules
> > (DefineGrammarItemsWalker.java:478)
> >        at org.antlr.tool.DefineGrammarItemsWalker.grammarSpec
> > (DefineGrammarItemsWalker.java:323)
> >        at org.antlr.tool.DefineGrammarItemsWalker.grammar
> > (DefineGrammarItemsWalker.java:179)
> >        at org.antlr.tool.Grammar.setGrammarContent(Grammar.java:491)
> >        at org.antlr.tool.Grammar.<init>(Grammar.java:409)
> >        at org.antlr.Tool.process(Tool.java:246)
> >        at org.antlr.Tool.main(Tool.java:70)
> >
> > Any ideas on what I'm doing wrong? I'm using Gentoo Linux with the Sun
> > Java5 compiler and environment.
> >
> > Thanks!
> > ~Brian DeVries

From antlr at jazillian.com  Thu Oct 12 15:47:52 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 18:47:52 -0400
Subject: [antlr-interest] Token Stream vs. AST
In-Reply-To: <1134D704-8318-4A6E-9ABC-DCBBA2C3E5C4@classdump.org>
References: <B7E07EB6-0B76-4E50-BDC1-628114D67E82@classdump.org>	<452E9FAE.6040106@jazillian.com>
	<1134D704-8318-4A6E-9ABC-DCBBA2C3E5C4@classdump.org>
Message-ID: <452EC618.7080502@jazillian.com>

Kay Roepke wrote:

>
> On 12. Oct 2006, at 22:03 Uhr, Andy Tripp wrote:
>
>> In all our other cases, the code seemed to always be very generic,  
>> high-level, business-logic stuff.
>> No unions, no bit twiddling, and very little pointer trickery.  
>> Subtle behavior changes are one of those
>> things that seem like they'd happen all the time, but actually  don't 
>> seem to in practice.
>>
>> In our most recent project, we converted 740,000 lines of C code to  
>> Java, and after a few weeks
>> of testing we still hadn't seen any subtle runtime bugs. I just  
>> IM'ed that customer and he confirmed
>> that he can't think of any subtle runtime errors that we  introduced. 
>> It all depends on the app.
>
>
> That's my experience, too (albeit with conversion by hand). A half- 
> well written program will try to confine the low-level stuff as much  
> as possible. Of course, things can get out of hand, but in the  
> general case...your work (and its apparent successes) continues to  
> impress me!

It's still too early to judge Jazillian's commercial success. The 
C-to-Java tool has been available for 18 months,
we're finishing COBOL-to-Java beta now, and starting C++ -to- Java beta. 
But the program does exactly what I had
hoped it would do, the existing customers are very happy. The customer's 
lead technical guy on that large project
was quite amazed. We had converted his 740,000 lines of C to Java, 
including automatically adding hooks into hibernate,
, his new web-based GUI, etc. Took 12 days :) Probably would have taken 
5 people working 6 months to a year
to do by hand.

>
> :) Here's another one:
> typedef void (*func)(int);

Function pointer syntax never looks right unless your eyes are crossed :)

>
> Wouldn't you yourself be the author of the grammar/AST? I cannot  
> imagine that you'd switch grammars like socks during a project, so  
> I'd assume that you know the structure pretty much off the top of  
> your hat, except maybe in a few border cases which you seldom  
> encounter. But for visualization there are tools available (like  
> graphviz, or custom made tree viewers) that make checking trees easy.  
> I find pen and paper useful, too ;)

I've only made slight modifications to Monty's C and GnuC ANTLR 
grammars. I have no problem with their design,
just saying that when I look at a chunk of code, a perfectly correct 
clear picture of the equivalent AST doesn't
pop into my head. I tried doing AST transforms for three months - really 
did give it a decent effort.

>
>> I'd much rather just remember that typedef looks like this:
>> typedef ....one or more replacement tokens... token_to_replace;
>> ...and then get surprised by the syntax for typedefs involving arrays.
>> That's much easier (for me) than remembering what the TYPEDEF part  
>> of an AST looks like.
>
>
> My approach would be to shape the tree to be uniform for all typedefs  
> in the parser and then let later stages work on that, instead of  
> propagating the special cases further down the stages. 

Right, me too.

> That's the  reason syntax trees are referred to as being abstract. I 
> love  abstraction, since it lets you talk/take care of things in  
> generalized manner, as long as you follow a certain terminology.  

I tend to think people think ASTs are more abstract than they really are.
OK, so there's no ";" or "]" stored in the AST - big deal.
I can still look at a C grammar and tell at a glance that it's C and not 
Java.
The grammar/AST is built to exactly match the language, so it's 
completely tied to that language.
The fact that it doesn't quite store every syntactic element doesn't 
mean it's really very abstract.

> That's why mathematical notation is so incredibly powerful: it let's  
> you built new things in terms of existing things. Whenever a notation  
> gets messy, you look at it and try to come up with a suitable set of  
> abstractions, to maximize your power of expressing things. Same way  
> with intermediate representations.

Mathematical notation is powerful that way, but at the expense of 
expressiveness. It's nice to be able to say
matrixC = matrixA * matrixB
...but only because anyone reading that would know what it means to 
multiply two matrices.
If you don't know matrix multiplication, then the "*" shorthand is more 
confusing than the "longhand" that it replaced.
Which raises the question: What's the point of source code? Is it to 
succinctly tell the computer what to do?
or is it to tell the reader what's being done? Well, it's both, so how 
do you balance those two often
conflicting goals?

> Ok, granted, you have already said that you have found it very hard,  
> if not impossible, to find a IR suitable for both Cobol and C to  
> Java, so your case might be an exception.
> Still, the power of having a translation engine (which suddenly  
> sounds a lot like a compiler, doesn't it) that has different front- 
> ends, an IR, and a back-end, is something that is very desirable. At  
> least to me. It appears you cannot share much code/many rules between  
> your C->Java and Cobol->Java products, or am I mistaken?

A good IR would be great, but I don't think it's really possible. Other 
language translators do claim to do this,
and obviously things like CIL
http://en.wikipedia.org/wiki/List_of_hello_world_programs#CIL  works 
fine for compilers.

I'd say about half of my C-to-Java rules are reused in COBOL-to-Java.
All the C-to-Java rules are reused by C++ - to - Java.

>
> -k



From antlr at jazillian.com  Thu Oct 12 16:01:23 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Thu, 12 Oct 2006 19:01:23 -0400
Subject: [antlr-interest] acceptance of new ideas (was philosophy about
 translation)
In-Reply-To: <0C5FA3C4-6F29-4FD8-B7F9-8BDA268C4031@classdump.org>
References: <7AE2E53336B37440A20C9590DB11BCB905119B6F@EXVS01.ex.dslextreme.net>	<452EA2F4.7080909@jazillian.com>
	<0C5FA3C4-6F29-4FD8-B7F9-8BDA268C4031@classdump.org>
Message-ID: <452EC943.6010105@jazillian.com>

Kay Roepke wrote:

>
> On 12. Oct 2006, at 22:17 Uhr, Andy Tripp wrote:
>
>> I think the "it's ok to generate less-than-perfect code" mindset is  
>> especially hard to get
>> for someone in the compiler crowd.
>
>
> Of course it depends. Clearly, no one can expect a code translator  
> that can convert huge programs
> flawlessly, in every instance. Those who expect that probably have no  
> inkling about the problem domain,
> even if they are successful compiler engineers. The sad thing is,  
> most of the time they are just pointing to
> the really hard stuff and ignore the 90% of the work you can take off  
> their shoulders. Stupid behavior, if you ask
> me.

It can and has been done. See http://ovid.tigris.org/Ephedra/.
I don't doubt that it works perfectly. Just don't expect to be able to 
read or maintain the
generated code just because it's Java and not assembly.

>
> What really interests me are automatic code refactoring (how I hate  
> that word) tools for a variety of languages (including
> script languages that have a very implicit type system, like Perl).
> In particular for Objective-C, since that has the immensely  
> fascinating mixture of both early and late binding,
> the latter inherited from Smalltalk.
> In that problem domain, accuracy is a must and it is a hard problem  
> to prove correctness of transformation, if you
> cannot completely rely on types. You don't want to mess with code  
> that will be failing in obscure ways at runtime.
> The effects of rearranging code can be hard to visualize so there  
> must not be any foul surprises lurking behind the corner.
> Coming from that direction, your work interests me immensely, and  
> your success gives me the hint that it indeed is
> feasible to try for something like I'm aiming at.

 From what I've seen, all the refactoring tools, IDEs, etc. all use ASTs.
Also note that Sun is adding adding an API to be able to access all 
javac functionality. That's pretty cool.
If you really do need 100% correctness, you'd better stick with ASTs.

> In that respect, it is of course valuable to know your motivations  
> for avoiding a tree based approach, and be it just
> for seeing a different approach which causes me to reflect my  
> presuppositions, which is always good.

I didn't start out avoiding ASTs. I had just jotted down a couple 
hundred simple rules like:
strcpy(a, b) --> a = b;
if (true) { x } --> x  // as long as there's no 'else'
printf(x) --> sprintf(stdout, x)

And I found it very hard to work with the ASTs. At least for these 
trivial cases, it shouldn't take much
longer than the few seconds it took to type that mapping.

>
>
>> Lex and Yacc where around for, what? 20 years
>> before ANTLR came along? 20 years of people using lex and yacc, and  
>> getting things
>> to work by trial-and-error because the generated code was  
>> unreadable? That's crazy!
>> Thank goodness Terence came along and saw the value in generating  
>> readable code.
>
>
> All hail the chief! :) BTW, I totally agree.

On some things, we can all agree :)

>
> -k
>
>
>
>


From parrt at cs.usfca.edu  Thu Oct 12 19:08:28 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 12 Oct 2006 19:08:28 -0700
Subject: [antlr-interest] ANTLR v2 to v3 converter version 0.1
Message-ID: <421FB981-5921-4E0C-990F-48EC100C9CF2@cs.usfca.edu>

Hi,

I have an initial v2 to v3 converter:

http://www.antlr.org/v3/v2v3-0.1.tar.gz

It converts two v2 ANTLR grammars from ANTLR v3 (antlr.g and  
antlr.print.g) syntactically, but I get lots of warnings...anyway,  
won't do trees in actions or anything, but it does some decent work  
for you.  Does most of the grunt work I'd say.

$ java v3me file.g

stdout will have the translation.

Use

$ java v3me -combined file.g

if you are converting a file with both parser/lexer in there!

Please send updates to me directly if you make some nice additions. :)

Let me know what you think.

Ter
------------------
Currently does this kind of stuff:

new keywords: grammar, tree; must warn with comment.

convert class T extends Parser -> grammar T if combined or
parser grammar T if not

header {...} -> @header {...} and move to action section after grammar.

option names; importVocab -> tokenVocab, buildAST=true -> output=AST

keyword protected->fragment

labels goes from colon to =

literals "abc" -> 'abc'

tree ^ -> ^^

kill empty strings in tokens; don't need to add to literals table.
tokens {
         "options";
}

add @members to member actions.

add @init to rule actions

comment out return value init expressions

move lexer member action to grammar member area if combined


From sohail at taggedtype.net  Thu Oct 12 19:56:50 2006
From: sohail at taggedtype.net (Sohail Somani)
Date: Thu, 12 Oct 2006 19:56:50 -0700
Subject: [antlr-interest] The 'Philosophy about translation' thread....
In-Reply-To: <41fed8f80610120737n1df9c41ai24884ebf2d171526@mail.gmail.com>
References: <41fed8f80610120715q420d6161k947956e49a18b055@mail.gmail.com>
	<1160663438.5592.0.camel@localhost.localdomain>
	<41fed8f80610120737n1df9c41ai24884ebf2d171526@mail.gmail.com>
Message-ID: <1160708210.7316.1.camel@localhost.localdomain>

On Thu, 2006-10-12 at 07:37 -0700, Prashant Deva wrote:
> 
> 
>         Thats pretty stupid!
> 
> Whats so stupid?

I forget what this email was about. I wish my email client would attach
*ALL* the emails ever received for this thread to my email.

Because that makes sense...

</sarcasm> :)
> 


From e.papegaaij at student.utwente.nl  Fri Oct 13 08:34:05 2006
From: e.papegaaij at student.utwente.nl (Emond Papegaaij)
Date: Fri, 13 Oct 2006 16:34:05 +0100
Subject: [antlr-interest] Lexing problem
Message-ID: <200610131734.05384.e.papegaaij@student.utwente.nl>

Hello,

I'm trying to match a multiline c-style comment into a COMMENT token 
without the opening and closing '/*' and '*/'. This is how I would do it 
in ANTLRv2:
COMMENT: '/*'! ( options {greedy=false;} : . )*  '*/'!;

However the '!' does not work in v3. So I tried all of the following:

COMMENT: '/*' contents=(( options {greedy=false;} : . )*) '*/'
         { setText($contents.text); };

COMMENT: '/*' contents=COMMENT_BODY '*/' { setText($contents.text); };
COMMENT_BODY: ( options {greedy=false;} : . )*;

COMMENT: '/*' ( options {greedy=false;} : contents=COMMENT_BODY ) '*/'
         { setText($contents.text); };
COMMENT_BODY: .*;

COMMENT: '/*' contents=COMMENT_BODY '*/' { setText($contents.text); };
COMMENT_BODY: (~'*/')*;

COMMENT: '/*' contents=COMMENT_BODY '*/' { setText($contents.text); };
COMMENT_BODY: ((~'*') | ('*' ~'/'))*;

Non of them work. Some produce syntax errors, others don't match the exit 
branch and the last one produces "mismatched char: '/' on line 1:9; 
expecting set null" during parsing. Can anybody help me out with this 
rule?

Best regards,
Emond Papegaaij

From kroepke at classdump.org  Fri Oct 13 09:21:25 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Fri, 13 Oct 2006 18:21:25 +0200
Subject: [antlr-interest] Lexing problem
In-Reply-To: <200610131734.05384.e.papegaaij@student.utwente.nl>
References: <200610131734.05384.e.papegaaij@student.utwente.nl>
Message-ID: <A976A2D2-ACC1-4B62-B00F-5DEC0E362B55@classdump.org>


On 13. Oct 2006, at 17:34 Uhr, Emond Papegaaij wrote:

> Hello,
>
> I'm trying to match a multiline c-style comment into a COMMENT token
> without the opening and closing '/*' and '*/'. This is how I would  
> do it
> in ANTLRv2:
> COMMENT: '/*'! ( options {greedy=false;} : . )*  '*/'!;
>
> However the '!' does not work in v3. So I tried all of the following:
>
> COMMENT: '/*' contents=(( options {greedy=false;} : . )*) '*/'
>          { setText($contents.text); };

it's easier to just strip off the '/*' and '*/' characters:
COMMENT: '/*' ( options {greedy=false;} : . )* '*/'
          { setText(getText().substring(2, getText().length()-2)); }
         ;

why it complains about the newline character, I can't say offhand.

this should work.

HTH,
-k


-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From parrt at cs.usfca.edu  Fri Oct 13 09:55:18 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 13 Oct 2006 09:55:18 -0700
Subject: [antlr-interest] Lexing problem
In-Reply-To: <200610131734.05384.e.papegaaij@student.utwente.nl>
References: <200610131734.05384.e.papegaaij@student.utwente.nl>
Message-ID: <151D2B50-AB16-4831-8DC5-AB8C11889EA2@cs.usfca.edu>


On Oct 13, 2006, at 8:34 AM, Emond Papegaaij wrote:

> Hello,
>
> I'm trying to match a multiline c-style comment into a COMMENT token
> without the opening and closing '/*' and '*/'. This is how I would  
> do it
> in ANTLRv2:
> COMMENT: '/*'! ( options {greedy=false;} : . )*  '*/'!;
>
> However the '!' does not work in v3. So I tried all of the following:
>
> COMMENT: '/*' contents=COMMENT_BODY '*/' { setText($contents.text); };
> COMMENT_BODY: ( options {greedy=false;} : . )*;

Make that rule a "fragment".

Ter


From antlr at jazillian.com  Fri Oct 13 10:27:55 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 13 Oct 2006 13:27:55 -0400
Subject: [antlr-interest] Token Stream vs. AST
In-Reply-To: <F89BA86F375B2F43B05CB04E01B199BA030966@castor-srvr1.benchmarkcanada.com>
References: <F89BA86F375B2F43B05CB04E01B199BA030966@castor-srvr1.benchmarkcanada.com>
Message-ID: <452FCC9B.1080807@jazillian.com>

Oliver Wong wrote:

>From: antlr-interest-bounces at antlr.org
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Andy Tripp
>  
>
>>I'd say about half of my C-to-Java rules are reused in COBOL-to-Java.
>>    
>>
>
>	This surprises me a lot. Can you elaborate on this? Surely stuff
>like "strcpy(a,b) -> a = b"  couldn't be re-used. What *could* be
>reused?
>
>	- Oliver
>  
>
After most of the COBOL-specific rules/phases have fired, the code looks 
pretty Java-like.
Some of the common rules:
remove gotos
rename files, vars, methods,
simplifications of various if/else if constructs
adding exception handling
checking for cases where javac will complain about "loss of precision".
making things into cleasses, adding imports, etc.
restoring comments

You're right, though, looking at it closely now, I'd say only maybe 20% 
of the
C-to-Java rules are reused in COBOL-to-Java.

Andy


From ilia at obnovlenie.ru  Fri Oct 13 13:35:45 2006
From: ilia at obnovlenie.ru (Ilia Kantor)
Date: Sat, 14 Oct 2006 00:35:45 +0400
Subject: [antlr-interest] LL(*) proof
In-Reply-To: <452D207B.3080408@jazillian.com>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
	<452D207B.3080408@jazillian.com>
Message-ID: <200610140035.45976.ilia@obnovlenie.ru>


I wrote a grammar for antlr v3. But I need to proff that it's
1) LL(*) 
2) single program tree 

How to do it in mathematically correct way ?


Also could you point out articles about LL(*) ?

From parrt at cs.usfca.edu  Fri Oct 13 13:56:09 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 13 Oct 2006 13:56:09 -0700
Subject: [antlr-interest] LL(*) proof
In-Reply-To: <200610140035.45976.ilia@obnovlenie.ru>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
	<452D207B.3080408@jazillian.com>
	<200610140035.45976.ilia@obnovlenie.ru>
Message-ID: <54F64356-17EB-4EC1-8B33-E001CBC9EBCB@cs.usfca.edu>


On Oct 13, 2006, at 1:35 PM, Ilia Kantor wrote:

>
> I wrote a grammar for antlr v3. But I need to proff that it's
> 1) LL(*)

ANTLR will tell you if it's LL(*).

> 2) single program tree

I'm not sure what you mean here.

> Also could you point out articles about LL(*) ?

None written yet I'm afraid.

Terence


From contingencyplan at gmail.com  Fri Oct 13 19:38:38 2006
From: contingencyplan at gmail.com (Brian DeVries)
Date: Fri, 13 Oct 2006 21:38:38 -0500
Subject: [antlr-interest] Header not copied to lexer file?
Message-ID: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>

In my 3.0b4 grammar file, I have the lines

@header
{
	package parsing;
}

The generated Java parsing file contains this line. However, the
generated lexer grammar and Java files do not, resulting in a compiler
error.

What can I do to fix this, aside from manually entereing the header in
the lexer file each time?

Thanks,
~Brian DeVries

From ilia at obnovlenie.ru  Sat Oct 14 01:09:32 2006
From: ilia at obnovlenie.ru (Ilia Kantor)
Date: Sat, 14 Oct 2006 12:09:32 +0400
Subject: [antlr-interest] LL(*) proof
In-Reply-To: <54F64356-17EB-4EC1-8B33-E001CBC9EBCB@cs.usfca.edu>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<200610140035.45976.ilia@obnovlenie.ru>
	<54F64356-17EB-4EC1-8B33-E001CBC9EBCB@cs.usfca.edu>
Message-ID: <200610141209.32483.ilia@obnovlenie.ru>

? ????????? ?? 14 ??????? 2006 00:56 Terence Parr ???????(a):
> On Oct 13, 2006, at 1:35 PM, Ilia Kantor wrote:
> > I wrote a grammar for antlr v3. But I need to proff that it's
> > 1) LL(*)
>
> ANTLR will tell you if it's LL(*).

Could be nice to have a mathematical proof.. W
hat's a definition of LL(*) ? How to prove that grammar is LL(*) having its 
antlr notation ?


>
> > 2) single program tree
>
> I'm not sure what you mean here.

I have a grammar of (kindof) programming language. 
I guess, to make sure its correct, need to prove, that it transforms a program 
into single, determined AST.

From Abhijit_Ghonge at infosys.com  Sat Oct 14 03:55:23 2006
From: Abhijit_Ghonge at infosys.com (Abhijit Nandkumar Ghonge)
Date: Sat, 14 Oct 2006 16:25:23 +0530
Subject: [antlr-interest] interpretation '\t'
Message-ID: <D72A054DF5002D4FA6CF14252F7997B8D97E5F@BLRKECMSG13.ad.infosys.com>




Hi Kay,

            Thanks for your advice. I found something we can do for the
'\t'. In Antlr Reference Manual page 59, Tracking Column Information, we
can override the tab() method and set the number of columns we want to
set for the '\t'. This worked for me.

            Thanks for the help.



Abhijit.







**************** CAUTION - Disclaimer *****************
This e-mail contains PRIVILEGED AND CONFIDENTIAL INFORMATION intended solely for the use of the addressee(s). If you are not the intended recipient, please notify the sender by e-mail and delete the original message. Further, you are not to copy, disclose, or distribute this e-mail or its contents to any other person and any such actions are unlawful. This e-mail may contain viruses. Infosys has taken every reasonable precaution to minimize this risk, but is not liable for any damage you may sustain as a result of any virus in this e-mail. You should carry out your own virus checks before opening the e-mail or attachment. Infosys reserves the right to monitor and review the content of all messages sent to or from this e-mail address. Messages sent to or from this e-mail address may be stored on the Infosys e-mail system.
***INFOSYS******** End of Disclaimer ********INFOSYS***
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061014/e4c53c65/attachment.html 

From michael.gerz at teststep.org  Sat Oct 14 04:30:59 2006
From: michael.gerz at teststep.org (Michael Gerz)
Date: Sat, 14 Oct 2006 13:30:59 +0200
Subject: [antlr-interest] ANTLR 3.0 documentation
Message-ID: <4530CA73.4010909@teststep.org>

All,

I used ANTLR 2.7 in the past and I consider using ANTLR 3.0 for a new 
project.

However, it is very difficult to find relevant information on ANTLR 3.0. 
I noticed the new ANTLR 3 wiki but it seems to be rather incomplete. For 
instance, "fragment" is not listed as a rule option.

May I assume that the 2.7 documentation still applies unless the 3.0 
documentation states the opposite? Concretely, I wondering whether the 
error handling is the same in 2.7 and 3.0 (exception hierarchy, parser 
exception handlers, defaultErrorHandler, ...). The wiki says nothing 
about this topic. Why don't you use the 2.7 documentation as a starting 
point and modify it where needed?

All in all I think that the ANTLR web site is too complicated. The 
average user is confronted with so many different things of varying 
importance (just count the links on the home page!) that (s)he doesn't 
know where to start. It reminds me of the Eclispe web site which is also 
concerned with so many things that the guys forgot to announce version 
3.2.1 on their home page.

Please don't take my comments personally. ANTLR is a great tool and I 
love it! Just make it simpler to understand its concepts!

Kind regards,

Michael Gerz (formerly known as Michael Schmitt)


From dave at badgers-in-foil.co.uk  Sat Oct 14 04:48:49 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Sat, 14 Oct 2006 11:48:49 +0000
Subject: [antlr-interest] Header not copied to lexer file?
In-Reply-To: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
References: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
Message-ID: <20061014114848.GA2602@badgers-in-foil.co.uk>

On Fri, Oct 13, 2006 at 09:38:38PM -0500, Brian DeVries wrote:
> In my 3.0b4 grammar file, I have the lines
> 
> @header
> {
> 	package parsing;
> }
> 
> The generated Java parsing file contains this line. However, the
> generated lexer grammar and Java files do not, resulting in a compiler
> error.
> 
> What can I do to fix this, aside from manually entereing the header in
> the lexer file each time?

I think the above section is implicitly just for the parser, so
duplicate for the lexer, like so,

@lexer::header
{
	package parsing;
}



ta,
dave

-- 
http://david.holroyd.me.uk/

From contingencyplan at gmail.com  Sat Oct 14 05:04:25 2006
From: contingencyplan at gmail.com (Brian DeVries)
Date: Sat, 14 Oct 2006 07:04:25 -0500
Subject: [antlr-interest] Header not copied to lexer file?
In-Reply-To: <20061014114848.GA2602@badgers-in-foil.co.uk>
References: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
	<20061014114848.GA2602@badgers-in-foil.co.uk>
Message-ID: <a3db01e90610140504r6dd60276ic99fb2857f4c0ad1@mail.gmail.com>

Thanks, that worked.
~Brian DeVries

On 10/14/06, David Holroyd <dave at badgers-in-foil.co.uk> wrote:
> On Fri, Oct 13, 2006 at 09:38:38PM -0500, Brian DeVries wrote:
> > In my 3.0b4 grammar file, I have the lines
> >
> > @header
> > {
> >       package parsing;
> > }
> >
> > The generated Java parsing file contains this line. However, the
> > generated lexer grammar and Java files do not, resulting in a compiler
> > error.
> >
> > What can I do to fix this, aside from manually entereing the header in
> > the lexer file each time?
>
> I think the above section is implicitly just for the parser, so
> duplicate for the lexer, like so,
>
> @lexer::header
> {
>         package parsing;
> }
>
>
>
> ta,
> dave
>
> --
> http://david.holroyd.me.uk/
>

From clinton.roy at gmail.com  Sat Oct 14 05:23:56 2006
From: clinton.roy at gmail.com (Clinton Roy)
Date: Sat, 14 Oct 2006 22:23:56 +1000
Subject: [antlr-interest] python target
Message-ID: <9c0715e40610140523u43c2c81bs458294dbe4c0ce9@mail.gmail.com>

Hey guys,

I've been interested in using antlr for a work project, but was
specifically interested in some of the benefits of version three.

My language of choice is python so I've spent a little time working on
a python v3 target, my work so far is available at
http://azure.humbug.org.au:/~croy/antlr.tgz

It's very much a work in progress, only the basic stuff is working
(see TODO) but a generated parser does work on at least one simple
example.

I haven't had any success generating a parser without a specific k
option, as far as I can tell analysis/DFA.java:edgeTransitionClassMap
isn't being populated, is this a known bug or am I doing something
wrong?

I'd be quite happy to maintain this target in the long term.

cheers,

PS. I really hope I'm not standing on any toes here...
-- 
Clinton Roy
www.acqao.org - ARC Centre of Excellence for Quantum-Atom Optics
www.humbug.org.au  - Brisbane Unix Group
azure.humbug.org.au/~croy/blog - Blog
www.flickr.com/photos/croy/ - Photos

From kroepke at classdump.org  Sat Oct 14 05:34:46 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sat, 14 Oct 2006 14:34:46 +0200
Subject: [antlr-interest] Header not copied to lexer file?
In-Reply-To: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
References: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
Message-ID: <7D0FD74A-2395-4F0D-8C8C-2EB4CB1406DB@classdump.org>

Hi Brian!

On 14. Oct 2006, at 4:38 Uhr, Brian DeVries wrote:

> In my 3.0b4 grammar file, I have the lines
>
> @header
> {
> 	package parsing;
> }
>
> The generated Java parsing file contains this line. However, the
> generated lexer grammar and Java files do not, resulting in a compiler
> error.
>
> What can I do to fix this, aside from manually entereing the header in
> the lexer file each time?

In combined grammars everything without prefix goes to the parser by  
default.
You can force it to go to the lexer by saying:

@lexer::header {

}

I'm not sure if there is a way to force one header block to go to  
both lexer and parser, or if you
have to do:

@header {
	package parsing;
}
@lexer::header {
	package parsing;
}

I strongly suspect that this is the only way to do it right now.  
Maybe we can think of something that forces ANTLR to
write it to both files.

Maybe
@all::header {
	//goes to lexer _and_ parser
}

?

HTH,

-k



From contingencyplan at gmail.com  Sat Oct 14 05:42:36 2006
From: contingencyplan at gmail.com (Brian DeVries)
Date: Sat, 14 Oct 2006 07:42:36 -0500
Subject: [antlr-interest] Problems using the command-line grammar interpreter
Message-ID: <a3db01e90610140542u73ab9d9br14c6627da7c24a3c@mail.gmail.com>

I'm trying to use the org.antlr.tool.Interp program to test my grammar
against some basic sample output. I also have a very basic main( ) to
do the same task (though I'd prefer the command-line if possible).

I am using the following grammar (stripped down from the full version):

grammar Pseudocode;
options
{
	language = Java;
	backtrack = true;
	memoize = true;
	output = AST;
} // end options

@header
{
	package parsing;
}

@lexer::header
{
	package parsing;
} // end header

/**
 * An assignment
 */
assign
	: variable ASSIGN expression;

/**
 * A variable - something that can be on the left-hand side of an assignment
 */
variable
	: ID
	;

/**
 * A mathematical expression. Here, we only have INTs, but we'll add more
 * stuff after it's working.
 */
expression
	:	INT
	|	variable
	;

// Basic building blocks
fragment
LETTER
	:	'A'..'Z'
	|	'a'..'z'
	;

fragment
DIGIT
	:	'0'..'9'
	;

// Basic types - IDs, numbers, and strings
ID: (LETTER | '_') (LETTER | '_' | DIGIT)* ;

INT
	: DIGIT+
	;

/* Whitespace */
WS	: ( ' '
	  | '\n'
	  | '\r'
	  | '\t'
	  )
	  {channel = 99;}	// I wish it was something other than a "magic number"
	  ;

ASSIGN
	:	':='
	;

Here is the code for my main ( ) (again stripped down)

String filename = "test.slpc";
CharStream cs = new ANTLRFileStream (filename);
PseudocodeLexer lexer = new PseudocodeLexer (cs);
CommonTokenStream tokens = new CommonTokenStream ();
tokens.setTokenSource(lexer);
Pseudocode parser = new Pseudocode (tokens);
parser.assign();
System.out.println ("It parsed!");

This code runs and produces the desired result (printing "It
parsed!"). No errors are printed nor exceptions thrown.

However, when I run the command

% java -cp ${HOME}/classpath/antlr-2.7.6.jar:${HOME}/classpath/antlr_mine.jar:${HOME}/classpath/stringtemplate-2.3b9.jar
org.antlr.tool.Interp Pseudocode2.g WS assign ../test.slpc


I get the output

(<grammar Pseudocode> (assign (variable [@0,0:0='x',<5>,1:0])
[@2,2:3=':=',<4>,1:2] (expression
FailedPredicateException(expression,{synpred1}?))))


Any ideas why it's throwing an exception here, but not in the regular Java code?

Thanks!
~Brian DeVries

From kroepke at classdump.org  Sat Oct 14 05:52:06 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sat, 14 Oct 2006 14:52:06 +0200
Subject: [antlr-interest] Problems using the command-line grammar
	interpreter
In-Reply-To: <a3db01e90610140542u73ab9d9br14c6627da7c24a3c@mail.gmail.com>
References: <a3db01e90610140542u73ab9d9br14c6627da7c24a3c@mail.gmail.com>
Message-ID: <A6505286-B578-4747-8B06-F10C06EDB9C9@classdump.org>


On 14. Oct 2006, at 14:42 Uhr, Brian DeVries wrote:

> % java -cp ${HOME}/classpath/antlr-2.7.6.jar:${HOME}/classpath/ 
> antlr_mine.jar:${HOME}/classpath/stringtemplate-2.3b9.jar
> org.antlr.tool.Interp Pseudocode2.g WS assign ../test.slpc

Wouldn't you have to say
org.antlr.tool.Interp Pseudocode2.g 'WS ASSIGN' ../test.slpc
?

you cannot ignore parser rules, only tokens (assign vs. ASSIGN) and I  
think you have to supply the tokens to ignore in a string, thus the  
single quotes on the command line.

> I get the output
>
> (<grammar Pseudocode> (assign (variable [@0,0:0='x',<5>,1:0])
> [@2,2:3=':=',<4>,1:2] (expression
> FailedPredicateException(expression,{synpred1}?))))
>
>
> Any ideas why it's throwing an exception here, but not in the  
> regular Java code?

How does the input file look like?

HTH,

-k




From parrt at cs.usfca.edu  Sat Oct 14 08:45:09 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 14 Oct 2006 08:45:09 -0700
Subject: [antlr-interest] Header not copied to lexer file?
In-Reply-To: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
References: <a3db01e90610131938g1116a07amf02bc68b66f90f62@mail.gmail.com>
Message-ID: <FBE6268F-AB16-4F54-B6AD-E854E5A40063@cs.usfca.edu>


On Oct 13, 2006, at 7:38 PM, Brian DeVries wrote:

> In my 3.0b4 grammar file, I have the lines
>
> @header
> {
> 	package parsing;
> }
>
> The generated Java parsing file contains this line. However, the
> generated lexer grammar and Java files do not, resulting in a compiler
> error.
>
> What can I do to fix this, aside from manually entereing the header in
> the lexer file each time?

@lexer::header { package parsing; }

:)

Actions have scopes now.  @lexer::members {...} too.

Ter


From parrt at cs.usfca.edu  Sat Oct 14 08:48:04 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 14 Oct 2006 08:48:04 -0700
Subject: [antlr-interest] LL(*) proof
In-Reply-To: <200610141209.32483.ilia@obnovlenie.ru>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<200610140035.45976.ilia@obnovlenie.ru>
	<54F64356-17EB-4EC1-8B33-E001CBC9EBCB@cs.usfca.edu>
	<200610141209.32483.ilia@obnovlenie.ru>
Message-ID: <A7B4BB07-F10E-4CFB-B1AC-98FA8E152BF2@cs.usfca.edu>


On Oct 14, 2006, at 1:09 AM, Ilia Kantor wrote:

> ? ????????? ?? 14 ??????? 2006 00:56 Terence  
> Parr ???????(a):
>> On Oct 13, 2006, at 1:35 PM, Ilia Kantor wrote:
>>> I wrote a grammar for antlr v3. But I need to proff that it's
>>> 1) LL(*)
>>
>> ANTLR will tell you if it's LL(*).
>
> Could be nice to have a mathematical proof.. W
> hat's a definition of LL(*) ? How to prove that grammar is LL(*)  
> having its
> antlr notation ?

Yes, I hope to write a nice paper convincing you the algorithm is  
sound, but it will have to wait probably a year. :(

>>> 2) single program tree
>>
>> I'm not sure what you mean here.
>
> I have a grammar of (kindof) programming language.
> I guess, to make sure its correct, need to prove, that it  
> transforms a program
> into single, determined AST.

Well, it will always give you exactly one AST, but it would be hard  
to prove you get the one your brain intended.

Ter

From parrt at cs.usfca.edu  Sat Oct 14 08:51:52 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 14 Oct 2006 08:51:52 -0700
Subject: [antlr-interest] python target
In-Reply-To: <9c0715e40610140523u43c2c81bs458294dbe4c0ce9@mail.gmail.com>
References: <9c0715e40610140523u43c2c81bs458294dbe4c0ce9@mail.gmail.com>
Message-ID: <4056663E-C328-4EA8-8BDC-1937AF510B21@cs.usfca.edu>

Hi Clinton,

Well I think Marq Kole was waiting until v3 stabilizes a bit before  
moving forward.  Perhaps you too can work together on this.   
Wolfgang, are you interested too?

Ter

On Oct 14, 2006, at 5:23 AM, Clinton Roy wrote:

> Hey guys,
>
> I've been interested in using antlr for a work project, but was
> specifically interested in some of the benefits of version three.
>
> My language of choice is python so I've spent a little time working on
> a python v3 target, my work so far is available at
> http://azure.humbug.org.au:/~croy/antlr.tgz
>
> It's very much a work in progress, only the basic stuff is working
> (see TODO) but a generated parser does work on at least one simple
> example.
>
> I haven't had any success generating a parser without a specific k
> option, as far as I can tell analysis/DFA.java:edgeTransitionClassMap
> isn't being populated, is this a known bug or am I doing something
> wrong?
>
> I'd be quite happy to maintain this target in the long term.
>
> cheers,
>
> PS. I really hope I'm not standing on any toes here...
> -- 
> Clinton Roy
> www.acqao.org - ARC Centre of Excellence for Quantum-Atom Optics
> www.humbug.org.au  - Brisbane Unix Group
> azure.humbug.org.au/~croy/blog - Blog
> www.flickr.com/photos/croy/ - Photos


From kroepke at classdump.org  Sat Oct 14 10:37:18 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sat, 14 Oct 2006 19:37:18 +0200
Subject: [antlr-interest] Problems using the command-line grammar
	interpreter
In-Reply-To: <A6505286-B578-4747-8B06-F10C06EDB9C9@classdump.org>
References: <a3db01e90610140542u73ab9d9br14c6627da7c24a3c@mail.gmail.com>
	<A6505286-B578-4747-8B06-F10C06EDB9C9@classdump.org>
Message-ID: <7BA76A74-C61D-4974-BD08-7F49D7F52F80@classdump.org>


On 14. Oct 2006, at 14:52 Uhr, Kay Roepke wrote:

> Wouldn't you have to say
> org.antlr.tool.Interp Pseudocode2.g 'WS ASSIGN' ../test.slpc
> ?
>
> you cannot ignore parser rules, only tokens (assign vs. ASSIGN) and  
> I think you have to supply the tokens to ignore in a string, thus  
> the single quotes on the command line.

Nevermind. My mistake here.

It seems to be that auto-backtracking triggers some issues here. Ter  
might know better...without backtrack=true it works for me.

-k

-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From parrt at cs.usfca.edu  Sat Oct 14 11:02:13 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 14 Oct 2006 11:02:13 -0700
Subject: [antlr-interest] Problems using the command-line grammar
	interpreter
In-Reply-To: <7BA76A74-C61D-4974-BD08-7F49D7F52F80@classdump.org>
References: <a3db01e90610140542u73ab9d9br14c6627da7c24a3c@mail.gmail.com>
	<A6505286-B578-4747-8B06-F10C06EDB9C9@classdump.org>
	<7BA76A74-C61D-4974-BD08-7F49D7F52F80@classdump.org>
Message-ID: <1E4988E4-A973-4EEA-96C5-D2E099FF7EFA@cs.usfca.edu>

interpreter can't handle backtracking at the moment.
Ter
On Oct 14, 2006, at 10:37 AM, Kay Roepke wrote:

>
> On 14. Oct 2006, at 14:52 Uhr, Kay Roepke wrote:
>
>> Wouldn't you have to say
>> org.antlr.tool.Interp Pseudocode2.g 'WS ASSIGN' ../test.slpc
>> ?
>>
>> you cannot ignore parser rules, only tokens (assign vs. ASSIGN)  
>> and I think you have to supply the tokens to ignore in a string,  
>> thus the single quotes on the command line.
>
> Nevermind. My mistake here.
>
> It seems to be that auto-backtracking triggers some issues here.  
> Ter might know better...without backtrack=true it works for me.
>
> -k
>
> -- 
> Kay R?pke <kroepke at classdump.org>
> classdump Software
> Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0
>
>
>


From e.papegaaij at student.utwente.nl  Sun Oct 15 00:48:40 2006
From: e.papegaaij at student.utwente.nl (Emond Papegaaij)
Date: Sun, 15 Oct 2006 08:48:40 +0100
Subject: [antlr-interest] Lexing problem
In-Reply-To: <151D2B50-AB16-4831-8DC5-AB8C11889EA2@cs.usfca.edu>
References: <200610131734.05384.e.papegaaij@student.utwente.nl>
	<151D2B50-AB16-4831-8DC5-AB8C11889EA2@cs.usfca.edu>
Message-ID: <200610150948.40439.e.papegaaij@student.utwente.nl>

On Friday 13 October 2006 18:55, Terence Parr wrote:
> On Oct 13, 2006, at 8:34 AM, Emond Papegaaij wrote:
> > Hello,
> >
> > I'm trying to match a multiline c-style comment into a COMMENT token
> > without the opening and closing '/*' and '*/'. This is how I would
> > do it
> > in ANTLRv2:
> > COMMENT: '/*'! ( options {greedy=false;} : . )*  '*/'!;
> >
> > However the '!' does not work in v3. So I tried all of the following:
> >
> > COMMENT: '/*' contents=COMMENT_BODY '*/' { setText($contents.text); };
> > COMMENT_BODY: ( options {greedy=false;} : . )*;
>
> Make that rule a "fragment".
>
Doh, I did write it with 'fragment' in the ANTLR file, but not in the 
email :) The rule with 'fragment' gives me the following warning:
nl/utwente/ewi/tpl/grammar/TPLLogic.g:173:54: The following alternatives 
are unreachable: 1

Kay Roepke suggested to use the following:
COMMENT: '/*' ( options {greedy=false;} : . )* '*/'
          { setText(getText().substring(2, getText().length()-2)); }
         ;

Which I'm using now, but still I would like to know what is wrong with the 
other approaches.

Best regards,
Emond Papegaaij

From michael.gerz at teststep.org  Sun Oct 15 03:42:13 2006
From: michael.gerz at teststep.org (Michael Gerz)
Date: Sun, 15 Oct 2006 12:42:13 +0200
Subject: [antlr-interest] rulecatch
Message-ID: <45321085.2040902@teststep.org>

Terence,

where can I find more information on @rulecatch? The only page that 
mentions it is "Migrating from ANTLR 2 to ANTLR 3". Is it a grammar or a 
rule action?

IMHO the ANTLR 3 document should somehow reflect ANTLR3's grammar. 
Knowing the complete ANTLR feature set (the complete structure of 
grammars and its rules, a complete list of all available actions, etc.) 
is the first step to enlightment :-)

Michael



From parrt at cs.usfca.edu  Sun Oct 15 08:21:55 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 15 Oct 2006 08:21:55 -0700
Subject: [antlr-interest] rulecatch
In-Reply-To: <45321085.2040902@teststep.org>
References: <45321085.2040902@teststep.org>
Message-ID: <C61551F1-8D88-4EE3-ABE2-EE694F38563C@cs.usfca.edu>


On Oct 15, 2006, at 3:42 AM, Michael Gerz wrote:

> Terence,
>
> where can I find more information on @rulecatch? The only page that  
> mentions it is "Migrating from ANTLR 2 to ANTLR 3". Is it a grammar  
> or a rule action?

@rulecatch {...} is an action above your rules.  it replaces the  
entire catch clause of the rules' try/catch.

> IMHO the ANTLR 3 document should somehow reflect ANTLR3's grammar.  
> Knowing the complete ANTLR feature set (the complete structure of  
> grammars and its rules, a complete list of all available actions,  
> etc.) is the first step to enlightment :-)

Yep, that would be nice...i'm doing the best I can with school, bug  
fixing, and working on the book.  I need to copy some of the basic  
details from the book to the online free doc...

Ter

From rob.hill at blueyonder.co.uk  Sun Oct 15 14:42:12 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Sun, 15 Oct 2006 22:42:12 +0100
Subject: [antlr-interest] can tree grammers have an output of AST?
Message-ID: <20061015214215.11BB71907AD@www.antlr.org>

Can you create a tree grammar that has an output of AST in v3.0b4?

The tree grammar I have compiles fine when I have output=template
But when I change to output = AST, I get errors like the following.


D:\ActiveProjects\IdeaProjects\Jtest1\src\SemanticCheck.java (178:39)cannot
find symbol
D:\ActiveProjects\IdeaProjects\Jtest1\src\SemanticCheck.java:178: cannot
find symbol
symbol  : method create(org.antlr.runtime.tree.Tree)
location: interface org.antlr.runtime.tree.TreeAdaptor
                adaptor.setTokenBoundaries(retval.tree, retval.start,
retval.stop);


ok, I gather that it cant find the create method, but If I edit the java
output, and type a '.' after the name the intellisense pops up (im using
intelliJ) and the create method is present.

Is this another class path issue? Or am I missing another directive that's
buried somewhere in the wiki??

Any ideas anyone?!

Cheers!

Rob




From dave.fet at gmail.com  Sun Oct 15 16:05:25 2006
From: dave.fet at gmail.com (davood khoshfetrat)
Date: Mon, 16 Oct 2006 02:35:25 +0330
Subject: [antlr-interest] How to generate code from AST.
Message-ID: <9e2360c40610151605m2cd69d30i93e8928cc967023e@mail.gmail.com>

Hi every body.

I've created my grammer and it works perfectly. Now I have AST. My
problem is that I have to generate code to 3 different languages and
they are complex. Meaning iterating throgh the AST won't cut it. I'm
looking for some kind of algorithm or framework. some thing flexible.
If you have any clue please guide me.

Looking forward to hear from you.
Thanks.

From lgcraymer at yahoo.com  Sun Oct 15 20:57:09 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sun, 15 Oct 2006 20:57:09 -0700 (PDT)
Subject: [antlr-interest] can tree grammers have an output of AST?
In-Reply-To: <20061015214215.11BB71907AD@www.antlr.org>
Message-ID: <20061016035709.42705.qmail@web55915.mail.re3.yahoo.com>

Rob--

Check out ANTLR Yggdrasil.  There is a zip in the
"file sharing" area of antlr.org; I am in the process
of setting up the antlr-yggdrasil project on
sourceforge.

Ter's latest statement on translation philosophy is
that trees are built during parsing and then walked
one or more times without transformation (that started
the latest thread on translation approaches, after
all).  ANTLR 3 was not designed to do complex
multi-pass transformations, nor was it designed _not_
to support such transformations, for that matter. 
However, features usually don't "just happen" in
software, but instead are the result of explicit
design or redesign efforts.

Yggdrasil is a work in progress--it does not
automatically generate tree grammars yet, for
example--but it will support complex multi-pass
transformation in its current form.

--Loring

--- Robert Hill <rob.hill at blueyonder.co.uk> wrote:

> Can you create a tree grammar that has an output of
> AST in v3.0b4?
> 
> The tree grammar I have compiles fine when I have
> output=template
> But when I change to output = AST, I get errors like
> the following.
> 
> 
>
D:\ActiveProjects\IdeaProjects\Jtest1\src\SemanticCheck.java
> (178:39)cannot
> find symbol
>
D:\ActiveProjects\IdeaProjects\Jtest1\src\SemanticCheck.java:178:
> cannot
> find symbol
> symbol  : method create(org.antlr.runtime.tree.Tree)
> location: interface
> org.antlr.runtime.tree.TreeAdaptor
>                
> adaptor.setTokenBoundaries(retval.tree,
> retval.start,
> retval.stop);
> 
> 
> ok, I gather that it cant find the create method,
> but If I edit the java
> output, and type a '.' after the name the
> intellisense pops up (im using
> intelliJ) and the create method is present.
> 
> Is this another class path issue? Or am I missing
> another directive that's
> buried somewhere in the wiki??
> 
> Any ideas anyone?!
> 
> Cheers!
> 
> Rob
> 
> 
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From parrt at cs.usfca.edu  Sun Oct 15 22:09:19 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 15 Oct 2006 22:09:19 -0700
Subject: [antlr-interest] How to generate code from AST.
In-Reply-To: <9e2360c40610151605m2cd69d30i93e8928cc967023e@mail.gmail.com>
References: <9e2360c40610151605m2cd69d30i93e8928cc967023e@mail.gmail.com>
Message-ID: <18377B7A-D1ED-4836-A4E0-8D1B66C7EF04@cs.usfca.edu>

Hi Davood.  Have you looked at my articles like:

http://www.codegeneration.net/tiki-read_article.php?articleId=77

That gives some idea of how ANTLR v3 works with so many different  
targets.  Just one code generator, multiple template backends.  works  
great. :)

Ter
On Oct 15, 2006, at 4:05 PM, davood khoshfetrat wrote:

> Hi every body.
>
> I've created my grammer and it works perfectly. Now I have AST. My
> problem is that I have to generate code to 3 different languages and
> they are complex. Meaning iterating throgh the AST won't cut it. I'm
> looking for some kind of algorithm or framework. some thing flexible.
> If you have any clue please guide me.
>
> Looking forward to hear from you.
> Thanks.


From rhill03 at eds.com  Sun Oct 15 23:30:44 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Mon, 16 Oct 2006 07:30:44 +0100
Subject: [antlr-interest] can tree grammers have an output of AST?
In-Reply-To: <20061016035709.42705.qmail@web55915.mail.re3.yahoo.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD40276EB4B@UKNSM201.emea.corp.eds.com>

Thanks for that Loring :)
I'd checked out Yggdrasil a while back when you first posted the release
notice :)
Looks pretty cool I must say!

>Ter's latest statement on translation philosophy is that trees 
>are built during parsing and then walked one or more times 
>without transformation (that started the latest thread on 
>translation approaches, after all).  

Hmm, I was (trying) to follow the thread , I must have missed that bit
:(
All I wanted to do was make successive passes only deal with the rules
that are
Relevent at that pass, so for instance if I optimise away unused
paramters, I wouldn't have to deal with them on the next pass, instead
of simply setUnused(true).. And checking it everywhere :( Its just a
source code thing , in that if you modify your parser, you have to
cascade that rule change/addition down through all the tree parsers too
:( in fact, I think the first post I made about this is what kicked off
the whole translation philosophy argument in the first place!
Oh well, I'll go with what I have then! 


>ANTLR 3 was not designed 
>to do complex multi-pass transformations, nor was it designed 
>_not_ to support such transformations, for that matter. 
>However, features usually don't "just happen" in software, but 
>instead are the result of explicit design or redesign efforts.

My misunderstanding, I just assumed that you could output either another
AST or a template from the treeparser. Just seemed natural to me, I
guess I was jumping the gun a bit ;)



>Yggdrasil is a work in progress--it does not automatically 
>generate tree grammars yet, for example--but it will support 
>complex multi-pass transformation in its current form.

I will have to look at this in more detail, although I've got everything
invested in V3.0 at the moment, so my time to check it out in detail
will be limited.

Cheers,
Rob

From stepan.samarin at gmail.com  Mon Oct 16 06:12:52 2006
From: stepan.samarin at gmail.com (Stepan Samarin)
Date: Mon, 16 Oct 2006 15:12:52 +0200
Subject: [antlr-interest] Modified SQL grammar
Message-ID: <7c542a710610160612s412f8070k5b32b5b06e5b877e@mail.gmail.com>

Hi,

I'm trying to parse a general where-clause, using Oracle 7 SQL grammar
I took from antlr.org. I modified it a bit and now am stuck with the
following:

TYPE BETWEEN 'OFFICE' AND 'FURNITURE'

line 1:1: unexpected token: TYPE

==> Dump of AST <==
where_condition [7]
   AND [88]
   sql_literal [10]
      'FURNITURE' [33]
nil [1]

Actual grammar is in the attachment, but I think the following is not
properly evaluated:
( exp_simple ( "not" )? "between" ) => exp_simple ( "not" )? "between"
exp_simple "and" exp_simple

Help would be really appreciated.

Cheers, Stepan.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: sql-where-clause.g
Type: application/octet-stream
Size: 11356 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061016/076d5eeb/attachment-0001.obj 

From dave.fet at gmail.com  Mon Oct 16 07:06:39 2006
From: dave.fet at gmail.com (davood khoshfetrat)
Date: Mon, 16 Oct 2006 17:36:39 +0330
Subject: [antlr-interest] How to generate code from AST.
In-Reply-To: <18377B7A-D1ED-4836-A4E0-8D1B66C7EF04@cs.usfca.edu>
References: <9e2360c40610151605m2cd69d30i93e8928cc967023e@mail.gmail.com>
	<18377B7A-D1ED-4836-A4E0-8D1B66C7EF04@cs.usfca.edu>
Message-ID: <9e2360c40610160706t175421d4s523a36ad0dccc0f2@mail.gmail.com>

Hi Terence and thanks for your message.

Yes I've already read about it but As I already said I have some
special needs. My language is some thing like GWT but with very
different concept. I have needs like determining type of an object to
specify create result in which languages. I have found some details
about OCL (Object Constraint Language) and it's featues, This tool has
some interesting features for analizing AST. I think I need something
to analyze the tree. String templates looks like interesting but I
think it will not work for me. In fact I wonder which technique is
used in other scripting languages like gwt,jython,jruby,..

Can you give me a clue?
Looking forward to hear from you.
Thanks.

On 10/16/06, Terence Parr <parrt at cs.usfca.edu> wrote:
> Hi Davood.  Have you looked at my articles like:
>
> http://www.codegeneration.net/tiki-read_article.php?articleId=77
>
> That gives some idea of how ANTLR v3 works with so many different
> targets.  Just one code generator, multiple template backends.  works
> great. :)
>
> Ter
> On Oct 15, 2006, at 4:05 PM, davood khoshfetrat wrote:
>
> > Hi every body.
> >
> > I've created my grammer and it works perfectly. Now I have AST. My
> > problem is that I have to generate code to 3 different languages and
> > they are complex. Meaning iterating throgh the AST won't cut it. I'm
> > looking for some kind of algorithm or framework. some thing flexible.
> > If you have any clue please guide me.
> >
> > Looking forward to hear from you.
> > Thanks.
>
>

From r_balaji82 at yahoo.com  Mon Oct 16 08:32:47 2006
From: r_balaji82 at yahoo.com (Balaji Ramasubbu)
Date: Mon, 16 Oct 2006 08:32:47 -0700 (PDT)
Subject: [antlr-interest] (no subject)
Message-ID: <20061016153247.49549.qmail@web57714.mail.re3.yahoo.com>

Hi Terence and All,
              I'm using antlr tool version 2.6.0. Antlr does not recognise gcc grammar for gcc3.4. Could you please help  to solve the problem. I'm getting the following error 

Error: line(1), unexpected token: __gnuc_va_list
Error: line(1), unexpected token: extern
Error: line(1), unexpected token: int
Error: line(1), unexpected token: __gnuc_va_list
Error: line(1), unexpected token: *
Error: line(1), expecting SEMI, found '__const'
Error: line(1), unexpected token: char
Error: line(1), unexpected token: )
Error: line(1), unexpected token: extern
Error: line(1), unexpected token: void
Error: line(1), unexpected token: FILE
Error: line(1), expecting SEMI, found 'int'
Thanks,
Balaji

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061016/03a24bf9/attachment.html 

From parrt at cs.usfca.edu  Mon Oct 16 10:13:30 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 16 Oct 2006 10:13:30 -0700
Subject: [antlr-interest] can tree grammers have an output of AST?
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD40276EB4B@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD40276EB4B@UKNSM201.emea.corp.eds.com>
Message-ID: <A3B4A0A7-54E9-4934-A134-C732C775D3B9@cs.usfca.edu>


On Oct 15, 2006, at 11:30 PM, Hill, Robert wrote:
>> Ter's latest statement on translation philosophy is that trees
>> are built during parsing and then walked one or more times
>> without transformation (that started the latest thread on
>> translation approaches, after all).
>
> Hmm, I was (trying) to follow the thread , I must have missed that bit
> :(

Tree transformation is great if you are going from language L to L. I  
think that managing Union tree grammars when moving from L to L' is  
too much of a hassle.  But, that is just my opinion.

> All I wanted to do was make successive passes only deal with the rules
> that are
> Relevent at that pass, so for instance if I optimise away unused
> paramters, I wouldn't have to deal with them on the next pass, instead
> of simply setUnused(true)..

   An appropriate transformation.

>> ANTLR 3 was not designed
>> to do complex multi-pass transformations, nor was it designed
>> _not_ to support such transformations, for that matter.
>> However, features usually don't "just happen" in software, but
>> instead are the result of explicit design or redesign efforts.
>
> My misunderstanding, I just assumed that you could output either  
> another
> AST or a template from the treeparser. Just seemed natural to me, I
> guess I was jumping the gun a bit ;)

   Yes, it is my intention that you can output trees.  I had to cut  
that out of the first release so I could do a feature freeze and  
focus on bugs.  You will note that the wiki has:

http://www.antlr.org/wiki/display/ANTLR3/support+output%3DAST+in+tree 
+grammars

  from July 27.

Ter

From parrt at cs.usfca.edu  Mon Oct 16 10:14:40 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 16 Oct 2006 10:14:40 -0700
Subject: [antlr-interest] (no subject)
In-Reply-To: <20061016153247.49549.qmail@web57714.mail.re3.yahoo.com>
References: <20061016153247.49549.qmail@web57714.mail.re3.yahoo.com>
Message-ID: <B9894EC4-3E0B-4D96-B7A7-3E9E314CA09E@cs.usfca.edu>

Upgrade to 2.7.6.
Ter
On Oct 16, 2006, at 8:32 AM, Balaji Ramasubbu wrote:

> Hi Terence and All,
>               I'm using antlr tool version 2.6.0. Antlr does not  
> recognise gcc grammar for gcc3.4. Could you please help  to solve  
> the problem. I'm getting the following error
> Error: line(1), unexpected token: __gnuc_va_list
> Error: line(1), unexpected token: extern
> Error: line(1), unexpected token: int
> Error: line(1), unexpected token: __gnuc_va_list
> Error: line(1), unexpected token: *
> Error: line(1), expecting SEMI, found '__const'
> Error: line(1), unexpected token: char
> Error: line(1), unexpected token: )
> Error: line(1), unexpected token: extern
> Error: line(1), unexpected token: void
> Error: line(1), unexpected token: FILE
> Error: line(1), expecting SEMI, found 'int'
> Thanks,
> Balaji
>
>


From parrt at cs.usfca.edu  Mon Oct 16 15:07:57 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 16 Oct 2006 15:07:57 -0700
Subject: [antlr-interest] use channel=HIDDEN now
Message-ID: <9B6302B8-BBF7-423F-9EDF-A97D7D3F971C@cs.usfca.edu>

not channel=99 (well if you grab latest build from the repo. browser).

I added HIDDEN so we can say channel=HIDDEN in lexer actions.

edit //depot/code/antlr/main/src/org/antlr/runtime/ 
BaseRecognizer.java#18
edit //depot/code/antlr/main/src/org/antlr/runtime/Token.java#20
Change 3114 submitted.

Ter

From rob.hill at blueyonder.co.uk  Mon Oct 16 15:47:29 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Mon, 16 Oct 2006 23:47:29 +0100
Subject: [antlr-interest] best method of outputting multiple templates from
	AST?
Message-ID: <20061016224731.DF78F1909F6@www.antlr.org>

	
If have a fair few rules which must output bits of code in more than one
place in the final output file, whats the best way to do this?
Eg, say im generating a kind of loop and I need to add a variable to the
start of a function method but need to generate the code further down in the
body.
I guess what I'd like would be something like the following.

Rule
:	^(blah1 blah2)
-> template1(id={blah}) , template2(pos={blah2)

Also I'd like to accumulate a bunch of these templates In a single block
somewhere to keep them together, nomatter where I come across them in my
language, do I just declare a single template in java code as a parser
member and fill it in from all the rules?

I just struggling a bit with the whole chaining up the templates to make one
big output string at the root rule..

Any pointers would be much appreciated.

Cheers!

Rob






From parrt at cs.usfca.edu  Mon Oct 16 17:35:10 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 16 Oct 2006 17:35:10 -0700
Subject: [antlr-interest] best method of outputting multiple templates
	from AST?
In-Reply-To: <20061016224731.DF78F1909F6@www.antlr.org>
References: <20061016224731.DF78F1909F6@www.antlr.org>
Message-ID: <C9C35B07-E18E-4A7A-BBC9-B0638322BE6A@cs.usfca.edu>


On Oct 16, 2006, at 3:47 PM, Robert Hill wrote:

> 	
> If have a fair few rules which must output bits of code in more  
> than one
> place in the final output file, whats the best way to do this?
> Eg, say im generating a kind of loop and I need to add a variable  
> to the
> start of a function method but need to generate the code further  
> down in the
> body.

Hi Rob,

I keep a ptr around to the template for the function and then when I  
see a loop that needs a var I do

functionST.setAttribute("implicitlyDefinedVarList", "foo");

to add "foo" as a var for which I need a define.  That could also be  
a template not just a string.

> I guess what I'd like would be something like the following.
>
> Rule
> :	^(blah1 blah2)
> -> template1(id={blah}) , template2(pos={blah2)

Think of reaching up and sticking the local var def where it belongs  
instead of having to return multiple things.

>
> Also I'd like to accumulate a bunch of these templates In a single  
> block
> somewhere to keep them together, nomatter where I come across them  
> in my
> language, do I just declare a single template in java code as a parser
> member and fill it in from all the rules?

Yep.  Imagine you want to track class refs so you can add imports.   
The import "hole" is at the top of the output file but you can fill  
from anywhere.  This is the key thing that decouples the order of  
tree traversal with order of output.

Ter

From lgcraymer at yahoo.com  Mon Oct 16 21:59:54 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Mon, 16 Oct 2006 21:59:54 -0700 (PDT)
Subject: [antlr-interest] How to generate code from AST.
In-Reply-To: <9e2360c40610160706t175421d4s523a36ad0dccc0f2@mail.gmail.com>
Message-ID: <20061017045954.44700.qmail@web55902.mail.re3.yahoo.com>

Davood--

It sounds like you are tackling a hard problem.  A
good place to start is to do a search on "type
inference".  This is an active area of research, and
maybe some of the published algorithms can help.

--Loring

--- davood khoshfetrat <dave.fet at gmail.com> wrote:

> Hi Terence and thanks for your message.
> 
> Yes I've already read about it but As I already said
> I have some
> special needs. My language is some thing like GWT
> but with very
> different concept. I have needs like determining
> type of an object to
> specify create result in which languages. I have
> found some details
> about OCL (Object Constraint Language) and it's
> featues, This tool has
> some interesting features for analizing AST. I think
> I need something
> to analyze the tree. String templates looks like
> interesting but I
> think it will not work for me. In fact I wonder
> which technique is
> used in other scripting languages like
> gwt,jython,jruby,..
> 
> Can you give me a clue?
> Looking forward to hear from you.
> Thanks.
> 
> On 10/16/06, Terence Parr <parrt at cs.usfca.edu>
> wrote:
> > Hi Davood.  Have you looked at my articles like:
> >
> >
>
http://www.codegeneration.net/tiki-read_article.php?articleId=77
> >
> > That gives some idea of how ANTLR v3 works with so
> many different
> > targets.  Just one code generator, multiple
> template backends.  works
> > great. :)
> >
> > Ter
> > On Oct 15, 2006, at 4:05 PM, davood khoshfetrat
> wrote:
> >
> > > Hi every body.
> > >
> > > I've created my grammer and it works perfectly.
> Now I have AST. My
> > > problem is that I have to generate code to 3
> different languages and
> > > they are complex. Meaning iterating throgh the
> AST won't cut it. I'm
> > > looking for some kind of algorithm or framework.
> some thing flexible.
> > > If you have any clue please guide me.
> > >
> > > Looking forward to hear from you.
> > > Thanks.
> >
> >
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From rhill03 at eds.com  Mon Oct 16 23:27:46 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Tue, 17 Oct 2006 07:27:46 +0100
Subject: [antlr-interest] best method of outputting multiple
	templatesfrom AST?
In-Reply-To: <C9C35B07-E18E-4A7A-BBC9-B0638322BE6A@cs.usfca.edu>
Message-ID: <2E909902FD3A03419E3A905908AE3DD40276EE8C@UKNSM201.emea.corp.eds.com>

Thanks Ter!
	I'd ended up settling on that because after another hour of
reflecting about neater ways came to the conclusion that it was the only
choice, and it doesn't actually make much sense to try to return chunks
of code/templates from rules when they're not going to be in the order
the token came in. You hit the nail on the head - "decoupling the output
from the order of tree traversal", pretty much what I ended up with :) I
thought I may have been missing something, or some syntax (other than
returns [String Template blah]) on the rules to allow this. I was
thinking , just how much of the stuff I've done that isn't on the wiki
anywhere.... can I pre-order your book? LOL! 
And I've lost count of the number of times I've typed in 
myArraylist.size	instead of .size() <sigh> I miss those c#
properties! :(

Ok :) sweet, im back in business!

Ta very much!

Rob

--
Rob Hill
EDS - Hallamshire Business Park
F1E/045
Sheffield	
T:	+44 (0) 114 291 1928
M:	+44 (0) 791 732 1227
E:	rhill03 at eds.com

 

>-----Original Message-----
>From: antlr-interest-bounces at antlr.org 
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Terence Parr
>Sent: 17 October 2006 01:35
>To: ANTLR Interest
>Subject: Re: [antlr-interest] best method of outputting 
>multiple templatesfrom AST?
>
>
>On Oct 16, 2006, at 3:47 PM, Robert Hill wrote:
>
>> 	
>> If have a fair few rules which must output bits of code in more than 
>> one place in the final output file, whats the best way to do this?
>> Eg, say im generating a kind of loop and I need to add a variable to 
>> the start of a function method but need to generate the code further 
>> down in the body.
>
>Hi Rob,
>
>I keep a ptr around to the template for the function and then 
>when I see a loop that needs a var I do
>
>functionST.setAttribute("implicitlyDefinedVarList", "foo");
>
>to add "foo" as a var for which I need a define.  That could 
>also be a template not just a string.
>
>> I guess what I'd like would be something like the following.
>>
>> Rule
>> :	^(blah1 blah2)
>> -> template1(id={blah}) , template2(pos={blah2)
>
>Think of reaching up and sticking the local var def where it 
>belongs instead of having to return multiple things.
>
>>
>> Also I'd like to accumulate a bunch of these templates In a single  
>> block
>> somewhere to keep them together, nomatter where I come across them  
>> in my
>> language, do I just declare a single template in java code 
>as a parser
>> member and fill it in from all the rules?
>
>Yep.  Imagine you want to track class refs so you can add imports.   
>The import "hole" is at the top of the output file but you can fill  
>from anywhere.  This is the key thing that decouples the order of  
>tree traversal with order of output.
>
>Ter
>

From Michiel_Vermandel at axi.be  Mon Oct 16 23:48:45 2006
From: Michiel_Vermandel at axi.be (Michiel Vermandel)
Date: Tue, 17 Oct 2006 08:48:45 +0200
Subject: [antlr-interest] use channel=HIDDEN now
In-Reply-To: <9B6302B8-BBF7-423F-9EDF-A97D7D3F971C@cs.usfca.edu>
Message-ID: <OFC7AF4109.2159A13C-ONC125720A.0025484D-C125720A.00256C55@Axi.be>

(how) can I get an AST that contains all nodes on any channel (so also the 
nodes on the hidden channel)?

thanks!





Terence Parr <parrt at cs.usfca.edu> 
Sent by: antlr-interest-bounces at antlr.org
17/10/2006 00:07

To
ANTLR-dev list <antlr-dev at antlr.org>
cc
ANTLR Interest <antlr-interest at antlr.org>
Subject
[antlr-interest] use channel=HIDDEN now






not channel=99 (well if you grab latest build from the repo. browser).

I added HIDDEN so we can say channel=HIDDEN in lexer actions.

edit //depot/code/antlr/main/src/org/antlr/runtime/ 
BaseRecognizer.java#18
edit //depot/code/antlr/main/src/org/antlr/runtime/Token.java#20
Change 3114 submitted.

Ter

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/85c6886c/attachment.html 

From kroepke at classdump.org  Tue Oct 17 03:39:50 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Tue, 17 Oct 2006 12:39:50 +0200
Subject: [antlr-interest] use channel=HIDDEN now
In-Reply-To: <OFC7AF4109.2159A13C-ONC125720A.0025484D-C125720A.00256C55@Axi.be>
References: <OFC7AF4109.2159A13C-ONC125720A.0025484D-C125720A.00256C55@Axi.be>
Message-ID: <3E033907-A37F-4F82-90B0-3D8FB95475CF@classdump.org>

Hi Michiel!

On Oct 17, 2006, at 8:48 AM, Michiel Vermandel wrote:

> (how) can I get an AST that contains all nodes on any channel (so  
> also the
> nodes on the hidden channel)?

There are two ways to achieve that.

1) CommonTokenStream has a channelOverrideMap. It maps tokenTypes to  
channel numbers. E.g.:

Say you have whitespace tokens (type WS) on channel=HIDDEN (99 in the  
current implementation).
If you do

	CommonTokenStream tokenStream = new CommonTokenStream(lexer);
	tokenStream.channelOverrideMap.put(new Integer(YourLexerClass.WS),  
new Integer(Token.DEFAULT_CHANNEL));

anything that reads from this tokenStream will receive WS tokens on  
the default channel even though they
really are on channel HIDDEN. The tokens themselves are not altered.

2) in a subclass of CommonTokenStream override skipOffTokenChannels 
(int) and skipOffTokenChannelsReverse(int) to always return
their argument. They return the next (or previous) index on the token  
stream that contains a token to be considered.
This is more of a hack, of course, but this way you don't have to  
manually specify every single tokentype in the channelOverrideMap.

Be sure to do either one before you actually use that tokenStream.  
There is no way to "reset" the stream making it read the tokens again.
Once they are buffered up, changes to channelOverrideMap aren't going  
to effect anything.
You could of course write you own TokenStream subclass that does it  
differently. In cases you might not even want to buffer up the stream  
beforehand, as it is done now (I know someone asked this a couple of  
weeks ago...can't remember who it was).

HTH,

-k





From allan.odgaard at gmail.com  Tue Oct 17 03:50:59 2006
From: allan.odgaard at gmail.com (Allan Odgaard)
Date: Tue, 17 Oct 2006 12:50:59 +0200
Subject: [antlr-interest] Nondeterminism problem
Message-ID: <25bceb150610170350g21be775ehbd1bf743a113f95d@mail.gmail.com>

Hi there,

I have this lexer:

    class format_lexer extends Lexer;
    options {
       k = 2;
       charVocabulary = '\u0001'..'\u00FF';
    }

    MARK:             'A' 'B';

    protected
    ESCAPED:          '\\' '\u0001'..'\u00FF';

    protected
    OTHER:            ~('A'|'\\');

    protected
    NOT_MARK:         'A' ~('B');

    ALL:              ESCAPED | OTHER | NOT_MARK;


When I run it through ANTLR I get this warning:

    warning:lexical nondeterminism between rules MARK and ALL upon
       k==1:'A'
       k==2:'B'

I don't really understand the problem here, so I'd hoped someone could help
me.

If I inspect the code generated for ALL then it looks like this:

    (LA(1) >= '\u0001' && LA(1) <= '\u00ff') && true

I can see how that match is ambiguous with the one for MARK:

    LA(1) == 'A' && LA(2) == 'B'

What surprises me is that ANTLR generates such broad match for ALL. It seems
it takes the union of all the LA(1) matches for the branches, then &&s that
with the union of all the LA(2)'s. Thus actually matching broader than what
the branches would handle.

Is this understanding correct? Is there a simple workaround for the above
lexer, or would it need to be resolved in the parser?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/9a9cb5d9/attachment-0001.html 

From kroepke at classdump.org  Tue Oct 17 03:56:20 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Tue, 17 Oct 2006 12:56:20 +0200
Subject: [antlr-interest] use channel=HIDDEN now
In-Reply-To: <3E033907-A37F-4F82-90B0-3D8FB95475CF@classdump.org>
References: <OFC7AF4109.2159A13C-ONC125720A.0025484D-C125720A.00256C55@Axi.be>
	<3E033907-A37F-4F82-90B0-3D8FB95475CF@classdump.org>
Message-ID: <06508138-E075-4CD8-BEC3-B96F0D97CB1F@classdump.org>

Ohh, afterthoughts, as soon as you send a mail ideas rush to your  
brain...

On Oct 17, 2006, at 12:39 PM, Kay Roepke wrote:

> 	tokenStream.channelOverrideMap.put(new Integer(YourLexerClass.WS),  
> new Integer(Token.DEFAULT_CHANNEL));

Fix: This must be:
	tokenStream.setTokenTypeChannel(YourLexerClass.WS,  
Token.DEFAULT_CHANNEL);
otherwise the channelOverrideMap will not be created. Doh!


> This is more of a hack, of course, but this way you don't have to  
> manually specify every single tokentype in the channelOverrideMap.

Clarification: This should read: "[...] manually specify every single  
tokentype not on the default channel in the channelOverrideMap."

Enhancement idea:
It might be useful to add a method to CommonTokenStream to make it  
override whole channels, not only based on tokentypes. With this you  
could say
	CommonTokenStream tokenStream = new CommonTokenStream(lexer);
	tokenStream.setChannelRedirection(Token.HIDDEN_CHANNEL,  
Token.DEFAULT_CHANNEL);

Maybe this rather should go into TokenRewriteStream, not sure.

-k, who has a rather severe lack of coffee today.




From kroepke at classdump.org  Tue Oct 17 04:18:10 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Tue, 17 Oct 2006 13:18:10 +0200
Subject: [antlr-interest] Nondeterminism problem
In-Reply-To: <25bceb150610170350g21be775ehbd1bf743a113f95d@mail.gmail.com>
References: <25bceb150610170350g21be775ehbd1bf743a113f95d@mail.gmail.com>
Message-ID: <BDBB153C-56F5-4DBC-A2A4-B2A92EEAB255@classdump.org>

Hi Allan,


On Oct 17, 2006, at 12:50 PM, Allan Odgaard wrote:

> When I run it through ANTLR I get this warning:
>
>    warning:lexical nondeterminism between rules MARK and ALL upon
>       k==1:'A'
>       k==2:'B'
>
> I don't really understand the problem here, so I'd hoped someone  
> could help
> me.
>
> If I inspect the code generated for ALL then it looks like this:
>
>    (LA(1) >= '\u0001' && LA(1) <= '\u00ff') && true
>
> I can see how that match is ambiguous with the one for MARK:
>
>    LA(1) == 'A' && LA(2) == 'B'
>
> What surprises me is that ANTLR generates such broad match for ALL.  
> It seems
> it takes the union of all the LA(1) matches for the branches, then  
> &&s that
> with the union of all the LA(2)'s. Thus actually matching broader  
> than what
> the branches would handle.

Yes, it is called linear approximate lookahead. You've hit the issue  
with it, where it collapses the FIRST sets to make it linear instead
of exponential.
See <http://www.antlr.org/doc/ 
glossary.html#Linear_approximate_lookahead> and <http:// 
seclib.blogspot.com/2005/11/linear-approximate-lookahead.html>
for an explanation.

> Is this understanding correct? Is there a simple workaround for the  
> above
> lexer, or would it need to be resolved in the parser?

You might have to reorganize your grammar and maybe set the correct  
token types manually in actions.
You'll be pleased to hear that ANTLR v3 doesn't do linear approximate  
lookahead anymore and will generate the correct LL(2) code for this.

         int LA2_0 = input.LA(1);
         if ( (LA2_0=='A') ) {
             int LA2_1 = input.LA(2);
             if ( (LA2_1=='B') ) {
                 alt2=1;
             }
             else if ( ((LA2_1>='\u0000' && LA2_1<='A')||(LA2_1>='C'  
&& LA2_1<='\uFFFE')) ) {
                 alt2=2;
             }

You might also like to hear that ANTLR v3 sports an Objective-C  
target (hint, hint...;))

HTH,

-k

-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From parrt at cs.usfca.edu  Tue Oct 17 10:18:40 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 17 Oct 2006 10:18:40 -0700
Subject: [antlr-interest] best method of outputting multiple
	templatesfrom AST?
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD40276EE8C@UKNSM201.emea.corp.eds.com>
References: <2E909902FD3A03419E3A905908AE3DD40276EE8C@UKNSM201.emea.corp.eds.com>
Message-ID: <8B6B5791-7B77-4F09-B590-1EB0AA2EF4EC@cs.usfca.edu>


On Oct 16, 2006, at 11:27 PM, Hill, Robert wrote:

> Thanks Ter!
> 	I'd ended up settling on that because after another hour of
> reflecting about neater ways came to the conclusion that it was the  
> only
> choice, and it doesn't actually make much sense to try to return  
> chunks
> of code/templates from rules when they're not going to be in the order
> the token came in. You hit the nail on the head - "decoupling the  
> output
> from the order of tree traversal",

Yep, I consider that a *fundamental* idea for translation (even Andy  
would agree as he doesn't traverse the trees at all).

> pretty much what I ended up with :) I
> thought I may have been missing something, or some syntax (other than
> returns [String Template blah]) on the rules to allow this. I was
> thinking , just how much of the stuff I've done that isn't on the wiki
> anywhere....

Then you should be putting it up there! ;)

> can I pre-order your book? LOL!

Not yet...perhaps Jan/Feb for a beta book.

> And I've lost count of the number of times I've typed in
> myArraylist.size	instead of .size() <sigh> I miss those c#
> properties! :(
>
> Ok :) sweet, im back in business!
>
> Ta very much!

:)

Ter

From mantu_lists at yahoo.com.br  Tue Oct 17 12:04:58 2006
From: mantu_lists at yahoo.com.br (luciano mantuaneli)
Date: Tue, 17 Oct 2006 19:04:58 +0000 (GMT)
Subject: [antlr-interest] Code translation: Is it possible to bring the
	TreeParser back?
Message-ID: <20061017190458.85224.qmail@web39514.mail.mud.yahoo.com>

Greetings!
I'm developing a Java2C# parser, and I'm having some trouble trying to translate constructors that call the supar class constructor.... In Java, we make that thing like this:

class MyClass extends MyOtherClass{
   public MyClass(Object param){
      super(param);
      /*...*/
   }
}

The corresponding C# code would be like this:

class MyClass: MyOtherClass{
   public MyClass(Object param): base(param){
     /*...*/
   }
}


The tree grammar I using to translate the code from Java to C# have the folowing rules to treat the constructor definition and invocation:

ctorDef :
    CTOR_DEF modifiers 
    ( typeParameters )? 
    methodHead 
    ( slist )? 
    ;

slist :
    SLIST 
    ( stat )* 
    ;

stat :
    typeDefinition 
    | variableDef 
    | expression 
    | //... 
    ;

expression :
    EXPR expr 
    ;

expr :
    conditionalExpr 
    | //...
    ;

conditionalExpr :
    //...
    | primaryExpression 
    ;

primaryExpression :
    //...
    | ctorCall 
    | //...
    ;

ctorCall :
    CTOR_CALL elist 
    | SUPER_CTOR_CALL 
    ( elist | primaryExpression elist ) 
    ;

elist :
    ELIST 
    ( expression )* 
    ;

Well, in C#, the super-constructor invocation is made before the statement list. In Java, that invocations, when exists, is the first statement in the statement list.
My question is: looking to the ctorDef rule, how can I know if the super-constructor was invoked before enter the slist rule?
I need it that way because I'm constructing the translation text like this:

ctorDef{
    MethodHead mh;
    ArrayList<String> mods = new ArrayList<String>();
}
    :    #(ctor:CTOR_DEF 
            mods=modifiers 
            (typeParameters)? 
            mh=methodHead {
                GSB.tab();
                for(String mod: mods)
                    GSB.app(mod + " ");
                GSB.app(mh);
                //if invokes super constructor then GSB.app(":base(" + ??? + ")");
                GSB.app("{");
            }
            (slist)?{
                GSB.less().tab("}").nl();
            }
        )
    ;
GSB is a class of mine that just represents an improved version of StringBuilder (Global String Builder) that have only static methods, which returns an sigleton instance of GSB. I use this clas to mount the C# code.
As you can see, after I append the String returned by the methodHead rule in my GSB, I need to know, before enter the slist rule, if the current constructor invokes the super-constructor...
I tried to do this manipulating directly the "ctor" AST node defined above, in order to find an AST node of type SUPER_CTOR_CALL, and then call directly the method corresponding to ctorCall rule. Obviously, it doesn't work, because I'm not sure if there is a way to walk "two times" over a same tree path...
So, how can I know if there is a super-constructor call, before entering in the slist rule?

Thanks in advance
 

Luciano Mantuaneli
Analist-Programmer
 		
---------------------------------
 Novidade no Yahoo! Mail: receba alertas de novas mensagens no seu celular. Registre seu aparelho agora!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/11172a2b/attachment.html 

From camiel at srxp.com  Tue Oct 17 12:15:17 2006
From: camiel at srxp.com (camiel at srxp.com)
Date: Tue, 17 Oct 2006 12:15:17 -0700
Subject: [antlr-interest] "Treeparser returns" question
Message-ID: <20061017121517.5ff1bdfaef4b15c00073fca9e2ebb440.696c0d85dc.wbe@email.secureserver.net>

An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/9677554a/attachment-0001.html 

From camiel at srxp.com  Tue Oct 17 12:19:36 2006
From: camiel at srxp.com (camiel at srxp.com)
Date: Tue, 17 Oct 2006 12:19:36 -0700
Subject: [antlr-interest] "Treeparser returns" question
Message-ID: <20061017121936.5ff1bdfaef4b15c00073fca9e2ebb440.8906e6f9e3.wbe@email.secureserver.net>

Hope plain text will work better...:

Hi you all,
 
I have a question on the proper syntax of Treeparser methods. Suppose
that you want to parse "a=1" or just "a"
with the following parser rule:
 
class myparser extends Parser
 
statement: IDENTIFIER (EQUALS INT)? EOF!;
 
and we want to echo the evaluation via an extension of the treeparser, 
the following is not going to work:
 
class mytreeparser extends TreeParser
 
statement returns [String s]
{String a; int b; s=""}
            : # (IDENTIFIER a=identifier) {s=a"}
            | # (EQUALS a=identifier, b=integer) {s=a+b;};
 
where identifier and integer are defined in the lexer.
 
My question is: what would work? The answer possibly centers around
method overloading (with different sets of parameters) but how exactly
I cannot figure out from online sources. Maybe anybody has written some
elaborate tutorial piece on this functionality of Antlr !?? 
 
Thanks anyway,
 
Camiel
 
 
 




From sunjigang1965 at yahoo.com.cn  Tue Oct 17 15:11:07 2006
From: sunjigang1965 at yahoo.com.cn (Jigang (Robert) Sun)
Date: Wed, 18 Oct 2006 06:11:07 +0800 (CST)
Subject: [antlr-interest] grammar overlapping in a rule
Message-ID: <20061017221107.9223.qmail@web15710.mail.cnb.yahoo.com>

The following garmmar is extracted from Clean Language Report version 2.1, p113, p116 and p117.
You can see FunctionName and ConstructorName overlapping.

Operator = FunctionName 
          | ConstructorName

FunctionName = LowerCaseId | UpperCaseId | FunnyId
ConstructorName = UpperCaseId | FunnyId

LowerCaseId = LowerCaseChar~{IdChar}
UpperCaseId = UpperCaseChar~{IdChar}
FunnyId = {SpecialChar}+

Any ideas?

Thanks.
Jigang


	

	
		
___________________________________________________________ 
Mp3???-???????
http://music.yahoo.com.cn/?source=mail_mailbox_footer

From rob.hill at blueyonder.co.uk  Tue Oct 17 15:27:28 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Tue, 17 Oct 2006 23:27:28 +0100
Subject: [antlr-interest] tree/token manipulation
Message-ID: <20061017222730.0450A1906E7@www.antlr.org>

Hi all,
	I have a rule that allows me to have syntactic shortcuts in my
language

So,

Select a using b,pack

Is the same as writing

Select a using b;
Pack a using b;


When I come across the first shortcut form in the AST, how can I transform
it into the second, effectively rewriting the tokens in the stream to the
next pass so the next treeparser sees the second form?
Can this be done easily? Or do I have to maintain the checks for the ',pack'
on subsequent grammars?

Ok, I realise this is dangerously close to the tree transform argument LOL,
but it would save me LOTS of typing :)

Thanks,

Rob





From lgcraymer at yahoo.com  Tue Oct 17 17:23:56 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 17 Oct 2006 17:23:56 -0700 (PDT)
Subject: [antlr-interest] grammar overlapping in a rule
In-Reply-To: <20061017221107.9223.qmail@web15710.mail.cnb.yahoo.com>
Message-ID: <20061018002356.53777.qmail@web55905.mail.re3.yahoo.com>

It is an ambiguity, probably resolved through the use
of symbol tables (to identify Constructors) and
semantic predicates.  I would resolve it by having

operator :  LowerCaseId | UpperCaseId | SpecialId ;

in the parser and distinguishing FunctionName from
Constructor in a tree pass--after you have built a
table of constructors that you can use for lookup. 
Then again, that may not be needed--do you really need
to distinguish constructors from functions in your
application?

--Loring

--- "Jigang (Robert) Sun" <sunjigang1965 at yahoo.com.cn>
wrote:

> The following garmmar is extracted from Clean
> Language Report version 2.1, p113, p116 and p117.
> You can see FunctionName and ConstructorName
> overlapping.
> 
> Operator = FunctionName 
>           | ConstructorName
> 
> FunctionName = LowerCaseId | UpperCaseId | FunnyId
> ConstructorName = UpperCaseId | FunnyId
> 
> LowerCaseId = LowerCaseChar~{IdChar}
> UpperCaseId = UpperCaseChar~{IdChar}
> FunnyId = {SpecialChar}+
> 
> Any ideas?
> 
> Thanks.
> Jigang
> 
> 
> 	
> 
> 	
> 		
>
___________________________________________________________
> 
> Mp3??????-??????????????
>
http://music.yahoo.com.cn/?source=mail_mailbox_footer
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From qwertie256 at gmail.com  Tue Oct 17 17:54:16 2006
From: qwertie256 at gmail.com (David Piepgrass)
Date: Tue, 17 Oct 2006 18:54:16 -0600
Subject: [antlr-interest] Cannot use or build antlr-3.0b4
Message-ID: <ce40b1470610171754n6510b735hc3c63cd0be0cc3d7@mail.gmail.com>

If I try to use antlr-3.0b4.jar included with antlr-3.0b4.tar.gz, using
either of these command lines:

java -cp antlr-3.0b4.jar antlr.Tool grammar.g
java -cp antlr-3.0b4.jar org.antlr.Tool grammar.g

I get:

Exception in thread "main" java.lang.NoClassDefFoundError:
org/antlr/stringtemplate/StringTemplateEr
rorListener
        at org.antlr.Tool.main(Tool.java:67)

Now I try:

java -cp antlr-3.0b4.jar;stringtemplate-2.3b9.jar org.antlr.Tool

But I get:

Exception in thread "main" java.lang.NoClassDefFoundError: antlr/TokenStream
        at org.antlr.tool.ErrorManager.setLocale(ErrorManager.java:357)
        at org.antlr.tool.ErrorManager.<clinit>(ErrorManager.java:323)
        at org.antlr.Tool.main(Tool.java:67)

Next I try to rebuild antlr according to the instruction in the README.txt:

D:\Dev\Sandbox\antlr-3.0b4\src>javac -cp ../lib/antlr-3.0b4.jar
;../lib/stringtemplate-2.3b9.jar -d .
 org/antlr/Tool.java org/antlr/*/*.java org/antlr/*/*/*.java

but I get:

error: cannot read: org/antlr/*/*.java
1 error

How can I enjoy the new antlr?
-- 
- David
http://qwertie.net
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/0083eccb/attachment.html 

From lgcraymer at yahoo.com  Tue Oct 17 18:02:14 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 17 Oct 2006 18:02:14 -0700 (PDT)
Subject: [antlr-interest] Cannot use or build antlr-3.0b4
In-Reply-To: <ce40b1470610171754n6510b735hc3c63cd0be0cc3d7@mail.gmail.com>
Message-ID: <20061018010214.14472.qmail@web55905.mail.re3.yahoo.com>

ANTLR 3 is still written in ANTLR 2.  You need an
ANTLR 2.7.6 (or 2.7.7) antlr.jar in your classpath as
well as StringTemplate.

--Loring

--- David Piepgrass <qwertie256 at gmail.com> wrote:

> If I try to use antlr-3.0b4.jar included with
> antlr-3.0b4.tar.gz, using
> either of these command lines:
> 
> java -cp antlr-3.0b4.jar antlr.Tool grammar.g
> java -cp antlr-3.0b4.jar org.antlr.Tool grammar.g
> 
> I get:
> 
> Exception in thread "main"
> java.lang.NoClassDefFoundError:
> org/antlr/stringtemplate/StringTemplateEr
> rorListener
>         at org.antlr.Tool.main(Tool.java:67)
> 
> Now I try:
> 
> java -cp antlr-3.0b4.jar;stringtemplate-2.3b9.jar
> org.antlr.Tool
> 
> But I get:
> 
> Exception in thread "main"
> java.lang.NoClassDefFoundError: antlr/TokenStream
>         at
>
org.antlr.tool.ErrorManager.setLocale(ErrorManager.java:357)
>         at
>
org.antlr.tool.ErrorManager.<clinit>(ErrorManager.java:323)
>         at org.antlr.Tool.main(Tool.java:67)
> 
> Next I try to rebuild antlr according to the
> instruction in the README.txt:
> 
> D:\Dev\Sandbox\antlr-3.0b4\src>javac -cp
> ../lib/antlr-3.0b4.jar
> ;../lib/stringtemplate-2.3b9.jar -d .
>  org/antlr/Tool.java org/antlr/*/*.java
> org/antlr/*/*/*.java
> 
> but I get:
> 
> error: cannot read: org/antlr/*/*.java
> 1 error
> 
> How can I enjoy the new antlr?
> -- 
> - David
> http://qwertie.net
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From qwertie256 at gmail.com  Tue Oct 17 18:23:57 2006
From: qwertie256 at gmail.com (David Piepgrass)
Date: Tue, 17 Oct 2006 19:23:57 -0600
Subject: [antlr-interest] Cannot use or build antlr-3.0b4
In-Reply-To: <20061018010214.14472.qmail@web55905.mail.re3.yahoo.com>
References: <ce40b1470610171754n6510b735hc3c63cd0be0cc3d7@mail.gmail.com>
	<20061018010214.14472.qmail@web55905.mail.re3.yahoo.com>
Message-ID: <ce40b1470610171823u689ff6ejad3e71bd0724ded9@mail.gmail.com>

Oops, wrong classpath. But when I fix it, the error is the same:

D:\Dev\Sandbox\antlr-3.0b4\src>javac -cp ../lib/antlr-2.7.6.jar
;../lib/stringtemplate-2.3b9.jar -d .
 org/antlr/Tool.java org/antlr/*/*.java org/antlr/*/*/*.java
error: cannot read: org/antlr/*/*.java
1 error

Luckily the binaries seem to work when the two versions are mixed:

D:\Dev\Sandbox\test>java -cp antlr-2.7.6.jar;antlr-3.0b4.jar;stringtemplate-
2.3b9.jar org.antlr.Tool test.g
ANTLR Parser Generator   Early Access Version 3.0b4 (??, 2006)  1989-2006

On 10/17/06, Loring Craymer <lgcraymer at yahoo.com> wrote:
>
> ANTLR 3 is still written in ANTLR 2.  You need an
> ANTLR 2.7.6 (or 2.7.7) antlr.jar in your classpath as
> well as StringTemplate.
>
> --Loring
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/e436bdbe/attachment.html 

From lgcraymer at yahoo.com  Tue Oct 17 18:28:43 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 17 Oct 2006 18:28:43 -0700 (PDT)
Subject: [antlr-interest] Cannot use or build antlr-3.0b4
In-Reply-To: <ce40b1470610171823u689ff6ejad3e71bd0724ded9@mail.gmail.com>
Message-ID: <20061018012843.38773.qmail@web55910.mail.re3.yahoo.com>

Ter lives on a Mac; you probably need to change
forward slashes to backslashes to get his one-liner to
work.

--Loring

--- David Piepgrass <qwertie256 at gmail.com> wrote:

> Oops, wrong classpath. But when I fix it, the error
> is the same:
> 
> D:\Dev\Sandbox\antlr-3.0b4\src>javac -cp
> ../lib/antlr-2.7.6.jar
> ;../lib/stringtemplate-2.3b9.jar -d .
>  org/antlr/Tool.java org/antlr/*/*.java
> org/antlr/*/*/*.java
> error: cannot read: org/antlr/*/*.java
> 1 error
> 
> Luckily the binaries seem to work when the two
> versions are mixed:
> 
> D:\Dev\Sandbox\test>java -cp
> antlr-2.7.6.jar;antlr-3.0b4.jar;stringtemplate-
> 2.3b9.jar org.antlr.Tool test.g
> ANTLR Parser Generator   Early Access Version 3.0b4
> (??, 2006)  1989-2006
> 
> On 10/17/06, Loring Craymer <lgcraymer at yahoo.com>
> wrote:
> >
> > ANTLR 3 is still written in ANTLR 2.  You need an
> > ANTLR 2.7.6 (or 2.7.7) antlr.jar in your classpath
> as
> > well as StringTemplate.
> >
> > --Loring
> >
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From lgcraymer at yahoo.com  Tue Oct 17 18:52:42 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 17 Oct 2006 18:52:42 -0700 (PDT)
Subject: [antlr-interest] tree/token manipulation
In-Reply-To: <20061017222730.0450A1906E7@www.antlr.org>
Message-ID: <20061018015243.20005.qmail@web55906.mail.re3.yahoo.com>

Rob--

I am sure that there is an answer involving
TreeAdaptors, eye of newt and wing of bat.  Properly,
though, this is a tree transformation issue.  It has
been a few years since Ter did any multi-pass tree
transformation work, though, so the best way to get
the functionality into the baseline is to keep raising
the issue.  (Unfortunate, that:  I consider
grammar-based tree manipulation to be one of Ter's
most important contributions to the field.)

--Loring

--- Robert Hill <rob.hill at blueyonder.co.uk> wrote:

> Hi all,
> 	I have a rule that allows me to have syntactic
> shortcuts in my
> language
> 
> So,
> 
> Select a using b,pack
> 
> Is the same as writing
> 
> Select a using b;
> Pack a using b;
> 
> 
> When I come across the first shortcut form in the
> AST, how can I transform
> it into the second, effectively rewriting the tokens
> in the stream to the
> next pass so the next treeparser sees the second
> form?
> Can this be done easily? Or do I have to maintain
> the checks for the ',pack'
> on subsequent grammars?
> 
> Ok, I realise this is dangerously close to the tree
> transform argument LOL,
> but it would save me LOTS of typing :)
> 
> Thanks,
> 
> Rob
> 
> 
> 
> 
> 



__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From qwertie256 at gmail.com  Tue Oct 17 20:32:02 2006
From: qwertie256 at gmail.com (David Piepgrass)
Date: Tue, 17 Oct 2006 21:32:02 -0600
Subject: [antlr-interest] Tweaking a source file.
Message-ID: <ce40b1470610172032s35d0382dx73fa90fd8fc296f6@mail.gmail.com>

I'm new to ANTLR and although I'm generally a quick study when it comes to
languages, I could use a little help because I'm on a hard deadline.

I want to write a preprocessor for a simplified boo language (boo is a
language that resembles Python). The preprocessor will process "unit"
declarations for a unit checker. For example, you could write code like
this:

def Energy(mass as double `kg`, speed as double `m/s`):
    return 0.5*mass*Square(speed)

def Square(x as double):
    return x*x

Then, the unit checker could automatically deduce that the return value of
Energy() is measured in kg*m^2/s^2. It also has to spit out a new source
file without the unit information:

def Energy(mass as double, speed as double):
    return 0.5*mass*Square(speed)
....

So, the unit checker needs to:

1. Strip out unit information such as `m/s`, to produce a new source file.
2. Create an AST, in order to do semantic analysis (i.e. unit checking.)
3. Process newlines and indentation as part of the syntax.

The first decision I need to make is, should I use ANTLR 2 or ANTLR 3? The
readme for ANTLR 3 says "For example, to read in some input, tweak it, and
write it back out preserving whitespace, is easy in v3." That sounds great
because it is exactly what I need to accomplish.  But how can it be done?
Does an example exist? For my application, I think an observer inserted
between the lexer and parser can do the job--I just don't know the details.

The second big question is, what is the easiest way to make an AST, and is
this task also easier in v3?

The third question is, how can one parse a language where indentation is
syntactically significant?

-- 
- David
http://qwertie.net
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061017/6fa8a29d/attachment-0001.html 

From lgcraymer at yahoo.com  Tue Oct 17 20:46:09 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 17 Oct 2006 20:46:09 -0700 (PDT)
Subject: [antlr-interest] Tweaking a source file.
In-Reply-To: <ce40b1470610172032s35d0382dx73fa90fd8fc296f6@mail.gmail.com>
Message-ID: <20061018034609.96488.qmail@web55913.mail.re3.yahoo.com>

Rodrigo used ANTLR 2 to create boo--it might be a good
idea to check out the grammar(s) he uses.  They should
be in the boo distribution.

ANTLR 3 is getting pretty robust, but is still in the
shakedown stage and as yet is poorly documented.  If
you have a tight deadline, it may be better to use
ANTLR 2 just because it is stable and well-documented.

--Loring

--- David Piepgrass <qwertie256 at gmail.com> wrote:

> I'm new to ANTLR and although I'm generally a quick
> study when it comes to
> languages, I could use a little help because I'm on
> a hard deadline.
> 
> I want to write a preprocessor for a simplified boo
> language (boo is a
> language that resembles Python). The preprocessor
> will process "unit"
> declarations for a unit checker. For example, you
> could write code like
> this:
> 
> def Energy(mass as double `kg`, speed as double
> `m/s`):
>     return 0.5*mass*Square(speed)
> 
> def Square(x as double):
>     return x*x
> 
> Then, the unit checker could automatically deduce
> that the return value of
> Energy() is measured in kg*m^2/s^2. It also has to
> spit out a new source
> file without the unit information:
> 
> def Energy(mass as double, speed as double):
>     return 0.5*mass*Square(speed)
> ....
> 
> So, the unit checker needs to:
> 
> 1. Strip out unit information such as `m/s`, to
> produce a new source file.
> 2. Create an AST, in order to do semantic analysis
> (i.e. unit checking.)
> 3. Process newlines and indentation as part of the
> syntax.
> 
> The first decision I need to make is, should I use
> ANTLR 2 or ANTLR 3? The
> readme for ANTLR 3 says "For example, to read in
> some input, tweak it, and
> write it back out preserving whitespace, is easy in
> v3." That sounds great
> because it is exactly what I need to accomplish. 
> But how can it be done?
> Does an example exist? For my application, I think
> an observer inserted
> between the lexer and parser can do the job--I just
> don't know the details.
> 
> The second big question is, what is the easiest way
> to make an AST, and is
> this task also easier in v3?
> 
> The third question is, how can one parse a language
> where indentation is
> syntactically significant?
> 
> -- 
> - David
> http://qwertie.net
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From rhill03 at eds.com  Tue Oct 17 23:16:10 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Wed, 18 Oct 2006 07:16:10 +0100
Subject: [antlr-interest] Cannot use or build antlr-3.0b4
In-Reply-To: <20061018012843.38773.qmail@web55910.mail.re3.yahoo.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD4027ED885@UKNSM201.emea.corp.eds.com>

>Ter lives on a Mac; 
<gasp!> all respect slowly drains away LOL

Just kiddin'

I didn't even know they had compilers. 

I'll stop now ;)

Hehe!
Rob


From lgcraymer at yahoo.com  Tue Oct 17 23:23:50 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 17 Oct 2006 23:23:50 -0700 (PDT)
Subject: [antlr-interest] Cannot use or build antlr-3.0b4
In-Reply-To: <2E909902FD3A03419E3A905908AE3DD4027ED885@UKNSM201.emea.corp.eds.com>
Message-ID: <20061018062350.91357.qmail@web55908.mail.re3.yahoo.com>

Hey, it's a UNIX box--there are advantages to not
having to use Cygwin for the routine software tools.

--Loring

--- "Hill, Robert" <rhill03 at eds.com> wrote:

> >Ter lives on a Mac; 
> <gasp!> all respect slowly drains away LOL
> 
> Just kiddin'
> 
> I didn't even know they had compilers. 
> 
> I'll stop now ;)
> 
> Hehe!
> Rob
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From alldiksha at yahoo.com  Wed Oct 18 09:07:26 2006
From: alldiksha at yahoo.com (Diksha)
Date: Wed, 18 Oct 2006 09:07:26 -0700 (PDT)
Subject: [antlr-interest] Reg: Unavailable Links on Antlr site
Message-ID: <20061018160726.65914.qmail@web32715.mail.mud.yahoo.com>

Hello,
   
  I have been trying to check out the "Java .class file Grammar" links present in the page http://www.antlr.org/grammar/list , but they display an error "Unknown location: modules/classfile/src/org/argouml/uml/reveng/classfile" which you can view at  http://argouml.tigris.org/source/browse/argouml/modules/classfile/src/org/argouml/uml/reveng/classfile/
   
  I just wanted to know if these links will be up and when will they be available.
   
  Thanks,
Diksha

 				
---------------------------------
Want to be your own boss? Learn how on  Yahoo! Small Business. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061018/2434ca4c/attachment.html 

From parrt at cs.usfca.edu  Wed Oct 18 09:57:13 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 18 Oct 2006 09:57:13 -0700
Subject: [antlr-interest] Reg: Unavailable Links on Antlr site
In-Reply-To: <20061018160726.65914.qmail@web32715.mail.mud.yahoo.com>
References: <20061018160726.65914.qmail@web32715.mail.mud.yahoo.com>
Message-ID: <0E147141-3E5D-4CAB-B5E2-8F39603D9A70@cs.usfca.edu>

Hi. I just found a copy on my disk and pushed a tarball, changing the  
link.

Ter
On Oct 18, 2006, at 9:07 AM, Diksha wrote:

> Hello,
>
> I have been trying to check out the "Java .class file Grammar"  
> links present in the page http://www.antlr.org/grammar/list , but  
> they display an error "Unknown location: modules/classfile/src/org/ 
> argouml/uml/reveng/classfile" which you can view at  http:// 
> argouml.tigris.org/source/browse/argouml/modules/classfile/src/org/ 
> argouml/uml/reveng/classfile/
>
> I just wanted to know if these links will be up and when will they  
> be available.
>
> Thanks,
> Diksha
>
> Want to be your own boss? Learn how on Yahoo! Small Business.


From parrt at cs.usfca.edu  Wed Oct 18 10:40:51 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 18 Oct 2006 10:40:51 -0700
Subject: [antlr-interest] an TJP interview on ST at artima.com
Message-ID: <0F9C45FD-E57B-49C7-899D-B44DF04A7C09@cs.usfca.edu>

http://www.artima.com/forums/flat.jsp?forum=276&thread=180957

From rob.hill at blueyonder.co.uk  Wed Oct 18 11:55:04 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Wed, 18 Oct 2006 19:55:04 +0100
Subject: [antlr-interest] definately NOT a tree transform question :)
Message-ID: <20061018185510.B11CC190A51@www.antlr.org>

Ok, I've given up on the tree transform/token twiddling stuff, and found
alternatives, next question :

I have a treeparse that checks the semantics, I'd like to store some of the
usefull things I've calculated that pass for future passes, rather than
recalculating the same stuff at the same point in the tree. I'd like to
store extra info somewhere with this tree/token/whatever, I guess I need to
provide a different/extended Node type with my payload? 
Can I change the node types on creation from the parser? Or can I change the
token when I get to it? OMG, that sounds suspiciously like a tree transform
question again LOL....

Any pointers to examples would be a greate help if there are any?!

Cheers

Rob




From rob.hill at blueyonder.co.uk  Wed Oct 18 12:20:22 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Wed, 18 Oct 2006 20:20:22 +0100
Subject: [antlr-interest] definately NOT a tree transform question :)
In-Reply-To: <F89BA86F375B2F43B05CB04E01B199BA0AAC7E@castor-srvr1.benchmarkcanada.com>
Message-ID: <20061018192034.050F6190A57@www.antlr.org>

Novel! , I'd not thought about Maps!, that's pretty cool because then im not
lumbering all the node with additional info, in case you cant apply nodes to
specific bits of the tree, and have to blanket change the node type. I
suppose the addition of a myStuff object ref wouldn't be a problem, I have <
1000 nodes..
Cool!

Cheers Oliver!

/2ob


> -----Original Message-----
> From: Oliver Wong [mailto:owong at benchmarkconsulting.com]
> Sent: 18 October 2006 20:15
> To: Robert Hill
> Subject: RE: [antlr-interest] definately NOT a tree transform question :)
> 
> 
> From: antlr-interest-bounces at antlr.org
> [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Robert Hill
> Sent: Wednesday, October 18, 2006 2:55 PM
> > I have a treeparse that checks the semantics, I'd like to store some
> of
> > the usefull things I've calculated that pass for future passes, rather
> > than recalculating the same stuff at the same point in the tree. I'd
> like
> > to store extra info somewhere with this tree/token/whatever, I guess I
> > need to provide a different/extended Node type with my payload?
> 
> 	One trick I've seen is to define a Map that goes from the nodes
> to the data you wish to store associated with that node. It's like
> faking the addition of fields to a class at runtime.
> 
> 	- Oliver
> 



From rob.hill at blueyonder.co.uk  Wed Oct 18 13:36:48 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Wed, 18 Oct 2006 21:36:48 +0100
Subject: [antlr-interest] Mismatched Token Exception
Message-ID: <20061018203656.0CBAB190A50@www.antlr.org>

Why doesn't this get caught in the @rulecatch {} statement?
I cant find anyway to stop it outputting the message, and give my own
sanitised error instead.


Rob





From mathieu.clabaut at gmail.com  Wed Oct 18 14:53:44 2006
From: mathieu.clabaut at gmail.com (Mathieu Clabaut)
Date: Wed, 18 Oct 2006 23:53:44 +0200
Subject: [antlr-interest] Transformation phylosophy : AST trans./ pattern
	matching
Message-ID: <db9360ca0610181453h22027552hb577c0650582cac5@mail.gmail.com>

 Hello all,

 I've read some of the interesting mails about the different way to do
transformation.

 Just for reference, a collegue of mine pointed me to the cocktail95
tool suite :
   http://www.iste.uni-stuttgart.de/ps/cocktail/
 which seems to allow AST transformation but as also a Transformation
Tool based on Pattern Matching (puma).... No, I didn't give a try to
it, but I may have a deeper look in a near futur...

-mathieu

From parrt at cs.usfca.edu  Wed Oct 18 14:54:38 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 18 Oct 2006 14:54:38 -0700
Subject: [antlr-interest] Mismatched Token Exception
In-Reply-To: <20061018203656.0CBAB190A50@www.antlr.org>
References: <20061018203656.0CBAB190A50@www.antlr.org>
Message-ID: <DC917334-D03F-4E24-9695-CAC22BE5511E@cs.usfca.edu>

Weird. Do you say catch[RecognitionException re] {...}  or some other  
exception?
Ter
On Oct 18, 2006, at 1:36 PM, Robert Hill wrote:

> Why doesn't this get caught in the @rulecatch {} statement?
> I cant find anyway to stop it outputting the message, and give my own
> sanitised error instead.
>
>
> Rob
>
>
>
>


From parrt at cs.usfca.edu  Wed Oct 18 14:56:14 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 18 Oct 2006 14:56:14 -0700
Subject: [antlr-interest] Tweaking a source file.
In-Reply-To: <ce40b1470610172032s35d0382dx73fa90fd8fc296f6@mail.gmail.com>
References: <ce40b1470610172032s35d0382dx73fa90fd8fc296f6@mail.gmail.com>
Message-ID: <8D695BE9-5A5F-4492-A102-1317D353E9AE@cs.usfca.edu>


On Oct 17, 2006, at 8:32 PM, David Piepgrass wrote:
> The first decision I need to make is, should I use ANTLR 2 or ANTLR  
> 3? The readme for ANTLR 3 says "For example, to read in some input,  
> tweak it, and write it back out preserving whitespace, is easy in  
> v3." That sounds great because it is exactly what I need to  
> accomplish.  But how can it be done?

Use TokenRewriteStream instead of COmmonTokenStream.  Look at the v2  
to v3 translator I just did for an example. :)

ter

> Does an example exist? For my application, I think an observer  
> inserted between the lexer and parser can do the job--I just don't  
> know the details.
>
> The second big question is, what is the easiest way to make an AST,  
> and is this task also easier in v3?
>
> The third question is, how can one parse a language where  
> indentation is syntactically significant?
>

Keep whitespace tokens as real tokens (don't skip them). :)

Ter


From jose.ventura.roda at gmail.com  Thu Oct 19 00:37:29 2006
From: jose.ventura.roda at gmail.com (Jose Ventura)
Date: Thu, 19 Oct 2006 09:37:29 +0200
Subject: [antlr-interest] Antlr 2 nondeterminism problem
Message-ID: <e39abda10610190037r3ddb55adm1d921723fa1c067e@mail.gmail.com>

Hi all,
I have these rules in my parser, I've marked with **** the error line.

*comando_read: READ^ IDENT
          (next_record|read_into|read_key)*
          (read_end)?
****     (read_no_end)?
                       (options {greedy=true;}:END_READ)?;
next_record!:    NEXT| RECORD;
read_into :      INTO^ campo;
read_key :      KEY^ (IS!)? campo ;
read_end :      (AT!)?  END sentencia_interna["END"];
read_no_end:   NOT (AT!)? END sentencia_interna["NOT-END"];
*
*cobolParser.g:899:17: warning:nondeterminism between alts 1 and 2 of block
upon
cobolParser.g:899:17:     k==1:"NOT"*

Can anyone help me with this error? I haven't achieved to solve it.

Thanks in advance.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061019/af95677e/attachment.html 

From pismikrop at gmail.com  Thu Oct 19 02:16:58 2006
From: pismikrop at gmail.com (=?ISO-8859-9?Q?F=FDrat_K=DC=C7=DCK?=)
Date: Thu, 19 Oct 2006 12:16:58 +0300
Subject: [antlr-interest] antlrworks feature request
Message-ID: <8e210baf0610190216v29c11ec4pb84a35c237867f7d@mail.gmail.com>

Hi,
i seperate my grammar lexer file, parser file and tree parser file
like

lexer grammar JavyLexer; // lexer.g
parser grammar JavyParser; // parser.g
tree grammar JavyTreeParser; // treeparser.g

and i use
tokenVocab = lexer

but antlrworks does not recognize seperate files.

-- 
??r. G?r. F?rat K???K
ADAMYO Distance Learning
SAKARYA University / TURKEY
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061019/92641795/attachment.html 

From r_balaji82 at yahoo.com  Thu Oct 19 05:30:55 2006
From: r_balaji82 at yahoo.com (Balaji Ramasubbu)
Date: Thu, 19 Oct 2006 05:30:55 -0700 (PDT)
Subject: [antlr-interest]  Upgrading to higher version
Message-ID: <20061019123055.59788.qmail@web57712.mail.re3.yahoo.com>

Hi Ter,
         We have been using 2.6.0 version, now because of the gcc3.4 grammar compatibility, we are upgrading to 2.7.6. Could you please let me know, how to adapt an application that works under 2.6.0 to work under 2.7.6.
Thanks,
Balaji

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061019/c3632a30/attachment.html 

From antlr at aubit.com  Thu Oct 19 06:16:42 2006
From: antlr at aubit.com (Mike Aubury)
Date: Thu, 19 Oct 2006 14:16:42 +0100
Subject: [antlr-interest] Bison-> Antlr 3 help
Message-ID: <200610191416.42090.antlr@aubit.com>

I'm trying to convert some bison grammar to work with Antlr and could do with 
some pointers on what needs to be done next...


I'm getting lots of output like : 

        fgl_v3.g:164:12: Decision can match input such as "NAMED OPEN_BRACKET" 
using    
        multiple alternatives: 4, 5
        As a result, alternative(s) 5 were disabled for that input

        fgl_v3.g:285:2: Decision can match input such as "AFTCONSTRUCT" using   
        multiple alternatives: 1, 2
        As a result, alternative(s) 2 were disabled for that input

        fgl_v3.g:285:2: Decision can match input such as "KW_ON" using 
multiple 
        alternatives: 1, 2
        As a result, alternative(s) 2 were disabled for that input

        fgl_v3.g:285:2: Decision can match input such as "BEFCONSTRUCT" using           
        multiple alternatives: 1, 2
        As a result, alternative(s) 2 were disabled for that input

        fgl_v3.g:285:2: Decision can match input such as "ON_ANY_KEY" using 
multiple    
        alternatives: 1, 2
        As a result, alternative(s) 2 were disabled for that input

.
.
.
        fgl_v3.g:1959:31: ANTLR could not analyze this decision in rule 
message_cmd;    
        often this is because of recursive rule references visible from the 
left edge   
        of alternatives.  ANTLR will re-analyze the decision with a fixed 
lookahead 
        of k=1.  Consider using "options {k=1;}" for that decision and 
possibly 
        adding a syntactic predicate.




Any help gratefully received!

Grammar is here : http:/www.aubit.com/fgl_v3.g 

FWIW - The 'end game' is to end up with some some of tree I can walk down to 
generate 
my code rather than the current "generate as I parse" bison stuff...



-- 
Mike Aubury


From prashant.deva at gmail.com  Thu Oct 19 08:26:57 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Thu, 19 Oct 2006 08:26:57 -0700
Subject: [antlr-interest] Part 2 of Creating a Commercial Quality IDE series
Message-ID: <41fed8f80610190826k7d4bbb61wc93f53a4682c9d9a@mail.gmail.com>

For those of you following my 'Creating a Commercial Quality IDE' series
which takes a look at designing a commercial quality Eclipse IDE using ANTLR
Studio as a case study, part 2 has just been published at the IBM
developerworks site- http://www-128.ibm.com/developerworks/opensource

Direct link -
http://www.ibm.com/developerworks/opensource/edu/os-dw-os-ecl-commplgin2.html?S_TACT=105AGX44&S_CMP=HP

-- 
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061019/3215af23/attachment.html 

From parrt at cs.usfca.edu  Thu Oct 19 09:43:04 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 09:43:04 -0700
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <200610191416.42090.antlr@aubit.com>
References: <200610191416.42090.antlr@aubit.com>
Message-ID: <E1D42B62-3E80-4573-B643-9F7C2C441199@cs.usfca.edu>

Have you tried looking at this with ANTLRWorks?
Ter


From ilia at obnovlenie.ru  Thu Oct 19 09:47:55 2006
From: ilia at obnovlenie.ru (Ilia Kantor)
Date: Thu, 19 Oct 2006 20:47:55 +0400
Subject: [antlr-interest] LL(*)
Message-ID: <200610192047.55596.ilia@obnovlenie.ru>


Hello, I'm using antlr-parsed grammar in my thesys.
At least, I say that it's LL(*), and I can refer to ANTLR to prove its really 
LL(*), but I have to supply definitions.

Is there a mathematical definition of LL(*) ?

I heard, Terrence did not write articles, but maybe any drafts/discussions 
available on scientific part of the topic ?

I really need something to make the text correct.


From parrt at cs.usfca.edu  Thu Oct 19 09:54:23 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 09:54:23 -0700
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <4e2eaea739f6a2175d742ee389e371d2@aubit.com>
References: <200610191416.42090.antlr@aubit.com>
	<E1D42B62-3E80-4573-B643-9F7C2C441199@cs.usfca.edu>
	<4e2eaea739f6a2175d742ee389e371d2@aubit.com>
Message-ID: <795F0BE0-3A6C-4E54-9B56-EDC3E38050A2@cs.usfca.edu>


On Oct 19, 2006, at 9:48 AM, Mike Aubury wrote:

> yeah...
> it runs out of heap space :) - but apart from that - it  
> (antlrworks) looks like a great tool for grammar development...

I run from command line with more ram and it's cool.  ANTLR is a  
pig ;)  'course so is swing.

> I could really do with knowing whats actually wrong and whats  
> needed to fix it.

Try more ram.
Ter

From antlr at aubit.com  Thu Oct 19 10:02:46 2006
From: antlr at aubit.com (Mike Aubury)
Date: Thu, 19 Oct 2006 18:02:46 +0100
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <795F0BE0-3A6C-4E54-9B56-EDC3E38050A2@cs.usfca.edu>
References: <200610191416.42090.antlr@aubit.com>
	<4e2eaea739f6a2175d742ee389e371d2@aubit.com>
	<795F0BE0-3A6C-4E54-9B56-EDC3E38050A2@cs.usfca.edu>
Message-ID: <200610191802.46489.antlr@aubit.com>

Done that - thats not what I meant :-)

When I run it I use this  (on Linux) : 
    java  -Xmx400m -jar antlrworks-1.0b4.jar

And it seems to work 

But - I could do with know how to resolve the grammar errors ;-)

On Thursday 19 October 2006 17:54, Terence Parr wrote:
> On Oct 19, 2006, at 9:48 AM, Mike Aubury wrote:
> > yeah...
> > it runs out of heap space :) - but apart from that - it
> > (antlrworks) looks like a great tool for grammar development...
>
> I run from command line with more ram and it's cool.  ANTLR is a
> pig ;)  'course so is swing.
>
> > I could really do with knowing whats actually wrong and whats
> > needed to fix it.
>
> Try more ram.
> Ter

-- 
Mike Aubury


From parrt at cs.usfca.edu  Thu Oct 19 10:11:27 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 10:11:27 -0700
Subject: [antlr-interest] LL(*)
In-Reply-To: <200610192047.55596.ilia@obnovlenie.ru>
References: <200610192047.55596.ilia@obnovlenie.ru>
Message-ID: <993811A9-3C06-44FA-8690-EDAA7C9451CC@cs.usfca.edu>


On Oct 19, 2006, at 9:47 AM, Ilia Kantor wrote:

>
> Hello, I'm using antlr-parsed grammar in my thesys.
> At least, I say that it's LL(*), and I can refer to ANTLR to prove  
> its really
> LL(*), but I have to supply definitions.
>
> Is there a mathematical definition of LL(*) ?
>
> I heard, Terrence did not write articles, but maybe any drafts/ 
> discussions
> available on scientific part of the topic ?
>
> I really need something to make the text correct.

http://www.antlr.org/blog/antlr3/lookahead.tml

:)

Added notes from start of my LL(*) paper. hope that helps.

Ter

From parrt at cs.usfca.edu  Thu Oct 19 10:12:07 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 10:12:07 -0700
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <200610191802.46489.antlr@aubit.com>
References: <200610191416.42090.antlr@aubit.com>
	<4e2eaea739f6a2175d742ee389e371d2@aubit.com>
	<795F0BE0-3A6C-4E54-9B56-EDC3E38050A2@cs.usfca.edu>
	<200610191802.46489.antlr@aubit.com>
Message-ID: <70A25263-119A-4AA9-859E-F816EF0BAFCE@cs.usfca.edu>


On Oct 19, 2006, at 10:02 AM, Mike Aubury wrote:

> Done that - thats not what I meant :-)
>
> When I run it I use this  (on Linux) :
>     java  -Xmx400m -jar antlrworks-1.0b4.jar
>
> And it seems to work
>
> But - I could do with know how to resolve the grammar errors ;-)

Have you looked at the rules highlighted in red and seen the syntax  
diagrams with green/red paths showing the ambiguity?
Ter


From parrt at cs.usfca.edu  Thu Oct 19 10:28:24 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 10:28:24 -0700
Subject: [antlr-interest] Transformation phylosophy : AST trans./
	pattern matching
In-Reply-To: <db9360ca0610181453h22027552hb577c0650582cac5@mail.gmail.com>
References: <db9360ca0610181453h22027552hb577c0650582cac5@mail.gmail.com>
Message-ID: <0E2583D7-CFDB-4A47-8125-C778692E00BF@cs.usfca.edu>


On Oct 18, 2006, at 2:53 PM, Mathieu Clabaut wrote:

> Hello all,
>
> I've read some of the interesting mails about the different way to do
> transformation.
>
> Just for reference, a collegue of mine pointed me to the cocktail95
> tool suite :
>   http://www.iste.uni-stuttgart.de/ps/cocktail/
> which seems to allow AST transformation but as also a Transformation
> Tool based on Pattern Matching (puma).... No, I didn't give a try to
> it, but I may have a deeper look in a near futur...

Interesting; just looked at Puma.  Syntax is not obvious.  Seems to  
allow tree grammar specification due to recursive references but  
doesn't call it that.  Allows patterns and predicates to match.  Has  
some interesting functionality similar to other tools.  My thoughts  
would lean more towards what Andy did but with some twists.

Andy Tripp arrives today at 2pm for discussions!  Hooray!

Ter


From parrt at cs.usfca.edu  Thu Oct 19 10:30:04 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 10:30:04 -0700
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <200610191823.38916.mike.aubury@aubit.com>
References: <200610191416.42090.antlr@aubit.com>
	<200610191802.46489.antlr@aubit.com>
	<70A25263-119A-4AA9-859E-F816EF0BAFCE@cs.usfca.edu>
	<200610191823.38916.mike.aubury@aubit.com>
Message-ID: <049B2959-1A8E-4450-B681-F56551C71A20@cs.usfca.edu>


On Oct 19, 2006, at 10:23 AM, Mike Aubury wrote:

> Yeah - I get things like  :
>
> 	OPEN_BRACKET ID CLOSE_BRACKET
> 	| OPEN_BRACKET SOMETHINGELSE CLOSE_BRACKET
>
> I know these can be rewritten as
> 	OPEN_BRACKET (ID|SOMETHINGELSE) CLOSE_BRACKET
> - but I thought thats what lookaheads are for...

It is.  What is SOMETHINGELSE?  Must include ID or there is no  
ambiguity.  Your error:

         fgl_v3.g:164:12: Decision can match input such as "NAMED  
OPEN_BRACKET"
using
         multiple alternatives: 4, 5
         As a result, alternative(s) 5 were disabled for that input

suggests a true ambiguity not a weakness in the parsing strategy.

> There are also ones where the tokens are way down in other others...
>
> (Also - as soon as you make one of these changes - you loose all the
> highlights...)

Rerun the grammar analysis then. ;)

Ter

From parrt at cs.usfca.edu  Thu Oct 19 10:52:35 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 10:52:35 -0700
Subject: [antlr-interest] [stringtemplate-interest] File based templates
	and maps.
In-Reply-To: <4537B855.4020201@ezswitch.net>
References: <4536C3E0.4030404@ezswitch.net>	<6C894A5E-8129-41D0-83DD-B8AF272214A2@cs.usfca.edu>	<4537B0F1.2060301@ezswitch.net>
	<88B73234-4618-4EEF-81B1-1A19C90F0E55@cs.usfca.edu>
	<4537B855.4020201@ezswitch.net>
Message-ID: <6F95EDBA-902A-4209-919E-4C903C0BD6D8@cs.usfca.edu>

try now...a spammer created 100 spam users. :(
Ter

On Oct 19, 2006, at 10:39 AM, Caleb Lyness wrote:

>>> I think it would be nice for future newbies if there was an  
>>> example along side the file based template (.st) method in the  
>>> source. Would speed the learning curve up a bit. cf: src\org\antlr 
>>> \stringtemplate\test.
>> Add a quick tutorial :) http://www.antlr.org/wiki/display/ST/ 
>> Tutorials
> Pitty, I cannot:
> I don't have a login and I can't create one.
>
> The following error(s) occurred:
> This installation of Confluence is not licensed to add any more  
> users. Please contact the site administrators for more information.
>
>


From lgcraymer at yahoo.com  Thu Oct 19 13:39:54 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Thu, 19 Oct 2006 13:39:54 -0700 (PDT)
Subject: [antlr-interest] Upgrading to higher version
In-Reply-To: <20061019123055.59788.qmail@web57712.mail.re3.yahoo.com>
Message-ID: <20061019203954.99234.qmail@web55905.mail.re3.yahoo.com>

There are some minor differences in the ANTLR grammar
which you might or might not encounter; you will also
need to set the ASTFactory (see the runtime
discussions).

Otherwise, it should "just work".

--Loring

--- Balaji Ramasubbu <r_balaji82 at yahoo.com> wrote:

> Hi Ter,
>          We have been using 2.6.0 version, now
> because of the gcc3.4 grammar compatibility, we are
> upgrading to 2.7.6. Could you please let me know,
> how to adapt an application that works under 2.6.0
> to work under 2.7.6.
> Thanks,
> Balaji
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From foolishewe at hotmail.com  Thu Oct 19 15:00:57 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Thu, 19 Oct 2006 22:00:57 +0000
Subject: [antlr-interest] First post, possible ANTLR 2.7.6 bug
Message-ID: <BAY107-F36DA3BD71E00D980D9B438C00C0@phx.gbl>

Hello All:

I've just done the Antlr mailing list registration, I hope the moderator 
will contact me
if for some reason this message is not approved.

Tihs message seeks to address a few questions about a project I'm working 
on.

1)  I think I may have encountered a bug in Antlr 2.7.6 (same version as in 
the original posting)
    (it may be just be that there is some code generation setting or lexer 
option settting
     that I'm overlooking, that would be a great help).  Please consider the 
following example
*******************BEGIN example.g********************************
//My play area for diagnosing strange ANTLR symptoms
//Version History: 1.0 WAM created


// WAM - Need to add some boilerplate to let Antlr generated files know that 
they are part of the ZTestParser package
header{
package testing;
}

class P extends Parser;

// Parser options
options{
k = 2; // Token stream lookahead, remember ANTLR uses LL(k) parsing
}

// Antlr requires Terminals have names beginning with uppercase letters, 
Nonterminals should use lowercase I guess
startRule
:
strval:NONEMPTYALPHASTRING nl:NEWLINE // breaks if the user types in "dun\n" 
where \n is newline
;
/*
optionala1:optA b:B
|
optionala2:optA c:C
;
*/

optA
:
A
|
//empty
;

class L extends Lexer;

// Lexer options
options{
k=7; // lookahead (need 2 for new line)
charVocabulary='\u0000'..'\u007F'; // Only support printable ASCII 
characters, don't try fancy unicode stuff
// case sensitivitity turned off
caseSensitiveLiterals=false;
caseSensitive=false;
}


NEWLINE
   :   '\r' '\n'    {newline();}        // DOS
   |   '\r'         {newline();}        // Macintosh
   |   '\n'         {newline();}        // UNIX
   ;


WHITESPACE :   ' '  {$setType(Token.SKIP);} // space character
            | '\t' {System.out.println("Found a tab"); tab(); 
$setType(Token.SKIP);};


MONTH: ("jan" | "feb" | "mar" | "apr" | "may" | "jun" | // MMM (month)
"jul" | "aug" | "sep" | "oct" | "nov" | "dec");

NONEMPTYALPHASTRING: ('a'..'z')+; // Probably needs testliteral check
********************END example.g********************************
For ease of replication, I have attached a Java source driver:
*******************Begin Main.java*********************************
package testing;
import java.io.*;

public class Main {

/**
* @param args
*/
public static void main(String[] args) {
try{
System.out.println("Enter a string for the test parser (note this is for 
simple ANTLR test cases)");

L lexer = new L(new DataInputStream(System.in));


System.out.println("After lexer instantiated before Parser instantiation");
P parser = new P(lexer);
System.out.println("After Parser instantiation before StartRule");
parser.startRule();
System.out.println("After startRule: Done?");
} catch(Exception e) {
System.err.println("exception: "+e);
}
}

}
************************end 
Main.java******************************************
Running the example gives the following trace (all tracing was enabled):
************************begin 
trace*******************************************
Enter a string for the test parser (note this is for simple ANTLR test 
cases)
After lexer instantiated before Parser instantiation
After Parser instantiation before StartRule
>startRule; dun
>lexer mMONTH; c==d
< lexer mMONTH; c==u
exception: line 1:2: expecting 'e', found 'u'
**********************end 
trace**********************************************
I think this happens because of the code generation, which appears (on the 
surface) to
check to see if LA(i) matches the ith letter of any MONTH alternative, 1 <= 
i <= 3 via bitmaps.
However, this is just a heuristic, and not a sure test that the lexeme is 
indeed a MONTH
alternative, so "d" matches the prefix of dec, while "un" matches the suffix 
of "jun".

Please correct me if I'm wrong here, are there any suggested work arounds?
I'm reluctant to make separate rules for each alternative, because I've seen 
the lexer
follow wrong alternatives in grammars when I've tried adding "helper" rules, 
so I try
to stick to literals on the RHS of lexer grammars.  If there is someway to 
tell the lexer
that a  lexer rule is not associated with a legitimate terminal, but just a 
subrule to make
writing the scanner easier, I'd like to hear it.

2) On a side note a colleague and I discovered (over a nice cup of coffiee) 
that left factoring
  does solve a problem I unsuccessfully tried to submit to the list 
ie--mail, so using a rule like:

  startRule: opta:optA ( b:B {System.out.println("Got optA B");} | c:C  
{System.out.println("Got optA C");});
  gets around this (I'm still not clear on why a larger lookahead didn't 
allow recognition of the
  original grammar, is it inherent in LL(k) parsing theory or is it an 
implementation limitation?).
  If anyone could point me to a reference or give a quick explanation, I'd 
appreciate it.


Regards:

Bill M. (Sorry but my last name is too unique and generates a lot of spam)

These opinions are my own and do not reflect in any way on my employer

	 	From: "Foolish Ewe" <foolishewe at hotmail.com>
To: antlr-interest at antlr.org
CC: FoolishEwe at hotmail.com
Subject: Handling optional tokens as prefixes in productions
Date: Mon, 16 Oct 2006 21:31:19 +0000

Hello All:

I've tried Antlr for a small project over the last few days, and so far it 
has been good.
However, I'm having a problem with an optional prefix that is specified in 
the language
I'm parsing, and I don't know whether:
1) LL(k) parsers can handle such a construct (although I hope so, so that I 
can use ANTLR)
2) If they can handle such a construct, what is the right way to pose the 
grammar for them

Consider the following (simple) example using ANTLR pseudocode, if you need 
the
complete ANTLR source for the example let me know and I'll try to post it.

.// Lexer rules,  use case insensitive lexemes
A: 'A' | 'a';
B: 'B' | 'b';
C: 'C' | 'c';
// Usual White space and new line stuff were in the code but are omitted 
here

Now my parser has the rules:
// Uses the optional prefix of A or nothing
startRule // Gets nondeterminism warning from ANTLR, even with k=7 parser 
look ahead
  :
     opta1:optA b:B
  |
     opta2:optA c:C
;

// This is the parser's rule for the optional prefix
optA
   :
       a:A
   |
      .// empty
   ;

I'm using the windows version from the Source Forge Eclipse plugin at
http://sourceforge.net/project/showfiles.php?group_id=55477 (Antlr 2.5.76).
Is there a way to refactor the grammar to fix this?

Thanks for your help:

Bill M. (sorry my last name is unusual and generates a lot of spam)

Disclaimer:  These opinions and questions are my own and are not those of my 
employer.

__

_________________________________________________________________
Stay in touch with old friends and meet new ones with Windows Live Spaces 
http://clk.atdmt.com/MSN/go/msnnkwsp0070000001msn/direct/01/?href=http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us


From nicolas.rouquette at jpl.nasa.gov  Thu Oct 19 15:49:45 2006
From: nicolas.rouquette at jpl.nasa.gov (Nicolas Rouquette)
Date: Thu, 19 Oct 2006 22:49:45 +0000 (UTC)
Subject: [antlr-interest] Tree grammars & optional AST nodes
Message-ID: <loom.20061020T002909-189@post.gmane.org>

When using ANTLR3 for tree grammars, I've noticed some annoying behavior.

Suppose that we take a grammar like Java1.5:

expression
 : conditionalExpression (assignmentOperator expression)?
 ;

conditionalExpression
 : conditionalOrExpression ( '?' expression ':' expression )?
 ;

...


As a tree grammar, it would make sense to write:

expression
 : conditionalExpression
 | e1=conditionalExpression op=assignmentOperator e2=expression
   -> ^($op $e1 $e2)
 ;

conditionalExpression
 : conditionalOrExpression
 | c=conditionalOrExpression '?' e1=expression ':' e2=expression
   -> ^(IF_THEN_ELSE $c $e1 $e2)
 ;

...

I get a bunch of errors:

internal eror: 
org.antlr.tool.Grammar.createLookaheadDFA(Grammar.java:778):
could not even do k=1 for decision <N>

for some value of <N>

When I run Antlr with the -Xwatchconversion option,
I see that the culprit is in 'expression' and 'conditionalExpression'.

To get rid of these errors, I changed the grammar like this:

expression
 : e1=conditionalExpression (op=assignmentOperator e2=expression)?
   -> ^(COND_EXPR $e1 $op? $e2?)
 ;

conditionalExpression
 : c=conditionalOrExpression ('?' e1=expression ':' e2=expression)?
   -> ^(IF_THEN_ELSE $c $e1? $e2?)
 ;

...

This would be OK except that when parsing the mother-of-all expressions, 42,
we'd get something like this:

COND_EXPR -> IF_THEN_ELSE -> .... -> (INTEGER 42)

when instead I'd like to have just:

(INTEGER 42)

So here are my universal questions:

a) is there a better way to write the tree grammar
   to avoid non-essential AST nodes?
b) if not, can someone point me to an example of a "cleanup" tree phase
   that eliminate all but the essential AST nodes?

-- Nicolas.

P.S. Yes, Antlr3 is really cool; ANTLRWorks makes lazy look cool.



From nicolas.rouquette at jpl.nasa.gov  Thu Oct 19 15:34:03 2006
From: nicolas.rouquette at jpl.nasa.gov (Nicolas Rouquette)
Date: Thu, 19 Oct 2006 22:34:03 +0000 (UTC)
Subject: [antlr-interest] Tree grammars & optional AST nodes
Message-ID: <loom.20061020T002909-189@post.gmane.org>

An ANTLR3 / ANTLRWorks newbie question, if I may.

The Java1.5 ANTLR3 grammar has rules like this:

expression
:	conditionalExpression (assignmentOperator expression)?
	;
conditionalExpression
    :   conditionalOrExpression ( '?' expression ':' expression )?
	;


From parrt at cs.usfca.edu  Thu Oct 19 16:14:21 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 16:14:21 -0700
Subject: [antlr-interest] [stringtemplate-interest] File based templates
	and maps.
In-Reply-To: <453804C4.4080207@ezswitch.net>
References: <4536C3E0.4030404@ezswitch.net>	<6C894A5E-8129-41D0-83DD-B8AF272214A2@cs.usfca.edu>	<4537B0F1.2060301@ezswitch.net>
	<88B73234-4618-4EEF-81B1-1A19C90F0E55@cs.usfca.edu>
	<4537B855.4020201@ezswitch.net>
	<6F95EDBA-902A-4209-919E-4C903C0BD6D8@cs.usfca.edu>
	<453804C4.4080207@ezswitch.net>
Message-ID: <9D940B5F-56CA-47C0-83A8-06C8F37254E1@cs.usfca.edu>

Wow!  Interesting...seems a bug.

added:

http://www.antlr.org/wiki/display/ST/numbers+not+allowed+as+keys

Ter
On Oct 19, 2006, at 4:05 PM, Caleb Lyness wrote:

> Terence Parr wrote:
>> try now...a spammer created 100 spam users. :(
> Sorted.
> -----
>
> Here is another problem I ran into while playing with maps:
>
> If the map has a number in the key you can't reference it directly.
>
> E.g.
>
> The map is defined as:
>
> collectionFailure ::= [
>   "1":     "Revoked",
>   "2":     "Other",
>   "A":     "Settled",
>   "B":     "Frozen",
>   default: "Unknown"
> ]
>
> If a tempate .st file refers to the map directly
>
> $collectionFailure.1$     - it fails (see below)
> $collectionFailure.A$     - works
>
> but if I use $collectionFailure.(reasonCode)$
> then Bobs your uncle it can be 1 or A...
>
> action parse error in group base templates line 0; template context  
> is [bodies/example1]
> line 1:19: unexpected token: 1
>     at org.antlr.stringtemplate.language.ActionParser.primaryExpr 
> (ActionParser.java:703)
>     at org.antlr.stringtemplate.language.ActionParser.expr 
> (ActionParser.java:430)
>     at org.antlr.stringtemplate.language.ActionParser.templatesExpr 
> (ActionParser.java:212)
>     at org.antlr.stringtemplate.language.ActionParser.action 
> (ActionParser.java:126)
>
>> Ter
>>
>> On Oct 19, 2006, at 10:39 AM, Caleb Lyness wrote:
>>
>>>>> I think it would be nice for future newbies if there was an  
>>>>> example along side the file based template (.st) method in the  
>>>>> source. Would speed the learning curve up a bit. cf: src\org 
>>>>> \antlr\stringtemplate\test.
>>>> Add a quick tutorial :) http://www.antlr.org/wiki/display/ST/ 
>>>> Tutorials
>>> Pitty, I cannot:
>>> I don't have a login and I can't create one.
>>>
>>> The following error(s) occurred:
>>> This installation of Confluence is not licensed to add any more  
>>> users. Please contact the site administrators for more information.
>>>
>>>
>>
>>
>


From parrt at cs.usfca.edu  Thu Oct 19 16:30:47 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 16:30:47 -0700
Subject: [antlr-interest] Tree grammars & optional AST nodes
In-Reply-To: <loom.20061020T002909-189@post.gmane.org>
References: <loom.20061020T002909-189@post.gmane.org>
Message-ID: <7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>


On Oct 19, 2006, at 3:49 PM, Nicolas Rouquette wrote:

> When using ANTLR3 for tree grammars, I've noticed some annoying  
> behavior.
>
> Suppose that we take a grammar like Java1.5:
>
> expression
>  : conditionalExpression (assignmentOperator expression)?
>  ;
>
> conditionalExpression
>  : conditionalOrExpression ( '?' expression ':' expression )?
>  ;
>
> ...
>
>
> As a tree grammar, it would make sense to write:

Hi :)

You mean a parser grammar that builds trees, right?

> expression
>  : conditionalExpression
>  | e1=conditionalExpression op=assignmentOperator e2=expression
>    -> ^($op $e1 $e2)
>  ;

Yes, but that is hard for ANTLRto deal with because conditional  
expression is recursive and ANTLR cannot decide which alternative to  
take. you could turn on the backtrack mode:

expression
options {backtrack=true;}
  : conditionalExpression
  | e1=conditionalExpression op=assignmentOperator e2=expression
    -> ^($op $e1 $e2)
  ;

  but that won't work either because it will always match the first  
alternative--you would have to reverse the alternatives.

expression
options {backtrack=true;}
  : e1=conditionalExpression op=assignmentOperator e2=expression
    -> ^($op $e1 $e2)
  | conditionalExpression
  ;

OR, do this:

expression
  : conditionalExpression (assignmentOperator^^ expression)?
  ;

:)

Hard to beat tree operators for expression stuff.

Ter

>
> conditionalExpression
>  : conditionalOrExpression
>  | c=conditionalOrExpression '?' e1=expression ':' e2=expression
>    -> ^(IF_THEN_ELSE $c $e1 $e2)
>  ;
>
> ...
>
> I get a bunch of errors:
>
> internal eror:
> org.antlr.tool.Grammar.createLookaheadDFA(Grammar.java:778):
> could not even do k=1 for decision <N>
>
> for some value of <N>
>
> When I run Antlr with the -Xwatchconversion option,
> I see that the culprit is in 'expression' and 'conditionalExpression'.
>
> To get rid of these errors, I changed the grammar like this:
>
> expression
>  : e1=conditionalExpression (op=assignmentOperator e2=expression)?
>    -> ^(COND_EXPR $e1 $op? $e2?)
>  ;
>
> conditionalExpression
>  : c=conditionalOrExpression ('?' e1=expression ':' e2=expression)?
>    -> ^(IF_THEN_ELSE $c $e1? $e2?)
>  ;
>
> ...
>
> This would be OK except that when parsing the mother-of-all  
> expressions, 42,
> we'd get something like this:
>
> COND_EXPR -> IF_THEN_ELSE -> .... -> (INTEGER 42)
>
> when instead I'd like to have just:
>
> (INTEGER 42)
>
> So here are my universal questions:
>
> a) is there a better way to write the tree grammar
>    to avoid non-essential AST nodes?
> b) if not, can someone point me to an example of a "cleanup" tree  
> phase
>    that eliminate all but the essential AST nodes?
>
> -- Nicolas.
>
> P.S. Yes, Antlr3 is really cool; ANTLRWorks makes lazy look cool.
>
>


From qwertie256 at gmail.com  Thu Oct 19 16:53:59 2006
From: qwertie256 at gmail.com (David Piepgrass)
Date: Thu, 19 Oct 2006 17:53:59 -0600
Subject: [antlr-interest] How to see the bare grammar?
Message-ID: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>

I'm examining a large grammar (boo, if you must know) where the .g file is
3400 lines. Is there a way to strip out the semantic action code, leaving
bare EBNF (preferably nicely formatted)?

I actually got a graphical representation of the grammar from the boo
website, but a textual representation would be much more compact.

-- 
- David
http://qwertie.net
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061019/24762464/attachment.html 

From lgcraymer at yahoo.com  Thu Oct 19 16:57:52 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Thu, 19 Oct 2006 16:57:52 -0700 (PDT)
Subject: [antlr-interest] How to see the bare grammar?
In-Reply-To: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>
Message-ID: <20061019235752.54714.qmail@web55903.mail.re3.yahoo.com>

There is an ANTLR 2 "pretty printer" that I posted to
the "sharing" section of antlr.org a few months ago. 
I never got around to testing all of the flags, but it
will strip out actions if you ask it to.

--Loring

--- David Piepgrass <qwertie256 at gmail.com> wrote:

> I'm examining a large grammar (boo, if you must
> know) where the .g file is
> 3400 lines. Is there a way to strip out the semantic
> action code, leaving
> bare EBNF (preferably nicely formatted)?
> 
> I actually got a graphical representation of the
> grammar from the boo
> website, but a textual representation would be much
> more compact.
> 
> -- 
> - David
> http://qwertie.net
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From nicolas.rouquette at jpl.nasa.gov  Thu Oct 19 17:09:17 2006
From: nicolas.rouquette at jpl.nasa.gov (Nicolas Rouquette)
Date: Fri, 20 Oct 2006 00:09:17 +0000 (UTC)
Subject: [antlr-interest] Tree grammars & optional AST nodes
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
Message-ID: <loom.20061020T014305-179@post.gmane.org>

Thanks for the answer!

Terence Parr <parrt at ...> writes:

> Hi :)
> 
> You mean a parser grammar that builds trees, right?

yes

> expression
> options {backtrack=true;}
>   : e1=conditionalExpression op=assignmentOperator e2=expression
>     -> ^($op $e1 $e2)
>   | conditionalExpression
>   ;
> 
> OR, do this:
> 
> expression
>   : conditionalExpression (assignmentOperator^^ expression)?
>   ;
> 
> :)
> 
> Hard to beat tree operators for expression stuff.

An ANTLR afficionado colleague suggested 
adding a simple semantic predicate 
to guide the tree construction:

@init { boolean flag=false; }
  : e1=conditionalExpression (op=assignmentOperator e2=expression {flag=true;})?
    -> {flag} ? ^($op $e1 $e2)
    -> $e1
  ;

I tried this w/ the ANTLRWorks debugger on a grammar
with several nested expression-like rules. Works very nicely!

I've used the same options as the java grammar
(although my language isn't java at all).

Adding the semantic predicate obfuscates a bit the grammar
but the price is really worth the result IMHO.

-- Nicolas. 

> Ter



From parrt at cs.usfca.edu  Thu Oct 19 17:52:15 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 19 Oct 2006 17:52:15 -0700
Subject: [antlr-interest] Tree grammars & optional AST nodes
In-Reply-To: <loom.20061020T014305-179@post.gmane.org>
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
	<loom.20061020T014305-179@post.gmane.org>
Message-ID: <E3E47602-B703-426A-80D3-1CF698D36C8F@cs.usfca.edu>


On Oct 19, 2006, at 5:09 PM, Nicolas Rouquette wrote:

>>
>> Hard to beat tree operators for expression stuff.
>
> An ANTLR afficionado colleague suggested
> adding a simple semantic predicate
> to guide the tree construction:
>
> @init { boolean flag=false; }
>   : e1=conditionalExpression (op=assignmentOperator e2=expression  
> {flag=true;})?
>     -> {flag} ? ^($op $e1 $e2)
>     -> $e1
>   ;
>
> I tried this w/ the ANTLRWorks debugger on a grammar
> with several nested expression-like rules. Works very nicely!

Hooray!

or use {$op!=null}? without the flag mumbojumbo.

> I've used the same options as the java grammar
> (although my language isn't java at all).
>
> Adding the semantic predicate obfuscates a bit the grammar
> but the price is really worth the result IMHO.

:)

Ter

From lists.steve at arachnedesign.net  Thu Oct 19 18:04:35 2006
From: lists.steve at arachnedesign.net (Steve Lianoglou)
Date: Thu, 19 Oct 2006 21:04:35 -0400
Subject: [antlr-interest] How to see the bare grammar?
In-Reply-To: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>
References: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>
Message-ID: <5F8C2193-78B2-4898-9351-75885564A39E@arachnedesign.net>

> I'm examining a large grammar (boo, if you must know) where the .g  
> file is 3400 lines. Is there a way to strip out the semantic action  
> code, leaving bare EBNF (preferably nicely formatted)?

If use the antlr plugin (http://antlreclipse.sourceforge.net/) with  
Eclipse, there is an "Overview" tab that you can select while looking  
at your grammar file.

It appears as if it removes some of the extra antlr stuff.

For instance, this in the normal grammar:

if_statement
	:	"if"^ LPAREN! test RPAREN! (statement | block)
		(	// combat the dangling else -- inspired by the java1.5 grammar
			options { warnWhenFollowAmbig = false; }:
			"else"! (statement | block)
		)?
	;

Is turned into this in the "Overview":
if_statement :
	"if" LPAREN test RPAREN
	( statement | block )
	( "else" ( statement | block ) )?
	;

I'm guessing it may do something similar for the rest of the things  
you'd like to temporarily "get out of the way"

-steve



From sridharxp at gmail.com  Thu Oct 19 18:18:24 2006
From: sridharxp at gmail.com (Sridharan S)
Date: Fri, 20 Oct 2006 06:48:24 +0530
Subject: [antlr-interest] newbie help
Message-ID: <e43731080610191818k317e8ef7sd053fd43224106aa@mail.gmail.com>

 Hi everybody

I am a new to antlr and I have two problems.

One is my grammar has keywords that can also be used interchangeably in
their shortened form of 4 chars. What to do to avoid doubling of keywords?

Second is my language statement always ends in a newline with one exception.
Eof can also work as a newline.ie When at the end of your program you need
not supply a newline, it is optional. .

Thanks everybody
- Sridhar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061020/bfa47ee3/attachment.html 

From ric.klaren at gmail.com  Fri Oct 20 00:28:31 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Fri, 20 Oct 2006 09:28:31 +0200
Subject: [antlr-interest] How to see the bare grammar?
In-Reply-To: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>
References: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>
Message-ID: <bc607a4e0610200028m9638e57ve9a2d8264416030c@mail.gmail.com>

Hi,

On 10/20/06, David Piepgrass <qwertie256 at gmail.com> wrote:
> I'm examining a large grammar (boo, if you must know) where the .g file is
> 3400 lines. Is there a way to strip out the semantic action code, leaving
> bare EBNF (preferably nicely formatted)?
>
> I actually got a graphical representation of the grammar from the boo
> website, but a textual representation would be much more compact.

If this is for antlr2 then you can use the -html or -docbook options
to generate a HTML or docbook XML file.

Cheers,

Ric

From foolishewe at hotmail.com  Fri Oct 20 05:19:22 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Fri, 20 Oct 2006 12:19:22 +0000
Subject: [antlr-interest] newbie help
In-Reply-To: <e43731080610191818k317e8ef7sd053fd43224106aa@mail.gmail.com>
Message-ID: <BAY107-F273733EED561762BB43338C00D0@phx.gbl>



Hello All:

I'm sorry if this appears twice, the original message may have been 
accidentally
sent before I finished typing.

Regarding the first problem, the, I have keyword/reserved word completion in 
a grammar
I am working on, and I handle it in the lexer by creating rules of the form:

TOKENTORETURN: mandatoryprefix  (optionalsuffix)? ;

Where TOKENTORETURN is the token generated for parsing
mandatoryprefix is the shortest accepted version of the key word
and optionalsuffix recursively adds characters optionally until the keyword 
is complete.

For example suppose we have a reserved word, "interface" and for now let's 
restrict
ourself to lowercase letters only.  If we want to recognice "inter", 
"interf", "interfa", "interfac"
and "interface", we could do something of the form:
INTERFACE: "inter" ('f' ('a' ('c' ('e')?)?)?)?;

This appears to work using the 2.7.6 version of ANTLR.
>From what I can tell, you do need to be careful that the mandatory prefix is 
sufficiently
long that keywords do not become ambiguous, e.g. if your language
had say "char" and "const" as keywords, you could not abbreviate one of them 
as "c".

Regarding EOF handling, I'm not quite sure about that, I'm pretty new to 
ANTLR,
and am wondering about that one myself.

Regards:

Bill M.
>From: "Sridharan S" <sridharxp at gmail.com>
>To: antlr-interest at antlr.org
>Subject: [antlr-interest] newbie help
>Date: Fri, 20 Oct 2006 06:48:24 +0530
>
>Hi everybody
>
>I am a new to antlr and I have two problems.
>
>One is my grammar has keywords that can also be used interchangeably in
>their shortened form of 4 chars. What to do to avoid doubling of keywords?
>
>Second is my language statement always ends in a newline with one 
>exception.
>Eof can also work as a newline.ie When at the end of your program you need
>not supply a newline, it is optional. .
>
>Thanks everybody
>- Sridhar

_________________________________________________________________
All-in-one security and maintenance for your PC.  Get a free 90-day trial! 
http://clk.atdmt.com/MSN/go/msnnkwlo0050000002msn/direct/01/?href=http://www.windowsonecare.com/?sc_cid=msn_hotmail


From jimi at intersystems.com  Fri Oct 20 08:33:24 2006
From: jimi at intersystems.com (Jim Idle)
Date: Fri, 20 Oct 2006 11:33:24 -0400
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <795F0BE0-3A6C-4E54-9B56-EDC3E38050A2@cs.usfca.edu>
Message-ID: <20061020153326.17EC31500@mail.intersystems.com>

The heap space is a n issue on larger grammars and there are some issues with it getting bigger and bigger etc. However, I am sure these will go away over time. 

In order to circumvent the error (but not the memory use ;-), I start works with:

java.exe -Xmx1000M ...

It is really useful for graphically seeing why your grammar has ambiguities that need various additions to solve them.

As a rule of thumb, do this:

1) See if you can think of a way to express the formation without needing to parse ahead in some way (write it such that the minimum number of tokens are required to distinguish one rule from another);
2) After doing 1, if you still have ambiguities, then you need to start adding predicates of one sort or another, preferably again with the minimum number of tokens in the predicate to make a decision.

Using your grammar, we can take:

add_column_clause_ss :
	table_element_ss
	(BEFORE identifier)?
	;

This has ambiguity because the BEFORE should always belong to table_element_ss but can also be skipped and BEFORE used as an indentifer it seems (works will show you the circuitous route by which this can happen).

So, it seems first that you need to solve the identifier issues perhaps, but you can solve this particular issue by:

add_column_clause_ss :
	table_element_ss
	( options {k=1;} : (BEFORE)=>(BEFORE identifier))?
	;

Now, remember that I have not looked at the grammar itself to see if you could formulate this differently by left factoring other rules and so on, which is better if you can do it. You could also turn on backtracking, which might help this complex grammar. You have quite a lot of contructs that complain about recursive calls for instance. k options might deal with these.

Your lexer also complains that it cannot reach many of your tokens. IN many cases this seems to be because you are trying to construct the parser within the lexer:

CLOSE_SESSION:
       'CLOSE' 'SESSION'
     ;

This is really just looking for one word 'CLOSESESSION'. You need to make the lexer rules much simpler placing the keywords and string definitions and identifiers etc in the order in which they should be seen. So the Id rule probably comes after your keywords, which would otherwise clash with the ID rule.


Then you have a parser rule:

close_session:

	CLOSE SESSION ;

Solving any ambiguities there.

I hope this helps to put you on the right track?

Jim







-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Terence Parr
Sent: Thursday, October 19, 2006 9:54 AM
To: ANTLR Interest
Subject: Re: [antlr-interest] Bison-> Antlr 3 help


On Oct 19, 2006, at 9:48 AM, Mike Aubury wrote:

> yeah...
> it runs out of heap space :) - but apart from that - it  
> (antlrworks) looks like a great tool for grammar development...

I run from command line with more ram and it's cool.  ANTLR is a  
pig ;)  'course so is swing.

> I could really do with knowing whats actually wrong and whats  
> needed to fix it.

Try more ram.
Ter

-- 
No virus found in this incoming message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.8/489 - Release Date: 10/20/2006
 

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.8/489 - Release Date: 10/20/2006
 

From antlr at aubit.com  Fri Oct 20 09:00:49 2006
From: antlr at aubit.com (Mike Aubury)
Date: Fri, 20 Oct 2006 17:00:49 +0100
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <20061020153326.17EC31500@mail.intersystems.com>
References: <20061020153326.17EC31500@mail.intersystems.com>
Message-ID: <200610201700.49404.antlr@aubit.com>

Cheer for that..
The idea with the 'CLOSE' 'SESSION' - was that I was (wrong) thinking it would 
do 'words' with strings (rather than single characters) in the quotes - I can 
see I'll need to do that with some whitespace in there...

Basically - the 
        close_session:
                        CLOSE_SESSION

comes from a lex token ("CLOSE SESSION" {... return CLOSE_SESSION;}
(ok - its not quite that simple - but you get the idea - remember I'm trying 
to port from bison/lex here)

>
> add_column_clause_ss :
>       table_element_ss
>       (BEFORE identifier)?
>       ;

The language is very verbose - that particular bit is part of the SQL ALTER 
statement - so at that point, BEFORE couldn't be an identifier - if 
the 'lexer' saw the word 'BEFORE' i'd want it as a 'reserved word', rather 
than the identifier..
In fact - if it can match to a reserved word at any point in the grammer - I'd 
want it to select that and not an 'ID' - is there any simple way to do that ? 



-- 
Mike Aubury


From jimi at intersystems.com  Fri Oct 20 09:06:06 2006
From: jimi at intersystems.com (Jim Idle)
Date: Fri, 20 Oct 2006 12:06:06 -0400
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <200610201658.08218.mike.aubury@aubit.com>
Message-ID: <20061020160607.684511613@mail.intersystems.com>

You would need an identifier rule and a keyword_id rule, you might also want to use hoisted predicates if there are places where the keywords are not identifiers such as where an identifier is optional and can be logically followed by some keyword, but basically something akin to:

identifier: ID | ( options {k=1;} : (keyword_id)=>keyword_id) ;

keyword_id: KEYWORD1 | KEYWORD2 |KEYWORD3 ....

This won't work for everything though, your own grammar requirements will have to be built in to it of course to avoid all the ensuing ambiguities.

Jim

-----Original Message-----
From: Mike Aubury [mailto:mike.aubury at aubit.com] 
Sent: Friday, October 20, 2006 8:58 AM
To: antlr-interest at antlr.org
Cc: Jim Idle
Subject: Re: [antlr-interest] Bison-> Antlr 3 help

Cheer for that..
The idea with the 'CLOSE' 'SESSION' - was that I was (wrong) thinking it would 
do 'words' with strings (rather than single characters) in the quotes - I can 
see I'll need to do that with some whitespace in there...

Basically - the 
	close_session:
			CLOSE_SESSION

comes from a lex token ("CLOSE SESSION" {... return CLOSE_SESSION;}
(ok - its not quite that simple - but you get the idea)

>
> add_column_clause_ss :
> 	table_element_ss
> 	(BEFORE identifier)?
> 	;

The language is very verbose - that particular bit is part of the SQL ALTER 
statement - so at that point, BEFORE couldn't be an identifier - if 
the 'lexer' saw the word 'BEFORE' i'd want it as a 'reserved word', rather 
than the identifier..
In fact - if it can match to a reserved word at any point in the grammer - I'd 
want it to select that and not an 'ID' - is there any simple way to do that ? 



-- 
Mike Aubury


-- 
No virus found in this incoming message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.8/489 - Release Date: 10/20/2006
 

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.8/489 - Release Date: 10/20/2006
 

From antlr at aubit.com  Fri Oct 20 09:14:27 2006
From: antlr at aubit.com (Mike Aubury)
Date: Fri, 20 Oct 2006 17:14:27 +0100
Subject: [antlr-interest] Bison-> Antlr 3 help
In-Reply-To: <20061020160607.684511613@mail.intersystems.com>
References: <20061020160607.684511613@mail.intersystems.com>
Message-ID: <200610201714.27425.antlr@aubit.com>


What I need is for BEFORE to only be the BEFORE token when its valid as a 
token at that point in the grammar. 
If its not valid - that I'd want it to be an identifier - I'm not sure that 
the keyword stuff below would do that ? 

FWIW - I spent weeks getting a lexer to only allow tokens that were allowed at 
that state for use with bison (basically had to decipher the generated 
y.output = major pain)..
If possible - I'd really like to avoid having to do that again!



On Friday 20 October 2006 17:06, Jim Idle wrote:
> You would need an identifier rule and a keyword_id rule, you might also
> want to use hoisted predicates if there are places where the keywords are
> not identifiers such as where an identifier is optional and can be
> logically followed by some keyword, but basically something akin to:
>
> identifier: ID | ( options {k=1;} : (keyword_id)=>keyword_id) ;
>
> keyword_id: KEYWORD1 | KEYWORD2 |KEYWORD3 ....
>
> This won't work for everything though, your own grammar requirements will
> have to be built in to it of course to avoid all the ensuing ambiguities.
>
> Jim

-- 
Mike Aubury


From wboese at ptd.net  Fri Oct 20 12:15:19 2006
From: wboese at ptd.net (Bill Boese)
Date: Fri, 20 Oct 2006 15:15:19 -0400
Subject: [antlr-interest] Newbie question: has anyone been able to build the
	PL/SQL Grammar?
Message-ID: <000f01c6f47c$158a3920$0600a8c0@ingres.prv>

Hi:
 
I am trying to work with the PL/SQL grammar on the website at:
 
http://www.antlr.org/grammar/1107752678378/PLSQLGrammar.g
 
and I am getting the errors below:
 
+++++++++++++++++++++++++++++++++++++++++++++++
 
C:\antlr-2.7.6\examples\plsql>java antlr.Tool PLSQLGrammar.g
ANTLR Parser Generator   Version 2.7.6 (2005-12-22)   1989-2005
PLSQLGrammar.g:1029:9: Treewalkers only support k=1
Exiting due to errors.
 
+++++++++++++++++++++++++++++++++++++++++++++++
 
The referenced line sets the option k = 4, so I am wondering if I am missing
something obvious or if this
was likely developed on a previous version of antlr (I'm using 2.7.6).
 
Thanks in advance,
 
Bill
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061020/609b98d5/attachment.html 

From parrt at cs.usfca.edu  Fri Oct 20 13:48:05 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 20 Oct 2006 13:48:05 -0700
Subject: [antlr-interest] Newbie question: has anyone been able to build
	the PL/SQL Grammar?
In-Reply-To: <000f01c6f47c$158a3920$0600a8c0@ingres.prv>
References: <000f01c6f47c$158a3920$0600a8c0@ingres.prv>
Message-ID: <E762DDC0-63CC-416A-AC2C-511319A5B20E@cs.usfca.edu>


On Oct 20, 2006, at 12:15 PM, Bill Boese wrote:

> Hi:
>
> I am trying to work with the PL/SQL grammar on the website at:
>
> http://www.antlr.org/grammar/1107752678378/PLSQLGrammar.g
>
> and I am getting the errors below:
>
> +++++++++++++++++++++++++++++++++++++++++++++++
>
> C:\antlr-2.7.6\examples\plsql>java antlr.Tool PLSQLGrammar.g
> ANTLR Parser Generator   Version 2.7.6 (2005-12-22)   1989-2005
> PLSQLGrammar.g:1029:9: Treewalkers only support k=1
> Exiting due to errors.

Did you change it to extend TreeParser not Parser?

Ter

>
> +++++++++++++++++++++++++++++++++++++++++++++++
>
> The referenced line sets the option k = 4, so I am wondering if I  
> am missing something obvious or if this
> was likely developed on a previous version of antlr (I'm using 2.7.6).
>
> Thanks in advance,
>
> Bill


From lgcraymer at yahoo.com  Fri Oct 20 14:14:14 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Fri, 20 Oct 2006 14:14:14 -0700 (PDT)
Subject: [antlr-interest] Newbie question: has anyone been able to build
	the PL/SQL Grammar?
In-Reply-To: <000f01c6f47c$158a3920$0600a8c0@ingres.prv>
Message-ID: <20061020211414.49684.qmail@web55903.mail.re3.yahoo.com>

Bill--

Just delete that line.  ANTLR 2 treewalkers are
effectively k=1.

--Loring

--- Bill Boese <wboese at ptd.net> wrote:

> Hi:
>  
> I am trying to work with the PL/SQL grammar on the
> website at:
>  
>
http://www.antlr.org/grammar/1107752678378/PLSQLGrammar.g
>  
> and I am getting the errors below:
>  
> +++++++++++++++++++++++++++++++++++++++++++++++
>  
> C:\antlr-2.7.6\examples\plsql>java antlr.Tool
> PLSQLGrammar.g
> ANTLR Parser Generator   Version 2.7.6 (2005-12-22) 
>  1989-2005
> PLSQLGrammar.g:1029:9: Treewalkers only support k=1
> Exiting due to errors.
>  
> +++++++++++++++++++++++++++++++++++++++++++++++
>  
> The referenced line sets the option k = 4, so I am
> wondering if I am missing
> something obvious or if this
> was likely developed on a previous version of antlr
> (I'm using 2.7.6).
>  
> Thanks in advance,
>  
> Bill
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From autophile at zoominternet.net  Fri Oct 20 18:42:05 2006
From: autophile at zoominternet.net (Robert Baruch)
Date: Fri, 20 Oct 2006 21:42:05 -0400
Subject: [antlr-interest] What's wrong with this grammar? (2.7.6)
Message-ID: <AAD63B20-CACD-41F4-9651-1DD5B20ACE43@zoominternet.net>

Here is a test grammar I was putting together and running through  
ANTLR 2.7.6:

header { package generated; }
class TestParser extends Parser;
options { k=2; }

r0 : . * ;

class TestLexer extends Lexer;

N : 'n';
V : 'v';


Really, all it says is that a valid sentence is any token, any number  
of times. Without the *, it works fine, but with the *, the output is:

ANTLR Parser Generator   Version 2.7.6 (2005-12-22)   1989-2005
generated.g:5:6: rule classDef trapped:
generated.g:5:6: unexpected token: .
error: aborting grammar 'TestParser' due to errors
Exiting due to errors.

So what is wrong with . *?

Thanks,

--Rob



From parrt at cs.usfca.edu  Fri Oct 20 18:49:37 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 20 Oct 2006 18:49:37 -0700
Subject: [antlr-interest] What's wrong with this grammar? (2.7.6)
In-Reply-To: <AAD63B20-CACD-41F4-9651-1DD5B20ACE43@zoominternet.net>
References: <AAD63B20-CACD-41F4-9651-1DD5B20ACE43@zoominternet.net>
Message-ID: <ABC23567-BE02-4BBD-8588-C86EECF0296D@cs.usfca.edu>

(.)*
Ter
On Oct 20, 2006, at 6:42 PM, Robert Baruch wrote:

> Here is a test grammar I was putting together and running through  
> ANTLR 2.7.6:
>
> header { package generated; }
> class TestParser extends Parser;
> options { k=2; }
>
> r0 : . * ;
>
> class TestLexer extends Lexer;
>
> N : 'n';
> V : 'v';
>
>
> Really, all it says is that a valid sentence is any token, any  
> number of times. Without the *, it works fine, but with the *, the  
> output is:
>
> ANTLR Parser Generator   Version 2.7.6 (2005-12-22)   1989-2005
> generated.g:5:6: rule classDef trapped:
> generated.g:5:6: unexpected token: .
> error: aborting grammar 'TestParser' due to errors
> Exiting due to errors.
>
> So what is wrong with . *?
>
> Thanks,
>
> --Rob
>
>


From nicolas.rouquette at jpl.nasa.gov  Fri Oct 20 23:24:47 2006
From: nicolas.rouquette at jpl.nasa.gov (Nicolas Rouquette)
Date: Sat, 21 Oct 2006 06:24:47 +0000 (UTC)
Subject: [antlr-interest] Tree grammars & optional AST nodes
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
	<loom.20061020T014305-179@post.gmane.org>
	<E3E47602-B703-426A-80D3-1CF698D36C8F@cs.usfca.edu>
Message-ID: <loom.20061021T063344-672@post.gmane.org>

Terence Parr <parrt at ...> writes:

> On Oct 19, 2006, at 5:09 PM, Nicolas Rouquette wrote:
> 
> >  <at> init { boolean flag=false; }
> >   : e1=conditionalExpression (op=assignmentOperator e2=expression  
> > {flag=true;})?
> >     -> {flag} ? ^($op $e1 $e2)
> >     -> $e1
> >   ;
> 
> or use {$op!=null}? without the flag mumbojumbo.

Thanks for this suggestion; however, there's one small glitch...
If I write:

expression
 : e1=conditionalExpression (op=assignmentOperator e2=expression)?
   -> {$op!=null} ? ^($op $e1 $e2)
   -> $e1
 ;

3.0b4 produces this kind of code:

if ($op!=null) {
  // the code for ^($op $e1 $e2)
} else {
  // the code for $e1
}

... and a telltale error message:

missing attribute access on rule scope: op

If, instead of {$op!=null} I try: {$expression.op!=null}
the code produce has a similar problem:

if ($expression.op!=null) ...

and the message is equally informative:

unknown attribute for rule expression: op

After some digging, I found that these messages
from from ERROR_X and ERROR_XY respectively in action.g

This gives a lot of clues w.r.t. troubleshooting this problem
since it's clear that none of the other lexer rules found
the action stuff palatable enough to eat it before the
voracious ERROR_X/Y rules did.

Which rules ought have matched?
Looks to me that we'd expect:

"$op" => LABEL_REF
"$expression.op" => TOKEN_SCOPE_ATTR

At this point, I don't know enough about the internal states 
of the lexer & parser to tell why the rules didn't match.

It's possible that my analysis is wrong,
that the problem is elsewhere entirely.
I tried some variations, including checking against
a non-optional part of the rule, e.g.:

expression 
  : e1=... (... e2=...)?
    -> {$e1!=null} ...

The results are the than if I check the optional part of the rule.

-- Nicolas.
 
> Ter
> 
> 





From nicolas.rouquette at jpl.nasa.gov  Fri Oct 20 23:42:11 2006
From: nicolas.rouquette at jpl.nasa.gov (Nicolas Rouquette)
Date: Sat, 21 Oct 2006 06:42:11 +0000 (UTC)
Subject: [antlr-interest] Tree grammars & optional AST nodes
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
	<loom.20061020T014305-179@post.gmane.org>
	<E3E47602-B703-426A-80D3-1CF698D36C8F@cs.usfca.edu>
	<loom.20061021T063344-672@post.gmane.org>
Message-ID: <loom.20061021T083113-58@post.gmane.org>

Nicolas Rouquette <nicolas.rouquette at ...> writes:

> 
> Terence Parr <parrt <at> ...> writes:
> 
> > On Oct 19, 2006, at 5:09 PM, Nicolas Rouquette wrote:
> > 
> > >  <at> init { boolean flag=false; }
> > >   : e1=conditionalExpression (op=assignmentOperator e2=expression  
> > > {flag=true;})?
> > >     -> {flag} ? ^($op $e1 $e2)
> > >     -> $e1
> > >   ;
> > 
> > or use {$op!=null}? without the flag mumbojumbo.

Bizarre... {op!=null} works.

I surprised action.g didn't barf at this.
It seems to work which is perplexing.

-- Nicolas.



From kroepke at classdump.org  Sat Oct 21 02:42:01 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sat, 21 Oct 2006 11:42:01 +0200
Subject: [antlr-interest] Usage of scopes in v3
Message-ID: <B9512779-E0E9-42C0-BFB5-AB3F01B89A6E@classdump.org>

Hi Ter,*!

I have played around with dynamic rule scopes over the last week or  
so and was wondering what the current best-practice was.
If you consider the symtab example for v3 below, I was wondering how  
you would go ahead in an implementation of a symbol table while using  
scopes.

A na?ve approach would be the @finally action below, which fails  
because right before the comment the current Symbol scope would be  
popped from the block. You would naturally need to access the Symbol  
scope to enter its entries into your program's symbol table which  
would not go away when the rule exits. The obvious solution is to add  
an action to the end of the rule block to do the transition so it  
doesn't execute when the rule fails.
Is this actually the recommended way or is there something I  
overlook? The downside with the @finally route is of course that it  
gets executed regardless whether the rule failed or not, so you'd  
have to guard against that manually. Same goes for backtracking.

cheers,
-k

grammar SymtabTestParser;

/* Scope of symbol names.  Both globals and block rules need to push  
a new
* symbol table upon entry and they must use the same stack.  So, I must
* define a global scope and say that globals and block use this by  
saying
* 'scope Symbols;' in those rule definitions.
*/
scope Symbols {
   List names;
}
[...]
block
scope Symbols;
@init {
     level++;
     $Symbols::names = new ArrayList();
}
@finally {
         // is $Symbols::names still valid here?
}
     :   '{' (decl)* (stat)* '}'
         {
         System.out.println("level "+level+" symbols: "+ 
$Symbols::names);
         level--;
         }
     ;
[...]


-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From matthias.gutheil at informatik.uni-mannheim.de  Sat Oct 21 04:54:31 2006
From: matthias.gutheil at informatik.uni-mannheim.de (Matthias Gutheil)
Date: Sat, 21 Oct 2006 13:54:31 +0200
Subject: [antlr-interest] How to look only for one rule?
In-Reply-To: <ABC23567-BE02-4BBD-8588-C86EECF0296D@cs.usfca.edu>
References: <AAD63B20-CACD-41F4-9651-1DD5B20ACE43@zoominternet.net>
	<ABC23567-BE02-4BBD-8588-C86EECF0296D@cs.usfca.edu>
Message-ID: <453A0A77.7050204@informatik.uni-mannheim.de>

Hello,

I am writing a fuzzy C grammar and I am only interesting in methods with 
parameters and return values.

The method definition is not the problem, but I want to skip anything else.
For example something like (method | ~method) doesn't work, cause so the 
first token af a real method (return type or name) goes in ~method.

Some tips?

Matthias

From peter.palotas at gmail.com  Sat Oct 21 05:27:19 2006
From: peter.palotas at gmail.com (Peter Palotas)
Date: Sat, 21 Oct 2006 14:27:19 +0200
Subject: [antlr-interest] How to get filename into token (c++)?
Message-ID: <bca7b0010610210527p4c9005f2q369c777a753ad514@mail.gmail.com>

I'm having some real problems getting filename information for tokens in
C++. It seems the default token class simply does nothing when setFilename()
is called.

How can I make ANTLR use a custom Token class, that does recognize
setFilename()?

Sincerely, Peter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061021/6d85139d/attachment-0001.html 

From peter.palotas at gmail.com  Sat Oct 21 05:57:10 2006
From: peter.palotas at gmail.com (Peter Palotas)
Date: Sat, 21 Oct 2006 14:57:10 +0200
Subject: [antlr-interest] How to get filename into token (c++)?
In-Reply-To: <bca7b0010610210527p4c9005f2q369c777a753ad514@mail.gmail.com>
References: <bca7b0010610210527p4c9005f2q369c777a753ad514@mail.gmail.com>
Message-ID: <bca7b0010610210557r54702d67h1246077492e2c783@mail.gmail.com>

Forgot to mention that I am using ANTLR 2.7.6.

On 10/21/06, Peter Palotas <peter.palotas at gmail.com> wrote:
>
> I'm having some real problems getting filename information for tokens in
> C++. It seems the default token class simply does nothing when setFilename()
> is called.
>
> How can I make ANTLR use a custom Token class, that does recognize
> setFilename()?
>
> Sincerely, Peter
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061021/8f777766/attachment.html 

From qwertie256 at gmail.com  Sat Oct 21 08:30:16 2006
From: qwertie256 at gmail.com (David Piepgrass)
Date: Sat, 21 Oct 2006 09:30:16 -0600
Subject: [antlr-interest] How to see the bare grammar?
In-Reply-To: <bc607a4e0610200028m9638e57ve9a2d8264416030c@mail.gmail.com>
References: <ce40b1470610191653n6786dce5mccbe2aa74232c7f0@mail.gmail.com>
	<bc607a4e0610200028m9638e57ve9a2d8264416030c@mail.gmail.com>
Message-ID: <ce40b1470610210830g5d0faa57x903eed2b9f243e6a@mail.gmail.com>

Thanks. The HTML output is useful, although not at all compact.

(oops, I keep forgetting to reply to the list)

On 10/20/06, Ric Klaren <ric.klaren at gmail.com> wrote:
>
> Hi,
>
> On 10/20/06, David Piepgrass <qwertie256 at gmail.com> wrote:
> > I'm examining a large grammar (boo, if you must know) where the .g file
> is
> > 3400 lines. Is there a way to strip out the semantic action code,
> leaving
> > bare EBNF (preferably nicely formatted)?
> >
> > I actually got a graphical representation of the grammar from the boo
> > website, but a textual representation would be much more compact.
>
> If this is for antlr2 then you can use the -html or -docbook options
> to generate a HTML or docbook XML file.
>
-- 
- David
http://qism.blogspot.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061021/fc2411e3/attachment.html 

From parrt at cs.usfca.edu  Sat Oct 21 09:35:53 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 21 Oct 2006 09:35:53 -0700
Subject: [antlr-interest] Tree grammars & optional AST nodes
In-Reply-To: <loom.20061021T063344-672@post.gmane.org>
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
	<loom.20061020T014305-179@post.gmane.org>
	<E3E47602-B703-426A-80D3-1CF698D36C8F@cs.usfca.edu>
	<loom.20061021T063344-672@post.gmane.org>
Message-ID: <8785C2AD-F057-490B-912C-F9AF838B930D@cs.usfca.edu>


On Oct 20, 2006, at 11:24 PM, Nicolas Rouquette wrote:

> Terence Parr <parrt at ...> writes:
>
>> On Oct 19, 2006, at 5:09 PM, Nicolas Rouquette wrote:
>>
>>>  <at> init { boolean flag=false; }
>>>   : e1=conditionalExpression (op=assignmentOperator e2=expression
>>> {flag=true;})?
>>>     -> {flag} ? ^($op $e1 $e2)
>>>     -> $e1
>>>   ;
>>
>> or use {$op!=null}? without the flag mumbojumbo.
>
> Thanks for this suggestion; however, there's one small glitch...
> If I write:
>
> expression
>  : e1=conditionalExpression (op=assignmentOperator e2=expression)?
>    -> {$op!=null} ? ^($op $e1 $e2)
>    -> $e1
>  ;
>
> 3.0b4 produces this kind of code:
>
> if ($op!=null) {
>   // the code for ^($op $e1 $e2)
> } else {
>   // the code for $e1
> }
>
> ... and a telltale error message:
>
> missing attribute access on rule scope: op

Oh.  It wants $op.tree or something.  Which which is the problem?  ^ 
($op i guess.  Try {$op.tree} for now.

Ter



From parrt at cs.usfca.edu  Sat Oct 21 09:36:43 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 21 Oct 2006 09:36:43 -0700
Subject: [antlr-interest] Tree grammars & optional AST nodes
In-Reply-To: <loom.20061021T083113-58@post.gmane.org>
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
	<loom.20061020T014305-179@post.gmane.org>
	<E3E47602-B703-426A-80D3-1CF698D36C8F@cs.usfca.edu>
	<loom.20061021T063344-672@post.gmane.org>
	<loom.20061021T083113-58@post.gmane.org>
Message-ID: <ADB991AD-9423-4E2A-94C9-6C51E46215C7@cs.usfca.edu>


On Oct 20, 2006, at 11:42 PM, Nicolas Rouquette wrote:

> Nicolas Rouquette <nicolas.rouquette at ...> writes:
>
>>
>> Terence Parr <parrt <at> ...> writes:
>>
>>> On Oct 19, 2006, at 5:09 PM, Nicolas Rouquette wrote:
>>>
>>>>  <at> init { boolean flag=false; }
>>>>   : e1=conditionalExpression (op=assignmentOperator e2=expression
>>>> {flag=true;})?
>>>>     -> {flag} ? ^($op $e1 $e2)
>>>>     -> $e1
>>>>   ;
>>>
>>> or use {$op!=null}? without the flag mumbojumbo.
>
> Bizarre... {op!=null} works.

Yes $op is op.

Ter


From parrt at cs.usfca.edu  Sat Oct 21 09:41:47 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sat, 21 Oct 2006 09:41:47 -0700
Subject: [antlr-interest] How to look only for one rule?
In-Reply-To: <453A0A77.7050204@informatik.uni-mannheim.de>
References: <AAD63B20-CACD-41F4-9651-1DD5B20ACE43@zoominternet.net>
	<ABC23567-BE02-4BBD-8588-C86EECF0296D@cs.usfca.edu>
	<453A0A77.7050204@informatik.uni-mannheim.de>
Message-ID: <B33E92E5-0555-47A1-B86F-685D99F72492@cs.usfca.edu>

Hi.  See the filter example, which does it all in the lexer.  Have a

EVERYTHINGELSE : . ;

rule at bottom to skip everything but your rules of interest.
Ter
On Oct 21, 2006, at 4:54 AM, Matthias Gutheil wrote:

> Hello,
>
> I am writing a fuzzy C grammar and I am only interesting in methods  
> with parameters and return values.
>
> The method definition is not the problem, but I want to skip  
> anything else.
> For example something like (method | ~method) doesn't work, cause  
> so the first token af a real method (return type or name) goes in  
> ~method.
>
> Some tips?
>
> Matthias


From nicolas.rouquette at jpl.nasa.gov  Sat Oct 21 14:10:26 2006
From: nicolas.rouquette at jpl.nasa.gov (Nicolas Rouquette)
Date: Sat, 21 Oct 2006 21:10:26 +0000 (UTC)
Subject: [antlr-interest] Tree grammars & optional AST nodes
References: <loom.20061020T002909-189@post.gmane.org>
	<7824DD4E-947D-4979-97F7-258A9D96B168@cs.usfca.edu>
	<loom.20061020T014305-179@post.gmane.org>
	<E3E47602-B703-426A-80D3-1CF698D36C8F@cs.usfca.edu>
	<loom.20061021T063344-672@post.gmane.org>
	<8785C2AD-F057-490B-912C-F9AF838B930D@cs.usfca.edu>
Message-ID: <loom.20061021T230807-753@post.gmane.org>

Terence Parr <parrt at ...> writes:

> On Oct 20, 2006, at 11:24 PM, Nicolas Rouquette wrote:
> 
> > Terence Parr <parrt <at> ...> writes:
> >
> > expression
> >  : e1=conditionalExpression (op=assignmentOperator e2=expression)?
> >    -> {$op!=null} ? ^($op $e1 $e2)
> >    -> $e1
> >  ;
> 
> Oh.  It wants $op.tree or something.  Which which is the problem?  ^ 
> ($op i guess.  Try {$op.tree} for now.

Since 'op' is inside an optional block, $op can be NULL
and $op.tree can produce a NullPointerException.

At most, it could be {$op!=null} but 3.0b4 doesn't like it.

-- Nicolas.

> Ter
> 
> 





From lgcraymer at yahoo.com  Sat Oct 21 14:32:19 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sat, 21 Oct 2006 14:32:19 -0700 (PDT)
Subject: [antlr-interest] How to look only for one rule?
In-Reply-To: <B33E92E5-0555-47A1-B86F-685D99F72492@cs.usfca.edu>
Message-ID: <20061021213219.51213.qmail@web55906.mail.re3.yahoo.com>

Hmm.  In cases where you have a complete grammar (and
for C, the ANTLR 2 C grammar stuff done by Monty and
others is definitely complete), I usually find it
better to take that and recognize everything but only
process what you need.  I would suggest modifying the
C grammar to build trees that only contain the methods
of interest and none of the stuff that you want to
ignore.  That gets you to a solution fast, and also
leaves room for extending the range of what you are
interested in later.

--Loring


--- Terence Parr <parrt at cs.usfca.edu> wrote:

> Hi.  See the filter example, which does it all in
> the lexer.  Have a
> 
> EVERYTHINGELSE : . ;
> 
> rule at bottom to skip everything but your rules of
> interest.
> Ter
> On Oct 21, 2006, at 4:54 AM, Matthias Gutheil wrote:
> 
> > Hello,
> >
> > I am writing a fuzzy C grammar and I am only
> interesting in methods  
> > with parameters and return values.
> >
> > The method definition is not the problem, but I
> want to skip  
> > anything else.
> > For example something like (method | ~method)
> doesn't work, cause  
> > so the first token af a real method (return type
> or name) goes in  
> > ~method.
> >
> > Some tips?
> >
> > Matthias
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From matthias.gutheil at informatik.uni-mannheim.de  Sat Oct 21 15:06:24 2006
From: matthias.gutheil at informatik.uni-mannheim.de (Matthias Gutheil)
Date: Sun, 22 Oct 2006 00:06:24 +0200
Subject: [antlr-interest] How to look only for one rule?
In-Reply-To: <20061021213219.51213.qmail@web55906.mail.re3.yahoo.com>
References: <20061021213219.51213.qmail@web55906.mail.re3.yahoo.com>
Message-ID: <453A99E0.4030901@informatik.uni-mannheim.de>

Yes but the problem is, that C is context sensitive and I only have one 
c-file and not all the included stuff.
I had a try to change the C grammar, but thats a to hard task for me at 
the moment.

-- Matthias
 

Loring Craymer schrieb:
> Hmm.  In cases where you have a complete grammar (and
> for C, the ANTLR 2 C grammar stuff done by Monty and
> others is definitely complete), I usually find it
> better to take that and recognize everything but only
> process what you need.  I would suggest modifying the
> C grammar to build trees that only contain the methods
> of interest and none of the stuff that you want to
> ignore.  That gets you to a solution fast, and also
> leaves room for extending the range of what you are
> interested in later.
>
> --Loring
>
>
> --- Terence Parr <parrt at cs.usfca.edu> wrote:
>
>   
>> Hi.  See the filter example, which does it all in
>> the lexer.  Have a
>>
>> EVERYTHINGELSE : . ;
>>
>> rule at bottom to skip everything but your rules of
>> interest.
>> Ter
>> On Oct 21, 2006, at 4:54 AM, Matthias Gutheil wrote:
>>
>>     
>>> Hello,
>>>
>>> I am writing a fuzzy C grammar and I am only
>>>       
>> interesting in methods  
>>     
>>> with parameters and return values.
>>>
>>> The method definition is not the problem, but I
>>>       
>> want to skip  
>>     
>>> anything else.
>>> For example something like (method | ~method)
>>>       
>> doesn't work, cause  
>>     
>>> so the first token af a real method (return type
>>>       
>> or name) goes in  
>>     
>>> ~method.
>>>
>>> Some tips?
>>>
>>> Matthias
>>>       
>>     
>
>
> __________________________________________________
> Do You Yahoo!?
> Tired of spam?  Yahoo! Mail has the best spam protection around 
> http://mail.yahoo.com 
>   


From lgcraymer at yahoo.com  Sat Oct 21 17:32:36 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sat, 21 Oct 2006 17:32:36 -0700 (PDT)
Subject: [antlr-interest] How to look only for one rule?
In-Reply-To: <453A99E0.4030901@informatik.uni-mannheim.de>
Message-ID: <20061022003236.91165.qmail@web55901.mail.re3.yahoo.com>

What are you trying to do, then?  For a single file,
building a custom tool is usually overkill.  If you
just want to do analysis of a single file, take a look
at Columbus/CAN from
<http://www.frontendart.com/>--it's a pretty nice tool
and there is an evaluation period during which you can
license it for free.

--Loring

--- Matthias Gutheil
<matthias.gutheil at informatik.uni-mannheim.de> wrote:

> Yes but the problem is, that C is context sensitive
> and I only have one 
> c-file and not all the included stuff.
> I had a try to change the C grammar, but thats a too
> hard task for me at 
> the moment.
> 
> -- Matthias
>  
> 
> Loring Craymer schrieb:
> > Hmm.  In cases where you have a complete grammar
> (and
> > for C, the ANTLR 2 C grammar stuff done by Monty
> and
> > others is definitely complete), I usually find it
> > better to take that and recognize everything but
> only
> > process what you need.  I would suggest modifying
> the
> > C grammar to build trees that only contain the
> methods
> > of interest and none of the stuff that you want to
> > ignore.  That gets you to a solution fast, and
> also
> > leaves room for extending the range of what you
> are
> > interested in later.
> >
> > --Loring
> >
> >
> > --- Terence Parr <parrt at cs.usfca.edu> wrote:
> >
> >   
> >> Hi.  See the filter example, which does it all in
> >> the lexer.  Have a
> >>
> >> EVERYTHINGELSE : . ;
> >>
> >> rule at bottom to skip everything but your rules
> of
> >> interest.
> >> Ter
> >> On Oct 21, 2006, at 4:54 AM, Matthias Gutheil
> wrote:
> >>
> >>     
> >>> Hello,
> >>>
> >>> I am writing a fuzzy C grammar and I am only
> >>>       
> >> interesting in methods  
> >>     
> >>> with parameters and return values.
> >>>
> >>> The method definition is not the problem, but I
> >>>       
> >> want to skip  
> >>     
> >>> anything else.
> >>> For example something like (method | ~method)
> >>>       
> >> doesn't work, cause  
> >>     
> >>> so the first token af a real method (return type
> >>>       
> >> or name) goes in  
> >>     
> >>> ~method.
> >>>
> >>> Some tips?
> >>>
> >>> Matthias
> >>>       
> >>     
> >
> >
> > __________________________________________________
> > Do You Yahoo!?
> > Tired of spam?  Yahoo! Mail has the best spam
> protection around 
> > http://mail.yahoo.com 
> >   
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From inshua at gmail.com  Sun Oct 22 02:59:59 2006
From: inshua at gmail.com (=?GB2312?B?0MLC8g==?=)
Date: Sun, 22 Oct 2006 17:59:59 +0800
Subject: [antlr-interest] Does ANTLR exactly allow Unicode?
Message-ID: <2506dcb70610220259xe868099p895ca310d76cd1b1@mail.gmail.com>

I had created a simple grammar to study ANTLR. and use Chinese charater as
letter, and ANTLR throws no warning or error.
However, when I input a piece of demo stream,like below:

??
?? "????";
??

it report some aweful error.
line 1:1: unexpected char: 0xBF
 at LearnLexer.nextToken(LearnLexer.java:102)
 at antlr.TokenBuffer.fill(TokenBuffer.java:69)
 at antlr.TokenBuffer.LT(TokenBuffer.java:86)
 at antlr.LLkParser.LT(LLkParser.java:56)
 at LearnParser.multiWriteStatement(LearnParser.java:89)
 at Test.main(Test.java:18)

Trace the lexer, I found an interesting thing. the char "?" is "\u5f00", but
it report with 0xBF.
Somebody tell me how use Unicode by ANTLR exactly,  thanks a lot.

header{
 import java.util.*;
}
class LearnLexer extends Lexer;
options{
  charVocabulary = '\u0003' .. '\uFFFE';
  caseSensitive = false;
  k = 2;
}
String :
 '\"' (~'\"')* '\"'
;

YINHAO :
 '\"';

WS : (' '
 | '\t'
 | '\n'
 | '\r')
  { _ttype = Token.SKIP; }
 ;

WRITE:
 "\u8f93\u51fa"
;

Fenhao : ';'
;

BEGIN :  "\u5f00\u59cb"
;

END   :     "\u5b8c\u6bd5"
;

class LearnParser extends Parser;
options{
 buildAST = true;
}
writeStatement :
   WRITE^ String Fenhao!;

multiWriteStatement :
  BEGIN^ (writeStatement)* END!
;


class LearnTreeWalker extends TreeParser;
multiWriteStatement{
 int i;
}
 : #(a:BEGIN .) {
   for(AST t = a.getFirstChild(); t != null; t = t.getNextSibling()){
    writeStatement(t);
   }
  }
;
writeStatement{
 String s;
}
: #(WRITE s=string) {System.out.print(s);}
;

string returns[String r]{
 r = null;
}
:  s : String {r = s.getText();}
;
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061022/851bcf61/attachment.html 

From matthias.gutheil at informatik.uni-mannheim.de  Sun Oct 22 04:11:27 2006
From: matthias.gutheil at informatik.uni-mannheim.de (Matthias Gutheil)
Date: Sun, 22 Oct 2006 13:11:27 +0200
Subject: [antlr-interest] How to look only for one rule?
In-Reply-To: <20061022003236.91165.qmail@web55901.mail.re3.yahoo.com>
References: <20061022003236.91165.qmail@web55901.mail.re3.yahoo.com>
Message-ID: <453B51DF.8000306@informatik.uni-mannheim.de>

Many C files one by one...

-- Matthias

Loring Craymer schrieb:
> What are you trying to do, then?  For a single file,
> building a custom tool is usually overkill.  If you
> just want to do analysis of a single file, take a look
> at Columbus/CAN from
> <http://www.frontendart.com/>--it's a pretty nice tool
> and there is an evaluation period during which you can
> license it for free.
>
> --Loring
>
> --- Matthias Gutheil
> <matthias.gutheil at informatik.uni-mannheim.de> wrote:
>
>   
>> Yes but the problem is, that C is context sensitive
>> and I only have one 
>> c-file and not all the included stuff.
>> I had a try to change the C grammar, but thats a too
>> hard task for me at 
>> the moment.
>>
>> -- Matthias
>>  
>>
>> Loring Craymer schrieb:
>>     
>>> Hmm.  In cases where you have a complete grammar
>>>       
>> (and
>>     
>>> for C, the ANTLR 2 C grammar stuff done by Monty
>>>       
>> and
>>     
>>> others is definitely complete), I usually find it
>>> better to take that and recognize everything but
>>>       
>> only
>>     
>>> process what you need.  I would suggest modifying
>>>       
>> the
>>     
>>> C grammar to build trees that only contain the
>>>       
>> methods
>>     
>>> of interest and none of the stuff that you want to
>>> ignore.  That gets you to a solution fast, and
>>>       
>> also
>>     
>>> leaves room for extending the range of what you
>>>       
>> are
>>     
>>> interested in later.
>>>
>>> --Loring
>>>
>>>
>>> --- Terence Parr <parrt at cs.usfca.edu> wrote:
>>>
>>>   
>>>       
>>>> Hi.  See the filter example, which does it all in
>>>> the lexer.  Have a
>>>>
>>>> EVERYTHINGELSE : . ;
>>>>
>>>> rule at bottom to skip everything but your rules
>>>>         
>> of
>>     
>>>> interest.
>>>> Ter
>>>> On Oct 21, 2006, at 4:54 AM, Matthias Gutheil
>>>>         
>> wrote:
>>     
>>>>     
>>>>         
>>>>> Hello,
>>>>>
>>>>> I am writing a fuzzy C grammar and I am only
>>>>>       
>>>>>           
>>>> interesting in methods  
>>>>     
>>>>         
>>>>> with parameters and return values.
>>>>>
>>>>> The method definition is not the problem, but I
>>>>>       
>>>>>           
>>>> want to skip  
>>>>     
>>>>         
>>>>> anything else.
>>>>> For example something like (method | ~method)
>>>>>       
>>>>>           
>>>> doesn't work, cause  
>>>>     
>>>>         
>>>>> so the first token af a real method (return type
>>>>>       
>>>>>           
>>>> or name) goes in  
>>>>     
>>>>         
>>>>> ~method.
>>>>>
>>>>> Some tips?
>>>>>
>>>>> Matthias
>>>>>       
>>>>>           
>>>>     
>>>>         
>>> __________________________________________________
>>> Do You Yahoo!?
>>> Tired of spam?  Yahoo! Mail has the best spam
>>>       
>> protection around 
>>     
>>> http://mail.yahoo.com 
>>>   
>>>       
>>     
>
>
> __________________________________________________
> Do You Yahoo!?
> Tired of spam?  Yahoo! Mail has the best spam protection around 
> http://mail.yahoo.com 
>   


From tommy.nordgren at chello.se  Sun Oct 22 04:48:10 2006
From: tommy.nordgren at chello.se (Tommy Nordgren)
Date: Sun, 22 Oct 2006 13:48:10 +0200
Subject: [antlr-interest] Does ANTLR exactly allow Unicode?
In-Reply-To: <2506dcb70610220259xe868099p895ca310d76cd1b1@mail.gmail.com>
References: <2506dcb70610220259xe868099p895ca310d76cd1b1@mail.gmail.com>
Message-ID: <79543756-28EC-4D2E-B97C-7766B2F40927@chello.se>


On 22 okt 2006, at 11.59, ?? wrote:

> I had created a simple grammar to study ANTLR. and use Chinese  
> charater as letter, and ANTLR throws no warning or error.
> However, when I input a piece of demo stream,like below:
>
> ??
> ?? "????";
> ??
>
> it report some aweful error.
> line 1:1: unexpected char: 0xBF
>  at LearnLexer.nextToken(LearnLexer.java:102)
>  at antlr.TokenBuffer.fill(TokenBuffer.java:69)
>  at antlr.TokenBuffer.LT(TokenBuffer.java:86)
>  at antlr.LLkParser.LT(LLkParser.java :56)
>  at LearnParser.multiWriteStatement(LearnParser.java:89)
>  at Test.main(Test.java:18)
>
> Trace the lexer, I found an interesting thing. the char "?" is  
> "\u5f00", but it report with 0xBF.
> Somebody tell me how use Unicode by ANTLR exactly,  thanks a lot.
	You need to set up your input (character) stream to use the correct  
encoding when
converting from it's input (byte) stream

From inshua at gmail.com  Sun Oct 22 05:44:20 2006
From: inshua at gmail.com (=?GB2312?B?0MLC8g==?=)
Date: Sun, 22 Oct 2006 20:44:20 +0800
Subject: [antlr-interest] Does ANTLR exactly allow Unicode?
In-Reply-To: <79543756-28EC-4D2E-B97C-7766B2F40927@chello.se>
References: <2506dcb70610220259xe868099p895ca310d76cd1b1@mail.gmail.com>
	<79543756-28EC-4D2E-B97C-7766B2F40927@chello.se>
Message-ID: <2506dcb70610220544v316284edk3dd50dae5072470d@mail.gmail.com>

Hi Tommy,

Thank you very much,the problem is resolved.

And by the way, in ANTLR2.7.6 Unicode cannot use double quote,  must sperate
into char one by one : as '\u5f00''\u59cb'.

Thanks.


On 10/22/06, Tommy Nordgren <tommy.nordgren at chello.se> wrote:
>
>
> On 22 okt 2006, at 11.59, ?? wrote:
>
> > I had created a simple grammar to study ANTLR. and use Chinese
> > charater as letter, and ANTLR throws no warning or error.
> > However, when I input a piece of demo stream,like below:
> >
> > ??
> > ?? "????";
> > ??
> >
> > it report some aweful error.
> > line 1:1: unexpected char: 0xBF
> >  at LearnLexer.nextToken(LearnLexer.java:102)
> >  at antlr.TokenBuffer.fill(TokenBuffer.java:69)
> >  at antlr.TokenBuffer.LT(TokenBuffer.java:86)
> >  at antlr.LLkParser.LT(LLkParser.java :56)
> >  at LearnParser.multiWriteStatement(LearnParser.java:89)
> >  at Test.main(Test.java:18)
> >
> > Trace the lexer, I found an interesting thing. the char "?" is
> > "\u5f00", but it report with 0xBF.
> > Somebody tell me how use Unicode by ANTLR exactly,  thanks a lot.
>        You need to set up your input (character) stream to use the correct
> encoding when
> converting from it's input (byte) stream
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061022/b2e4e088/attachment-0001.html 

From matthias.gutheil at informatik.uni-mannheim.de  Sun Oct 22 06:59:02 2006
From: matthias.gutheil at informatik.uni-mannheim.de (Matthias Gutheil)
Date: Sun, 22 Oct 2006 15:59:02 +0200
Subject: [antlr-interest] filter=RULE
In-Reply-To: <20061022003236.91165.qmail@web55901.mail.re3.yahoo.com>
References: <20061022003236.91165.qmail@web55901.mail.re3.yahoo.com>
Message-ID: <453B7926.1080909@informatik.uni-mannheim.de>

Hello,

does someone have a small working example with filter=RULE?

I tried a lot but with version3 and ANTLRWorks I couldn't get something 
to run :-(

-- Matthias

From kroepke at classdump.org  Sun Oct 22 08:00:38 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sun, 22 Oct 2006 17:00:38 +0200
Subject: [antlr-interest] filter=RULE
In-Reply-To: <453B7926.1080909@informatik.uni-mannheim.de>
References: <20061022003236.91165.qmail@web55901.mail.re3.yahoo.com>
	<453B7926.1080909@informatik.uni-mannheim.de>
Message-ID: <E30A1007-E1DE-40F9-BF62-D3A7E20E1FF1@classdump.org>

Hallo Matthias!

On 22. Oct 2006, at 15:59 , Matthias Gutheil wrote:

> does someone have a small working example with filter=RULE?
>
> I tried a lot but with version3 and ANTLRWorks I couldn't get  
> something to run :-(

I believe that ANTLRWorks cannot do filter mode right now, you must  
use a custom Main.java.
Take a look at the examples from the website <http://www.antlr.org/ 
download/examples-v3.tar.gz>. In there is a directory called fuzzy,  
which uses filter mode for a subset of Java.

HTH,

-k

-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From mailing-lists at rblasch.org  Sun Oct 22 08:08:36 2006
From: mailing-lists at rblasch.org (Ron Blaschke)
Date: Sun, 22 Oct 2006 17:08:36 +0200
Subject: [antlr-interest] ANTLR 3.0b4 DIGIT-INTEGER grammar question
Message-ID: <453B8974.5000202@rblasch.org>

I have a simple question, and it may well be something stupid.  But I
just can't put my finger on what I'm missing.  Any help is greatly
appreciated.

Consider this grammar.
----
grammar TestParser;
options {
    output = AST;
    ASTLabelType = CommonTree;
}

number
    :    INTEGER EOF!
    ;

protected
DIGIT
    :   '0'..'9'
    ;

INTEGER
    :   (DIGIT)+
    ;

WHITESPACE
    :      (' '
    |       '\t'
    |       '\n'
    |       '\r')
            { channel=99; }
    ;
----

And this simple test program.
----
import org.antlr.runtime.ANTLRFileStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeNodeStream;

public class Test {
    public static void main(final String[] args) throws Exception {
        final TestParserLexer lexer = new TestParserLexer(
                                      new ANTLRFileStream("test.txt"));
        final CommonTokenStream tokens = new CommonTokenStream(lexer);
        final TestParser parser = new TestParser(tokens);

        final TestParser.number_return result = parser.number();
        final CommonTree testTree = (CommonTree) result.getTree();

        System.out.println(testTree.toStringTree());
    }
}
----

If I put "425" into test.txt I get:

    >echo 425 >test.txt
    >java -cp antlr-3.0b4.jar;. Test
    425

with just a single digit, e.g. "4", I get:

    >echo 4 >test.txt
    >java -cp antlr-3.0b4.jar;. Test
    [number]: line 1:0 mismatched token: [@0,0:0='4',<5>,1:0]; expecting
type INTEGER
nil

Feels like the parser doesn't know it should go from DIGIT to INTEGER.
Removing the DIGIT rule and replacing INTEGER with

    INTEGER
        :   ('0'..'9')+
        ;

yields:

    >echo 425 >test.txt
    >java -cp antlr-3.0b4.jar;. Test
    425

    >echo 4 >test.txt
    >java -cp antlr-3.0b4.jar;. Test
    4

Any thoughts?

Thanks,
Ron

From kroepke at classdump.org  Sun Oct 22 08:28:16 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sun, 22 Oct 2006 17:28:16 +0200
Subject: [antlr-interest] ANTLR 3.0b4 DIGIT-INTEGER grammar question
In-Reply-To: <453B8974.5000202@rblasch.org>
References: <453B8974.5000202@rblasch.org>
Message-ID: <52686332-00D5-4C73-B503-CB7F7859350B@classdump.org>

Hi Ron!

On 22. Oct 2006, at 17:08 , Ron Blaschke wrote:

> protected
> DIGIT
>     :   '0'..'9'
>     ;

the protected keyword is for v2. In version 3 that must be fragment.  
Then it works as expected :)

HTH,

-k
-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From mailing-lists at rblasch.org  Sun Oct 22 09:22:14 2006
From: mailing-lists at rblasch.org (Ron Blaschke)
Date: Sun, 22 Oct 2006 18:22:14 +0200
Subject: [antlr-interest] ANTLR 3.0b4 DIGIT-INTEGER grammar question
In-Reply-To: <52686332-00D5-4C73-B503-CB7F7859350B@classdump.org>
References: <453B8974.5000202@rblasch.org>
	<52686332-00D5-4C73-B503-CB7F7859350B@classdump.org>
Message-ID: <453B9AB6.9040902@rblasch.org>

Hello Kay,

Kay Roepke wrote:
> On 22. Oct 2006, at 17:08 , Ron Blaschke wrote:
> 
>> protected
>> DIGIT
>>     :   '0'..'9'
>>     ;
> 
> the protected keyword is for v2. In version 3 that must be fragment.
> Then it works as expected :)

Thanks a lot!  This information would be a fine addition to "Migrating
from ANTLR 2 to ANTLR 3" [1].

[1]
http://www.antlr.org/wiki/display/ANTLR3/Migrating+from+ANTLR+2+to+ANTLR+3

Ron

From iamhere2 at gmail.com  Sun Oct 22 09:29:05 2006
From: iamhere2 at gmail.com (Igor Trofimov)
Date: Sun, 22 Oct 2006 20:29:05 +0400
Subject: [antlr-interest] ANTLR3 and C# 2.0 Lexer troubles
Message-ID: <e642c6be0610220929h426606d6gfb748c11b9bd292a@mail.gmail.com>

Hey! Can anybody help with it?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061022/488b6474/attachment.html 

From kroepke at classdump.org  Sun Oct 22 09:37:42 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Sun, 22 Oct 2006 18:37:42 +0200
Subject: [antlr-interest] ANTLR 3.0b4 DIGIT-INTEGER grammar question
In-Reply-To: <453B9AB6.9040902@rblasch.org>
References: <453B8974.5000202@rblasch.org>
	<52686332-00D5-4C73-B503-CB7F7859350B@classdump.org>
	<453B9AB6.9040902@rblasch.org>
Message-ID: <92C3B49B-1FA0-4B76-91DE-2CF8524D3C21@classdump.org>


On 22. Oct 2006, at 18:22 , Ron Blaschke wrote:

> Thanks a lot!  This information would be a fine addition to "Migrating
> from ANTLR 2 to ANTLR 3" [1].

Done. :)

-k




From autophile at zoominternet.net  Sun Oct 22 11:18:38 2006
From: autophile at zoominternet.net (Robert Baruch)
Date: Sun, 22 Oct 2006 14:18:38 -0400
Subject: [antlr-interest] Error in 3.0b4?
Message-ID: <0BB6A8A5-5946-40F6-BBF9-5160D31B4C5A@zoominternet.net>

Hi all,

Here is a grammar which seems to generate invalid Java code:

grammar TestParser;
@parser::header { package generated; }
@lexer::header { package generated; }

start : r0 EOF;
r0 : (.) * ;

N : 'n';
V : 'v';

Compiling the result gives the following error:

generated/TestParser.java:92: exception  
org.antlr.runtime.RecognitionException is never thrown in body of  
corresponding try statement
         catch (RecognitionException re) {
         ^
1 error


Again, granted it's a stupid grammar, but it's a valid grammar and  
should generate valid code :)

Any chance of a quickfix?

Thanks,

--Rob

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061022/ac2a362d/attachment.html 

From porcelli at uol.com.br  Sun Oct 22 12:25:42 2006
From: porcelli at uol.com.br (Alexandre Porcelli)
Date: Sun, 22 Oct 2006 16:25:42 -0300
Subject: [antlr-interest] How To: Tree Rewrite when there is an OR operator
Message-ID: <ee873c070610221225y6e2d1975if8d169be23a21072@mail.gmail.com>

Hi all,

I?d like to know from you how to rewrite a tree when we have this situation:


groupByClause
        :       'GROUP' 'BY' ('INPUT' 'SEQUENCE'| expression (','? expression)*)
        ;

I tried this one:

groupByClause
        :       'GROUP' 'BY' ('INPUT' 'SEQUENCE'| expression (','? expression)*)
        -> 'GROUP' 'BY' ('INPUT' 'SEQUENCE'| expression+)
        ;

But I got the following message:

syntax error: antlr: SQLDLI.g:172:37: expecting RPAREN, found '|'

How to solve this?

Thanks in advance,
Alexandre Porcelli

From parrt at cs.usfca.edu  Sun Oct 22 12:36:11 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 22 Oct 2006 12:36:11 -0700
Subject: [antlr-interest] Usage of scopes in v3
In-Reply-To: <B9512779-E0E9-42C0-BFB5-AB3F01B89A6E@classdump.org>
References: <B9512779-E0E9-42C0-BFB5-AB3F01B89A6E@classdump.org>
Message-ID: <BED89C4B-5309-4258-8260-3182963D3264@cs.usfca.edu>


On Oct 21, 2006, at 2:42 AM, Kay Roepke wrote:

> Hi Ter,*!
>
> I have played around with dynamic rule scopes over the last week or  
> so and was wondering what the current best-practice was.
> If you consider the symtab example for v3 below, I was wondering  
> how you would go ahead in an implementation of a symbol table while  
> using scopes.

What are you trying to do in the finally?  It will just pop off and  
go away after the method unless it's saved; a finally would do that.

Crap. the stuff is popped BEFORE the finally action.  Hmm...that  
doesn't seem right, does it?

Ter

>
> A na?ve approach would be the @finally action below, which fails  
> because right before the comment the current Symbol scope would be  
> popped from the block. You would naturally need to access the  
> Symbol scope to enter its entries into your program's symbol table  
> which would not go away when the rule exits. The obvious solution  
> is to add an action to the end of the rule block to do the  
> transition so it doesn't execute when the rule fails.
> Is this actually the recommended way or is there something I  
> overlook? The downside with the @finally route is of course that it  
> gets executed regardless whether the rule failed or not, so you'd  
> have to guard against that manually. Same goes for backtracking.
>
> cheers,
> -k
>
> grammar SymtabTestParser;
>
> /* Scope of symbol names.  Both globals and block rules need to  
> push a new
> * symbol table upon entry and they must use the same stack.  So, I  
> must
> * define a global scope and say that globals and block use this by  
> saying
> * 'scope Symbols;' in those rule definitions.
> */
> scope Symbols {
>   List names;
> }
> [...]
> block
> scope Symbols;
> @init {
>     level++;
>     $Symbols::names = new ArrayList();
> }
> @finally {
>         // is $Symbols::names still valid here?
> }
>     :   '{' (decl)* (stat)* '}'
>         {
>         System.out.println("level "+level+" symbols: "+ 
> $Symbols::names);
>         level--;
>         }
>     ;
> [...]
>
>
> -- 
> Kay R?pke <kroepke at classdump.org>
> classdump Software
> Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0
>
>
>


From parrt at cs.usfca.edu  Sun Oct 22 12:47:07 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 22 Oct 2006 12:47:07 -0700
Subject: [antlr-interest] Error in 3.0b4?
In-Reply-To: <0BB6A8A5-5946-40F6-BBF9-5160D31B4C5A@zoominternet.net>
References: <0BB6A8A5-5946-40F6-BBF9-5160D31B4C5A@zoominternet.net>
Message-ID: <7713CA10-72A3-49AD-910E-5F08CBC95CC6@cs.usfca.edu>

oh, it's due to just .* in a grammar, which cannot throw an  
exception.  .* will never terminate by the way.
Ter
On Oct 22, 2006, at 11:18 AM, Robert Baruch wrote:

> Hi all,
>
> Here is a grammar which seems to generate invalid Java code:
>
> grammar TestParser;
> @parser::header { package generated; }
> @lexer::header { package generated; }
>
> start : r0 EOF;
> r0 : (.) * ;
>
> N : 'n';
> V : 'v';
>
> Compiling the result gives the following error:
>
> generated/TestParser.java:92: exception  
> org.antlr.runtime.RecognitionException is never thrown in body of  
> corresponding try statement
>         catch (RecognitionException re) {
>         ^
> 1 error
>
>
> Again, granted it's a stupid grammar, but it's a valid grammar and  
> should generate valid code :)
>
> Any chance of a quickfix?
>
> Thanks,
>
> --Rob
>


From autophile at zoominternet.net  Sun Oct 22 15:43:15 2006
From: autophile at zoominternet.net (Robert Baruch)
Date: Sun, 22 Oct 2006 18:43:15 -0400
Subject: [antlr-interest] [3.0b4] superClass package?
Message-ID: <069A77E7-47ED-4BA4-98CF-A907A702536F@zoominternet.net>

Hi all,

How do I set the superclass of a parser where the superclass is in a  
different package from the parser? I tried this:

grammar TestParser;
options { superClass = grammatotron.GeneratedParser; }
@parser::header { package generated; }
@lexer::header { package generated; }

start : r0 EOF;
r0 : ;


N : 'n';
V : 'v';

But that generates this error:

2:36: syntax error: antlr: generated.g:2:36: expecting SEMI, found '.'
2:52: syntax error: antlr: generated.g:2:52: unexpected token: ;

Any help appreciated!

Thanks,

--Rob

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061022/418b8890/attachment.html 

From kroepke at classdump.org  Sun Oct 22 15:54:35 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Mon, 23 Oct 2006 00:54:35 +0200
Subject: [antlr-interest] Usage of scopes in v3
In-Reply-To: <BED89C4B-5309-4258-8260-3182963D3264@cs.usfca.edu>
References: <B9512779-E0E9-42C0-BFB5-AB3F01B89A6E@classdump.org>
	<BED89C4B-5309-4258-8260-3182963D3264@cs.usfca.edu>
Message-ID: <004D81EF-3D2B-4308-8679-8F03ADF743A9@classdump.org>


On 22. Oct 2006, at 21:36 , Terence Parr wrote:

> What are you trying to do in the finally?  It will just pop off and  
> go away after the method unless it's saved; a finally would do that.
>
> Crap. the stuff is popped BEFORE the finally action.  Hmm...that  
> doesn't seem right, does it?

Hence the question ;)
You could argue that @finally isn't the correct place to do it,  
because it largely is concerned with cleanup. OTOH it seems a  
sensible place because it will be the last thing executed.
Anyhoo, the user supplied finally IS place after everything else, so  
it's too late.
I'm comfortable with putting it into an action at the end of the rule/ 
subrule, but was expecting the finally block to be ok, too.

-k
-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From porcelli at uol.com.br  Sun Oct 22 16:04:58 2006
From: porcelli at uol.com.br (Alexandre Porcelli)
Date: Sun, 22 Oct 2006 20:04:58 -0300
Subject: [antlr-interest] A question about multiple alternatives
Message-ID: <ee873c070610221604i64edadbau29774d57dc4e39a1@mail.gmail.com>

I?d like to know from you how could I solve this problem....

   I'm developing a Cobol Grammar using v3. The "IF" statement in
cobol language there isn't block to define scopes, for this there is
just the "." token to say it has finished.
  For this I created a nestedIfStatement that is the same as If but
with no ".", but with my approach I got always a message :

"[19:50:39] CobolParser.g:891:3: Decision can match input such as
"'ELSE'" using multiple alternatives: 1, 2
As a result, alternative(s) 2 were disabled for that input
[19:50:39] CobolParser.g:892:3: Decision can match input such as
"'END-IF'" using multiple alternatives: 1, 2
As a result, alternative(s) 2 were disabled for that input"


Here is a piece of my code:

imperativeStatementList
	:	imperativeStatement+
	;

imperativeStatement
	:	acceptStatement
	|	addImperativeStatement
	|	alterStatement
	|	callImperativeStatement
	|	cancelStatement
	|	closeStatement
	|	computeImperativeStatement
	;

ifStatement
	:	'IF' generalCondition 'THEN'? (nestedIfStatement |
imperativeStatementList nestedIfStatement?)
		('ELSE' (nestedIfStatement | imperativeStatementList nestedIfStatement?) )?
		'END-IF'? DOT
	;

nestedIfStatement
	: 	'IF' generalCondition 'THEN'? (nestedIfStatement |
imperativeStatementList nestedIfStatement?)
		('ELSE' (nestedIfStatement | imperativeStatementList nestedIfStatement?))?
		'END-IF'?
	;

Does anyone has any sugestion?

Thanks in Advance,
Alexandre Porcelli

From parrt at cs.usfca.edu  Sun Oct 22 19:32:12 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 22 Oct 2006 19:32:12 -0700
Subject: [antlr-interest] [3.0b4] superClass package?
In-Reply-To: <069A77E7-47ED-4BA4-98CF-A907A702536F@zoominternet.net>
References: <069A77E7-47ED-4BA4-98CF-A907A702536F@zoominternet.net>
Message-ID: <59200989-EEBE-44F4-8F44-274C20C1E204@cs.usfca.edu>

use "..."
Ter
On Oct 22, 2006, at 3:43 PM, Robert Baruch wrote:

> Hi all,
>
> How do I set the superclass of a parser where the superclass is in  
> a different package from the parser? I tried this:
>
> grammar TestParser;
> options { superClass = grammatotron.GeneratedParser; }
> @parser::header { package generated; }
> @lexer::header { package generated; }
>
> start : r0 EOF;
> r0 : ;
>
>
> N : 'n';
> V : 'v';
>
> But that generates this error:
>
> 2:36: syntax error: antlr: generated.g:2:36: expecting SEMI, found '.'
> 2:52: syntax error: antlr: generated.g:2:52: unexpected token: ;
>
> Any help appreciated!
>
> Thanks,
>
> --Rob
>


From jose.ventura.roda at gmail.com  Mon Oct 23 03:24:18 2006
From: jose.ventura.roda at gmail.com (Jose Ventura)
Date: Mon, 23 Oct 2006 12:24:18 +0200
Subject: [antlr-interest] A question about multiple alternatives
In-Reply-To: <ee873c070610221604i64edadbau29774d57dc4e39a1@mail.gmail.com>
References: <ee873c070610221604i64edadbau29774d57dc4e39a1@mail.gmail.com>
Message-ID: <e39abda10610230324j2e05c478h1cd0b15c25f48df0@mail.gmail.com>

I post my own if command code, I hope help you

Regards,


comando
               : comando_if
               |  comando_perform
               |  comando_call
...

comando_if
	: IF^ condicion
                       parte_then
                       (options {greedy=true;}: ELSE! parte_else)?
                  (options {greedy=true;}: END_IF)? 				;

parte_then
: (THEN!)?
       ( (NEXT^ SENTENCE {## = #( #[SENTENCIAS, "THEN"] ,##);})
          |sentencia_interna
       )
;
	
parte_else
: (NEXT^ SENTENCE {## = #( #[SENTENCIAS, "ELSE"] ,##);})	
| sentencia_interna
;



2006/10/23, Alexandre Porcelli <porcelli at uol.com.br>:
> I?d like to know from you how could I solve this problem....
>
>   I'm developing a Cobol Grammar using v3. The "IF" statement in
> cobol language there isn't block to define scopes, for this there is
> just the "." token to say it has finished.
> For this I created a nestedIfStatement that is the same as If but
> with no ".", but with my approach I got always a message :
>
> "[19:50:39] CobolParser.g:891:3: Decision can match input such as
> "'ELSE'" using multiple alternatives: 1, 2
> As a result, alternative(s) 2 were disabled for that input
> [19:50:39] CobolParser.g:892:3: Decision can match input such as
> "'END-IF'" using multiple alternatives: 1, 2
> As a result, alternative(s) 2 were disabled for that input"
>
>
> Here is a piece of my code:
>
> imperativeStatementList
>        :       imperativeStatement+
>        ;
>
> imperativeStatement
>        :       acceptStatement
>        |       addImperativeStatement
>        |       alterStatement
>        |       callImperativeStatement
>        |       cancelStatement
>        |       closeStatement
>        |       computeImperativeStatement
>        ;
>
> ifStatement
>        :       'IF' generalCondition 'THEN'? (nestedIfStatement |
> imperativeStatementList nestedIfStatement?)
>                ('ELSE' (nestedIfStatement | imperativeStatementList nestedIfStatement?) )?
>                'END-IF'? DOT
>        ;
>
> nestedIfStatement
>        :       'IF' generalCondition 'THEN'? (nestedIfStatement |
> imperativeStatementList nestedIfStatement?)
>                ('ELSE' (nestedIfStatement | imperativeStatementList nestedIfStatement?))?
>                'END-IF'?
>        ;
>
> Does anyone has any sugestion?
>
> Thanks in Advance,
> Alexandre Porcelli
>

From peter.palotas at gmail.com  Mon Oct 23 03:54:29 2006
From: peter.palotas at gmail.com (Peter Palotas)
Date: Mon, 23 Oct 2006 12:54:29 +0200
Subject: [antlr-interest] Assertion failed on SemanticException in 2.7.6
Message-ID: <bca7b0010610230354vac5ea43j8f7a3bc8adf231f9@mail.gmail.com>

Hi,

I searched the archives and found that someone brought this issue up a while
back. I get the following error message:

Assertion failed: nb <= entries(), file
..\..\antlr\lib\cpp\antlr/CircularQueue.hpp, line 59

when throwing an antlr::SemanticException() from a rule in my parser.

Is there any way to solve this?  I am using 2.7.6 and the C++ target.

Would really appreciate the help, since this is sort of a showstopper at the
moment.

Regards, Peter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061023/4900e34e/attachment-0001.html 

From ric.klaren at gmail.com  Mon Oct 23 05:32:53 2006
From: ric.klaren at gmail.com (Ric Klaren)
Date: Mon, 23 Oct 2006 14:32:53 +0200
Subject: [antlr-interest] Assertion failed on SemanticException in 2.7.6
In-Reply-To: <bca7b0010610230354vac5ea43j8f7a3bc8adf231f9@mail.gmail.com>
References: <bca7b0010610230354vac5ea43j8f7a3bc8adf231f9@mail.gmail.com>
Message-ID: <bc607a4e0610230532t1fd6b34s7a0a39d00c837919@mail.gmail.com>

Hi,

On 10/23/06, Peter Palotas <peter.palotas at gmail.com> wrote:
> I searched the archives and found that someone brought this issue up a while
> back. I get the following error message:
>
> Assertion failed: nb <= entries(), file
> ..\..\antlr\lib\cpp\antlr/CircularQueue.hpp, line 59
>
> when throwing an antlr::SemanticException() from a rule in my parser.
>
> Is there any way to solve this?  I am using 2.7.6 and the C++ target.

Please try the 2.7.7 prerelease and report back. It should be fixed in there.

http://www.antlr.org/download/antlr-2.7.7rc1.tar.gz

Cheers,

Ric

From gzsombor at gmail.com  Mon Oct 23 05:35:31 2006
From: gzsombor at gmail.com (Zsombor)
Date: Mon, 23 Oct 2006 14:35:31 +0200
Subject: [antlr-interest] package name is ignored in antlr v3
Message-ID: <a8fbd6780610230535o4f74600ub33fb10bf3dbb640@mail.gmail.com>

Hi !

 Probably i've done something unusual, or missed something, but it
seems that however I've specified

grammar MyTestGrammar;
@header {
    package my.testparser;
}

It's only showing up in the MyTestGrammar class, not in the
MyTestGrammarLexer. I'm using the  3.0b4 version.

BR
 Zsombor

From kroepke at classdump.org  Mon Oct 23 06:30:05 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Mon, 23 Oct 2006 15:30:05 +0200
Subject: [antlr-interest] package name is ignored in antlr v3
In-Reply-To: <a8fbd6780610230535o4f74600ub33fb10bf3dbb640@mail.gmail.com>
References: <a8fbd6780610230535o4f74600ub33fb10bf3dbb640@mail.gmail.com>
Message-ID: <04C7A1BC-A16D-40C8-8313-DFFA4D9161F8@classdump.org>

Hi!

On 23. Oct 2006, at 14:35 , Zsombor wrote:

> Probably i've done something unusual, or missed something, but it
> seems that however I've specified
>
> grammar MyTestGrammar;
> @header {
>    package my.testparser;
> }
>
> It's only showing up in the MyTestGrammar class, not in the
> MyTestGrammarLexer. I'm using the  3.0b4 version.

For combined grammars the unqualified stuff goes into the parser by  
default.
You can do:

@lexer::header {
}

and

@parser::header {
}

to put stuff into the lexer resp. parser.
Currently, you have to specify it twice, using @header and  
@lexer::header for combined grammars.

HTH,
-k




From foolishewe at hotmail.com  Mon Oct 23 08:46:19 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Mon, 23 Oct 2006 15:46:19 +0000
Subject: [antlr-interest] A newbie question and is this mailing list a black
	hole for me?
Message-ID: <BAY107-F339267FBB68B9BC51BE24FC0000@phx.gbl>

Hello All:

I'm still waiting to see any of my earlier posts acknowledged by this 
mailing list, however,
they aren't showing up, so I am not sure what is happening (it's been 
several business days).
If anyone gets this, please reply directly to me (or cc me and send to the 
mailing list if it
is of general interest). I have started development using ANTLR and 
advocated it to my
team as (1) generating java source, (2) being hardened by widespread use and
(3) actively supported.  Please back me up on the actively supported part, I 
don't want
to look foolish  :-).

For my job, I am writing a tool to parse a language, that for historical 
reasons has
what I'll call "undelimited strings", which are positional string parameters 
with white space delimiiters.
The problem becomes that if the undelimited string has a prefix that matches 
a keyword,
then the scanner will call it a keyword and not a string (which is 
understandable but not the
behavior I want).  I would like to control when keywords are recognized by 
the lexer, and
I would like to activate/deactivate this control in parser actions.  In the 
lexer, I added a public
boolean flag "recognizeKeyWords" which appears to work in a toy example, 
however, I don't know
how to access the extended lexer class resulting from my ANTLR file to 
control this flag.
Is there a way to do this, if so, what is the java/ANTLR syntax?

As an example, please see a small ANTLR file and Java example are appended 
to the end of this
message.

Thanks:

Bill M.

******************BEGIN ANTLR**************************************
//My play area for diagnosing strange ANTLR symptoms
//Version History: 1.0 WAM created


// WAM - Need to add some boilerplate to let Antlr generated files know that 
they are part of the ZTestParser package
header{
	package testing;
}

class P extends Parser;

// Parser options
options{
	k = 2; // Token stream lookahead, remember ANTLR uses LL(k) parsing
}

// Antlr requires Terminals have names beginning with uppercase letters, 
Nonterminals should use lowercase I guess
startRule
	:
		// the actual prefix tokens are different in practice
		getstring:GETSTRING
		// I would like to do something like the following actions where lexer is 
a type L object used in lexing
		// This is not the right syntax for this, but it shows the general idea
		// {this.lexer.recognizeKeyWord = false;}
		strval:NONEMPTYSTRING
		// {this.lexer.recognizeKeyWord = true;}
		nl1:NEWLINE sr1:startRule// breaks if the user types in "dun\n" where \n 
is newline
	|
		month:MONTH nl2:NEWLINE sr2:startRule
	|
		// added for testing, but won't work for my requirements.
		toggle:TOGGLE nl3:NEWLINE sr3:startRule
	|
		end:END nl4:NEWLINE
	;

class L extends Lexer;

// Lexer options
options{
	k=3; // lookahead (need 2 for new line, 3 should be enough for months)
	charVocabulary='\u0000'..'\u007F'; // Only support printable ASCII 
characters, don't try fancy unicode stuff
	// case sensitivitity turned off
	caseSensitiveLiterals=false;
	caseSensitive=false;
}

*****************END ANTLR BEGIN 
JAVA*****************************************

package testing;
import java.io.*;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try{
			System.out.println("Enter a string for the test parser (note this is for 
simple ANTLR test cases)");

			L lexer = new L(new DataInputStream(System.in));


			System.out.println("After lexer instantiated before Parser 
instantiation");
			P parser = new P(lexer);
			System.out.println("After Parser instantiation before StartRule");
			parser.startRule();
			System.out.println("After startRule: Done?");
		} catch(Exception e) {
			System.err.println("exception: "+e);
		}
	}

}

_________________________________________________________________
Try the next generation of search with Windows Live Search today!  
http://imagine-windowslive.com/minisites/searchlaunch/?locale=en-us&source=hmtagline


From dave at badgers-in-foil.co.uk  Mon Oct 23 09:06:27 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Mon, 23 Oct 2006 16:06:27 +0000
Subject: [antlr-interest] A newbie question and is this mailing list a
	black hole for me?
In-Reply-To: <BAY107-F339267FBB68B9BC51BE24FC0000@phx.gbl>
References: <BAY107-F339267FBB68B9BC51BE24FC0000@phx.gbl>
Message-ID: <20061023160627.GB6190@badgers-in-foil.co.uk>

On Mon, Oct 23, 2006 at 03:46:19PM +0000, Foolish Ewe wrote:
> For my job, I am writing a tool to parse a language, that for
> historical reasons has what I'll call "undelimited strings", which are
> positional string parameters with white space delimiiters.  The
> problem becomes that if the undelimited string has a prefix that
> matches a keyword, then the scanner will call it a keyword and not a
> string (which is understandable but not the behavior I want).

I dunno if this helps you, but in the cases where I had the 'is it a
keyword or an IDENT?' problem, I just dropped the keyword def from the
lexer, and then had a parser rule with a predicate testing the IDENT
value.

e.g. 'namespace' is sometimes a keyword, and sometimes an identifier,
depending on context, so I drop the NAMESPACE definition in the lexer,
and then replace all references to NAMESPACE in the grammar to a
namespaceKeyword rule, defined like this:

namespaceKeyword
	:	{input.LT(1).getText().equals("namespace")}? IDENT
	;

(You could also change the type of the token with a rewrite, if that
were useful for your app.)


Any good?
dave

-- 
http://david.holroyd.me.uk/

From zhiyong_zhang5 at yahoo.ie  Mon Oct 23 10:11:33 2006
From: zhiyong_zhang5 at yahoo.ie (Zhiyong Zhang)
Date: Mon, 23 Oct 2006 17:11:33 +0000 (GMT)
Subject: [antlr-interest] ambiguity identifier
Message-ID: <20061023171133.53248.qmail@web27215.mail.ukl.yahoo.com>

Hi,

The identifier is supposed to in be the format of "abc.d6f" or "abc.current.dg47".

I got identifier ambiguity problem with the following lexical grammar, can anybody point some light.


IDSTART : ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|':')*;
IDEND : ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|':');

IDENTIFIER options {testLiterals=true;} : (IDSTART)
(DOT) (CURRENT) => (IDSTART)((DOT)(CURRENT)(DOT)(IDEND)+)? | (IDSTART) ((DOT)(IDEND)+)?;

....

CURRENT : "current";
DOT : '.';


	
	
		
___________________________________________________________ 
All new Yahoo! Mail "The new Interface is stunning in its simplicity and ease of use." - PC Magazine 
http://uk.docs.yahoo.com/nowyoucan.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061023/9342eb6a/attachment.html 

From foolishewe at hotmail.com  Mon Oct 23 10:24:06 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Mon, 23 Oct 2006 17:24:06 +0000
Subject: [antlr-interest] A newbie question and is this mailing list
	ablack hole for
In-Reply-To: <20061023160627.GB6190@badgers-in-foil.co.uk>
Message-ID: <BAY107-F3564DC8AEBC109E4A4AC65C0000@phx.gbl>

David:

Thanks for the reply, I appreciate it!

Regarding the keyword recognition, the language specifies what I call 
"keyword completion",
so that if say "namespace" was a keyword and I wanted to recognize "names", 
"namesp", ...,
"namespace", then in the lexer to recognize the token I do:

NAMESPACE: "names" ('p' ('a' ('c' ('e')?)?)?)?;

I suspect I may need to roll a comparison method to allow for completion 
matching.

I hadn't really considered your approach, I guess I could push the keyword 
recognition
back on the parser (although I wonder about the performance hit and how to 
generate
meaningful error messages).  Off the top of my head, I can't see a show 
stopper in this
approach, but I want to think a bit before I try this transformation.

Thanks Again:

Bill M.



>From: David Holroyd <dave at badgers-in-foil.co.uk>
>To: antlr-interest at antlr.org
>Subject: Re: [antlr-interest] A newbie question and is this mailing list 
>ablack hole for me?
>Date: Mon, 23 Oct 2006 16:06:27 +0000
>
>On Mon, Oct 23, 2006 at 03:46:19PM +0000, Foolish Ewe wrote:
> > For my job, I am writing a tool to parse a language, that for
> > historical reasons has what I'll call "undelimited strings", which are
> > positional string parameters with white space delimiiters.  The
> > problem becomes that if the undelimited string has a prefix that
> > matches a keyword, then the scanner will call it a keyword and not a
> > string (which is understandable but not the behavior I want).
>
>I dunno if this helps you, but in the cases where I had the 'is it a
>keyword or an IDENT?' problem, I just dropped the keyword def from the
>lexer, and then had a parser rule with a predicate testing the IDENT
>value.
>
>e.g. 'namespace' is sometimes a keyword, and sometimes an identifier,
>depending on context, so I drop the NAMESPACE definition in the lexer,
>and then replace all references to NAMESPACE in the grammar to a
>namespaceKeyword rule, defined like this:
>
>namespaceKeyword
>	:	{input.LT(1).getText().equals("namespace")}? IDENT
>	;
>
>(You could also change the type of the token with a rewrite, if that
>were useful for your app.)
>
>
>Any good?
>dave
>
>--
>http://david.holroyd.me.uk/

_________________________________________________________________
Try the next generation of search with Windows Live Search today!  
http://imagine-windowslive.com/minisites/searchlaunch/?locale=en-us&source=hmtagline


From foolishewe at hotmail.com  Mon Oct 23 14:21:59 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Mon, 23 Oct 2006 21:21:59 +0000
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
In-Reply-To: <BAY107-F3564DC8AEBC109E4A4AC65C0000@phx.gbl>
Message-ID: <BAY107-F31F0F1749398237EF6E98FC0000@phx.gbl>

Hi Dave and ANTLR list members:

Some early experiences show that I may either be executing this method 
wrong,
or that there may be some limitations in the approach.

Attached is a small sample attempt at doing the sort of stuff Dave seems to 
be
hinting at.  I've noticed that I'm getting nondeterminism messages in the 
parser for both
startRule and Month, probably due to the fact all keywords are scanned in as 
ALPHANUMSTRING
tokens, which doesn't give much distinguishing structure at the leaf nodes 
of the parse tree.
Is my solution prone to this?

The grammar also accepts language constructs which I don't think it should 
accept,
but I haven't tried to hard to shake out bugs from it at this point.
What should the parser be doing if the keyword does NOT match the expected 
string
(e.g. do we make it throw an exception, if so what exception is a good 
choice?)?

Thanks for the help, I'm just trying to do this the smart way.
A revised ANTLR file and Java file are below.

Regards:

Bill M.

*****************Begin ANTLR Source*********************************
//My play area for diagnosing strange ANTLR symptoms
//Version History: 1.0 WAM created


// WAM - Need to add some boilerplate to let Antlr generated files know that 
they are part of the ZTestParser package
header{
	package testing;
}

class P extends Parser;

// Parser options
options{
	k = 2; // Token stream lookahead, remember ANTLR uses LL(k) parsing
}
{
	private boolean recognizeKeyWords = true;

	// checks to see if minlength or more leading characters in pattern are the 
prefix of str
	// note, references the private recognizeKeywords member
	private boolean kwPrefixMatch(	String str,
									String pattern,
									int minlength)
	{
		boolean result;
		if (!recognizeKeyWords){
			result = false; // don't bother to do additional tests at this point
		} else if (str.length() > pattern.length()){
			result = false; // the string is longer than the pattern, so it cannot 
match
		} else if (str.length() < minlength){
			result = false; // the string is too to match the minimum pattern length
		} else {
			String strval = new String(str.toLowerCase()); // For case sensitivity 
reasons
			result = str.startsWith(pattern);
		}
		return result;
	}

}

// Antlr requires Terminals have names beginning with uppercase letters, 
Nonterminals should use lowercase I guess
startRule
	:
		// the actual prefix tokens are different in practice
		getstring:getString
		// I would like to do something like the following actions where lexer is 
a type L object used in lexing
		// This is not the right syntax for this, but it shows the general idea
		// {this.lexer.recognizeKeyWord = false;}
		strval:ALPHANUMSTRING
		// {this.lexer.recognizeKeyWord = true;}
		nl1:NEWLINE sr1:startRule// breaks if the user types in "dun\n" where \n 
is newline
	|
		monthval:month nl2:NEWLINE sr2:startRule
	|
		// added for testing, but won't work for my requirements.
		toggleval:toggle nl3:NEWLINE sr3:startRule
	|
		endval:end nl4:NEWLINE
	;

month
	:
		(jan | feb)// | mar | apr | may | jun | jul | aug | sep | oct | nov | dec)
	;

jan
	:
		{kwPrefixMatch(LT(1).getText(), "jan", 3)}?
		ALPHANUMSTRING
	;

feb
	:
		{kwPrefixMatch(LT(1).getText(), "feb", 3)}?
		ALPHANUMSTRING
	;


getString
	:
		{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
		ALPHANUMSTRING
	;

toggle
	:
		{kwPrefixMatch(LT(1).getText(), "toggle", 3)}?
		ALPHANUMSTRING
	;

end
	:
		{kwPrefixMatch(LT(1).getText(), "end", 3)}?
		ALPHANUMSTRING
	;

class L extends Lexer;

// Lexer options
options{
	k=3; // lookahead (need 2 for new line, 3 should be enough for months)
	charVocabulary='\u0000'..'\u007F'; // Only support printable ASCII 
characters, don't try fancy unicode stuff
	// case sensitivitity turned off
	caseSensitiveLiterals=false;
	caseSensitive=false;
}


NEWLINE
    :   '\r' '\n'    {newline();}        // DOS
    |   '\r'         {newline();}        // Macintosh
    |   '\n'         {newline();}        // UNIX
    ;


WHITESPACE :   ' '  {$setType(Token.SKIP);} // space character
             | '\t' {System.out.println("Found a tab"); tab(); 
$setType(Token.SKIP);};

protected ALPHANUMERIC: ('a'..'z') | ('0'..'9');

ALPHANUMSTRING: (ALPHANUMERIC)+;
************************Begin Java 
Source*************************************
package testing;
import java.io.*;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try{
			System.out.println("Enter a string for the test parser (note this is for 
simple ANTLR test cases)");

			L lexer = new L(new DataInputStream(System.in));


			System.out.println("After lexer instantiated before Parser 
instantiation");
			P parser = new P(lexer);
			System.out.println("After Parser instantiation before StartRule");
			parser.startRule();
			System.out.println("After startRule: Done?");
		} catch(Exception e) {
			System.err.println("exception: "+e);
		}
	}

}


>From: "Foolish Ewe" <foolishewe at hotmail.com>
>To: dave at badgers-in-foil.co.uk, antlr-interest at antlr.org
>Subject: Re: [antlr-interest] A newbie question and is this mailing 
>listablack hole for
>Date: Mon, 23 Oct 2006 17:24:06 +0000
>
>David:
>
>Thanks for the reply, I appreciate it!
>
>Regarding the keyword recognition, the language specifies what I call 
>"keyword completion",
>so that if say "namespace" was a keyword and I wanted to recognize "names", 
>"namesp", ...,
>"namespace", then in the lexer to recognize the token I do:
>
>NAMESPACE: "names" ('p' ('a' ('c' ('e')?)?)?)?;
>
>I suspect I may need to roll a comparison method to allow for completion 
>matching.
>
>I hadn't really considered your approach, I guess I could push the keyword 
>recognition
>back on the parser (although I wonder about the performance hit and how to 
>generate
>meaningful error messages).  Off the top of my head, I can't see a show 
>stopper in this
>approach, but I want to think a bit before I try this transformation.
>
>Thanks Again:
>
>Bill M.
>
>
>
>>From: David Holroyd <dave at badgers-in-foil.co.uk>
>>To: antlr-interest at antlr.org
>>Subject: Re: [antlr-interest] A newbie question and is this mailing list 
>>ablack hole for me?
>>Date: Mon, 23 Oct 2006 16:06:27 +0000
>>
>>On Mon, Oct 23, 2006 at 03:46:19PM +0000, Foolish Ewe wrote:
>> > For my job, I am writing a tool to parse a language, that for
>> > historical reasons has what I'll call "undelimited strings", which are
>> > positional string parameters with white space delimiiters.  The
>> > problem becomes that if the undelimited string has a prefix that
>> > matches a keyword, then the scanner will call it a keyword and not a
>> > string (which is understandable but not the behavior I want).
>>
>>I dunno if this helps you, but in the cases where I had the 'is it a
>>keyword or an IDENT?' problem, I just dropped the keyword def from the
>>lexer, and then had a parser rule with a predicate testing the IDENT
>>value.
>>
>>e.g. 'namespace' is sometimes a keyword, and sometimes an identifier,
>>depending on context, so I drop the NAMESPACE definition in the lexer,
>>and then replace all references to NAMESPACE in the grammar to a
>>namespaceKeyword rule, defined like this:
>>
>>namespaceKeyword
>>	:	{input.LT(1).getText().equals("namespace")}? IDENT
>>	;
>>
>>(You could also change the type of the token with a rewrite, if that
>>were useful for your app.)
>>
>>
>>Any good?
>>dave
>>
>>--
>>http://david.holroyd.me.uk/
>
>_________________________________________________________________
>Try the next generation of search with Windows Live Search today!  
>http://imagine-windowslive.com/minisites/searchlaunch/?locale=en-us&source=hmtagline
>

_________________________________________________________________
Add a Yahoo! contact to Windows Live Messenger for a chance to win a free 
trip! 
http://www.imagine-windowslive.com/minisites/yahoo/default.aspx?locale=en-us&hmtagline


From wboese at ptd.net  Mon Oct 23 17:26:54 2006
From: wboese at ptd.net (Bill Boese)
Date: Mon, 23 Oct 2006 20:26:54 -0400
Subject: [antlr-interest] Newbie question: has anyone been able to build
	the PL/SQL Grammar?
In-Reply-To: <20061020211414.49684.qmail@web55903.mail.re3.yahoo.com>
Message-ID: <001b01c6f703$1bced460$0600a8c0@ingres.prv>

Loring, Terence:

Thanks, I was able to build it deleting the line below but there are a
tremendous number of warnings regarding ambiguities.

>> Did you change it to extend TreeParser not Parser?

Nope, the version posted on the site extends TreeParser as below, my comment
only added.

+++++++++++++++++++++++++++++++++++++++++++++++++++++

class PLSqlTreeWalker extends TreeParser;

options {
    exportVocab = PLSql;
//    k = 4;
    buildAST = true;
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++

Thanks for your help!

- Bill


-----Original Message-----
From: Loring Craymer [mailto:lgcraymer at yahoo.com] 
Sent: Friday, October 20, 2006 5:14 PM
To: Bill Boese; antlr-interest at antlr.org
Subject: Re: [antlr-interest] Newbie question: has anyone been able to build
the PL/SQL Grammar?

Bill--

Just delete that line.  ANTLR 2 treewalkers are effectively k=1.

--Loring

--- Bill Boese <wboese at ptd.net> wrote:

> Hi:
>  
> I am trying to work with the PL/SQL grammar on the website at:
>  
>
http://www.antlr.org/grammar/1107752678378/PLSQLGrammar.g
>  
> and I am getting the errors below:
>  
> +++++++++++++++++++++++++++++++++++++++++++++++
>  
> C:\antlr-2.7.6\examples\plsql>java antlr.Tool
> PLSQLGrammar.g
> ANTLR Parser Generator   Version 2.7.6 (2005-12-22) 
>  1989-2005
> PLSQLGrammar.g:1029:9: Treewalkers only support k=1
> Exiting due to errors.
>  
> +++++++++++++++++++++++++++++++++++++++++++++++
>  
> The referenced line sets the option k = 4, so I am
> wondering if I am missing
> something obvious or if this
> was likely developed on a previous version of antlr
> (I'm using 2.7.6).
>  
> Thanks in advance,
>  
> Bill
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 


From lgcraymer at yahoo.com  Mon Oct 23 19:47:02 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Mon, 23 Oct 2006 19:47:02 -0700 (PDT)
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
In-Reply-To: <BAY107-F31F0F1749398237EF6E98FC0000@phx.gbl>
Message-ID: <20061024024702.88072.qmail@web55914.mail.re3.yahoo.com>

Bill--

Congratulations!  You have discovered the lack of
semantic predicate hoisting in ANTLR 2!  Not many do
that: apart from those of us who sorely missed this
feature in going from PCCTS (ANTLR 1) to ANTLR 2,
yours is the first post on the subject in the past six
years.  One of the pluses of ANTLR 3 is that it is
bringing back predicate hoisting.

What happens in your grammar is that the predicate in
getString (and other such rules) is not part of the
lookahead decision in the calling rule.  startRule
sees getString and looks for any ALPHANUMSTRING; the
predicate is only triggered within getString.  If you
change the
getstring:getString to
{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
		getstring:ALPHANUMSTRING
(that is, don't bury it in a subrule), the error
reported for startRule will disappear.  Alternatively,
you can manually hoist the predicate and do
{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
        getstring:getString

with the same result.

--Loring

--- Foolish Ewe <foolishewe at hotmail.com> wrote:

> Hi Dave and ANTLR list members:
> 
> Some early experiences show that I may either be
> executing this method 
> wrong,
> or that there may be some limitations in the
> approach.
> 
> Attached is a small sample attempt at doing the sort
> of stuff Dave seems to 
> be
> hinting at.  I've noticed that I'm getting
> nondeterminism messages in the 
> parser for both
> startRule and Month, probably due to the fact all
> keywords are scanned in as 
> ALPHANUMSTRING
> tokens, which doesn't give much distinguishing
> structure at the leaf nodes 
> of the parse tree.
> Is my solution prone to this?
> 
> The grammar also accepts language constructs which I
> don't think it should 
> accept,
> but I haven't tried to hard to shake out bugs from
> it at this point.
> What should the parser be doing if the keyword does
> NOT match the expected 
> string
> (e.g. do we make it throw an exception, if so what
> exception is a good 
> choice?)?
> 
> Thanks for the help, I'm just trying to do this the
> smart way.
> A revised ANTLR file and Java file are below.
> 
> Regards:
> 
> Bill M.
> 
> *****************Begin ANTLR
> Source*********************************
> //My play area for diagnosing strange ANTLR symptoms
> //Version History: 1.0 WAM created
> 
> 
> // WAM - Need to add some boilerplate to let Antlr
> generated files know that 
> they are part of the ZTestParser package
> header{
> 	package testing;
> }
> 
> class P extends Parser;
> 
> // Parser options
> options{
> 	k = 2; // Token stream lookahead, remember ANTLR
> uses LL(k) parsing
> }
> {
> 	private boolean recognizeKeyWords = true;
> 
> 	// checks to see if minlength or more leading
> characters in pattern are the 
> prefix of str
> 	// note, references the private recognizeKeywords
> member
> 	private boolean kwPrefixMatch(	String str,
> 									String pattern,
> 									int minlength)
> 	{
> 		boolean result;
> 		if (!recognizeKeyWords){
> 			result = false; // don't bother to do additional
> tests at this point
> 		} else if (str.length() > pattern.length()){
> 			result = false; // the string is longer than the
> pattern, so it cannot 
> match
> 		} else if (str.length() < minlength){
> 			result = false; // the string is too to match the
> minimum pattern length
> 		} else {
> 			String strval = new String(str.toLowerCase()); //
> For case sensitivity 
> reasons
> 			result = str.startsWith(pattern);
> 		}
> 		return result;
> 	}
> 
> }
> 
> // Antlr requires Terminals have names beginning
> with uppercase letters, 
> Nonterminals should use lowercase I guess
> startRule
> 	:
> 		// the actual prefix tokens are different in
> practice
> 		getstring:getString
> 		// I would like to do something like the following
> actions where lexer is 
> a type L object used in lexing
> 		// This is not the right syntax for this, but it
> shows the general idea
> 		// {this.lexer.recognizeKeyWord = false;}
> 		strval:ALPHANUMSTRING
> 		// {this.lexer.recognizeKeyWord = true;}
> 		nl1:NEWLINE sr1:startRule// breaks if the user
> types in "dun\n" where \n 
> is newline
> 	|
> 		monthval:month nl2:NEWLINE sr2:startRule
> 	|
> 		// added for testing, but won't work for my
> requirements.
> 		toggleval:toggle nl3:NEWLINE sr3:startRule
> 	|
> 		endval:end nl4:NEWLINE
> 	;
> 
> month
> 	:
> 		(jan | feb)// | mar | apr | may | jun | jul | aug
> | sep | oct | nov | dec)
> 	;
> 
> jan
> 	:
> 		{kwPrefixMatch(LT(1).getText(), "jan", 3)}?
> 		ALPHANUMSTRING
> 	;
> 
> feb
> 	:
> 		{kwPrefixMatch(LT(1).getText(), "feb", 3)}?
> 		ALPHANUMSTRING
> 	;
> 
> 
> getString
> 	:
> 		{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
> 		ALPHANUMSTRING
> 	;
> 
> toggle
> 	:
> 		{kwPrefixMatch(LT(1).getText(), "toggle", 3)}?
> 		ALPHANUMSTRING
> 	;
> 
> end
> 	:
> 		{kwPrefixMatch(LT(1).getText(), "end", 3)}?
> 		ALPHANUMSTRING
> 	;
> 
> class L extends Lexer;
> 
> // Lexer options
> options{
> 	k=3; // lookahead (need 2 for new line, 3 should be
> enough for months)
> 	charVocabulary='\u0000'..'\u007F'; // Only support
> printable ASCII 
> characters, don't try fancy unicode stuff
> 	// case sensitivitity turned off
> 	caseSensitiveLiterals=false;
> 	caseSensitive=false;
> }
> 
> 
> NEWLINE
>     :   '\r' '\n'    {newline();}        // DOS
>     |   '\r'         {newline();}        //
> Macintosh
>     |   '\n'         {newline();}        // UNIX
>     ;
> 
> 
> WHITESPACE :   ' '  {$setType(Token.SKIP);} // space
> character
>              | '\t' {System.out.println("Found a
> tab"); tab(); 
> $setType(Token.SKIP);};
> 
> protected ALPHANUMERIC: ('a'..'z') | ('0'..'9');
> 
> ALPHANUMSTRING: (ALPHANUMERIC)+;
> ************************Begin Java 
> Source*************************************
> package testing;
> import java.io.*;
> 
> public class Main {
> 
> 
=== message truncated ===


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From yutao at td-tech.com  Mon Oct 23 22:55:49 2006
From: yutao at td-tech.com (Yu Tao)
Date: Tue, 24 Oct 2006 13:55:49 +0800
Subject: [antlr-interest] Help. Who can tell me what's the mean of # in the
	.g file of parser?
Message-ID: <47E3A002773FF54CAEC246D7C7AD4099FC73C0@SHMSX.SH.TD-TECH.net>

I can not find these grammer meaning in the manual doc , who can tell me
which this means? Tks



// This is a list of expressions.
expressionList
	:	expression (COMMA! expression)*
		{#expressionList = #(#[ELIST,"ELIST"], expressionList);}
//?? what's the mean of #
	;

superClassClause!
	:	( "extends" id:identifier )?
		{#superClassClause =
#(#[EXTENDS_CLAUSE,"EXTENDS_CLAUSE"],id);}   	//?? what's the mean of
#
	;
	
	
// boolean relational expressions (level 5)
relationalExpression
	:	shiftExpression
		(	(	(	LT^
				|	GT^
				|	LE^
				|	GE^
				)
				shiftExpression
			)*
		|	"instanceof"^ typeSpec[true]      //?? what's
the difference of  "instanceof"^ typeSpec and "instanceof"^
typeSpec[true]
		)
	;

From dave at badgers-in-foil.co.uk  Tue Oct 24 01:47:39 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Tue, 24 Oct 2006 08:47:39 +0000
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
In-Reply-To: <20061024024702.88072.qmail@web55914.mail.re3.yahoo.com>
References: <BAY107-F31F0F1749398237EF6E98FC0000@phx.gbl>
	<20061024024702.88072.qmail@web55914.mail.re3.yahoo.com>
Message-ID: <20061024084739.GA20352@badgers-in-foil.co.uk>

On Mon, Oct 23, 2006 at 07:47:02PM -0700, Loring Craymer wrote:
> Congratulations!  You have discovered the lack of
> semantic predicate hoisting in ANTLR 2!

Eek!  Sorry Foolish Ewe, I forgot to say that I was executing that trick
in an ANTLR3 grammar (didn't realise this wouldn't work in v2).  Forgive!  :(


dave

From foolishewe at hotmail.com  Tue Oct 24 05:57:01 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Tue, 24 Oct 2006 12:57:01 +0000
Subject: [antlr-interest] A newbie question and is this
	mailinglistablack hole for
In-Reply-To: <20061024084739.GA20352@badgers-in-foil.co.uk>
Message-ID: <BAY107-F16820778E42026DDA0FA18C0010@phx.gbl>


Hi Dave:

Actually I'm pretty overjoyed at the help you offerred, and I'm the one
who is sorry for putting you and the other folks out.  You can call me Bill,
I have needed an account without my name for usenet posting for the last 
several years,
my last name is unfortunately unique and leads to oodles of spam :-(, hence 
the
"pseudo-anonymous" account for things like mailing list postings.

Thanks for the hint, it is still an avenue I'm explorig (even with the 
hoisting issues).

Bill M.

>From: David Holroyd <dave at badgers-in-foil.co.uk>
>To: antlr-interest at antlr.org
>Subject: Re: [antlr-interest] A newbie question and is this 
>mailinglistablack hole for
>Date: Tue, 24 Oct 2006 08:47:39 +0000
>
>On Mon, Oct 23, 2006 at 07:47:02PM -0700, Loring Craymer wrote:
> > Congratulations!  You have discovered the lack of
> > semantic predicate hoisting in ANTLR 2!
>
>Eek!  Sorry Foolish Ewe, I forgot to say that I was executing that trick
>in an ANTLR3 grammar (didn't realise this wouldn't work in v2).  Forgive!  
>:(
>
>
>dave

_________________________________________________________________
Get today's hot entertainment gossip  
http://movies.msn.com/movies/hotgossip?icid=T002MSN03A07001


From foolishewe at hotmail.com  Tue Oct 24 06:45:30 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Tue, 24 Oct 2006 13:45:30 +0000
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
Message-ID: <BAY107-F19D8A582A47B1E3A7A0B32C0010@phx.gbl>

Hi Loring:

Thanks for the encouragement, however, I don't think this particular
discovery will get me the Nobel prize (or Turing award if you prefer) :-).
At least I haven't belabored a FAQ point that had a lot of recent mailing 
list activity.
Regarding the mailing list archives, if I could lobby for a feature, I would 
like
to see a search option for the archives page (it could dummy up say a google 
search
or some such trick).

I tried this approach because of my own ignorance (I may be a slow learner,
but I'm learning :-) ), if we go back to the original problem that motivated 
the
approach, I wanted the parser to communicate a boolean value to the scanner
to control the scanning.  While it may be possible to push the scanner's job
back into the parser, I was initially inclined to have the scanner do it.  
I'd like
to revisit that option at this time.

In the Java source for Main (snipped off the end of the e-mail exchanges)
there was an instantiation the parser object of class P, and it was passed a 
lexer object of class L,
as follows (actual source code shown).

	L lexer = new L(new DataInputStream(System.in));
	P parser = new P(lexer);

In my original approach I used the ANTLR source to add a public booean 
member, say
"recognizeKeyWords" to class L, which in turn uses recognizeKeyWords as a 
predicate
to know when to prefer strings to key words.  I got that working correctly 
in the lexer,
but never was able to control it from the parser.  Now let's look at the 
constructor
for class P used here. Normally when I see such a constructor, I expect that 
class to
have a reference/handle for the object passed in.

1) Are my assumptions wrong? Is using the parser to control lexer a bad 
idea?
    Is it really the right thing to push the scanner's work back on the 
parser?
2) If I'm right, what is the name of the handle to lexer of type L in P of 
type parser?
3) If I'm right, what is the syntax for referencing lexer.recognizeKeyWords 
in parser?

Regards:

Bill M.


>From: Loring Craymer <lgcraymer at yahoo.com>
>To: Foolish Ewe <foolishewe at hotmail.com>, dave at badgers-in-foil.co.uk,  
>antlr-interest at antlr.org
>Subject: Re: [antlr-interest] A newbie question and is this mailing 
>listablack hole for
>Date: Mon, 23 Oct 2006 19:47:02 -0700 (PDT)
>
>Bill--
>
>Congratulations!  You have discovered the lack of
>semantic predicate hoisting in ANTLR 2!  Not many do
>that: apart from those of us who sorely missed this
>feature in going from PCCTS (ANTLR 1) to ANTLR 2,
>yours is the first post on the subject in the past six
>years.  One of the pluses of ANTLR 3 is that it is
>bringing back predicate hoisting.
>
>What happens in your grammar is that the predicate in
>getString (and other such rules) is not part of the
>lookahead decision in the calling rule.  startRule
>sees getString and looks for any ALPHANUMSTRING; the
>predicate is only triggered within getString.  If you
>change the
>getstring:getString to
>{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
>		getstring:ALPHANUMSTRING
>(that is, don't bury it in a subrule), the error
>reported for startRule will disappear.  Alternatively,
>you can manually hoist the predicate and do
>{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
>         getstring:getString
>
>with the same result.
>
>--Loring
>
>--- Foolish Ewe <foolishewe at hotmail.com> wrote:
>
> > Hi Dave and ANTLR list members:
> >
> > Some early experiences show that I may either be
> > executing this method
> > wrong,
> > or that there may be some limitations in the
> > approach.
> >
> > Attached is a small sample attempt at doing the sort
> > of stuff Dave seems to
> > be
> > hinting at.  I've noticed that I'm getting
> > nondeterminism messages in the
> > parser for both
> > startRule and Month, probably due to the fact all
> > keywords are scanned in as
> > ALPHANUMSTRING
> > tokens, which doesn't give much distinguishing
> > structure at the leaf nodes
> > of the parse tree.
> > Is my solution prone to this?
> >
> > The grammar also accepts language constructs which I
> > don't think it should
> > accept,
> > but I haven't tried to hard to shake out bugs from
> > it at this point.
> > What should the parser be doing if the keyword does
> > NOT match the expected
> > string
> > (e.g. do we make it throw an exception, if so what
> > exception is a good
> > choice?)?
> >
> > Thanks for the help, I'm just trying to do this the
> > smart way.
> > A revised ANTLR file and Java file are below.
> >
> > Regards:
> >
> > Bill M.
> >
> > *****************Begin ANTLR
> > Source*********************************
> > //My play area for diagnosing strange ANTLR symptoms
> > //Version History: 1.0 WAM created
> >
> >
> > // WAM - Need to add some boilerplate to let Antlr
> > generated files know that
> > they are part of the ZTestParser package
> > header{
> > 	package testing;
> > }
> >
> > class P extends Parser;
> >
> > // Parser options
> > options{
> > 	k = 2; // Token stream lookahead, remember ANTLR
> > uses LL(k) parsing
> > }
> > {
> > 	private boolean recognizeKeyWords = true;
> >
> > 	// checks to see if minlength or more leading
> > characters in pattern are the
> > prefix of str
> > 	// note, references the private recognizeKeywords
> > member
> > 	private boolean kwPrefixMatch(	String str,
> > 									String pattern,
> > 									int minlength)
> > 	{
> > 		boolean result;
> > 		if (!recognizeKeyWords){
> > 			result = false; // don't bother to do additional
> > tests at this point
> > 		} else if (str.length() > pattern.length()){
> > 			result = false; // the string is longer than the
> > pattern, so it cannot
> > match
> > 		} else if (str.length() < minlength){
> > 			result = false; // the string is too to match the
> > minimum pattern length
> > 		} else {
> > 			String strval = new String(str.toLowerCase()); //
> > For case sensitivity
> > reasons
> > 			result = str.startsWith(pattern);
> > 		}
> > 		return result;
> > 	}
> >
> > }
> >
> > // Antlr requires Terminals have names beginning
> > with uppercase letters,
> > Nonterminals should use lowercase I guess
> > startRule
> > 	:
> > 		// the actual prefix tokens are different in
> > practice
> > 		getstring:getString
> > 		// I would like to do something like the following
> > actions where lexer is
> > a type L object used in lexing
> > 		// This is not the right syntax for this, but it
> > shows the general idea
> > 		// {this.lexer.recognizeKeyWord = false;}
> > 		strval:ALPHANUMSTRING
> > 		// {this.lexer.recognizeKeyWord = true;}
> > 		nl1:NEWLINE sr1:startRule// breaks if the user
> > types in "dun\n" where \n
> > is newline
> > 	|
> > 		monthval:month nl2:NEWLINE sr2:startRule
> > 	|
> > 		// added for testing, but won't work for my
> > requirements.
> > 		toggleval:toggle nl3:NEWLINE sr3:startRule
> > 	|
> > 		endval:end nl4:NEWLINE
> > 	;
> >
> > month
> > 	:
> > 		(jan | feb)// | mar | apr | may | jun | jul | aug
> > | sep | oct | nov | dec)
> > 	;
> >
> > jan
> > 	:
> > 		{kwPrefixMatch(LT(1).getText(), "jan", 3)}?
> > 		ALPHANUMSTRING
> > 	;
> >
> > feb
> > 	:
> > 		{kwPrefixMatch(LT(1).getText(), "feb", 3)}?
> > 		ALPHANUMSTRING
> > 	;
> >
> >
> > getString
> > 	:
> > 		{kwPrefixMatch(LT(1).getText(), "getstring", 4)}?
> > 		ALPHANUMSTRING
> > 	;
> >
> > toggle
> > 	:
> > 		{kwPrefixMatch(LT(1).getText(), "toggle", 3)}?
> > 		ALPHANUMSTRING
> > 	;
> >
> > end
> > 	:
> > 		{kwPrefixMatch(LT(1).getText(), "end", 3)}?
> > 		ALPHANUMSTRING
> > 	;
> >
> > class L extends Lexer;
> >
> > // Lexer options
> > options{
> > 	k=3; // lookahead (need 2 for new line, 3 should be
> > enough for months)
> > 	charVocabulary='\u0000'..'\u007F'; // Only support
> > printable ASCII
> > characters, don't try fancy unicode stuff
> > 	// case sensitivitity turned off
> > 	caseSensitiveLiterals=false;
> > 	caseSensitive=false;
> > }
> >
> >
> > NEWLINE
> >     :   '\r' '\n'    {newline();}        // DOS
> >     |   '\r'         {newline();}        //
> > Macintosh
> >     |   '\n'         {newline();}        // UNIX
> >     ;
> >
> >
> > WHITESPACE :   ' '  {$setType(Token.SKIP);} // space
> > character
> >              | '\t' {System.out.println("Found a
> > tab"); tab();
> > $setType(Token.SKIP);};
> >
> > protected ALPHANUMERIC: ('a'..'z') | ('0'..'9');
> >
> > ALPHANUMSTRING: (ALPHANUMERIC)+;
> > ************************Begin Java
> > Source*************************************
> > package testing;
> > import java.io.*;
> >
> > public class Main {
> >
> >
>=== message truncated ===
>
>
>__________________________________________________
>Do You Yahoo!?
>Tired of spam?  Yahoo! Mail has the best spam protection around
>http://mail.yahoo.com

_________________________________________________________________
All-in-one security and maintenance for your PC.  Get a free 90-day trial! 
http://clk.atdmt.com/MSN/go/msnnkwlo0050000002msn/direct/01/?href=http://www.windowsonecare.com/?sc_cid=msn_hotmail


From lgcraymer at yahoo.com  Tue Oct 24 09:37:01 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 24 Oct 2006 09:37:01 -0700 (PDT)
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
In-Reply-To: <20061024084739.GA20352@badgers-in-foil.co.uk>
Message-ID: <20061024163701.77476.qmail@web55901.mail.re3.yahoo.com>

The sempreds work, it's just the hoisting that does
not.  If the rest of his grammar looks like what Bill
showed, he should be able to get it to work with only
a little refactoring.

--Loring


--- David Holroyd <dave at badgers-in-foil.co.uk> wrote:

> On Mon, Oct 23, 2006 at 07:47:02PM -0700, Loring
> Craymer wrote:
> > Congratulations!  You have discovered the lack of
> > semantic predicate hoisting in ANTLR 2!
> 
> Eek!  Sorry Foolish Ewe, I forgot to say that I was
> executing that trick
> in an ANTLR3 grammar (didn't realise this wouldn't
> work in v2).  Forgive!  :(
> 
> 
> dave
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From autophile at zoominternet.net  Tue Oct 24 10:15:57 2006
From: autophile at zoominternet.net (Robert Baruch)
Date: Tue, 24 Oct 2006 13:15:57 -0400
Subject: [antlr-interest] [3.0b4] StackOverflowError report
Message-ID: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>

Hi all,

I have found a grammar which, although admittedly ridiculous,  
nevertheless passes through ANTLR but throws a StackOverflowError  
when parsing anything (in this case, the sentence "nn").

Is there something wrong with the grammar? ANTLR?

Thanks,

--Rob


grammar TestParser;
options { superClass = GeneratedParser; }
@parser::header {
   import grammatotron.*; }

start : r0 EOF ;
r0 : r1 r0  ;
r1 : N  ;


N : 'n';
V : 'v';

Exception in thread "main" java.lang.StackOverflowError
	at org.antlr.runtime.BaseRecognizer.combineFollows 
(BaseRecognizer.java:388)
	at org.antlr.runtime.BaseRecognizer.computeContextSensitiveRuleFOLLOW 
(BaseRecognizer.java:376)
	at org.antlr.runtime.BaseRecognizer.recoverFromMismatchedElement 
(BaseRecognizer.java:478)
	at org.antlr.runtime.BaseRecognizer.recoverFromMismatchedToken 
(BaseRecognizer.java:445)
	at org.antlr.runtime.BaseRecognizer.mismatch(BaseRecognizer.java:98)
	at org.antlr.runtime.BaseRecognizer.match(BaseRecognizer.java:80)
	at TestParser.r1(TestParser.java:92)
	at TestParser.r0(TestParser.java:63)
	at TestParser.r0(TestParser.java:67)
	at TestParser.r0(TestParser.java:67)
	at TestParser.r0(TestParser.java:67)
	at TestParser.r0(TestParser.java:67)
	at TestParser.r0(TestParser.java:67)
(etc)

--Rob

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061024/65cc6ad9/attachment.html 

From lgcraymer at yahoo.com  Tue Oct 24 10:27:30 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 24 Oct 2006 10:27:30 -0700 (PDT)
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
In-Reply-To: <BAY107-F19D8A582A47B1E3A7A0B32C0010@phx.gbl>
Message-ID: <20061024172730.44838.qmail@web55910.mail.re3.yahoo.com>



--- Foolish Ewe <foolishewe at hotmail.com> wrote:
> 1) Are my assumptions wrong? Is using the parser to
> control lexer a bad 
> idea?

Yes.  The problem is lookahead--decisions are made
based on not only the next token but sometimes several
more after that.  "Now" for the parser could be 5
tokens in the "past" for the lexer.  That is probably
why you encountered unexpected results when you tried
to add feedback.

>     Is it really the right thing to push the
> scanner's work back on the 
> parser?

Separating functionality between parser and lexer is
sometimes a challenge.  Sometimes it is a case of
"whatever works"; other times, there is a clear
boundary.  Judgement improves with experience; I
cannot think of a set of hard and fast rules.  Messy
problems sometimes have messy solutions!

--Loring

> 2) If I'm right, what is the name of the handle to
> lexer of type L in P of 
> type parser?
> 3) If I'm right, what is the syntax for referencing
> lexer.recognizeKeyWords 
> in parser?
> 
> Regards:
> 
> Bill M.


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From ewbank at gmail.com  Tue Oct 24 13:21:49 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Tue, 24 Oct 2006 16:21:49 -0400
Subject: [antlr-interest] Who can tell me what's the mean of # in the .g
	file of parser?
Message-ID: <dd3a065f0610241321r2c414383j9216d1a51352d0f3@mail.gmail.com>

Blasted mailer defaults :-( ... ... ...


On 10/24/06, Yu Tao <yutao at td-tech.com> wrote:
> I can not find these grammer meaning in the manual doc, who can tell me which
> this means?

--- --- ---
Definition of The # Forms
--- --- ---

It means, "a tree node with....".  The forms seen are:

   #[ ... ]    -- create a single node with the given type and text
   #( ... )    -- create a tree with the first argument as root and all
                  following arguments as children
                  >>> NOTE THAT THE ARGUMENTS CAN BE LISTS <<<
   #foo        -- reference the (possibly created) tree associated with the
                  (sub)production named "foo"
   ##          -- an alias for the (possibly created) tree associated with the
                  current production

--- --- ---
Some Examples
--- --- ---

> expressionList
>     : expression (COMMA! expression)*
>        { #expressionList = #(#[ELIST,"ELIST"], #expressionList); }
>     ;

The last line means "create a tree with root ELIST/"ELIST", and use whatever
has been generated for #expressionList as the children.

--- --- ---

> expressionList
>     : expression (COMMA! expression)*
>        { ## = #(#[ELIST,"ELIST"], ##); }
>     ;

This means exactly the same thing, but is more easily understood and less error
prone if you change the name of the production.

--- --- ---

> superClassClause!
>     : ( "extends" id:identifier )?
>        { ## = #(#[EXTENDS_CLAUSE,"EXTENDS_CLAUSE"],id); }
>     ;

Here, ## (the tree for superClassClaus) is defined to be a simple AST with
EXTEND_CLAUSE as the root and the tree (list) returned by the production named
"id" as it's child or children.

--- --- ---

Hope this helps,
- Bryan Ewbank

From foolishewe at hotmail.com  Tue Oct 24 13:26:33 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Tue, 24 Oct 2006 20:26:33 +0000
Subject: [antlr-interest] A newbie question and is this mailing
	listablack hole for
Message-ID: <BAY107-F24D60F7805E6E6A86766B9C0010@phx.gbl>

Hello Loring:

Thanks for your patience with my rookie questions.  On a side note I 
discovered
a trick to directly access the lexer in the parser (wrap ANTLR's constructor 
with
my own constructor, which preserves a reference to the lexer).  However, I 
also
confirmed that the parser's handling of the token and its string occurs 
quite a
bit after it is scanned, so the timing of the actions invocations in the 
parser
can occur too late for the scanner.


I guess the options are:
1) Manual hoisting (as per your original hint).  I'm still trying it in a 
small example, but I'm not
    really having any joy currently.  I'm not sure if there is any smart way 
to do it :-(
    Some rules (like month: ("jan" | "feb" | ... | "dec")) become complex, 
and I'm not sure
    if that semantic predicate in turn has to be hoisted :-(.
    So while it can be done i guess, but there may be more hoisting I had 
hoped,
    and in fact was indicated in the simple example shown.  I'll know better 
when I
    start trying.  Looking at the language, I think there are terminals that 
on the left hand side
    of multiple productions, so it appears that recognition will have to be 
done thoughout the code
    (every single place a key word is used in a production from what I can 
tell)
    instead of in one place where the key word is defined. :-(.
2) Trying a newer version of ANTLR (3.x) - I'm not sure about that for 
ANTLR's stabiity and
    local reasons (e.g. we are an eclipse shop here, and I'm not sure ANTLR 
3.x has eclipse
    plugins, etc.)  I'm inclined to investigate this one if it is likely to 
be quick, however
    the ANTLR 3 docs aren't very fleshed out yet.  Any howtos on getting 
started in Windows XP?

Thanks:

Bill

>From: Loring Craymer <lgcraymer at yahoo.com>
>To: Foolish Ewe <foolishewe at hotmail.com>, antlr-interest at antlr.org,  
>dave at badgers-in-foil.co.uk
>CC: FoolishEwe at hotmail.com
>Subject: Re: [antlr-interest] A newbie question and is this mailing 
>listablack hole for
>Date: Tue, 24 Oct 2006 10:27:30 -0700 (PDT)
>
>
>
>--- Foolish Ewe <foolishewe at hotmail.com> wrote:
> > 1) Are my assumptions wrong? Is using the parser to
> > control lexer a bad
> > idea?
>
>Yes.  The problem is lookahead--decisions are made
>based on not only the next token but sometimes several
>more after that.  "Now" for the parser could be 5
>tokens in the "past" for the lexer.  That is probably
>why you encountered unexpected results when you tried
>to add feedback.
>
> >     Is it really the right thing to push the
> > scanner's work back on the
> > parser?
>
>Separating functionality between parser and lexer is
>sometimes a challenge.  Sometimes it is a case of
>"whatever works"; other times, there is a clear
>boundary.  Judgement improves with experience; I
>cannot think of a set of hard and fast rules.  Messy
>problems sometimes have messy solutions!
>
>--Loring
>
> > 2) If I'm right, what is the name of the handle to
> > lexer of type L in P of
> > type parser?
> > 3) If I'm right, what is the syntax for referencing
> > lexer.recognizeKeyWords
> > in parser?
> >
> > Regards:
> >
> > Bill M.
>
>
>__________________________________________________
>Do You Yahoo!?
>Tired of spam?  Yahoo! Mail has the best spam protection around
>http://mail.yahoo.com

_________________________________________________________________
Stay in touch with old friends and meet new ones with Windows Live Spaces 
http://clk.atdmt.com/MSN/go/msnnkwsp0070000001msn/direct/01/?href=http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us


From autophile at zoominternet.net  Tue Oct 24 13:58:41 2006
From: autophile at zoominternet.net (Robert Baruch)
Date: Tue, 24 Oct 2006 16:58:41 -0400
Subject: [antlr-interest] [3.0b4] StackOverflowError report
In-Reply-To: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>
References: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>
Message-ID: <26BD72D4-28E6-42B1-87B6-D09D476A5B3F@zoominternet.net>

Additional info, the equivalent grammar:

> start : r0 EOF ;
> r0 : N r0  ;
> r1 : N  ;

does not cause a stack overflow. So what's wrong with the r0 : r1 r0  
grammar?

--Rob


On Oct 24, 2006, at 1:15 PM, Robert Baruch wrote:

> Hi all,
>
> I have found a grammar which, although admittedly ridiculous,  
> nevertheless passes through ANTLR but throws a StackOverflowError  
> when parsing anything (in this case, the sentence "nn").
>
> Is there something wrong with the grammar? ANTLR?
>
> Thanks,
>
> --Rob
>
>
> grammar TestParser;
> options { superClass = GeneratedParser; }
> @parser::header {
>   import grammatotron.*; }
>
> start : r0 EOF ;
> r0 : r1 r0  ;
> r1 : N  ;
>
>
> N : 'n';
> V : 'v';
>
> Exception in thread "main" java.lang.StackOverflowError
> 	at org.antlr.runtime.BaseRecognizer.combineFollows 
> (BaseRecognizer.java:388)
> 	at  
> org.antlr.runtime.BaseRecognizer.computeContextSensitiveRuleFOLLOW 
> (BaseRecognizer.java:376)
> 	at org.antlr.runtime.BaseRecognizer.recoverFromMismatchedElement 
> (BaseRecognizer.java:478)
> 	at org.antlr.runtime.BaseRecognizer.recoverFromMismatchedToken 
> (BaseRecognizer.java:445)
> 	at org.antlr.runtime.BaseRecognizer.mismatch(BaseRecognizer.java:98)
> 	at org.antlr.runtime.BaseRecognizer.match(BaseRecognizer.java:80)
> 	at TestParser.r1(TestParser.java:92)
> 	at TestParser.r0(TestParser.java:63)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> (etc)
>
> --Rob
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061024/607d2b91/attachment.html 

From jbb at acm.org  Tue Oct 24 15:23:57 2006
From: jbb at acm.org (John B. Brodie)
Date: Tue, 24 Oct 2006 18:23:57 -0400
Subject: [antlr-interest] [3.0b4] StackOverflowError report
In-Reply-To: <26BD72D4-28E6-42B1-87B6-D09D476A5B3F@zoominternet.net> (message
	from Robert Baruch on Tue, 24 Oct 2006 16:58:41 -0400)
References: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>
	<26BD72D4-28E6-42B1-87B6-D09D476A5B3F@zoominternet.net>
Message-ID: <E1GcUgf-00057V-00@gecko>

>Additional info, the equivalent grammar:
>
>> start : r0 EOF ;
>> r0 : N r0  ;
>> r1 : N  ;
>
>does not cause a stack overflow. So what's wrong with the r0 : r1 r0  
>grammar?

...snipped...
...a grammar that causes stack overflow

> grammar TestParser;
> options { superClass = GeneratedParser; }
> @parser::header {
>   import grammatotron.*; }
>
> start : r0 EOF ;
> r0 : r1 r0  ;
> r1 : N  ;
>
>
> N : 'n';
> V : 'v';
>
> Exception in thread "main" java.lang.StackOverflowError
> 	at org.antlr.runtime.BaseRecognizer.combineFollows 
> (BaseRecognizer.java:388)
> 	at  
> org.antlr.runtime.BaseRecognizer.computeContextSensitiveRuleFOLLOW 
> (BaseRecognizer.java:376)
> 	at org.antlr.runtime.BaseRecognizer.recoverFromMismatchedElement 
> (BaseRecognizer.java:478)
> 	at org.antlr.runtime.BaseRecognizer.recoverFromMismatchedToken 
> (BaseRecognizer.java:445)
> 	at org.antlr.runtime.BaseRecognizer.mismatch(BaseRecognizer.java:98)
> 	at org.antlr.runtime.BaseRecognizer.match(BaseRecognizer.java:80)
> 	at TestParser.r1(TestParser.java:92)
> 	at TestParser.r0(TestParser.java:63)
> 	at TestParser.r0(TestParser.java:67)

observe that the stack overflow occurs while trying to recover from a syntax
error...

observe that both of the above grammars get syntax errors when run.

this happens because there is no base-case for the r0 recursive rule. that is,
an r0 *ALWAYS* has another r0 as its tail.  thus we are expected to parse an
INFINITE sequence of N's followed by an EOF. Impossible.

do you mean r0 : r1 + ; or r0 : (r1 r0) | r1 ; <-- both are equivalent.
or perhaps  r0 : r1 * ; or r0 : (r1 r0) | /*empty*/ ; <-- both are equivalent.

i do not know why error recovery terminates under the `r0 : N r0 ;` rule but
not under the `r0 : r1 r0 ;` rule.

Hope this helps...
   -jbb

From lgcraymer at yahoo.com  Tue Oct 24 16:17:20 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Tue, 24 Oct 2006 16:17:20 -0700 (PDT)
Subject: [antlr-interest] [3.0b4] StackOverflowError report
In-Reply-To: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>
Message-ID: <20061024231720.17867.qmail@web55905.mail.re3.yahoo.com>

It's the grammar.  You cannot expect

r0:  r1 r0 ;

to terminate--it is looking for an infinite number of
r1's.

--Loring


--- Robert Baruch <autophile at zoominternet.net> wrote:

> Hi all,
> 
> I have found a grammar which, although admittedly
> ridiculous,  
> nevertheless passes through ANTLR but throws a
> StackOverflowError  
> when parsing anything (in this case, the sentence
> "nn").
> 
> Is there something wrong with the grammar? ANTLR?
> 
> Thanks,
> 
> --Rob
> 
> 
> grammar TestParser;
> options { superClass = GeneratedParser; }
> @parser::header {
>    import grammatotron.*; }
> 
> start : r0 EOF ;
> r0 : r1 r0  ;
> r1 : N  ;
> 
> 
> N : 'n';
> V : 'v';
> 
> Exception in thread "main"
> java.lang.StackOverflowError
> 	at org.antlr.runtime.BaseRecognizer.combineFollows 
> (BaseRecognizer.java:388)
> 	at
>
org.antlr.runtime.BaseRecognizer.computeContextSensitiveRuleFOLLOW
> 
> (BaseRecognizer.java:376)
> 	at
>
org.antlr.runtime.BaseRecognizer.recoverFromMismatchedElement
> 
> (BaseRecognizer.java:478)
> 	at
>
org.antlr.runtime.BaseRecognizer.recoverFromMismatchedToken
> 
> (BaseRecognizer.java:445)
> 	at
>
org.antlr.runtime.BaseRecognizer.mismatch(BaseRecognizer.java:98)
> 	at
>
org.antlr.runtime.BaseRecognizer.match(BaseRecognizer.java:80)
> 	at TestParser.r1(TestParser.java:92)
> 	at TestParser.r0(TestParser.java:63)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> 	at TestParser.r0(TestParser.java:67)
> (etc)
> 
> --Rob
> 
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From autophile at zoominternet.net  Tue Oct 24 20:03:51 2006
From: autophile at zoominternet.net (Robert Baruch)
Date: Tue, 24 Oct 2006 23:03:51 -0400
Subject: [antlr-interest] [3.0b4] StackOverflowError report
In-Reply-To: <E1GcUgf-00057V-00@gecko>
References: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>
	<26BD72D4-28E6-42B1-87B6-D09D476A5B3F@zoominternet.net>
	<E1GcUgf-00057V-00@gecko>
Message-ID: <D18A4EED-C5C8-47D0-8756-3901AE9AF8DA@zoominternet.net>


>
> observe that both of the above grammars get syntax errors when run.
>
> this happens because there is no base-case for the r0 recursive  
> rule. that is,
> an r0 *ALWAYS* has another r0 as its tail.  thus we are expected to  
> parse an
> INFINITE sequence of N's followed by an EOF. Impossible.
>
> do you mean r0 : r1 + ; or r0 : (r1 r0) | r1 ; <-- both are  
> equivalent.
> or perhaps  r0 : r1 * ; or r0 : (r1 r0) | /*empty*/ ; <-- both are  
> equivalent.
>

My application generates random grammars, then runs them through  
ANTLR. Any grammar that passes ANTLR compilation gets run through the  
Java compiler. Any grammar that passes Java compilation gets run  
against a few test sentences. So I really meant r0 : r1 r0.

> i do not know why error recovery terminates under the `r0 : N r0 ;`  
> rule but
> not under the `r0 : r1 r0 ;` rule.

That's the key. To my eyes anyway, the two grammars are equivalent,  
yet one causes ANTLR to crash, while the other proceeds normally.

--Rob


From ewbank at gmail.com  Wed Oct 25 03:25:03 2006
From: ewbank at gmail.com (Bryan Ewbank)
Date: Wed, 25 Oct 2006 06:25:03 -0400
Subject: [antlr-interest] Who can tell me what's the mean of # in the
	.gfile of parser?
In-Reply-To: <47E3A002773FF54CAEC246D7C7AD4099FC78A8@SHMSX.SH.TD-TECH.net>
References: <47E3A002773FF54CAEC246D7C7AD4099FC78A8@SHMSX.SH.TD-TECH.net>
Message-ID: <dd3a065f0610250325o72b4f7een6ac62edc4ef32340@mail.gmail.com>

I can only speak for C++ here... have yet to use Java...

The [] are used to pass additional arguments to a production -- formally, to
pass inherited attributes.  They require the production to be declared with
additional inputs.  The current AST node is always the first argument to the
function in the generated C++ code, those you provide are added as additional
arguments.

   relExpr : typeSpec[true] ;

   // when matching a relExpr, attempt to match a typeSpec using the value
   // "true" as an inherited attribute

Note that synthesized attributes (those passed up the tree) can be passed this
way as well...

   relExpr
   { int x = 0; }
   :  myExpr[&x]
      { ... x ... }
   ;

   // the address of "x" is passed to myExpr, and we assume that myExpr will
   // change the value of x in some way before passing control back to the
   // relExpr production.

On 10/24/06, Yu Tao <yutao at td-tech.com> wrote:
> And, can I ask u one futher question?  what's the mean of []?
>
> relationalExpression
> : shiftExpression
>   (
>     (
>       ( LT^ | GT^ | LE^ | GE^ )
>       shiftExpression
>     )*
>   |
>     "instanceof"^ typeSpec[true]
>   )
> ;

From antlr at thewolery.demon.co.uk  Wed Oct 25 04:11:47 2006
From: antlr at thewolery.demon.co.uk (Anthony W. Youngman)
Date: Wed, 25 Oct 2006 12:11:47 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45267B17.6060107@jazillian.com>
References: <8818ADCA969F2F4DA513CEE078066DCA01F2DA15@rock-exchange.microfocus.com>
	<45267B17.6060107@jazillian.com>
Message-ID: <jrLmXEkzZ0PFFwwT@thewolery.demon.co.uk>

In message <45267B17.6060107 at jazillian.com>, Andy Tripp 
<antlr at jazillian.com> writes
>Jim O'Connor wrote:
>
>>
>>COBOL -> generic language -> JAVA. In the general case, any specific
>>language -> generic language.  Generic language -> any specific
>>language.
>>
>>
>I've thought a lot about this idea of having a generic intermediate 
>representation. There are at least
>a couple of products that say they do this. I can't see how to make it 
>work. Say we have
>a generic "add A to B" idea ("ADD A TO B" in COBOL, "B += A" in Java). 
>If we're going to
>produce "natural" Java code, we'll produce "A++" when B is 1. Or should 
>it be "++A"???
>No way to know, unless we also store that information, so we add some 
>flag to our
>generic representation. The guy working on the generic-to-Java part 
>demands that the
>guy working on the COBOL-to-generic part stores that information, even 
>though it's
>meaningless to the COBOL guy.
>
>Then, the next day, the generic-to-Java guy realizes that A can be any 
>arbitrary expression,
>and that the expression must be evaluated first, before the assignment 
>is made. He starts
>going to make the generic representation more generic, and the COBOL 
>sees him and says
>"WTF are you doing? You can only add two numbers! I'm not going to deal 
>with your
>complicated data structure, I just want to store the fact that you're 
>adding one number to another.
>
>And then the next day, the problem goes the other way. The COBOL guy 
>realizes that
>the Java guy is going to need to know that B is 10 digits before the 
>decimal, 5 after the decimal,
>and a particular precision. The Java guy eventually realizes
>that he can't even use "B += A", he's got to use BigDecimal. That 
>doesn't bother him so much
>as the term "digits".  "You're going to tell me how many 'digits' it 
>is???" He screams.
>"Don't you mean bytes?" No, he really does mean "digits". And you 
>haven't seen nothin' yet,
>Java guy. Wait till he tells you how to store those digits on disk in 
>packed decimal format.
>
>So in the end, the "generic representation" can't really be "generic". 
>The Java guy just wants to know
>whether a variable is a "int" or a "long", while the COBOL guy wants to 
>say how many digits it is
>before and after the decimal. OK, I suppose you could make it generic, 
>you can store both,
>or have the "generic representation" automatically
>convert between the two. But things are going very badly and you just 
>got started :)
>
I've been wanting to say this, ever since Monty said "AREV and VB are 
very different" ...

Look at the following snippet of AREV code (bear in mind that : is the 
string concatenation operator, and all variables in AREV are strings...)

X = X : 0

What do you think the programmer meant?



















In VB, this *probably* translates as

int X
X = X*10

Of course, if the AREV guy accidentally put a real number in X, then it 
would have no effect at all, and if he'd put text in X he'd have 
appended a 0 to it (note that in the original code, the 0 wasn't quoted, 
so it was a number not a string ...).

Your point about the programmer's original intent was well made, Andy 
:-) (and no I'm not suggesting programmers should write code like that, 
but as someone who programs in that language, I make use of that sort of 
trick)

Cheers,
Wol
-- 
Anthony W. Youngman - anthony at thewolery.demon.co.uk


From antlr at thewolery.demon.co.uk  Wed Oct 25 04:41:36 2006
From: antlr at thewolery.demon.co.uk (Anthony W. Youngman)
Date: Wed, 25 Oct 2006 12:41:36 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
References: <20061009085219.43236.qmail@web55906.mail.re3.yahoo.com>
	<452BC893.3040204@jazillian.com>
	<D677B863-2607-4CBF-B907-32E176F9C846@cs.usfca.edu>
Message-ID: <2bbjbgnw10PFFwxg@thewolery.demon.co.uk>

In message <D677B863-2607-4CBF-B907-32E176F9C846 at cs.usfca.edu>, Terence 
Parr <parrt at cs.usfca.edu> writes
>Anyway, now make it 400 of those rules.  Now, add a bunch of  arbitrary 
>actions that test "am I in this function and did I see this  variable 
>defined before by walking backwards?" in addition to these  syntactic 
>rules and I am certain that your brain must be very large  to figure 
>out the emergent behavior of all of these rules.   This is  the 
>standard Prolog programming problem.  Andy confirmed for me on  the 
>phone that debugging why the huge list of rules is not giving you  the 
>right translation requires tools that generate nice HTML reports  and 
>lots of thinking sometimes.  Further, the constant threat of  infinite 
>rule-application loops frightens me.    Perhaps he can give  us a 
>better idea of how often he hits a landmine.  I may be incorrect  to 
>focus on this problem.

Linus and git may be an interesting example here ...

Never mind why he had to write it, Linus wrote git as a rush job source 
code control system. And did it very quickly because he basically threw 
all previous received wisdom out the window and started again.

It stores files based on their MD5 hash. It's theoretically possible for 
several files to share a hash, and Linus said to himself "loads of sccs 
code is based on dealing with the possibility of a collision, and seeing 
as collisions are rare this code rarely gets tested".

So he made the *engineering* decision that (1) you never corrupt data, 
so you never overwrite a file already in the sccs, and (2) the chances 
of having a collision were less than the chances of the error-recovery 
code going wrong, so ...

Should you get an MD5 collision, it's a fatal error. The merge fails and 
the user is left to sort out the mess by hand. It seems a pretty poor 
way to handle things, but at the end of the day it's a rational decision 
- attempting to handle a corner case automatically is a high risk 
strategy and no rational person would try. The trouble is people aren't 
rational, much as we like to think we are :-)

Cheers,
Wol
-- 
Anthony W. Youngman - anthony at thewolery.demon.co.uk


From antlr at thewolery.demon.co.uk  Wed Oct 25 04:57:10 2006
From: antlr at thewolery.demon.co.uk (Anthony W. Youngman)
Date: Wed, 25 Oct 2006 12:57:10 +0100
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <452D3180.2070907@jazillian.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
	<452D3180.2070907@jazillian.com>
Message-ID: <h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>

In message <452D3180.2070907 at jazillian.com>, Andy Tripp 
<antlr at jazillian.com> writes
>> "Thinking in trees" does not come automatically.  It is like learning 
>>LISP or Forth or one of the functional languages (and, for that 
>>matter, object-oriented programming:  there is a lot of badly designed 
>>and implemented C++ code out there).  For a time, working with trees 
>>is like slogging through molasses, and then you get the "Aha!" 
>>experience and things become easy.  It usually is not about designing 
>>the perfect tree structure; instead, it is about simplifying the 
>>recognition problem and expressing target language constructs in tree  form.
>
>For the record, I had no trouble "getting" LISP when I learned it 25 
>years ago. When I started with C++, I don't think I
>really "got" OOD, and only started writing real OO code when learning 
>Java forced me to. I think the fact that LISP never
>became "mainstream" means that it failed to be easy enough to grasp. 
>Regardless of how inherently beautiful it is,
>if a lot of programmers don't easily "get it", then it's not that 
>great.

The trouble is, the "average" programmer is just that, average.

A great programmer can do the work of ten ordinary programmers. The 
trouble is, he probably does it with tools that are beyond the ability 
of the ordinary programmer to "get".

As a result, the majority of tools on the market are "average" tools, 
aimed at the "average" programmer, and the product suffers accordingly. 
Look at the mass of IDEs available now - I *hate* them. I think verbally 
and an IDE gets in the way. But the majority of people think visually - 
that's why Windows is such a hit. But because they think visually, they 
can't think in abstract terms, and they can't do anything beyond basic 
problem solving. (As an aside, my University foray into childhood 
development said that kids start progressing beyond this stage at about 
the age of 14, and that modern thought says that maybe HALF the 
population NEVER get beyond it.)

I think it was Celko - wrote an article on databases and Access. He 
predicted that, because a certain (rather important) database concept 
couldn't be visualised, that it wouldn't be available in Access. Sure 
enough, it wasn't (even in the programming language behind it!)

Years ago, IBM did an experiment. They made a bunch of programmers write 
a program without access to the computer to test it. It was written on 
paper and desk-checked. When it was signed off, typed in and run, the 
"quality profiler" run on it equated it with a program that had been in 
production for two years with two years of bug-fixes done on it ...

Cheers,
Wol
-- 
Anthony W. Youngman - anthony at thewolery.demon.co.uk


From koen.vanderkimpen+antlr at cs.kuleuven.be  Wed Oct 25 06:45:51 2006
From: koen.vanderkimpen+antlr at cs.kuleuven.be (Koen Vanderkimpen)
Date: Wed, 25 Oct 2006 15:45:51 +0200
Subject: [antlr-interest] java 1.5 grammar corrections
Message-ID: <004801c6f83b$e39e0220$b3273a86@codewalker>

Hi,

I already mailed some time ago because I had a problem with the java 1.5 grammar and generic casts.
By using antlrworks, my colleague and me fixed this, and also a typo in the rule for interface declarations.


castExpression
    :  '(' primitiveType ')' unaryExpression
    |  '(' type ')' unaryExpressionNotPlusMinus
    ;

In the third line of that rule, we changed " '(' expression | type ')' ", because, according to the Java Language Specification, expressions don't belong there. But it only says so in the semantics of casting, not in the syntax at the end of the document. The rule made it impossible to use a castExpression of the form " (List<Object>)someList ".


normalInterfaceDeclaration
 : 'interface' Identifier typeParameter? ('extends' typeList)? interfaceBody
 ;

Here, "typeParameters" was changed from "typeParameter", according to JLS syntax.


I attached a modified grammar file to this message, so that people are able to use it from here or put it on the site.


Regards,

Koen Vanderkimpen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061025/31debb01/attachment-0001.html 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: java.g
Type: application/octet-stream
Size: 15927 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061025/31debb01/attachment-0001.obj 

From kroepke at classdump.org  Wed Oct 25 07:17:07 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Wed, 25 Oct 2006 16:17:07 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
	<452D3180.2070907@jazillian.com>
	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
Message-ID: <3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>


On 25. Oct 2006, at 13:57 , Anthony W. Youngman wrote:

> As a result, the majority of tools on the market are "average"  
> tools, aimed at the "average" programmer, and the product suffers  
> accordingly. Look at the mass of IDEs available now - I *hate*  
> them. I think verbally and an IDE gets in the way. But the majority  
> of people think visually - that's why Windows is such a hit. But  
> because they think visually, they can't think in abstract terms,  
> and they can't do anything beyond basic problem solving. (As an  
> aside, my University foray into childhood development said that  
> kids start progressing beyond this stage at about the age of 14,  
> and that modern thought says that maybe HALF the population NEVER  
> get beyond it.)

In my opinion, visualization is a very important tool, even if you  
have the ability to "think verbally". Being able to solve problems  
use abstract terms is a powerful one, but the ability of pictograms  
and diagrams to convey important information about structure is very  
important, too, if for the lone reason that it seems to be more  
natural to humans. The fact that children do things primarily in a  
visual way indicates (IMHO) that building upon that concept increases  
your productivity if it is done right.

I agree with you that once it is the only method of working it gets  
in the way quick and hinders your ability to facilitate your ability  
to work in abstract terms (which BTW a diagram is, too.  
Philosophically every expressed notion needs to be abstract, or it  
couldn't be expressed at all, but that's academic ;)). Thus the goal  
can only be to combine the two approaches by making them tightly  
integrated. I see a high value in systems that let you write programs  
in a visual manner, but everything I have seen stop there and do not  
even make an attempt in unification.

To briefly return to the topic ;), if you are doing source-to-source  
translation, I would love to see a product that let's me see the  
effect of one certain rule not only by the grammatical structure of  
the (ENBF-)rules that drive it, but also by some form of  
visualization that let me see the big "picture" without having to  
simulate the parser/translator in my head. I am convinced that a  
visual representation of this process would speed up my work  
tremendously. The mere fact that I always draw diagrams to understand  
algorithms (and, of course, also the use of diagrams used in books  
and reports to illustrate the working of a certain algorithm) is a  
tribute to the fact that "thinking visually" comes more natural to a  
human than only having the abstract terms.
For bonus, this product would not only visualize its own effect but  
also allow me to create new rules partially using visual techniques  
in addition to text based input (which is often seen as the abstract  
approach, because you need to literally spell out the abstractions).  
In my opinion, both differ simply in the form of representation but  
not in the use of abstract terms. To create something always requires  
abstraction if the outcome is to be considered high quality.

I'm not sure what exactly you mean by IDE, but I have the impression  
you are referring to what has been called "4G development tools"  
rather than the simply integrated development environments that  
integrate editors, compilers, and debuggers to minimize the time lost  
switching between these tools.

cheers,

-k




From zhiyong_zhang5 at yahoo.ie  Wed Oct 25 07:33:55 2006
From: zhiyong_zhang5 at yahoo.ie (Zhiyong Zhang)
Date: Wed, 25 Oct 2006 14:33:55 +0000 (GMT)
Subject: [antlr-interest] problem on the grammar of identifier
Message-ID: <20061025143355.17197.qmail@web27208.mail.ukl.yahoo.com>

Hi,
 
The identifier is supposed to in be the format of "abc.d6f" or "abc.current.dg47". I got ambiguity problem with the lookahead =3 in the lexical grammar, it also reported problem abc.currentAbcdE. Can anybody give me some light?

IDENTIFIER options {testLiterals=true;} : ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|':')*  ( (".current."|".") ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|':')+)?;

Thanks in advance.

Send instant messages to your online friends http://uk.messenger.yahoo.com 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061025/ae12752e/attachment.html 

From jose.ventura.roda at gmail.com  Wed Oct 25 08:59:08 2006
From: jose.ventura.roda at gmail.com (Jose Ventura)
Date: Wed, 25 Oct 2006 17:59:08 +0200
Subject: [antlr-interest] Fwd:  problem on the grammar of identifier
In-Reply-To: <e39abda10610250851m22c8e1eena4ace443aa38362@mail.gmail.com>
References: <20061025143355.17197.qmail@web27208.mail.ukl.yahoo.com>
	<e39abda10610250851m22c8e1eena4ace443aa38362@mail.gmail.com>
Message-ID: <e39abda10610250859o67006743ia41ec48f91814181@mail.gmail.com>

 Hi Zhiyoung,

I can't test it, but I think the problem is (".current"|"."). This part of
rule is ambiguous with the next part of rule ('a'..'z'), because the string
".current" is right with "." and 'a'..'z', and also with ".current".

I think is better to you to do this test at parser. Maybe with a rule for
the identifier and a tokens 'current' and '.'

Regards
Jos? Ventura



2006/10/25, Zhiyong Zhang <zhiyong_zhang5 at yahoo.ie>:
>
>  Hi,
>
>
> The identifier is supposed to in be the format of "abc.d6f" or "
> abc.current.dg47". I got ambiguity problem with the lookahead =3 in the
> lexical grammar, it also reported problem abc.currentAbcdE. Can anybody
> give me some light?
>
>
>
> IDENTIFIER
> options {testLiterals=true;} : ('a'.. 'z'|'A'..'Z'|'_')( 'a'..'z'|'A'..'Z'
> |'0'..'9'|'_'| ':')*  ( (".current."| ".") ('a'..'z'|'A' ..'Z'|'0'..'9'|'_'
> |':')+)?;
>
>
>
> Thanks in advance.
>
>
>
> Send instant messages to your online friends http://uk.messenger.yahoo.com
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061025/c63d533a/attachment.html 

From parrt at cs.usfca.edu  Wed Oct 25 09:19:48 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 25 Oct 2006 09:19:48 -0700
Subject: [antlr-interest] [3.0b4] StackOverflowError report
In-Reply-To: <D18A4EED-C5C8-47D0-8756-3901AE9AF8DA@zoominternet.net>
References: <7863F670-E5C2-44F6-B9E3-F17A038AC444@zoominternet.net>
	<26BD72D4-28E6-42B1-87B6-D09D476A5B3F@zoominternet.net>
	<E1GcUgf-00057V-00@gecko>
	<D18A4EED-C5C8-47D0-8756-3901AE9AF8DA@zoominternet.net>
Message-ID: <DC13ADA6-EEC8-4A7E-8A32-A889204B2B6A@cs.usfca.edu>

The key to understanding why this crashes is looking at the generated  
code.  Note that

f() { f(); }

is what you'll see.

Ter

From foolishewe at hotmail.com  Wed Oct 25 13:30:29 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Wed, 25 Oct 2006 20:30:29 +0000
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the current
	ANTLRWorks under Window XP)
Message-ID: <BAY107-F13BFE03903D85A088DD565C0060@phx.gbl>

Hi Folks:

I'm trying ANTLR 3 today, using ANTLRworks (so far it seems like Bovet and 
Parr have some
reallly neat stuff in there).

I'm trying to compile the attached grammar in the tool and am getting a 
message:

Cannot generate the grammar because grammar TestGrammar : no start rule (no 
rule can
obviously be followed by EOF).

This will probably out me to my coauthors and students, but I'm not a big 
fan of the words
obviously/easily or their variants :-).

What does this message mean, how can I better convey to ANTLR that startRule 
is the start rule?

Thanks:

Bill M.
// Test hoisting and use of predicates to allow us to use "undelimited 
strings"
grammar TestGrammar;

// I'm not using tokens in this langauge yet.
//tokens = { }

@members {
	public static void main(String[] args) throws Exception {
		TestGrammarLexer lex = new TestGrammmarLexer(new 
ANTLRFileStream(args[0]));
		CommonTokenStream tokens = new CommonTokenStream(lex);

		SimpleCalc parser = new SimpleCalc(tokens);
		try {
			parser.startRule();
		} catch (RecognitionException e)  {
			e.printStackTrace();
		}
	}

	// see if we need to use this sort of flag or if parser based checks are 
enough
	// public boolean recognizeKeyWords = true; // should we recognize 
keywords?

	// is a token input.LT(i)'s lexeme at least minLength characters long and a 
key word prefix match?
	public boolean kwpm(int i, String pattern, int minlength){
		booleean result = false;
		String lexeme = input.LT(i).getText().toLower(); // Poor man's case 
insensitivity :-)
		if (lexeme.length() < minLength){ // lexeme too short?
			result = false;
		} else if (lexeme.length() > pattern.length()){ // lexeme too long?
			result = false;
		} else { // now we have to check the content
			result = pattern.startsWith(lexeme); // is the lexeme a prefix of the 
pattern?
		}
		return result;

_________________________________________________________________
Use your PC to make calls at very low rates 
https://voiceoam.pcs.v2s.live.com/partnerredirect.aspx


From dieter_frej at gmx.net  Wed Oct 25 13:30:41 2006
From: dieter_frej at gmx.net (Dieter Frej)
Date: Wed, 25 Oct 2006 22:30:41 +0200
Subject: [antlr-interest] rewriting done in antlrworks
Message-ID: <453FC971.40107@gmx.net>

Hi,

in the current java.g for antlr3 there are no ^ to specify the order of
nodes in the AST. When I use the interpreter in antlrworks a correct AST
will be drawn showing which rules was executed. I would like to know how
this is realised. Does antlrworks modify the grammar on-the-fly or is
the execution somehow monitored? And: can I use this functionality "from
outside"? What I would like to do is to generate such an AST and work on
it... (ok, first display it and then go through it)... Or any other
ideas if this can done in a different way?

Thanks in advance!

- Didi

From kroepke at classdump.org  Wed Oct 25 13:43:58 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Wed, 25 Oct 2006 22:43:58 +0200
Subject: [antlr-interest] rewriting done in antlrworks
In-Reply-To: <453FC971.40107@gmx.net>
References: <453FC971.40107@gmx.net>
Message-ID: <394A12A5-0D62-4F96-A6A3-AE3295D9578D@classdump.org>

Moin Dieter!

On 25. Oct 2006, at 22:30 , Dieter Frej wrote:

> When I use the interpreter in antlrworks a correct AST
> will be drawn showing which rules was executed.

Isn't that just the parse tree instead of an AST? I believe the Parse  
Tree and AST buttons show
the same thing if there are no tree operators or rewrites in the  
grammar. Admittedly I haven't
checked, but I imagine that's what's happening.

To get the parse tree, you could insert actions at the end of each of  
your rules, to get the structure.
The token indices you can get out of the rule's return value (named  
retval currently).

HTH,

-k
-- 
Kay R?pke <kroepke at classdump.org>
classdump Software
Key fingerprint = A849 0F2C C322 4022 379E  8661 7E1B FE0D 4CD2 A6D0




From parrt at cs.usfca.edu  Wed Oct 25 14:08:16 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Wed, 25 Oct 2006 14:08:16 -0700
Subject: [antlr-interest] rewriting done in antlrworks
In-Reply-To: <453FC971.40107@gmx.net>
References: <453FC971.40107@gmx.net>
Message-ID: <BF439129-D4A7-4AAE-A0E8-6414F9C59159@cs.usfca.edu>


On Oct 25, 2006, at 1:30 PM, Dieter Frej wrote:

> Hi,
>
> in the current java.g for antlr3 there are no ^ to specify the  
> order of
> nodes in the AST. When I use the interpreter in antlrworks a  
> correct AST
> will be drawn showing which rules was executed. I would like to  
> know how
> this is realised. Does antlrworks modify the grammar on-the-fly or is
> the execution somehow monitored? And: can I use this functionality  
> "from
> outside"? What I would like to do is to generate such an AST and  
> work on
> it... (ok, first display it and then go through it)... Or any other
> ideas if this can done in a different way?

Hi :)  That's a parse tree versus AST.  The parse tree can be  
automatically generated as it's a record of the parse. :)

Ter


From jimi at intersystems.com  Wed Oct 25 15:24:46 2006
From: jimi at intersystems.com (Jim Idle)
Date: Wed, 25 Oct 2006 18:24:46 -0400
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the
	currentANTLRWorks under Window XP)
Message-ID: <20061025222433.EEC2A16BA@mail.intersystems.com>

Bill,

Unless you have missed some of the grammar out from this post, it looks
to me like you don't actually have any rules in the grammar, only some
member functions? I would think that that you do really have some rules
but just have not posted them? ;-)

If I take out the java code from your post, we are left with:

// Test hoisting and use of predicates to allow us to use "undelimited 
strings"
grammar TestGrammar;

// I'm not using tokens in this langauge yet.
//tokens = { }


If this is really your grammar, then I would think it is pretty obvious
;-), that there is no rule for ANTLR to look for EOF in. 

Jim

-----Original Message-----
From: antlr-interest-bounces at antlr.org
[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Foolish Ewe
Sent: Wednesday, October 25, 2006 1:30 PM
To: antlr-interest at antlr.org
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the
currentANTLRWorks under Window XP)

Hi Folks:

I'm trying ANTLR 3 today, using ANTLRworks (so far it seems like Bovet
and 
Parr have some
reallly neat stuff in there).

I'm trying to compile the attached grammar in the tool and am getting a 
message:

Cannot generate the grammar because grammar TestGrammar : no start rule
(no 
rule can
obviously be followed by EOF).

This will probably out me to my coauthors and students, but I'm not a
big 
fan of the words
obviously/easily or their variants :-).

What does this message mean, how can I better convey to ANTLR that
startRule 
is the start rule?

Thanks:

Bill M.

_________________________________________________________________
Use your PC to make calls at very low rates 
https://voiceoam.pcs.v2s.live.com/partnerredirect.aspx


-- 
No virus found in this incoming message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.11/496 - Release Date:
10/24/2006
 

From jose.ventura.roda at gmail.com  Thu Oct 26 00:30:01 2006
From: jose.ventura.roda at gmail.com (Jose Ventura)
Date: Thu, 26 Oct 2006 09:30:01 +0200
Subject: [antlr-interest] problem on the grammar of identifier
In-Reply-To: <20061025170139.68093.qmail@web27215.mail.ukl.yahoo.com>
References: <20061025170139.68093.qmail@web27215.mail.ukl.yahoo.com>
Message-ID: <e39abda10610260030i130b7cc3x45e479f51005f3aa@mail.gmail.com>

I don't know how use predicates for this, but in the parser it could be so
(please test it, i'm writing directly, without test):

In Lexer:

{
DOT=".";
CURRENT="current";
}

ID options {testLiterals=true}:
('a'..'z'|'A'..'Z')('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;

In parser:

identifier : ID (DOT (ID|CURRENT {countCurrent++;} DOT ID ) )*
               { if (countCurrent>1) //error;}
               ;

Regards,

2006/10/25, Zhiyong Zhang <zhiyong_zhang5 at yahoo.ie>:

>  Hi Jose,
>
> Thanks for your suggestion.
>
> I am trying to move this identifier from lexer to parser, but have no idea
> how to do it with correct syntax in parser.
>
> Could you please help me on this?
>
> I also thinking if it's possible to use predicate in lexer to solve this
> problem, but still can not use correct syntax for this.
>
> Thanks
>
>
>  ----- Original Message ----
> From: Jose Ventura <jose.ventura.roda at gmail.com>
> To: Zhiyong Zhang <zhiyong_zhang5 at yahoo.ie>
> Sent: Wednesday, 25 October, 2006 4:51:42 PM
> Subject: Re: [antlr-interest] problem on the grammar of identifier
>
> Hi Zhiyoung,
>
> I can't test it, but I think the problem is (".current"|"."). This part of
> rule is ambiguous with the next part of rule ('a'..'z'), because the string
> ".current" is right with "." and 'a'..'z', and also with ".current".
>
> I think is better to you to do this test at parser. Maybe with a rule for
> the identifier and a tokens 'current' and '.'
>
> Regards
> Jos? Ventura
>
>
>
> 2006/10/25, Zhiyong Zhang <zhiyong_zhang5 at yahoo.ie>:
> >
> >  Hi,
> >
> >
> > The identifier is supposed to in be the format of "abc.d6f" or "
> > abc.current.dg47". I got ambiguity problem with the lookahead =3 in the
> > lexical grammar, it also reported problem abc.currentAbcdE. Can anybody
> > give me some light?
> >
> >
> >
> > IDENTIFIER
> > options {testLiterals=true;} : ('a'.. 'z'|'A'..'Z'|'_')( 'a'..'z'|'A'..'Z'
> > |'0'..'9'|'_'| ':')*  ( (".current."| ".") ('a'..'z'|'A' ..'Z'|'0'..'9'|'_'
> > |':')+)?;
> >
> >
> >
> > Thanks in advance.
> >
> >
> >
> > Send instant messages to your online friends
> > http://uk.messenger.yahoo.com
> >
>
>
>
>
>
> Send instant messages to your online friends http://uk.messenger.yahoo.com
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061026/9932fb4a/attachment.html 

From jbb at acm.org  Thu Oct 26 06:25:32 2006
From: jbb at acm.org (John B. Brodie)
Date: Thu, 26 Oct 2006 09:25:32 -0400
Subject: [antlr-interest] problem on the grammar of identifier
In-Reply-To: <e39abda10610260030i130b7cc3x45e479f51005f3aa@mail.gmail.com>
	(message from Jose Ventura on Thu, 26 Oct 2006 09:30:01 +0200)
References: <20061025170139.68093.qmail@web27215.mail.ukl.yahoo.com>
	<e39abda10610260030i130b7cc3x45e479f51005f3aa@mail.gmail.com>
Message-ID: <E1Gd5Ei-0006Gz-00@gecko>

> 2006/10/25, Zhiyong Zhang <zhiyong_zhang5 at yahoo.ie>:
>
> The identifier is supposed to in be the format of "abc.d6f" or "
> abc.current.dg47". I got ambiguity problem with the lookahead =3D3 in t=
>
> lexical grammar, it also reported problem abc.currentAbcdE. Can anybody
> give me some light?
>
> IDENTIFIER
> options {testLiterals=3Dtrue;} : ('a'.. 'z'|'A'..'Z'|'_')( 'a'..'z'|'A' ..'Z'
> |'0'..'9'|'_'| ':')*  ( (".current."| ".") ('a'..'z'|'A' ..'Z'|'0'..'9' |'_'
> |':')+)?;

class L extends Lexer;
options { k = 9; }
IDENTIFIER options {testLiterals=true;} :
        INITIAL (SUBSEQUENT)* ( "." ("current.")? (SUBSEQUENT)+ )?;
protected INITIAL : 'a'..'z'|'A'..'Z'|'_' ;
protected SUBSEQUENT : INITIAL | ':' ;

From dieter_frej at gmx.net  Thu Oct 26 09:39:04 2006
From: dieter_frej at gmx.net (Dieter Frej)
Date: Thu, 26 Oct 2006 18:39:04 +0200
Subject: [antlr-interest] rewriting done in antlrworks
In-Reply-To: <BF439129-D4A7-4AAE-A0E8-6414F9C59159@cs.usfca.edu>
References: <453FC971.40107@gmx.net>
	<BF439129-D4A7-4AAE-A0E8-6414F9C59159@cs.usfca.edu>
Message-ID: <4540E4A8.5010001@gmx.net>

ok, then I meant the parse tree ;-)

How can I get hold of the record resp the parse tree? Can I use
antlrworks functionality for that or do I habe to implement that myself?

- Didi



Terence Parr wrote:
> 
> On Oct 25, 2006, at 1:30 PM, Dieter Frej wrote:
> 
>> Hi,
>>
>> in the current java.g for antlr3 there are no ^ to specify the  order of
>> nodes in the AST. When I use the interpreter in antlrworks a  correct AST
>> will be drawn showing which rules was executed. I would like to  know how
>> this is realised. Does antlrworks modify the grammar on-the-fly or is
>> the execution somehow monitored? And: can I use this functionality  "from
>> outside"? What I would like to do is to generate such an AST and  work on
>> it... (ok, first display it and then go through it)... Or any other
>> ideas if this can done in a different way?
> 
> 
> Hi :)  That's a parse tree versus AST.  The parse tree can be  
> automatically generated as it's a record of the parse. :)
> 
> Ter
> 
> 


From parrt at cs.usfca.edu  Thu Oct 26 09:54:01 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 26 Oct 2006 09:54:01 -0700
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the current
	ANTLRWorks under Window XP)
In-Reply-To: <BAY107-F13BFE03903D85A088DD565C0060@phx.gbl>
References: <BAY107-F13BFE03903D85A088DD565C0060@phx.gbl>
Message-ID: <E68D66C6-60D9-4DC2-B1B2-166C7447B426@cs.usfca.edu>

well, there is no rule at all so that's a problem.  But, ANTLR is  
warning you I think not generating an error, right?  Can't remember.
Terence
On Oct 25, 2006, at 1:30 PM, Foolish Ewe wrote:

> Hi Folks:
>
> I'm trying ANTLR 3 today, using ANTLRworks (so far it seems like  
> Bovet and Parr have some
> reallly neat stuff in there).
>
> I'm trying to compile the attached grammar in the tool and am  
> getting a message:
>
> Cannot generate the grammar because grammar TestGrammar : no start  
> rule (no rule can
> obviously be followed by EOF).
>
> This will probably out me to my coauthors and students, but I'm not  
> a big fan of the words
> obviously/easily or their variants :-).
>
> What does this message mean, how can I better convey to ANTLR that  
> startRule is the start rule?
>
> Thanks:
>
> Bill M.
> // Test hoisting and use of predicates to allow us to use  
> "undelimited strings"
> grammar TestGrammar;
>
> // I'm not using tokens in this langauge yet.
> //tokens = { }
>
> @members {
> 	public static void main(String[] args) throws Exception {
> 		TestGrammarLexer lex = new TestGrammmarLexer(new ANTLRFileStream 
> (args[0]));
> 		CommonTokenStream tokens = new CommonTokenStream(lex);
>
> 		SimpleCalc parser = new SimpleCalc(tokens);
> 		try {
> 			parser.startRule();
> 		} catch (RecognitionException e)  {
> 			e.printStackTrace();
> 		}
> 	}
>
> 	// see if we need to use this sort of flag or if parser based  
> checks are enough
> 	// public boolean recognizeKeyWords = true; // should we recognize  
> keywords?
>
> 	// is a token input.LT(i)'s lexeme at least minLength characters  
> long and a key word prefix match?
> 	public boolean kwpm(int i, String pattern, int minlength){
> 		booleean result = false;
> 		String lexeme = input.LT(i).getText().toLower(); // Poor man's  
> case insensitivity :-)
> 		if (lexeme.length() < minLength){ // lexeme too short?
> 			result = false;
> 		} else if (lexeme.length() > pattern.length()){ // lexeme too long?
> 			result = false;
> 		} else { // now we have to check the content
> 			result = pattern.startsWith(lexeme); // is the lexeme a prefix  
> of the pattern?
> 		}
> 		return result;
>
> _________________________________________________________________
> Use your PC to make calls at very low rates https:// 
> voiceoam.pcs.v2s.live.com/partnerredirect.aspx
>


From parrt at cs.usfca.edu  Thu Oct 26 09:55:21 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 26 Oct 2006 09:55:21 -0700
Subject: [antlr-interest] rewriting done in antlrworks
In-Reply-To: <4540E4A8.5010001@gmx.net>
References: <453FC971.40107@gmx.net>
	<BF439129-D4A7-4AAE-A0E8-6414F9C59159@cs.usfca.edu>
	<4540E4A8.5010001@gmx.net>
Message-ID: <06923200-D0F9-4527-9177-8F1A8612C6A5@cs.usfca.edu>


On Oct 26, 2006, at 9:39 AM, Dieter Frej wrote:

> ok, then I meant the parse tree ;-)
>
> How can I get hold of the record resp the parse tree? Can I use
> antlrworks functionality for that or do I habe to implement that  
> myself?

I plan on adding but just look at my parse tree creator (a debug  
event listener or something) in the Interpreter stuff in antlr  
source.  Should show how to do it.

Ter

From sunjigang1965 at yahoo.com.cn  Thu Oct 26 10:42:18 2006
From: sunjigang1965 at yahoo.com.cn (Jigang (Robert) Sun)
Date: Fri, 27 Oct 2006 01:42:18 +0800 (CST)
Subject: [antlr-interest] lazy parser code writing
Message-ID: <20061026174218.21697.qmail@web15705.mail.cnb.yahoo.com>

Hi,
I am writing parser by hand. I want to be lazy, i.e. I write less code. For example, for the
following grammar

SpecialExpression = BasicValue
| List

BasicValue = INT
|BOOL
|REAL

List = ListDenotation
| DotDotexpression

ListDenotation = "["[ListKind] [{LGraphExpr}-list [: GraphExpr]] [SpineStrictness] "]"
LGraphExpr = GraphExpr| CharsDenotation

DotDotexpression = "["[ListKind] GraphExpr [,GraphExpr]..[GraphExpr] [SpineStrictness] "]"

the best parsing method is, at each level, to decide exactly the next route to go, for 
SpecialExpression = BasicValue
| List

the usual method is: when the parser is at a point to parse SpecialExpression, the parser should
check the first token type met,if the token is a token that starts BasicValue(is of INT, REAL or
BOOL) then parse BasicValue, if the first token is "[" then parse List. 

The method I want to adopt is not do token type checking, instead go straight to parse BasicValue,
let BasicValue parsing method check if the first token is of INT, REAL or BOOL, if not then return
null; then parse List. The token type checking is done at lowerest level, and only once.

The advantage is that the program code is short, because I ommit the token type checking that is
repeatedly done at a further lower levels, e.g. at List parsing and further down List, i.e.
ListDenotation and DotDotexpression.

Maybe the disadvantage is slower speed.

How about the method?

Thanks.
Jigang


 



		
___________________________________________________________ 
????????-3.5G???20M??? 
http://cn.mail.yahoo.com

From foolishewe at hotmail.com  Thu Oct 26 11:43:26 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Thu, 26 Oct 2006 18:43:26 +0000
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (Using ANTLRWORKS second
	correction attempt)
Message-ID: <BAY107-F34BD63DACE7431DFB65F53C0070@phx.gbl>

Hello All:

I had a catastrophe during the edit of my previous attempt at a correction,
so now I'm really groveling, please forgive me if you get a redundant reply.
I'm using ANTLR3 using ANTLRworks (which seems very nice so far) under
Windows XP in case you are wondering. There should be a MIME attached
ANTLR3 grammar to this message.

When I try to compile TestGrammar.g (a MIME attached file), I get the 
following errors in the
console tab in the bottom subwindow.  Although the prior posting omitted the 
grammar
(just as well, since I got to correct the java code in the @members 
section), there really
was some code generating that message.
[14:40:33] grammar TestGrammar: no start rule (no rule can obviously be 
followed by EOF)
[14:40:33] [Long path omitted]TestGrammar.g:44:3: The following alternatives 
are unreachable: 3

Note that I'm trying this approach because I've got a strange language that 
I'm trying
to scan which has "undelimited" strings (for historical reasons, this wasn't 
my doing),
so I sometimes would like to suppress key word recognition.  If I could scan 
in the language
properly, I think the parsing itself might not be too bad.

If I comment out the first and second alternative, (so that startRule->end 
NEWLINE) then
ANTLR will generate source but instead I get  (what seems to be) a Java code 
generation error.

13:06:08] [Long Path Snipped]\TestGrammar.java:78: illegal start of 
expression
[13:06:08]         void endtoken = null;
[13:06:08]         ^
[13:06:08] 1 error

Once again, sorry about cluttering up the mailing list with the prior 
malformed message,
I hope this one is well formed.

Thanks:

Bill M.

>From: "Jim Idle" <jimi at intersystems.com>
>To: "Foolish Ewe" <foolishewe at hotmail.com>,<antlr-interest at antlr.org>
>Subject: Re: [antlr-interest] Rookie attempt at ANTLR 3 (using 
>thecurrentANTLRWorks under Window XP)
>Date: Wed, 25 Oct 2006 18:24:46 -0400
>
>Bill,
>
>Unless you have missed some of the grammar out from this post, it looks
>to me like you don't actually have any rules in the grammar, only some
>member functions? I would think that that you do really have some rules
>but just have not posted them? ;-)
>
>If I take out the java code from your post, we are left with:
>
>// Test hoisting and use of predicates to allow us to use "undelimited
>strings"
>grammar TestGrammar;
>
>// I'm not using tokens in this langauge yet.
>//tokens = { }
>
>
>If this is really your grammar, then I would think it is pretty obvious
>;-), that there is no rule for ANTLR to look for EOF in.
>
>Jim
>
>-----Original Message-----
>From: antlr-interest-bounces at antlr.org
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Foolish Ewe
>Sent: Wednesday, October 25, 2006 1:30 PM
>To: antlr-interest at antlr.org
>Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the
>currentANTLRWorks under Window XP)
>
>Hi Folks:
>
>I'm trying ANTLR 3 today, using ANTLRworks (so far it seems like Bovet
>and
>Parr have some
>reallly neat stuff in there).
>
>I'm trying to compile the attached grammar in the tool and am getting a
>message:
>
>Cannot generate the grammar because grammar TestGrammar : no start rule
>(no
>rule can
>obviously be followed by EOF).
>
>This will probably out me to my coauthors and students, but I'm not a
>big
>fan of the words
>obviously/easily or their variants :-).
>
>What does this message mean, how can I better convey to ANTLR that
>startRule
>is the start rule?
>
>Thanks:
>
>Bill M.
>
>_________________________________________________________________
>Use your PC to make calls at very low rates
>https://voiceoam.pcs.v2s.live.com/partnerredirect.aspx
>
>
>--
>No virus found in this incoming message.
>Checked by AVG Free Edition.
>Version: 7.1.408 / Virus Database: 268.13.11/496 - Release Date:
>10/24/2006
>

_________________________________________________________________
Stay in touch with old friends and meet new ones with Windows Live Spaces 
http://clk.atdmt.com/MSN/go/msnnkwsp0070000001msn/direct/01/?href=http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us
-------------- next part --------------
A non-text attachment was scrubbed...
Name: TestGrammar.g
Type: application/octet-stream
Size: 2771 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061026/6064576b/attachment.obj 

From jimi at intersystems.com  Thu Oct 26 14:35:37 2006
From: jimi at intersystems.com (Jim Idle)
Date: Thu, 26 Oct 2006 17:35:37 -0400
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (Using ANTLRWORKS
	second correction attempt)
In-Reply-To: <BAY107-F34BD63DACE7431DFB65F53C0070@phx.gbl>
Message-ID: <20061026213522.DDC0E15A7@mail.intersystems.com>

First ALPHANUMSTRING can end up matching nothing as it does not force any character to be there, having a * rather than a +. I think that that is probably your start rule issue.

Next issue is that all your rules are the same thing. Your lexer only recognizes ALPHANUMSTRING and so every rule is just str=ALPHANUMSTRING. 

Next, it is difficult to see exactly what your start rule is trying to achieve but I guess you trying to get it to follow multiple lines and end when you see end. I think that you can throw away the newline tokens unless they end up being significant as you expand the grammar to cover the whole language, which is certainly possible. But you need to formulate this such that there is a rule that can match a valid construct, then use a higher rule to say how this repeats. Try thinking out in words how you can describe it (there you go Anthony ;-), such as a line of code is one statement followed by any number of additional statements separated by a semi-colon, then a NEWLINE. A statement block is any number of statements, including zero, surrounded by {} etc. Once you can describe it to yourself in English, 

However, I am afraid to say that I don't think that this approach is at all correct; basically you are just telling the lexer to tokenize everything that isn't a whitespace into one thing, then are trying to do all the tokenizing in the parser, and not actually doing any parsing. You would be better off, dare I say it, hand crafting such a beast ;-).

All is not lost however, as ANTLR3 can handle your language I believe (but then I believe it can be made to handle anything).

I think that what you should do is lex the keywords, and provide a lex rule, say IDORSTRING that matches anything that isn't a keyword. Then in the parser, at the points you know you can have an non-delimited string, match any possible token that can be a string (with suitable predicated rules to avoid ambiguities where necessary) and interpret it as an non-delimited string. Difficulties arise when an undelimited string is optional and you have to lookahead and use predicates and stuff, but that's what ANTLR is good at. 

Next, if your keywords can be: P PR PRI PRIN PRINT, then code the keyword, accordingly, and distinguish it as a string back in the parser:

PRINT: 'P' ( 'R' ( 'I' ( 'N' ( 'T')? )? )? )? ;

Be careful about ambiguities here. Basically ANTLR will match the first sequence listed (but you may end up with warnings and so on - you will need to experiment).

In order that you have an example of all this, I took the liberty of making something close to your sample, that produces a tree (which is what you want to do here, get your grammar/parser to produce an unambiguous and correct tree, then write your action code to do whatever it is you want to do with this in the tree parser)... that you might try to expand (tested with ANTLRWorks 1.0b5):

grammar TestMe;

options
{
	output=AST;
}
	
tokens
{
	STRING;
	CODEBLOCK;
	CODELINE;
	MONTH;
}

codeBlock
	: (c+= codelines)+
	  END
	  
	  -> ^(CODEBLOCK $c+)
	;
	 
codelines
	: m=month		-> ^(CODELINE ^(MONTH $m))
	| PRINT s=string	-> ^(CODELINE ^(PRINT $s))
	;

string
	: i=IDORSTRING			     	-> ^(STRING[$i.text] )
	| (keyword_strings)=> k=keyword_strings -> ^(STRING[$k.text] )
	;
	
keyword_strings
	: month
	| PRINT
	| END
	;

month	: JAN | FEB | MAR | APR | JUN | JUL | SEP | OCT | NOV | DEC ;

JAN	:	'jan' ;
FEB	:	'feb' ;
MAR	:	'mar' ;
APR	:	'apr' ;
MAY	:	'may' ;
JUN	:	'jun' ;
JUL	:	'aug' ;
SEP	:	'sep' ;
OCT	:	'oct' ;
NOV	:	'nov' ;
DEC	:	'dec' ;

END	:	'e' 'n' 'd'
	;
	
PRINT	:	'p' ( 'r' ( 'i' ( 'n' ( 't' )? )? )? )? ;

IDORSTRING
	: (ALPHA | DIGIT)+
	;

fragment DIGIT 
	:	('0'..'9')
	;

fragment ALPHA
	:	('a'..'z')
	;

WS	: (' ' | '\t')+ {channel=99;}
	;

NEWLINE	: ('\r' '\n'? | '\n') { channel=99;}
	;









-----Original Message-----
From: Foolish Ewe [mailto:foolishewe at hotmail.com] 
Sent: Thursday, October 26, 2006 11:43 AM
To: Jim Idle; antlr-interest at antlr.org
Subject: Rookie attempt at ANTLR 3 (Using ANTLRWORKS second correction attempt)

Hello All:

I had a catastrophe during the edit of my previous attempt at a correction,
so now I'm really groveling, please forgive me if you get a redundant reply.
I'm using ANTLR3 using ANTLRworks (which seems very nice so far) under
Windows XP in case you are wondering. There should be a MIME attached
ANTLR3 grammar to this message.

When I try to compile TestGrammar.g (a MIME attached file), I get the 
following errors in the
console tab in the bottom subwindow.  Although the prior posting omitted the 
grammar
(just as well, since I got to correct the java code in the @members 
section), there really
was some code generating that message.
[14:40:33] grammar TestGrammar: no start rule (no rule can obviously be 
followed by EOF)
[14:40:33] [Long path omitted]TestGrammar.g:44:3: The following alternatives 
are unreachable: 3

Note that I'm trying this approach because I've got a strange language that 
I'm trying
to scan which has "undelimited" strings (for historical reasons, this wasn't 
my doing),
so I sometimes would like to suppress key word recognition.  If I could scan 
in the language
properly, I think the parsing itself might not be too bad.

If I comment out the first and second alternative, (so that startRule->end 
NEWLINE) then
ANTLR will generate source but instead I get  (what seems to be) a Java code 
generation error.

13:06:08] [Long Path Snipped]\TestGrammar.java:78: illegal start of 
expression
[13:06:08]         void endtoken = null;
[13:06:08]         ^
[13:06:08] 1 error

Once again, sorry about cluttering up the mailing list with the prior 
malformed message,
I hope this one is well formed.

Thanks:

Bill M.

>From: "Jim Idle" <jimi at intersystems.com>
>To: "Foolish Ewe" <foolishewe at hotmail.com>,<antlr-interest at antlr.org>
>Subject: Re: [antlr-interest] Rookie attempt at ANTLR 3 (using 
>thecurrentANTLRWorks under Window XP)
>Date: Wed, 25 Oct 2006 18:24:46 -0400
>
>Bill,
>
>Unless you have missed some of the grammar out from this post, it looks
>to me like you don't actually have any rules in the grammar, only some
>member functions? I would think that that you do really have some rules
>but just have not posted them? ;-)
>
>If I take out the java code from your post, we are left with:
>
>// Test hoisting and use of predicates to allow us to use "undelimited
>strings"
>grammar TestGrammar;
>
>// I'm not using tokens in this langauge yet.
>//tokens = { }
>
>
>If this is really your grammar, then I would think it is pretty obvious
>;-), that there is no rule for ANTLR to look for EOF in.
>
>Jim
>
>-----Original Message-----
>From: antlr-interest-bounces at antlr.org
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Foolish Ewe
>Sent: Wednesday, October 25, 2006 1:30 PM
>To: antlr-interest at antlr.org
>Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the
>currentANTLRWorks under Window XP)
>
>Hi Folks:
>
>I'm trying ANTLR 3 today, using ANTLRworks (so far it seems like Bovet
>and
>Parr have some
>reallly neat stuff in there).
>
>I'm trying to compile the attached grammar in the tool and am getting a
>message:
>
>Cannot generate the grammar because grammar TestGrammar : no start rule
>(no
>rule can
>obviously be followed by EOF).
>
>This will probably out me to my coauthors and students, but I'm not a
>big
>fan of the words
>obviously/easily or their variants :-).
>
>What does this message mean, how can I better convey to ANTLR that
>startRule
>is the start rule?
>
>Thanks:
>
>Bill M.
>
>_________________________________________________________________
>Use your PC to make calls at very low rates
>https://voiceoam.pcs.v2s.live.com/partnerredirect.aspx
>
>
>--
>No virus found in this incoming message.
>Checked by AVG Free Edition.
>Version: 7.1.408 / Virus Database: 268.13.11/496 - Release Date:
>10/24/2006
>

_________________________________________________________________
Stay in touch with old friends and meet new ones with Windows Live Spaces 
http://clk.atdmt.com/MSN/go/msnnkwsp0070000001msn/direct/01/?href=http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us

-- 
No virus found in this incoming message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.11/498 - Release Date: 10/26/2006
 
  

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.11/498 - Release Date: 10/26/2006
 

From jimi at intersystems.com  Thu Oct 26 14:41:09 2006
From: jimi at intersystems.com (Jim Idle)
Date: Thu, 26 Oct 2006 17:41:09 -0400
Subject: [antlr-interest] lazy parser code writing
In-Reply-To: <20061026174218.21697.qmail@web15705.mail.cnb.yahoo.com>
Message-ID: <20061026214053.B9C0989C@mail.intersystems.com>

Robert,

I think you should just let the ANTLR code generator decide how to match your rules... You may be able to get the output code to do things like you suggest by place predicates in place but this is slower AND more code, so only do this if ANTLR tells you it is going to need one and you can't think of another way to express the construct to avoid the need.

Jim

-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest- 

The method I want to adopt is not do token type checking, instead go straight to parse BasicValue,
let BasicValue parsing method check if the first token is of INT, REAL or BOOL, if not then return
null; then parse List. The token type checking is done at lowerest level, and only once.


-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.11/498 - Release Date: 10/26/2006
 

From parrt at cs.usfca.edu  Thu Oct 26 14:42:35 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Thu, 26 Oct 2006 14:42:35 -0700
Subject: [antlr-interest] java 1.5 grammar corrections
In-Reply-To: <004801c6f83b$e39e0220$b3273a86@codewalker>
References: <004801c6f83b$e39e0220$b3273a86@codewalker>
Message-ID: <C427A6C4-8675-4957-8C36-AF94AF65D80B@cs.usfca.edu>


On Oct 25, 2006, at 6:45 AM, Koen Vanderkimpen wrote:

> Hi,
>
> I already mailed some time ago because I had a problem with the  
> java 1.5 grammar and generic casts.
> By using antlrworks, my colleague and me fixed this, and also a  
> typo in the rule for interface declarations.
>
>
> castExpression
>     :  '(' primitiveType ')' unaryExpression
>     |  '(' type ')' unaryExpressionNotPlusMinus
>     ;
>
> In the third line of that rule, we changed " '(' expression | type ')'

Hmm...i remember looking at this.  Can someone else confirm?  For now  
I'll leave as-is.  I have updated the other change.  Thanks!

Ter


From lgcraymer at yahoo.com  Thu Oct 26 20:41:31 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Thu, 26 Oct 2006 20:41:31 -0700 (PDT)
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (Using ANTLRWORKS
	second correction attempt)
In-Reply-To: <BAY107-F34BD63DACE7431DFB65F53C0070@phx.gbl>
Message-ID: <20061027034131.85118.qmail@web55904.mail.re3.yahoo.com>

startRule is recursive, so it cannot be the entry rule
(no implied EOF).  Try

rules: (startRule)* end NEWLINE ;

startRule:
    getString ALPHANUMSTRING NEWLINE
    |
       month NEWLINE
    ;

--Loring

--- Foolish Ewe <foolishewe at hotmail.com> wrote:

> Hello All:
> 
> I had a catastrophe during the edit of my previous
> attempt at a correction,
> so now I'm really groveling, please forgive me if
> you get a redundant reply.
> I'm using ANTLR3 using ANTLRworks (which seems very
> nice so far) under
> Windows XP in case you are wondering. There should
> be a MIME attached
> ANTLR3 grammar to this message.
> 
> When I try to compile TestGrammar.g (a MIME attached
> file), I get the 
> following errors in the
> console tab in the bottom subwindow.  Although the
> prior posting omitted the 
> grammar
> (just as well, since I got to correct the java code
> in the @members 
> section), there really
> was some code generating that message.
> [14:40:33] grammar TestGrammar: no start rule (no
> rule can obviously be 
> followed by EOF)
> [14:40:33] [Long path omitted]TestGrammar.g:44:3:
> The following alternatives 
> are unreachable: 3
> 
> Note that I'm trying this approach because I've got
> a strange language that 
> I'm trying
> to scan which has "undelimited" strings (for
> historical reasons, this wasn't 
> my doing),
> so I sometimes would like to suppress key word
> recognition.  If I could scan 
> in the language
> properly, I think the parsing itself might not be
> too bad.
> 
> If I comment out the first and second alternative,
> (so that startRule->end 
> NEWLINE) then
> ANTLR will generate source but instead I get  (what
> seems to be) a Java code 
> generation error.
> 
> 13:06:08] [Long Path Snipped]\TestGrammar.java:78:
> illegal start of 
> expression
> [13:06:08]         void endtoken = null;
> [13:06:08]         ^
> [13:06:08] 1 error
> 
> Once again, sorry about cluttering up the mailing
> list with the prior 
> malformed message,
> I hope this one is well formed.
> 
> Thanks:
> 
> Bill M.
> 
> >From: "Jim Idle" <jimi at intersystems.com>
> >To: "Foolish Ewe"
> <foolishewe at hotmail.com>,<antlr-interest at antlr.org>
> >Subject: Re: [antlr-interest] Rookie attempt at
> ANTLR 3 (using 
> >thecurrentANTLRWorks under Window XP)
> >Date: Wed, 25 Oct 2006 18:24:46 -0400
> >
> >Bill,
> >
> >Unless you have missed some of the grammar out from
> this post, it looks
> >to me like you don't actually have any rules in the
> grammar, only some
> >member functions? I would think that that you do
> really have some rules
> >but just have not posted them? ;-)
> >
> >If I take out the java code from your post, we are
> left with:
> >
> >// Test hoisting and use of predicates to allow us
> to use "undelimited
> >strings"
> >grammar TestGrammar;
> >
> >// I'm not using tokens in this langauge yet.
> >//tokens = { }
> >
> >
> >If this is really your grammar, then I would think
> it is pretty obvious
> >;-), that there is no rule for ANTLR to look for
> EOF in.
> >
> >Jim
> >
> >-----Original Message-----
> >From: antlr-interest-bounces at antlr.org
> >[mailto:antlr-interest-bounces at antlr.org] On Behalf
> Of Foolish Ewe
> >Sent: Wednesday, October 25, 2006 1:30 PM
> >To: antlr-interest at antlr.org
> >Subject: [antlr-interest] Rookie attempt at ANTLR 3
> (using the
> >currentANTLRWorks under Window XP)
> >
> >Hi Folks:
> >
> >I'm trying ANTLR 3 today, using ANTLRworks (so far
> it seems like Bovet
> >and
> >Parr have some
> >reallly neat stuff in there).
> >
> >I'm trying to compile the attached grammar in the
> tool and am getting a
> >message:
> >
> >Cannot generate the grammar because grammar
> TestGrammar : no start rule
> >(no
> >rule can
> >obviously be followed by EOF).
> >
> >This will probably out me to my coauthors and
> students, but I'm not a
> >big
> >fan of the words
> >obviously/easily or their variants :-).
> >
> >What does this message mean, how can I better
> convey to ANTLR that
> >startRule
> >is the start rule?
> >
> >Thanks:
> >
> >Bill M.
> >
>
>_________________________________________________________________
> >Use your PC to make calls at very low rates
>
>https://voiceoam.pcs.v2s.live.com/partnerredirect.aspx
> >
> >
> >--
> >No virus found in this incoming message.
> >Checked by AVG Free Edition.
> >Version: 7.1.408 / Virus Database: 268.13.11/496 -
> Release Date:
> >10/24/2006
> >
> 
>
_________________________________________________________________
> Stay in touch with old friends and meet new ones
> with Windows Live Spaces 
>
http://clk.atdmt.com/MSN/go/msnnkwsp0070000001msn/direct/01/?href=http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us
> 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

From Gerz at fgan.de  Fri Oct 27 03:24:39 2006
From: Gerz at fgan.de (Gerz, Michael)
Date: Fri, 27 Oct 2006 12:24:39 +0200
Subject: [antlr-interest] How to disable error recovery?
Message-ID: <EF2ED99C54B0FD4188B64423658925EDAA7750@mailserv.lorien.fkie.fgan.de>

Hello,

in our project, we need a simple parser/lexer that stops at the very first error => no error recovery at all.

AFAICS, ANTLR 3.0 allows using 
  
  @rulecatch {} 

to disable error recovery. However, this doesn't seem to work for lexical errors. Is there another way to disable recovery _completely_?

BTW: Is @rulecatch a rule-specific action, a grammar-specific action, or both?

Any help is greatly appreciated. Thanks in advance!

Michael

************************************************************************
Dr. Michael Gerz                                                        
FGAN e.V.                                      Phone:  +49 228 9435-414 
Department FKIE/ITF                            Fax:    +49 228 9435-685 
Neuenahrer Stra?e 20                           E-Mail: gerz at fgan.de     
53343 Wachtberg-Werthhoven                     WWW:    www.fgan.de     

From raj.sisodia at impetus.co.in  Fri Oct 27 06:09:24 2006
From: raj.sisodia at impetus.co.in (raj sisodia)
Date: Fri, 27 Oct 2006 18:39:24 +0530
Subject: [antlr-interest] Is Antlr good for this?
Message-ID: <017801c6f9c9$1fbe0f50$4361a8c0@impetus.co.in>

Hi,

 

I have a small project and I was wondering if ANTLR would be good to do it.
Here it goes.

 

I have a bunch of DTDs and I have to constantly write XSLs to convert XML
based on one DTD to another. Thease DTDs keep getting updated in very short
intervals, so I always have to update my XSL maps accordingly, now I want to
automate this. So the problem in simple words would be to create an XSL map
file based on the two DTDs. Now I know I can do this using XSL itself but
the job would be pretty much complicated owing to the fact that I have to do
"many to many" mapping here. Also the design has to be generic so that any
set of DTD could be used. Many good compilers and transformers have been
written in ANTLR but would it be good for this, if not is there any other
approach I could employ. Please enlighten me on this..

 

Thanks

Raj Singh Sisodia

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061027/ee3f54c9/attachment.html 

From antlr at jazillian.com  Fri Oct 27 06:48:46 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 09:48:46 -0400
Subject: [antlr-interest] How to generate code from AST.
In-Reply-To: <9e2360c40610151605m2cd69d30i93e8928cc967023e@mail.gmail.com>
References: <9e2360c40610151605m2cd69d30i93e8928cc967023e@mail.gmail.com>
Message-ID: <45420E3E.5070306@jazillian.com>

davood khoshfetrat wrote:

> Hi every body.
>
> I've created my grammer and it works perfectly. Now I have AST. My
> problem is that I have to generate code to 3 different languages and
> they are complex. Meaning iterating throgh the AST won't cut it. I'm
> looking for some kind of algorithm or framework. some thing flexible.
> If you have any clue please guide me.
>
> Looking forward to hear from you.
> Thanks.
>
Hi Davood,
My JavaEmitter code http://jazillian.com/antlr/emitter.html
pretty-prints Java code from an ANTLR-generated Java AST.
Needing a similar thing for other languages, I started to make a general
AST-pretty-printer that could apply to "any" language. Alas,
I got busy and never finished.

But the idea was to let a programmer specify how each type of node should
be handled by the pretty-printer. So you might say something like:
prettyPrinter.setFollowingString(STATEMENT, ";\n");
to indicate that it should append a semicolon and newline
after printing a STATEMENT node.

So this approach would be an alternative to the StringTemplate approach,
allowing programatic specification of the "look" of each particular 
language.

Andy

From antlr at jazillian.com  Fri Oct 27 07:02:09 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 10:02:09 -0400
Subject: [antlr-interest] Transformation phylosophy : AST
 trans./	pattern matching
In-Reply-To: <0E2583D7-CFDB-4A47-8125-C778692E00BF@cs.usfca.edu>
References: <db9360ca0610181453h22027552hb577c0650582cac5@mail.gmail.com>
	<0E2583D7-CFDB-4A47-8125-C778692E00BF@cs.usfca.edu>
Message-ID: <45421161.8090204@jazillian.com>

Terence Parr wrote:

>
> On Oct 18, 2006, at 2:53 PM, Mathieu Clabaut wrote:
>
>> Hello all,
>>
>> I've read some of the interesting mails about the different way to do
>> transformation.
>>
>> Just for reference, a collegue of mine pointed me to the cocktail95
>> tool suite :
>>   http://www.iste.uni-stuttgart.de/ps/cocktail/
>> which seems to allow AST transformation but as also a Transformation
>> Tool based on Pattern Matching (puma).... No, I didn't give a try to
>> it, but I may have a deeper look in a near futur...
>
>
> Interesting; just looked at Puma.  Syntax is not obvious.  Seems to  
> allow tree grammar specification due to recursive references but  
> doesn't call it that.  Allows patterns and predicates to match.  Has  
> some interesting functionality similar to other tools.  My thoughts  
> would lean more towards what Andy did but with some twists.
>
I had looked into Cocktail and a bunch of similar tools when I was 
starting out. IIRC, Terence is being kind when he says
the syntax is "not obvious". "Not obvious" is almost an anagram for 
"obnoxios" or "oblivious" :)
I don't remember the details, but I would guess that my attitude was "I 
just can't work with this syntax."

Andy


From antlr at jazillian.com  Fri Oct 27 07:31:47 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 10:31:47 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>	<452D3180.2070907@jazillian.com>
	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
Message-ID: <45421853.3080907@jazillian.com>

Anthony W. Youngman wrote:

> In message <452D3180.2070907 at jazillian.com>, Andy Tripp 
> <antlr at jazillian.com> writes
>
>>> "Thinking in trees" does not come automatically.  It is like 
>>> learning LISP or Forth or one of the functional languages (and, for 
>>> that matter, object-oriented programming:  there is a lot of badly 
>>> designed and implemented C++ code out there).  For a time, working 
>>> with trees is like slogging through molasses, and then you get the 
>>> "Aha!" experience and things become easy.  It usually is not about 
>>> designing the perfect tree structure; instead, it is about 
>>> simplifying the recognition problem and expressing target language 
>>> constructs in tree  form.
>>
>>
>> For the record, I had no trouble "getting" LISP when I learned it 25 
>> years ago. When I started with C++, I don't think I
>> really "got" OOD, and only started writing real OO code when learning 
>> Java forced me to. I think the fact that LISP never
>> became "mainstream" means that it failed to be easy enough to grasp. 
>> Regardless of how inherently beautiful it is,
>> if a lot of programmers don't easily "get it", then it's not that great.
>
>
> The trouble is, the "average" programmer is just that, average.
>
> A great programmer can do the work of ten ordinary programmers. The 
> trouble is, he probably does it with tools that are beyond the ability 
> of the ordinary programmer to "get".

Just to be clear, I'm not saying I'm an "average" programmer or looking 
for tools for the "average" programmer.
I might be in the top 2% of all programmers, but I'm not in the top 0.1% 
of language-tools-gurus as Terence is.
So I want tools that helps us good-programmers-but-not-compiler-gurus 
build stuff.
I'm not a Terence looking to automate my parser-creation task;
I'm just an Andy looking to build a language translator while barely 
knowing the difference between LL(*) and LL(k).

Just as a compiler lets the programmer focus 100% on the problem at hand 
(application logic) and 0% on
the underlying level (creation of object or byte code), ANTLR lets me 
focus on the problem at hand
(lexing and parsing) and not the underlying level (creation of 
lexing/parsing code). Unfortunately, I
don't think there's one really good tool for hiding the whole "language 
translation" level. ANTLR treewalking
combined with StringTemplate attempts to do that, but falls short in two 
ways, I think. First, ANTRL treewalking
requires perfect knowledge of the input language structure. And second, 
I don't think treewalking is the better
way to slice the problem, as the problem scales up. In other words, when 
you have a ton on translation logic,
"Here are each of the translation rules I'd like to apply" is a better 
way to approach it than
"Here is what to do at each node of the input structure tree".

From antlr at jazillian.com  Fri Oct 27 07:44:49 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 10:44:49 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>	<452D3180.2070907@jazillian.com>	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
	<3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>
Message-ID: <45421B61.1030601@jazillian.com>


>
> To briefly return to the topic ;), if you are doing source-to-source  
> translation, I would love to see a product that let's me see the  
> effect of one certain rule not only by the grammatical structure of  
> the (ENBF-)rules that drive it, but also by some form of  
> visualization that let me see the big "picture" without having to  
> simulate the parser/translator in my head. I am convinced that a  
> visual representation of this process would speed up my work  
> tremendously. 

Yes! Suppose we're changing a "long" variable to be "BigDecimal".
So, for example, "i + 3" becomes "i.add(3)".
I'd rather have a set of rules that look like this:

v + x --> v.add(x)

...than the correct-but-nontrivial tree version:

PLUS
  v
  x
-->
METHOD_CALL
   DOT
      v
      add
   ELIST
      x

I'm sorry, but I just didn't know, off the top of my head, what the AST 
for "v.add(x)" looks like.
I'm going to be writing at least 10 of these sorts of "pattern 
replacements" just for this BigDecimalRule
alone, and I refuse to get bogged down in mental images of ASTs.

So what I'm doing is write a tree-matching class that allows you to say
"v + x --> v.add(x)" to mean "look through an AST for a "+"
node with a first child that's an IDENT that has a particular text, and 
any arbitrary
second child. If found, replace that AST node with a different AST node
that has a METHOD_CALL node as its root, a DOT node as first child,
etc."

Humans think in terms of token streams, translators can go ahead and 
implement
the humans' wishes in terms of nicely structured trees.

From johnicholas.hines at gmail.com  Fri Oct 27 09:14:01 2006
From: johnicholas.hines at gmail.com (Johnicholas Hines)
Date: Fri, 27 Oct 2006 12:14:01 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45421B61.1030601@jazillian.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
	<452D3180.2070907@jazillian.com>
	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
	<3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>
	<45421B61.1030601@jazillian.com>
Message-ID: <d092c2300610270914y19b7a0e8oc93f6f2df36c2510@mail.gmail.com>

You know,

v + x --> v.add(x)

could be parsed into trees, recognizing v and x as metasyntactic
variables, with enough tool support.

If we have a formal notion of "tree transducer" (I'm sure there are
several definitions, not sure which one Antlr uses), then several of
these rules could be composed to create one tree transducer. Running a
single tree transducer over a tree is likely to be faster than the
"lots and lots of linear searches" that Andy Tripp seems to be
recommending.

Johnicholas

> I'd rather have a set of rules that look like this:
>
> v + x --> v.add(x)
>
> ...than the correct-but-nontrivial tree version:
>
> PLUS
>   v
>   x
> -->
> METHOD_CALL
>    DOT
>       v
>       add
>    ELIST
>       x
>
> I'm sorry, but I just didn't know, off the top of my head, what the AST
> for "v.add(x)" looks like.
> I'm going to be writing at least 10 of these sorts of "pattern
> replacements" just for this BigDecimalRule
> alone, and I refuse to get bogged down in mental images of ASTs.
>
> So what I'm doing is write a tree-matching class that allows you to say
> "v + x --> v.add(x)" to mean "look through an AST for a "+"
> node with a first child that's an IDENT that has a particular text, and
> any arbitrary
> second child. If found, replace that AST node with a different AST node
> that has a METHOD_CALL node as its root, a DOT node as first child,
> etc."
>
> Humans think in terms of token streams, translators can go ahead and
> implement
> the humans' wishes in terms of nicely structured trees.
>

From antlr at jazillian.com  Fri Oct 27 10:44:58 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 13:44:58 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <d092c2300610270914y19b7a0e8oc93f6f2df36c2510@mail.gmail.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>	
	<452D3180.2070907@jazillian.com>	
	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>	
	<3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>	
	<45421B61.1030601@jazillian.com>
	<d092c2300610270914y19b7a0e8oc93f6f2df36c2510@mail.gmail.com>
Message-ID: <4542459A.1020705@jazillian.com>

Johnicholas Hines wrote:

> You know,
>
> v + x --> v.add(x)
>
> could be parsed into trees, recognizing v and x as metasyntactic
> variables, with enough tool support.

Right, I'm building a simple tool to do that right now.
But what I'm doing will probably be specific to Java/C/C++ expressions only.

So my main recommendation to Terence is to think about how one could 
build a tool
that does this for any grammar and in a very flexible way (with more 
than just
'v' and 'x' types of placeholders, hooks into code (i.e. "actions"), 
constraints
("only apply this rule at certain points in the AST), etc.

Basically, an alternative to the treewalker approach, for those of us 
who want to
frame the problem as a series of these kinds of rules, as opposed to a 
series of
actions that fire at various points during a tree walk.

>
> If we have a formal notion of "tree transducer" (I'm sure there are
> several definitions, not sure which one Antlr uses), then several of
> these rules could be composed to create one tree transducer. Running a
> single tree transducer over a tree is likely to be faster than the
> "lots and lots of linear searches" that Andy Tripp seems to be
> recommending.

Yes, but I think in general that "faster" at runtime is not a big issue for
high-level-language to high-level-language translators (as opposed to
compilers).

>
> Johnicholas
>


From kroepke at classdump.org  Fri Oct 27 10:51:30 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Fri, 27 Oct 2006 19:51:30 +0200
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45421B61.1030601@jazillian.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>	<452D3180.2070907@jazillian.com>	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
	<3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>
	<45421B61.1030601@jazillian.com>
Message-ID: <3ABF876D-E0B7-43B8-B219-F1B78A775FEB@classdump.org>


On 27. Oct 2006, at 16:44 , Andy Tripp wrote:

> So what I'm doing is write a tree-matching class that allows you to  
> say
> "v + x --> v.add(x)" to mean "look through an AST for a "+"
> node with a first child that's an IDENT that has a particular text,  
> and any arbitrary
> second child. If found, replace that AST node with a different AST  
> node
> that has a METHOD_CALL node as its root, a DOT node as first child,
> etc."

Like a parser rule with a rewrite action? Sounds tremendously like  
it...;)
I think a filtering parser (or even tree  parser with rewrite  
ability) will be able to
do just that!
For some reason there's a voice in my head that says "you want to  
write a translator from
a more human-readable text input to ANTLR grammars". Because this is  
pretty much what you
can do with ANTLR already, although not completely in ANTLR syntax.
Once ANTLR can support tree rewrites I don't see why you'd have to  
resort to custom Java
classes to reimplement that.
It seems to me that you are actually implementing a treeparser  
generator, looking at
"v + x ..." and your explanation of it. Just with a different (non- 
EBNF) syntax. Is that a
wise decision? I cannot really say, but I have the feeling that you  
might open a can of worms
there. Of course, I might also be totally wrong :)

If I was to tackle this problem, I'd try to actually generate some  
sort of ANTLR grammar to
do the actual tree walking for me, translated from my rule definitions.
This could mean that I'd have to enhance certain aspects of ANTLR  
(like implementing filtering
parsers and treeparsers, tree rewrites), but in the long run that  
would be worth it, I think.

cheers,
-k





From antlr at jazillian.com  Fri Oct 27 11:22:29 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 14:22:29 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <3ABF876D-E0B7-43B8-B219-F1B78A775FEB@classdump.org>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>	<452D3180.2070907@jazillian.com>	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
	<3EB7CC32-6FCF-429B-A8C2-6C78A0A6B974@classdump.org>
	<45421B61.1030601@jazillian.com>
	<3ABF876D-E0B7-43B8-B219-F1B78A775FEB@classdump.org>
Message-ID: <45424E65.5040200@jazillian.com>

Kay Roepke wrote:

>
> On 27. Oct 2006, at 16:44 , Andy Tripp wrote:
>
>> So what I'm doing is write a tree-matching class that allows you to  say
>> "v + x --> v.add(x)" to mean "look through an AST for a "+"
>> node with a first child that's an IDENT that has a particular text,  
>> and any arbitrary
>> second child. If found, replace that AST node with a different AST  node
>> that has a METHOD_CALL node as its root, a DOT node as first child,
>> etc."
>
>
> Like a parser rule with a rewrite action? Sounds tremendously like  
> it...;)

Yes, with the following differences:
* the "action" is always the same: "replace the matched pattern with 
this one"
* the "action" is not fired at particular place(s) in the tree during a 
treewalk, but
  rather fired by arbitrary Java code. (In my BigDecimal example, it 
only fires
  on expressions that contain a reference to some variable that I've 
just changed to
  BigDecimal type).
* the "v + x --> v.add(x)" specification is quite different syntax than 
a treewalker action.
* with the treewalker approach you'd be sure to "cover the whole input 
grammar", with
   this approach you wouldn't.

> I think a filtering parser (or even tree  parser with rewrite  
> ability) will be able to
> do just that!
> For some reason there's a voice in my head that says "you want to  
> write a translator from
> a more human-readable text input to ANTLR grammars". 

No I'm saying I want to write a translator *without* ever having to 
really know the
input and output language grammars and AST structures. I don't care how 
smart someone
is, I doubt they'll know what "a.add(1)" looks like as a C-AST, a 
Java-AST and a COBOL-AST.
And that's about as trivial a snippet of code as you'll ever see.

> Because this is  pretty much what you
> can do with ANTLR already, although not completely in ANTLR syntax.


I disagree. With ANTLR treewalkers or even any other tool and not 
treewalkers when you build
ASTs and then transform them to other ASTs, you have to be intimately 
familiar with the
shape of those ASTs (i.e. the grammar for the input and output 
languages). I'd rather not have
to know that. I know that the COBOL sentence:
ADD 1 TO A GIVING B.
...maps to the Java statement...
B = A + 1;

...and yet I have little clue as to what the COBOL or Java ASTs look like.
So I really do want to write:
ADD v1 TO v2 GIVING v3 --> v3 = v1 + v2;
...and never even think about AST structures.
If the underlying tool wants to use ASTs (or not), that's fine with me.

>
> Once ANTLR can support tree rewrites I don't see why you'd have to  
> resort to custom Java
> classes to reimplement that.

Is there some upcoming ANTLR "tree rewrite" feature I don't know about 
that's different from treewalkers?

> It seems to me that you are actually implementing a treeparser  
> generator, looking at
> "v + x ..." and your explanation of it. Just with a different (non- 
> EBNF) syntax. Is that a
> wise decision? I cannot really say, but I have the feeling that you  
> might open a can of worms
> there. Of course, I might also be totally wrong :)

Yes, I currently use token streams for my pattern matching, and I'm 
adding a similar thing that
uses similar syntax that works on ASTs instead. I'll keep you posted on 
any cans of worms :)

>
> If I was to tackle this problem, I'd try to actually generate some  
> sort of ANTLR grammar to
> do the actual tree walking for me, translated from my rule definitions.
> This could mean that I'd have to enhance certain aspects of ANTLR  
> (like implementing filtering
> parsers and treeparsers, tree rewrites), but in the long run that  
> would be worth it, I think.

What I have seems to be working fine after just one day of design and 
development. The
real test will come when I use it to replace C++ operator overloading. 
As I've said before,
I'm don't really see the benefit of treewalking as opposed to just 
walking the tree "by hand"
(via visitor pattern or otherwise). It's very few lines of code to check 
if a given AST "matches"
another AST...no need to get any ANTLR grammar involved.

Andy

>
> cheers,
> -k
>
>
>
>


From owong at benchmarkconsulting.com  Fri Oct 27 11:40:48 2006
From: owong at benchmarkconsulting.com (Oliver Wong)
Date: Fri, 27 Oct 2006 14:40:48 -0400
Subject: [antlr-interest] philosophy about translation
Message-ID: <F89BA86F375B2F43B05CB04E01B199BA0AAE36@castor-srvr1.benchmarkcanada.com>

-----Original Message-----
From: antlr-interest-bounces at antlr.org
[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Andy Tripp
> I don't care how smart someone is, I doubt they'll know what
"a.add(1)"
> looks like as a C-AST, a Java-AST and a COBOL-AST. And that's about as
> trivial a snippet of code as you'll ever see.

    That may be because there's some information in the AST form which
isn't present in the raw string (or token stream) form. Assuming
"a.add(1)" is Java, just from the raw string or the token stream, you
can't tell whether that's an instance method invocation, a static method
invocation, or something else. That snippet might even appear within the
bigger context of "new a.add(1);", where "a" is a package name, and
"add" is a class name, for example.
    
    But given an AST like...

<Statement>
  <StatementExpression>
    <Expression>
      <QualifiedMethodInvocation>
        <Expression>
          <LocalVariableRef image="a">
        </Expression>
        <MethodInvocation image="add">
          <Params>
            <Param>
              <Expression>
                <Literal>
                  <IntegerLiteral image="1"/>
                </Literal>
             </Expression>
            </Param>
          </Params>
       </MethodInvocation>
      </QualifiedMethodInvocation>
    </Expression>
  </StatementExpression>
</Statement>

    ... you can eliminate the possibility of a static method invocation
and constructor invocation.

    - Oliver

From antlr at jazillian.com  Fri Oct 27 13:56:39 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 16:56:39 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <F89BA86F375B2F43B05CB04E01B199BA0AAE36@castor-srvr1.benchmarkcanada.com>
References: <F89BA86F375B2F43B05CB04E01B199BA0AAE36@castor-srvr1.benchmarkcanada.com>
Message-ID: <45427287.7020401@jazillian.com>

Oliver,

Yes, that's a great point. In theory, that's the price I pay for 
avoiding the treewalker approach :
I'm never sure if my "snippet" (e.g. "a.add(1)") actually might match 
something more than
what I'm picturing.

But because of the way I'm doing things, that's rarely a problem. In 
this case, I'm only
invoking this "snippet matcher" on each reference to a BigDecimal 
variable. In other words,
I've already found a "BigDecimal a;" declaration, and I'm looping 
through all the references
to that "a", and I only process the expression that surrounds it.

But this is the sort of thing I was hoping that Terence would hit if he 
attempted to "do it right".
That is, I'd like to have a tool that sees "a.add(1)", and then looks 
through the grammar,
sees that there are, say, 3 different places in the grammar that may 
match that pattern,
and then force me to specify which of those 3 I'm referring to.

Andy

Oliver Wong wrote:

>-----Original Message-----
>From: antlr-interest-bounces at antlr.org
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Andy Tripp
>  
>
>>I don't care how smart someone is, I doubt they'll know what
>>    
>>
>"a.add(1)"
>  
>
>>looks like as a C-AST, a Java-AST and a COBOL-AST. And that's about as
>>trivial a snippet of code as you'll ever see.
>>    
>>
>
>    That may be because there's some information in the AST form which
>isn't present in the raw string (or token stream) form. Assuming
>"a.add(1)" is Java, just from the raw string or the token stream, you
>can't tell whether that's an instance method invocation, a static method
>invocation, or something else. That snippet might even appear within the
>bigger context of "new a.add(1);", where "a" is a package name, and
>"add" is a class name, for example.
>    
>    But given an AST like...
>
><Statement>
>  <StatementExpression>
>    <Expression>
>      <QualifiedMethodInvocation>
>        <Expression>
>          <LocalVariableRef image="a">
>        </Expression>
>        <MethodInvocation image="add">
>          <Params>
>            <Param>
>              <Expression>
>                <Literal>
>                  <IntegerLiteral image="1"/>
>                </Literal>
>             </Expression>
>            </Param>
>          </Params>
>       </MethodInvocation>
>      </QualifiedMethodInvocation>
>    </Expression>
>  </StatementExpression>
></Statement>
>
>    ... you can eliminate the possibility of a static method invocation
>and constructor invocation.
>
>    - Oliver
>
>  
>


From tommy.nordgren at chello.se  Fri Oct 27 14:13:39 2006
From: tommy.nordgren at chello.se (Tommy Nordgren)
Date: Fri, 27 Oct 2006 23:13:39 +0200
Subject: [antlr-interest] Any docs on Antlr 3?
Message-ID: <23BB9E95-477D-49C9-9A39-A7108971F234@chello.se>

How is the current status of Antlr 3. Is there any user level  
documentation available by now?
-------------------------------------
This sig is dedicated to the advancement of Nuclear Power
Tommy Nordgren
tommy.nordgren at chello.se




From jimi at intersystems.com  Fri Oct 27 15:03:28 2006
From: jimi at intersystems.com (Jim Idle)
Date: Fri, 27 Oct 2006 18:03:28 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45424E65.5040200@jazillian.com>
Message-ID: <20061027220329.89291143E@mail.intersystems.com>


> I disagree. With ANTLR treewalkers or even any other tool and not 
> treewalkers when you build
> ASTs and then transform them to other ASTs, you have to be intimately 
> familiar with the
> shape of those ASTs (i.e. the grammar for the input and output 
> languages). I'd rather not have
> to know that.

I see no way to avoid this and produce a good result. However there are few languages such that being familiar with the type of tree that one language produces does not help with the tree that another produces. In fact I think that that TreeParser grammar is a huge aid to being able to 'read' the tree. 

> I know that the COBOL sentence:
> ADD 1 TO A GIVING B.
> ...maps to the Java statement...
> B = A + 1;

> ...and yet I have little clue as to what the COBOL or Java ASTs look like.
> So I really do want to write:
> ADD v1 TO v2 GIVING v3 --> v3 = v1 + v2; 

Taking your COBOL example though, I think that the issue of translating one language to another is much more complex in general than this and that the issue would be being intimately familiar with the languages, the tree surely being a relatively easy thing to pick up? What is the PIC of A and B for instance, where is the meta data about this to be stored (front end, encoded in IR, back end?), what significance does this have on the target language? What is the behavior of the VM when you produce System.out.println("String " + A); // What happens internally with A, will I produce code that cause STR->INT->STR conversion all the time. COBOL will reject things that don't fit the PIC... etc.

What happens with:

MOVE MOUNTAIN TO MOHAMMED;

A universal front end->IR->high level language methodology is probably not possible. 

Surely the rule matching scenario would be able to formulate an unknown sequence of events such that ruletriggerA changes some part of the input which fires ruletriggerB, which changes some part of the input that fires ruletriggerA... 

It would seem that one has a specific project "Source code for app A1 in lang L1 translated to A1 in lang L1", or "Any App AN in L1 to L2" or "Lang L1 to Lang L2" or "LN1 to LN2; N1 # N2" and so on. I will ignore A1->A2 ;-). 

The amount of support library programming in lang L2 would probably far outweigh other issues and I think that assuming you can find good enough programmers (big if though I admit) that just rewriting it in L2 would be better anyway. There is probably no way to avoid the new source code looking like the input source code and that a programmer of LANG L2 would say "What the bejesus is this?"

For a translation solution, I suspect then that you just "type it in" and end up with a tool specific to the thing you want to translate, starting with tree walkers then probably some manual hard coded passes. Of course, you could consider this rule set approach part of the latter phase with a more specific task at hand. I think that this yields a practical solution to the task in hand and that you could knock out 10 of these in the time taken to deal with more general solutions ;-)

Jim

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.15/503 - Release Date: 10/27/2006
 

From antlr at jazillian.com  Fri Oct 27 16:12:59 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Fri, 27 Oct 2006 19:12:59 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061027220329.89291143E@mail.intersystems.com>
References: <20061027220329.89291143E@mail.intersystems.com>
Message-ID: <4542927B.805@jazillian.com>

Jim Idle wrote:

>>I disagree. With ANTLR treewalkers or even any other tool and not 
>>treewalkers when you build
>>ASTs and then transform them to other ASTs, you have to be intimately 
>>familiar with the
>>shape of those ASTs (i.e. the grammar for the input and output 
>>languages). I'd rather not have
>>to know that.
>>    
>>
>
>I see no way to avoid this and produce a good result. 
>
I feel that I'm getting a "good result" for C, C++, and COBOL to Java
translation without being intimately
familiar with their AST structures. If you can point to a potential
problem spot, I can address what I do.

>However there are few languages such that being familiar with the type of tree that one language produces does not help with the tree that another produces. In fact I think that that TreeParser grammar is a huge aid to being able to 'read' the tree. 
>  
>
I'm sure that knowing the C tree structure helps a lot with C++. But
even comparing the C structure with the
Java one, there are quite a few differences for no real reason other
than the whim of the person who wrote each.
That really shows when you compare the two perfectly good, but
different, java.g files at antlr.org.

>>I know that the COBOL sentence:
>>ADD 1 TO A GIVING B.
>>...maps to the Java statement...
>>B = A + 1;
>>    
>>
>
>  
>
>>...and yet I have little clue as to what the COBOL or Java ASTs look like.
>>So I really do want to write:
>>ADD v1 TO v2 GIVING v3 --> v3 = v1 + v2; 
>>    
>>
>
>Taking your COBOL example though, I think that the issue of translating one language to another is much more complex in general than this and that the issue would be being intimately familiar with the languages, the tree surely being a relatively easy thing to pick up? 
>
Not for me. I've been programming in C for 25 years, and yet I didn't
know until I tried it what the "a.add(1)" tree looks like.
Sure, I could have guessed and gotten close, but close counts for
nothing in this context.

>What is the PIC of A and B for instance, where is the meta data about this to be stored (front end, encoded in IR, back end?), what significance does this have on the target language? What is the behavior of the VM when you produce System.out.println("String " + A); // What happens internally with A, will I produce code that cause STR->INT->STR conversion all the time. COBOL will reject things that don't fit the PIC... etc.
>  
>
Right. Those are all things I deal with, and they're all difficult. So
that's where I want to spend my time, not in worrying about
AST details.

>What happens with:
>
>MOVE MOUNTAIN TO MOHAMMED;
>
>A universal front end->IR->high level language methodology is probably not possible. 
>  
>
Right. Like replacing a C memset() call, it's not possible in general
probably. Yet it is possible in practice,
I believe. I know it would take a lot of work to convince you on that one.

>Surely the rule matching scenario would be able to formulate an unknown sequence of events such that ruletriggerA changes some part of the input which fires ruletriggerB, which changes some part of the input that fires ruletriggerA... 
>  
>
I don't have "triggers" firing rules, but rule firing order is very
important. And some rules might just keep firing until
they stop making changes.

>It would seem that one has a specific project "Source code for app A1 in lang L1 translated to A1 in lang L1", or "Any App AN in L1 to L2" or "Lang L1 to Lang L2" or "LN1 to LN2; N1 # N2" and so on. I will ignore A1->A2 ;-). 
>
>The amount of support library programming in lang L2 would probably far outweigh other issues and I think that assuming you can find good enough programmers (big if though I admit) that just rewriting it in L2 would be better anyway. There is probably no way to avoid the new source code looking like the input source code and that a programmer of LANG L2 would say "What the bejesus is this?"
>  
>
If you do lots of intelligent replacement, then the "support library"
can be very small - that's the case with Jazillian.
And if you don't do intelligent replacement, it's impossible anyway -
you're never going to write memset() in Java
no matter how great your programmers. That's why we have just two
classes of language translators today -
the kind that produce correct, horribly convoluted code (like Ephedra
for C to Java), and the kind that produce
not-guaranteed-correct, nice, readable code. Jazillian is the only
translator in that second category (except maybe
for this one: http://reinventsoft.com/intentionalcompilation.html)

>For a translation solution, I suspect then that you just "type it in" and end up with a tool specific to the thing you want to translate, starting with tree walkers then probably some manual hard coded passes. Of course, you could consider this rule set approach part of the latter phase with a more specific task at hand. I think that this yields a practical solution to the task in hand and that you could knock out 10 of these in the time taken to deal with more general solutions ;-)
>  
>
As for "just type it in", here is a small chunk of rules from Jazillian:
isalnum(x1) --> Character.isLetterOrDigit(x1)
isalpha(x1) --> Character.isLetter(x1)
iscntrl(x1) --> Character.isISOControl(x1)
isdigit(x1) --> Character.isDigit(x1)
isgraph(x1) --> x1 > '\u0020' && x1 < '\u007E' && !Character.isSpaceChar(x1)
islower(x1) --> Character.isLowerCase(x1)
isprint(x1) --> ( x1 > '\u0020' && x1 < '\u007E')
ispunct(x1) --> ( x1 > '\u0020' && x1 < '\u007E' &&
!Character.isSpaceChar(x1) &
& !Character.isLetterOrDigit(x1))
isspace(x1) --> Character.isWhitespace(x1)
isupper(x1) --> Character.isUpperCase(x1)
isxdigit(x1) --> Character.isDigit(x1) || ( Character.toLower(x1) >= 'a'
&& Char
acter.toLower(x1) <= 'f')
memchr(x1, x2) --> CStringUtils.memchr(x1,x2)
tolower(x1) --> Character.toLowerCase(x1)
toupper(x1) --> Character.toUpperCase(x1)

The development time for these is only slightly longer than the time to
type them.
Try implementing them using a treewalker and see how long it takes.

As for "hard-coded passes", I've found that I have so many of these
passes that I'd guess that
less than 1% of my code would be related to treewalking, if I used
treewalking. At that point,
you have to wonder whether it's even worth figuring out how ANTLR
treewalking works.

I agree that you have to build something specific to the input and
output language.
Sure, Terence has StringTemplate (and even just ANTLR itself before v3)
spitting out code in lots of different languages, but he has an unfair
advantage: he gets
to design the ANTLR input language and the scope of what ANTLR does. Try
spitting
out PIC clauses in just about any language other than COBOL...there just
is no real
equivalent.

Andy

>Jim
>
>  
>



From parrt at cs.usfca.edu  Fri Oct 27 17:44:03 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Fri, 27 Oct 2006 17:44:03 -0700
Subject: [antlr-interest] Any docs on Antlr 3?
In-Reply-To: <23BB9E95-477D-49C9-9A39-A7108971F234@chello.se>
References: <23BB9E95-477D-49C9-9A39-A7108971F234@chello.se>
Message-ID: <E17E7AB6-9B81-4567-B06D-8926B969B3E9@cs.usfca.edu>


On Oct 27, 2006, at 2:13 PM, Tommy Nordgren wrote:

> How is the current status of Antlr 3. Is there any user level  
> documentation available by now?

Hi Tommy.  Under the documentation section of antlr.org/v3 there  is  
a link to the wiki:

http://www.antlr.org/wiki/display/ANTLR3/ANTLR+v3+documentation

:)

Ter


From foolishewe at hotmail.com  Fri Oct 27 18:09:46 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Sat, 28 Oct 2006 01:09:46 +0000
Subject: [antlr-interest] ANTLR 3.0b4 code generation question
Message-ID: <BAY107-F1470656C192A96BEDC27A3C0050@phx.gbl>

Hello All:

Thanks for the wonderful hints so far.  I've noticed some unusual java code 
generated
under ANTLR3, and I'm wondering if it is a cockpit error or if I might be 
tickling an ANTLR3 bug.

The MIME attached smalltest.g using my recently downloaded version of 
ANTLRworks creates
the following line in the parser:
       void c = null;

Is this correct Java, or did I do something wrong to cause this?

Regards:

Bill Maniatty

_________________________________________________________________
All-in-one security and maintenance for your PC.  Get a free 90-day trial! 
http://clk.atdmt.com/MSN/go/msnnkwlo0050000002msn/direct/01/?href=http://www.windowsonecare.com/?sc_cid=msn_hotmail
-------------- next part --------------
A non-text attachment was scrubbed...
Name: SmallTest.g
Type: application/octet-stream
Size: 559 bytes
Desc: not available
Url : http://www.antlr.org/pipermail/antlr-interest/attachments/20061028/0b3e6b5b/attachment.obj 

From jbb at acm.org  Fri Oct 27 19:13:30 2006
From: jbb at acm.org (John B. Brodie)
Date: Fri, 27 Oct 2006 22:13:30 -0400
Subject: [antlr-interest] ANTLR 3.0b4 code generation question
In-Reply-To: <BAY107-F1470656C192A96BEDC27A3C0050@phx.gbl> (message from
	Foolish Ewe on Sat, 28 Oct 2006 01:09:46 +0000)
References: <BAY107-F1470656C192A96BEDC27A3C0050@phx.gbl>
Message-ID: <E1GddhS-0005df-00@gecko>


Greetings!

>Thanks for the wonderful hints so far.  I've noticed some unusual
>java code generated under ANTLR3, and I'm wondering if it is a
>cockpit error or if I might be tickling an ANTLR3 bug.
>
>The MIME attached smalltest.g using my recently downloaded version of
>ANTLRworks creates the following line in the parser:
>
>       void c = null;
>
>Is this correct Java, or did I do something wrong to cause this?

You have done something wrong which ANTLR v3 (in my opinion) should have
complained about.

Your grammar is (essentially this):

>grammar SmallTest;
>
... at members snipped, not relevant to this issue
>
>startRule : c=command NEWLINE | NEWLINE ;
>
>command : a=A ;
>
>NEWLINE	: ('\r' | '\n' | '\r\n');	
>A	: 'a';

and now we must ask what is the type of variable c in startRule to be?

there is no

options { output = AST; }

so variable c can not be an AST.

and variable c is not declared in an @init{} section, never mind that rule
command has no returns clause

command returns [SomeClass foo] : ... ; // not present!



so it is a quandary as to exactly what your desires for the variable c are.



I think ANTLR should have scolded you for not specifying a type for c ;=)



You need to decide (and tell ANTLR) what the type of the variable c is.

Hope This Helps
   -jbb

From c.shoemaker at cox.net  Fri Oct 27 20:13:19 2006
From: c.shoemaker at cox.net (Chris Shoemaker)
Date: Fri, 27 Oct 2006 23:13:19 -0400
Subject: [antlr-interest] Use of Syntactic Predicates
Message-ID: <20061028031319.GA12266@pe.Belkin>

Hi,
    I'm new to antlr, and am having trouble with syntactic predicates.

I want a lexer rule that matches exactly two digits optionally
followed by a format specifier, but never by a third digit.

First attempt, using syntactic predicate:

protected
SUFFIX: (WS)* ("pa"|"aa") WS
   ;

FIELD
   : (DIGIT DIGIT ~('0'..'9')) => DIGIT DIGIT (SUFFIX)?
   ;

Here's a table showing how I intend for strings to be tokenized (where
quoted strings in the Tokens column mean not-yet-tokenized)

  String       Tokens 

  "41 pa"      FIELD
  "41 pq.."    FIELD " pq.."
  "411"        -rejected-

I _thought_ that the rules above expressed what I want. However, I'm
getting: warning:Syntactic predicate ignored for single alternative

Q1) Is it really valid to ignore a single alternative synpred for a
lexical rule?  Isn't there an implicit "exit" alternative?  IOW, I
just want the token to never match if the synpred fails.

I've tried many different ways to reformulate this, and have run into
other interesting problems.

For example, I thought I would try pushing the synpred further right:

protected
SUFFIX
   :  (~('0'..'9')) => (WS)* ("pa"|"aa") WS
   | 'Q' /* This is to avoid the "Syntactic predicate ignored for
            single alternative" warning.  I know it's a little "wrong" 
            but I'm willing to work with it for now. */
   ;

FIELD
   : DIGIT DIGIT (SUFFIX)?
   ;

AFAICT, this just generates wrong code.  For example, when scanning
"41paX", it matches the digits, matches the synpred, matches the "pa",
but when it gets to the 'X', I think it should not create SUFFIX, but
still create FIELD, since SUFFIX was optional.  Instead, it throws an
exception that's caught by another synpred way above mFIELD(), so it
doesn't create FIELD.

Q2) Is this a bug or am I just abusing the tool?

Thanks in advance for any help and, remember, I'm new at this. ;)

-chris

From joseph at iist.unu.edu  Fri Oct 27 22:36:50 2006
From: joseph at iist.unu.edu (Joseph)
Date: Sat, 28 Oct 2006 13:36:50 +0800
Subject: [antlr-interest] Can't find template
Message-ID: <200610281336.50568.joseph@iist.unu.edu>

Dear All,

I am a new user of ANTLR and String Template. I am developing a translator and  
using the example cminus as a starting point. I get the following error which 
i cannot figure out why its there even when the "type_int" is specified in 
the .stg file. 

Could any one help me out.

Here is the error message:

joe at joe:~/utpcompiler/utp2pvs$ java -cp .:antlr-2.7.7.jar:stringtemplate.jar 
UTP < test1.utp
Exception in thread "main" java.lang.IllegalArgumentException: Can't find 
template type_int.st
        at 
org.antlr.stringtemplate.StringTemplateGroup.lookupTemplate(StringTemplateGroup.java:485)
        at 
org.antlr.stringtemplate.StringTemplateGroup.getInstanceOf(StringTemplateGroup.java:372)
        at 
org.antlr.stringtemplate.StringTemplateGroup.getInstanceOf(StringTemplateGroup.java:384)
        at UTPParser.template(UTPParser.java:26)
        at UTPParser.typename(UTPParser.java:232)
        at UTPParser.vardecl(UTPParser.java:131)
        at UTPParser.declarationBlock(UTPParser.java:99)
        at UTPParser.utpspec(UTPParser.java:71)
        at UTP.main(UTP.java:20)

Here is the definition in the grammar.
*************************************************
typename returns [StringTemplate code=null]
    :   "int"  {code=template("type_int");}
    |   "nat"  {code=template("type_nat");}
    |   id:IDENT
        {
        code=template("type_user_def");
        code.setAttribute("name", id.getText());
        }
    ;
************************************************

Here is the definition the .stg

*************************************************
group Pvs;

utpspec(vars, commands) ::= <<
 <name> : THEORY
    BEGIN
	<vars>
	<commands>
>>

vardecl(name, typename) ::= "<name>, <name>' : VAR <type><\n>"
State: TYPE = "[<typename>,]"
IMPORTING UTPProg[State]
s : VAR State

globalVariable ::= vardecl

commandseq(typename,name,inits,cmds) ::= <<
 pre : pred[State] = 
    ( LAMBDA s : s(<name>) = 
    <inits>
    <cmds; separator="\n">
 END <name>
>>

type_int() ::= "int"

type_nat() ::= "nat"

type_user_def(name) ::= "<name>"

inits(typename, val) ::= "<typename> = <val>"
***********************************************

Thanks and best regards.

Joe.

From lgcraymer at yahoo.com  Sat Oct 28 00:23:22 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Sat, 28 Oct 2006 00:23:22 -0700 (PDT)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <4542927B.805@jazillian.com>
Message-ID: <20061028072322.29884.qmail@web55910.mail.re3.yahoo.com>

Sheesh.  Can we please stop rehashing late 70's
technology and get away from ignorance of modern
rewrite systems?  A friend of mine--Ron Ayres--did one
of the first such systems for his PhD thesis in the
late '70's and subsequently used it as a core
technology for Silicon Compilers and then for MOSIS. 
Somewhere I have a copy of a paper from the early
'80's advocating the use of iterative pattern matching
for rewriting parse trees.  The current easily
available pattern-matching transformation systems
(rule-based) include TXL (http://www.txl.ca)and
stratego
(http://www.stratego-language.org/Stratego/WebHome). 
Both are open source; the power and quirks of such
systems are well documented.

I can understand why Andy found TXL unsatisfactory: 
it is a pure interpreter, and that makes it unsuitable
for producing a packaged product.  Stratego generates
C, but it requires doing at least a minimal literature
search to find and is not so well-known as TXL.

There are innovative possibilities for using rewrite
systems with ANTLR, and I would certainly be
interested in hearing of anyone exploring them.  For
that matter, I would be quite interested in hearing of
anyone using TXL for working with ANTLR grammars. 
However, I get tired of being told about the use of
rule-based systems for simple HLL to HLL translations:
 there are some nice TXL examples of this already.

--Loring


 
____________________________________________________________________________________
Get your email and see which of your friends are online - Right on the New Yahoo.com 
(http://www.yahoo.com/preview) 


From raj.sisodia at impetus.co.in  Sat Oct 28 02:08:25 2006
From: raj.sisodia at impetus.co.in (raj sisodia)
Date: Sat, 28 Oct 2006 14:38:25 +0530
Subject: [antlr-interest] Need help on ANTLR for a domain specific NLP
	project
Message-ID: <01d701c6fa70$a0514680$4361a8c0@impetus.co.in>

Hi,

 

I need to create a parser (more specifically a translator) on a Business
rule published in telecom domain. I have worked quite a bit on the project
and came to the conclusion of writing a parser for this. But due to lack of
time and the necessary skills on the subject of writing parser and Language
processing I am not able to achieve the desired result. 

 

Now I have a list of around 7000 such rules (a rule is one sentence written
in English, which I need to translate into a code hybrid of  to java and
XML). Since many Rules are similar I expect around 700 different patterns in
rules. Now do you think it is codable using ANTLR (well I know it is, the
only question is how), if yes then would someone please guide me on this or
provide their services (what would be the approx cost and time to do this).
For better understanding I am adding a few rules and their codes in the end
of the mail.

 

Please have a look and let me know your comments. I would be glad to provide
any other information you may require.

 

Thanks

Raj Singh Sisodia

 

Rule 1: LNUM is required

Coding

context :
/Request/lsr_order/lsnp/lsnp_servicedetailscontainer/lsnp_servicedetails[*]/
LNUM

assertion : present()

 

The fields in capital (though it not a compulsory to have field names in
capital for the ease of understanding I am putting them so) are always
p[resent in a DTD. Based on their position in DTD we take out XPaths. The
field for which the rule is coded (generally there is only one) is put n
context. All other fields XPaths are put relative to the XPath in context.

 

Rule 2: The valid format for ECCKT is NN.AAAA.NNNNNN..AA when SC is TX, MO,
KS, OK, or AR.

Coding

context :
/Request/lsr_order/lsnp/lsnp_servicedetailscontainer/lsnp_servicedetails[*]/
ECCKT

assertion : value().hasFormat("NN.AAAA.NNNNNN..AA")

condition : present() && isSWBT()

 

Here value is a class in the framework of the program that would use this
produced code. similarly isSWBT is a "custom function" that would compare SC
value to TX, MO, KS, OK, or AR.

This example shows one problem area too. The value class is stable and no
changes are made to it, but custom functions are added every now and then
and to produce the correct code we need to use them. So the translator
should also have a mechanism to understand and add the custom function and
where to use them.

 

Rule 3: NPI is optional when LNA is N, or when LNA is C and OTN is populated
and REQTYP is E and ACT is C, otherwise prohibited.

Coding

context :
/Request/lsr_order/rs/rs_servicedetailscontainer/rs_servicedetails[*]/NPI

assertion : absent()

condition : req1().equals("E") && act().equals("C") && 

( !value("../LNA").equals("N") && 

  ( !(value("../LNA").equals("C") && 

    present("../OTN") ) 

  ) 

)

 

Both assertion and condition can have multiple functions the combination of
which would return a Boolean value.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061028/a730d8fa/attachment.html 

From antlr at jazillian.com  Sat Oct 28 08:14:30 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Sat, 28 Oct 2006 11:14:30 -0400
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <20061028072322.29884.qmail@web55910.mail.re3.yahoo.com>
References: <20061028072322.29884.qmail@web55910.mail.re3.yahoo.com>
Message-ID: <454373D6.7020405@jazillian.com>

Loring Craymer wrote:

>Sheesh.  Can we please stop rehashing late 70's
>technology and get away from ignorance of modern
>rewrite systems?  A friend of mine--Ron Ayres--did one
>of the first such systems for his PhD thesis in the
>late '70's and subsequently used it as a core
>technology for Silicon Compilers and then for MOSIS. 
>Somewhere I have a copy of a paper from the early
>'80's advocating the use of iterative pattern matching
>for rewriting parse trees.  The current easily
>available pattern-matching transformation systems
>(rule-based) include TXL (http://www.txl.ca)and
>stratego
>(http://www.stratego-language.org/Stratego/WebHome). 
>Both are open source; the power and quirks of such
>systems are well documented.
>  
>
I didn't mean to imply that the little term-rewriting thing that I just 
did was
in any way new or innovative. And if my mentioning it makes you think
that I don't know about TXL and stratego, that's your call.

>I can understand why Andy found TXL unsatisfactory: 
>it is a pure interpreter, and that makes it unsuitable
>for producing a packaged product.  
>
That's not why I found TXL unsatisfactory. It's because I didn't see how it
would scale beyond the trivial examples in its documentation. But then 
again,
ANTLR often scales to do things that I didn't realize it could, so maybe 
it's
just me.

>Stratego generates
>C, but it requires doing at least a minimal literature
>search to find and is not so well-known as TXL.
>  
>

IIRC, I had the same problem with stratego as I did with TXL.

My problem with all these tools
(including ASTs in general and ANTLR treewalkers) is that while they
may be capable of a lot of things, they require far too much effort to
learn about all those abilities.

That's why I prefer Swing over VB. I prefer a well-designed library
where I can build something up using code, rather than a all-in-one
tool. Once you get a few basic ideas,
a nicely designed toolkit becomes easy and infinitely powerful. With
VB, you either know how to do what you want, or you don't. And if you
don't, it's tough to find out it can be done (and maybe it can't). I get the
same feeling with ANTLR and these other tools.

>There are innovative possibilities for using rewrite
>systems with ANTLR, and I would certainly be
>interested in hearing of anyone exploring them.  For
>that matter, I would be quite interested in hearing of
>anyone using TXL for working with ANTLR grammars. 
>However, I get tired of being told about the use of
>rule-based systems for simple HLL to HLL translations:
> there are some nice TXL examples of this already.
>  
>
That's fine, but not everyone is interested in just hearing about 
innovative stuff.
Some of us are interested in building real-world solutions to real-world 
problems.
That's nice that TXL exists to help me replace "a+0" with just "a". But 
it's sure
not obvious how it might help me with replacing goto's. In fact, I don't 
see how
it can even help me to know whether "a+0" really is the same as "a" when I
take operator overloading into account.

It's not always about science, sometimes it's about engineering, too.

And it's not about what works in theory, but what works in practice.
If I had taken the "what works in theory" approach, I'd have quickly 
seen that
translating C to Java is impossible in general and given up. Or, I'd 
have seen that
it's already been done (Ephedra) and given up. Instead, I chose to say 
"lots of
people are rewriting C code to Java...let's automate that process and 
save them
huge amounts of time and money".

Andy

>--Loring
>
>
> 
>____________________________________________________________________________________
>Get your email and see which of your friends are online - Right on the New Yahoo.com 
>(http://www.yahoo.com/preview) 
>
>  
>


From dieter_frej at gmx.net  Sun Oct 29 02:52:47 2006
From: dieter_frej at gmx.net (Dieter Frej)
Date: Sun, 29 Oct 2006 11:52:47 +0100
Subject: [antlr-interest] rewriting done in antlrworks
In-Reply-To: <06923200-D0F9-4527-9177-8F1A8612C6A5@cs.usfca.edu>
References: <453FC971.40107@gmx.net>	<BF439129-D4A7-4AAE-A0E8-6414F9C59159@cs.usfca.edu>	<4540E4A8.5010001@gmx.net>
	<06923200-D0F9-4527-9177-8F1A8612C6A5@cs.usfca.edu>
Message-ID: <454487FF.10704@gmx.net>

just for my time plan: is there time frame from your side to put in this
functionality? Or should I go ahead and build this stuff for myself?

Thanks

- Didi



Terence Parr wrote:
> 
> On Oct 26, 2006, at 9:39 AM, Dieter Frej wrote:
> 
>> ok, then I meant the parse tree ;-)
>>
>> How can I get hold of the record resp the parse tree? Can I use
>> antlrworks functionality for that or do I habe to implement that  myself?
> 
> 
> I plan on adding but just look at my parse tree creator (a debug  event 
> listener or something) in the Interpreter stuff in antlr  source.  
> Should show how to do it.
> 
> Ter
> 
> 


From foolishewe at hotmail.com  Sun Oct 29 02:18:12 2006
From: foolishewe at hotmail.com (Foolish Ewe)
Date: Sun, 29 Oct 2006 10:18:12 +0000
Subject: [antlr-interest] Rookie attempt at ANTLR 3 (Using ANTLRWORKS
	second correction attempt)
In-Reply-To: <20061026213523.0D9D31576@mail.intersystems.com>
Message-ID: <BAY107-F11EC68998D0FE251880B01C0FB0@phx.gbl>


Hello All:

Thanks for this hint, Jim.  I'm sorry for the delay, thanks for the rapid 
and detailed reply.

Regards:

Bill

>From: "Jim Idle" <jimi at intersystems.com>
>To: "Foolish Ewe" <foolishewe at hotmail.com>,<antlr-interest at antlr.org>
>Subject: RE: Rookie attempt at ANTLR 3 (Using ANTLRWORKS second correction 
>attempt)
>Date: Thu, 26 Oct 2006 17:35:37 -0400
>
>First ALPHANUMSTRING can end up matching nothing as it does not force any 
>character to be there, having a * rather than a +. I think that that is 
>probably your start rule issue.
>
>Next issue is that all your rules are the same thing. Your lexer only 
>recognizes ALPHANUMSTRING and so every rule is just str=ALPHANUMSTRING.
>
>Next, it is difficult to see exactly what your start rule is trying to 
>achieve but I guess you trying to get it to follow multiple lines and end 
>when you see end. I think that you can throw away the newline tokens unless 
>they end up being significant as you expand the grammar to cover the whole 
>language, which is certainly possible. But you need to formulate this such 
>that there is a rule that can match a valid construct, then use a higher 
>rule to say how this repeats. Try thinking out in words how you can 
>describe it (there you go Anthony ;-), such as a line of code is one 
>statement followed by any number of additional statements separated by a 
>semi-colon, then a NEWLINE. A statement block is any number of statements, 
>including zero, surrounded by {} etc. Once you can describe it to yourself 
>in English,
>
>However, I am afraid to say that I don't think that this approach is at all 
>correct; basically you are just telling the lexer to tokenize everything 
>that isn't a whitespace into one thing, then are trying to do all the 
>tokenizing in the parser, and not actually doing any parsing. You would be 
>better off, dare I say it, hand crafting such a beast ;-).
>
>All is not lost however, as ANTLR3 can handle your language I believe (but 
>then I believe it can be made to handle anything).
>
>I think that what you should do is lex the keywords, and provide a lex 
>rule, say IDORSTRING that matches anything that isn't a keyword. Then in 
>the parser, at the points you know you can have an non-delimited string, 
>match any possible token that can be a string (with suitable predicated 
>rules to avoid ambiguities where necessary) and interpret it as an 
>non-delimited string. Difficulties arise when an undelimited string is 
>optional and you have to lookahead and use predicates and stuff, but that's 
>what ANTLR is good at.
>
>Next, if your keywords can be: P PR PRI PRIN PRINT, then code the keyword, 
>accordingly, and distinguish it as a string back in the parser:
>
>PRINT: 'P' ( 'R' ( 'I' ( 'N' ( 'T')? )? )? )? ;
>
>Be careful about ambiguities here. Basically ANTLR will match the first 
>sequence listed (but you may end up with warnings and so on - you will need 
>to experiment).
>
>In order that you have an example of all this, I took the liberty of making 
>something close to your sample, that produces a tree (which is what you 
>want to do here, get your grammar/parser to produce an unambiguous and 
>correct tree, then write your action code to do whatever it is you want to 
>do with this in the tree parser)... that you might try to expand (tested 
>with ANTLRWorks 1.0b5):
>
>grammar TestMe;
>
>options
>{
>	output=AST;
>}
>
>tokens
>{
>	STRING;
>	CODEBLOCK;
>	CODELINE;
>	MONTH;
>}
>
>codeBlock
>	: (c+= codelines)+
>	  END
>
>	  -> ^(CODEBLOCK $c+)
>	;
>
>codelines
>	: m=month		-> ^(CODELINE ^(MONTH $m))
>	| PRINT s=string	-> ^(CODELINE ^(PRINT $s))
>	;
>
>string
>	: i=IDORSTRING			     	-> ^(STRING[$i.text] )
>	| (keyword_strings)=> k=keyword_strings -> ^(STRING[$k.text] )
>	;
>
>keyword_strings
>	: month
>	| PRINT
>	| END
>	;
>
>month	: JAN | FEB | MAR | APR | JUN | JUL | SEP | OCT | NOV | DEC ;
>
>JAN	:	'jan' ;
>FEB	:	'feb' ;
>MAR	:	'mar' ;
>APR	:	'apr' ;
>MAY	:	'may' ;
>JUN	:	'jun' ;
>JUL	:	'aug' ;
>SEP	:	'sep' ;
>OCT	:	'oct' ;
>NOV	:	'nov' ;
>DEC	:	'dec' ;
>
>END	:	'e' 'n' 'd'
>	;
>
>PRINT	:	'p' ( 'r' ( 'i' ( 'n' ( 't' )? )? )? )? ;
>
>IDORSTRING
>	: (ALPHA | DIGIT)+
>	;
>
>fragment DIGIT
>	:	('0'..'9')
>	;
>
>fragment ALPHA
>	:	('a'..'z')
>	;
>
>WS	: (' ' | '\t')+ {channel=99;}
>	;
>
>NEWLINE	: ('\r' '\n'? | '\n') { channel=99;}
>	;
>
>
>
>
>
>
>
>
>
>-----Original Message-----
>From: Foolish Ewe [mailto:foolishewe at hotmail.com]
>Sent: Thursday, October 26, 2006 11:43 AM
>To: Jim Idle; antlr-interest at antlr.org
>Subject: Rookie attempt at ANTLR 3 (Using ANTLRWORKS second correction 
>attempt)
>
>Hello All:
>
>I had a catastrophe during the edit of my previous attempt at a correction,
>so now I'm really groveling, please forgive me if you get a redundant 
>reply.
>I'm using ANTLR3 using ANTLRworks (which seems very nice so far) under
>Windows XP in case you are wondering. There should be a MIME attached
>ANTLR3 grammar to this message.
>
>When I try to compile TestGrammar.g (a MIME attached file), I get the
>following errors in the
>console tab in the bottom subwindow.  Although the prior posting omitted 
>the
>grammar
>(just as well, since I got to correct the java code in the @members
>section), there really
>was some code generating that message.
>[14:40:33] grammar TestGrammar: no start rule (no rule can obviously be
>followed by EOF)
>[14:40:33] [Long path omitted]TestGrammar.g:44:3: The following 
>alternatives
>are unreachable: 3
>
>Note that I'm trying this approach because I've got a strange language that
>I'm trying
>to scan which has "undelimited" strings (for historical reasons, this 
>wasn't
>my doing),
>so I sometimes would like to suppress key word recognition.  If I could 
>scan
>in the language
>properly, I think the parsing itself might not be too bad.
>
>If I comment out the first and second alternative, (so that startRule->end
>NEWLINE) then
>ANTLR will generate source but instead I get  (what seems to be) a Java 
>code
>generation error.
>
>13:06:08] [Long Path Snipped]\TestGrammar.java:78: illegal start of
>expression
>[13:06:08]         void endtoken = null;
>[13:06:08]         ^
>[13:06:08] 1 error
>
>Once again, sorry about cluttering up the mailing list with the prior
>malformed message,
>I hope this one is well formed.
>
>Thanks:
>
>Bill M.
>
> >From: "Jim Idle" <jimi at intersystems.com>
> >To: "Foolish Ewe" <foolishewe at hotmail.com>,<antlr-interest at antlr.org>
> >Subject: Re: [antlr-interest] Rookie attempt at ANTLR 3 (using
> >thecurrentANTLRWorks under Window XP)
> >Date: Wed, 25 Oct 2006 18:24:46 -0400
> >
> >Bill,
> >
> >Unless you have missed some of the grammar out from this post, it looks
> >to me like you don't actually have any rules in the grammar, only some
> >member functions? I would think that that you do really have some rules
> >but just have not posted them? ;-)
> >
> >If I take out the java code from your post, we are left with:
> >
> >// Test hoisting and use of predicates to allow us to use "undelimited
> >strings"
> >grammar TestGrammar;
> >
> >// I'm not using tokens in this langauge yet.
> >//tokens = { }
> >
> >
> >If this is really your grammar, then I would think it is pretty obvious
> >;-), that there is no rule for ANTLR to look for EOF in.
> >
> >Jim
> >
> >-----Original Message-----
> >From: antlr-interest-bounces at antlr.org
> >[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Foolish Ewe
> >Sent: Wednesday, October 25, 2006 1:30 PM
> >To: antlr-interest at antlr.org
> >Subject: [antlr-interest] Rookie attempt at ANTLR 3 (using the
> >currentANTLRWorks under Window XP)
> >
> >Hi Folks:
> >
> >I'm trying ANTLR 3 today, using ANTLRworks (so far it seems like Bovet
> >and
> >Parr have some
> >reallly neat stuff in there).
> >
> >I'm trying to compile the attached grammar in the tool and am getting a
> >message:
> >
> >Cannot generate the grammar because grammar TestGrammar : no start rule
> >(no
> >rule can
> >obviously be followed by EOF).
> >
> >This will probably out me to my coauthors and students, but I'm not a
> >big
> >fan of the words
> >obviously/easily or their variants :-).
> >
> >What does this message mean, how can I better convey to ANTLR that
> >startRule
> >is the start rule?
> >
> >Thanks:
> >
> >Bill M.
> >
> >_________________________________________________________________
> >Use your PC to make calls at very low rates
> >https://voiceoam.pcs.v2s.live.com/partnerredirect.aspx
> >
> >
> >--
> >No virus found in this incoming message.
> >Checked by AVG Free Edition.
> >Version: 7.1.408 / Virus Database: 268.13.11/496 - Release Date:
> >10/24/2006
> >
>
>_________________________________________________________________
>Stay in touch with old friends and meet new ones with Windows Live Spaces
>http://clk.atdmt.com/MSN/go/msnnkwsp0070000001msn/direct/01/?href=http://spaces.live.com/spacesapi.aspx?wx_action=create&wx_url=/friends.aspx&mkt=en-us
>
>--
>No virus found in this incoming message.
>Checked by AVG Free Edition.
>Version: 7.1.408 / Virus Database: 268.13.11/498 - Release Date: 10/26/2006
>
>
>
>--
>No virus found in this outgoing message.
>Checked by AVG Free Edition.
>Version: 7.1.408 / Virus Database: 268.13.11/498 - Release Date: 10/26/2006
>

_________________________________________________________________
Find a local pizza place, music store, museum and more?then map the best 
route!  http://local.live.com?FORM=MGA001


From rikmorgan at gmail.com  Sun Oct 29 04:15:47 2006
From: rikmorgan at gmail.com (Rick Morgan)
Date: Sun, 29 Oct 2006 05:15:47 -0700
Subject: [antlr-interest] Generated declaration?
Message-ID: <45449B73.4020105@gmail.com>

Hi, just discovered antlr 2 days ago, so pretty new at this... I'm 
trying to discover how actions I specify are placed in the generated 
code so I wrote the following inside a rule:
( cs:classSpec { initEntity( cs.getText() ); } )*

As expected, the generated code contained initEntity( cs.getText() );

Problem is there is no declaration of cs.  I could declare it myself 
somewhere if I new what type it was but I doubt that is the correct 
solution.  I ran this test using both the command line tool (java 
antlr.Tool verbTest.g) and using an Eclipse plugin, both do not generate 
a declaration for cs.

I reread the wiki entries for labels several times, but it doesn't go 
into these details.  I'm using antlr version 2.7.7rc1.

thanks for any advice,
Rick

From parrt at cs.usfca.edu  Sun Oct 29 07:36:59 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Sun, 29 Oct 2006 07:36:59 -0800
Subject: [antlr-interest] rewriting done in antlrworks
In-Reply-To: <454487FF.10704@gmx.net>
References: <453FC971.40107@gmx.net>	<BF439129-D4A7-4AAE-A0E8-6414F9C59159@cs.usfca.edu>	<4540E4A8.5010001@gmx.net>
	<06923200-D0F9-4527-9177-8F1A8612C6A5@cs.usfca.edu>
	<454487FF.10704@gmx.net>
Message-ID: <1ED05803-C5D6-42A5-94DF-C8F9DE8C455F@cs.usfca.edu>


On Oct 29, 2006, at 2:52 AM, Dieter Frej wrote:

> just for my time plan: is there time frame from your side to put in  
> this
> functionality? Or should I go ahead and build this stuff for myself?

Hi.  It's an easy change probably from the old ASTView so you might  
give it a try.  I won't get to it for a while.
Ter


From owen at backspaces.net  Sun Oct 29 13:38:21 2006
From: owen at backspaces.net (Owen Densmore)
Date: Sun, 29 Oct 2006 14:38:21 -0700
Subject: [antlr-interest] A Kinder, Gentler Java
Message-ID: <94137C2F-DF7E-4B69-BC57-55C60C701117@backspaces.net>

I'd like to build a preprocessor to create a much cleaner, less  
verbose version of Java. I'm not sure if ANTLR can do this for me ..  
sorta a preprocessor from a "java--" to java. If it can, PLEASE send  
along a few pointers to me, a newbie!

Here's the story:

I've been following the JVM "agile" languages: Groovy, JRuby, Jython.  
Although I've very much enjoyed using them, I've also been impressed  
with the improvements in Java itself, especially with Java 1.5.

Although I like the agile languages, it's my impression that just  
simplifying Java itself would be good enough for me. These three  
sites capture the sort of thing I'd like to achieve:
10 Reasons We Need Java 3.0
   http://www.onjava.com/lpt/a/2524
Shorter Syntax for Common Operations
   http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6389769\
   Here's a better formatted version:
   http://tinyurl.com/hc2ea
James Gosling: on the Java Road -- Scripting flamewar
(This also refers to the Shorter Syntax article above)
   http://blogs.sun.com/jag/entry/scripting_flamewar
They all address verbosity and warts in Java fairly nicely.

I'm convinced that a preprocessor could handle these, translating  
simplifications of Java into standard Java. I mean, how hard could it  
be to introduce raw strings and multi-line strings, right? Maybe  
something like python/groovy strings would do the trick. So:
   r"\n\r" -> "\\n\\r" in Java and
"""
This is a multi line string
with newlines.
"""
   ->
"This is a multi line string\n"+"with newlines.\n"

Reducing the verbosity of declarations should fairly reasonable:
Java:
   Foo<T> foo = new Foo<T>(a,b,c);
Simplified to:
   Foo<T> foo = new(a,b,c);
or
   foo := Foo<T>(a,b,c);

The biggest simplification I'm thinking about would be for one-method  
interfaces generally used an anonymous inner classes. [Google for  
Functor to see great examples. Closures also capture the idea.]
So in Java, you define a method in a class:
   ApplyExec(List<T>, Exec<T>);
.. that uses a simple interface:
   interface Exec<T> {
     void exec(T t);
   }
It would be called like this in Java:
   ApplyExec(myTList, new Exec<T>(){
       void exec(T t) {
         t.foo = t.bar + 7;
       }
   })
I'd prefer a very simple:
   ApplyExec(myTList,{t|t.foo = t.bar + 7})
Note that this captures the feel of a dynamic call, but it really is  
not, its a simple anonymous inner class shorthand. This would need  
either a name convention or a bit more information or both to work  
without building a fairly sophisticated parser. But still, you get  
the idea.

So is this something we could do easily in ANTLR??  If so, how!?

Thanks


From prashant.deva at gmail.com  Sun Oct 29 13:55:39 2006
From: prashant.deva at gmail.com (Prashant Deva)
Date: Sun, 29 Oct 2006 13:55:39 -0800
Subject: [antlr-interest] A Kinder, Gentler Java
In-Reply-To: <94137C2F-DF7E-4B69-BC57-55C60C701117@backspaces.net>
References: <94137C2F-DF7E-4B69-BC57-55C60C701117@backspaces.net>
Message-ID: <41fed8f80610291355p72757819o5cb6c4504de86f7f@mail.gmail.com>

Terence Parr, (author of antlr) is already working on his Mantra language
which translates to java and is pretty cool, so you might wish to talk to
him.


-- 
Prashant Deva
Creator, ANTLR Studio
Founder, Placid Systems, www.placidsystems.com

On 10/29/06, Owen Densmore <owen at backspaces.net> wrote:
>
> I'd like to build a preprocessor to create a much cleaner, less
> verbose version of Java. I'm not sure if ANTLR can do this for me ..
> sorta a preprocessor from a "java--" to java. If it can, PLEASE send
> along a few pointers to me, a newbie!
>
> Here's the story:
>
> I've been following the JVM "agile" languages: Groovy, JRuby, Jython.
> Although I've very much enjoyed using them, I've also been impressed
> with the improvements in Java itself, especially with Java 1.5.
>
> Although I like the agile languages, it's my impression that just
> simplifying Java itself would be good enough for me. These three
> sites capture the sort of thing I'd like to achieve:
> 10 Reasons We Need Java 3.0
>    http://www.onjava.com/lpt/a/2524
> Shorter Syntax for Common Operations
>    http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6389769\
>    Here's a better formatted version:
>    http://tinyurl.com/hc2ea
> James Gosling: on the Java Road -- Scripting flamewar
> (This also refers to the Shorter Syntax article above)
>    http://blogs.sun.com/jag/entry/scripting_flamewar
> They all address verbosity and warts in Java fairly nicely.
>
> I'm convinced that a preprocessor could handle these, translating
> simplifications of Java into standard Java. I mean, how hard could it
> be to introduce raw strings and multi-line strings, right? Maybe
> something like python/groovy strings would do the trick. So:
>    r"\n\r" -> "\\n\\r" in Java and
> """
> This is a multi line string
> with newlines.
> """
>    ->
> "This is a multi line string\n"+"with newlines.\n"
>
> Reducing the verbosity of declarations should fairly reasonable:
> Java:
>    Foo<T> foo = new Foo<T>(a,b,c);
> Simplified to:
>    Foo<T> foo = new(a,b,c);
> or
>    foo := Foo<T>(a,b,c);
>
> The biggest simplification I'm thinking about would be for one-method
> interfaces generally used an anonymous inner classes. [Google for
> Functor to see great examples. Closures also capture the idea.]
> So in Java, you define a method in a class:
>    ApplyExec(List<T>, Exec<T>);
> .. that uses a simple interface:
>    interface Exec<T> {
>      void exec(T t);
>    }
> It would be called like this in Java:
>    ApplyExec(myTList, new Exec<T>(){
>        void exec(T t) {
>          t.foo = t.bar + 7;
>        }
>    })
> I'd prefer a very simple:
>    ApplyExec(myTList,{t|t.foo = t.bar + 7})
> Note that this captures the feel of a dynamic call, but it really is
> not, its a simple anonymous inner class shorthand. This would need
> either a name convention or a bit more information or both to work
> without building a fairly sophisticated parser. But still, you get
> the idea.
>
> So is this something we could do easily in ANTLR??  If so, how!?
>
> Thanks
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061029/1b4bcb0d/attachment.html 

From joseph at iist.unu.edu  Sun Oct 29 20:58:07 2006
From: joseph at iist.unu.edu (Joseph)
Date: Mon, 30 Oct 2006 12:58:07 +0800 (CST)
Subject: [antlr-interest] [Fwd:  Can't find template]
Message-ID: <2155.125.31.29.122.1162184287.squirrel@webmail.iist.unu.edu>



---------------------------- Original Message ----------------------------
Subject: [antlr-interest] Can't find template
From:    "Joseph" <joseph at iist.unu.edu>
Date:    Sat, October 28, 2006 1:36 pm
To:      antlr-interest at antlr.org
--------------------------------------------------------------------------

Dear All,

I am a new user of ANTLR and String Template. I am developing a translator
and
using the example cminus as a starting point. I get the following error which
i cannot figure out why its there even when the "type_int" is specified in
the .stg file.

Could any one help me out.

Here is the error message:

joe at joe:~/utpcompiler/utp2pvs$ java -cp .:antlr-2.7.7.jar:stringtemplate.jar
UTP < test1.utp
Exception in thread "main" java.lang.IllegalArgumentException: Can't find
template type_int.st
        at
org.antlr.stringtemplate.StringTemplateGroup.lookupTemplate(StringTemplateGroup.java:485)
        at
org.antlr.stringtemplate.StringTemplateGroup.getInstanceOf(StringTemplateGroup.java:372)
        at
org.antlr.stringtemplate.StringTemplateGroup.getInstanceOf(StringTemplateGroup.java:384)
        at UTPParser.template(UTPParser.java:26)
        at UTPParser.typename(UTPParser.java:232)
        at UTPParser.vardecl(UTPParser.java:131)
        at UTPParser.declarationBlock(UTPParser.java:99)
        at UTPParser.utpspec(UTPParser.java:71)
        at UTP.main(UTP.java:20)

Here is the definition in the grammar.
*************************************************
typename returns [StringTemplate code=null]
    :   "int"  {code=template("type_int");}
    |   "nat"  {code=template("type_nat");}
    |   id:IDENT
        {
        code=template("type_user_def");
        code.setAttribute("name", id.getText());
        }
    ;
************************************************

Here is the definition the .stg

*************************************************
group Pvs;

utpspec(vars, commands) ::= <<
 <name> : THEORY
    BEGIN
	<vars>
	<commands>
>>

vardecl(name, typename) ::= "<name>, <name>' : VAR <type><\n>"
State: TYPE = "[<typename>,]"
IMPORTING UTPProg[State]
s : VAR State

globalVariable ::= vardecl

commandseq(typename,name,inits,cmds) ::= <<
 pre : pred[State] =
    ( LAMBDA s : s(<name>) =
    <inits>
    <cmds; separator="\n">
 END <name>
>>

type_int() ::= "int"

type_nat() ::= "nat"

type_user_def(name) ::= "<name>"

inits(typename, val) ::= "<typename> = <val>"
***********************************************

Thanks and best regards.

Joe.


************************************************
The United Nations University
International Institute for Software Technology,
P.O.Box 3058,
Casa Silva Mendes Est. do Engenheiro Trigo No. 4
Macau.
Tel: +853 5040415
Email: joseph at iist.unu.edu
URL: www.iist.unu.edu/~

From antlr at thewolery.demon.co.uk  Sun Oct 29 12:50:22 2006
From: antlr at thewolery.demon.co.uk (Anthony W. Youngman)
Date: Sun, 29 Oct 2006 20:50:22 +0000
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45421853.3080907@jazillian.com>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>
	<452D3180.2070907@jazillian.com>
	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>
	<45421853.3080907@jazillian.com>
Message-ID: <FpqzI4FOQRRFFw1a@thewolery.demon.co.uk>

In message <45421853.3080907 at jazillian.com>, Andy Tripp 
<antlr at jazillian.com> writes
>>> For the record, I had no trouble "getting" LISP when I learned it 25 
>>>years ago. When I started with C++, I don't think I
>>> really "got" OOD, and only started writing real OO code when 
>>>learning Java forced me to. I think the fact that LISP never
>>> became "mainstream" means that it failed to be easy enough to grasp. 
>>>Regardless of how inherently beautiful it is,
>>> if a lot of programmers don't easily "get it", then it's not that great.
>>
>>
>> The trouble is, the "average" programmer is just that, average.
>>
>> A great programmer can do the work of ten ordinary programmers. The 
>>trouble is, he probably does it with tools that are beyond the ability 
>>the ordinary programmer to "get".
>
>Just to be clear, I'm not saying I'm an "average" programmer or looking 
>for tools for the "average" programmer.
>I might be in the top 2% of all programmers, but I'm not in the top 
>0.1% of language-tools-gurus as Terence is.
>So I want tools that helps us good-programmers-but-not-compiler-gurus 
>build stuff.
>I'm not a Terence looking to automate my parser-creation task;
>I'm just an Andy looking to build a language translator while barely 
>knowing the difference between LL(*) and LL(k).

I think you've missed my point :-) "Regardless of how inherently 
beautiful it is, if a lot of programmers don't easily "get it", then 
it's not that great."

If it really *is* great, then the chances are the majority of 
programmers *can't* 'easily "get it" '.

I understand your problems with language translation - I still haven't 
got to grips with Java, and I'm struggling with Antlr, lexing/parsing 
etc. Thing is, you've got to learn the tools available to you. And if 
you're tackling something hard (it sounds like you are :-) then either 
(a) the task is beyond your abilities, or (b) the task is beyond your 
tools' abilities, or (c) the tools will be difficult and hard to learn.

You say you're probably in "the top 2% of programmers". In other words, 
if you think a tool "is great", the chances are that a lot (the 
majority?) of programmers WON'T easily get it - in fact - quite likely - 
CAN'T "get it" AT ALL!

So don't dismiss tools because they're hard to grasp. My brother thought 
Emacs was a user-friendly disaster-area until he really needed a 
power-editor. Then he realised how friendly it really was ...

Cheers,
Wol
-- 
Anthony W. Youngman - anthony at thewolery.demon.co.uk


From hou.bou at ge.com  Mon Oct 30 03:23:59 2006
From: hou.bou at ge.com (bou, hou (GE Money, consultant))
Date: Mon, 30 Oct 2006 20:23:59 +0900
Subject: [antlr-interest] Get class name in *.java use antlr-2.7.6
Message-ID: <1249495B7DE02945BFF50390D8C5750878A61A@OSAMLVEM02.e2k.ad.ge.com>

hello all:
Who can give me a sample to get all class names in java source file with using antlr.And can I get the type of class , which as main class , class or inner class.
<http://www.antlr.org/doc/getting-started.html>
I have read the doc , but don't really understand.
May be you had used antlr, help me. 
thank u. 


From antlr at jazillian.com  Mon Oct 30 06:12:27 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Mon, 30 Oct 2006 09:12:27 -0500
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <FpqzI4FOQRRFFw1a@thewolery.demon.co.uk>
References: <20061011023210.78533.qmail@web55902.mail.re3.yahoo.com>	<452D3180.2070907@jazillian.com>	<h5iGD6pWE1PFFwAa@thewolery.demon.co.uk>	<45421853.3080907@jazillian.com>
	<FpqzI4FOQRRFFw1a@thewolery.demon.co.uk>
Message-ID: <4546084B.1080607@jazillian.com>

Anthony W. Youngman wrote:

>
> I think you've missed my point :-) "Regardless of how inherently 
> beautiful it is, if a lot of programmers don't easily "get it", then 
> it's not that great."
>
> If it really *is* great, then the chances are the majority of 
> programmers *can't* 'easily "get it" '.

I disagree. Object Oriented Design is, and always was, great, for 
example. Yet it languished in Smalltalk80 for all those years, and didn't
even really catch on completely with C++, and only became mainstream 
with Java. I myself didn't really "get" OO,
even using C++, until Java came along. It took a mix of a great idea 
*and* a good implementation for OO to become mainstream.

>
> I understand your problems with language translation - I still haven't 
> got to grips with Java, and I'm struggling with Antlr, lexing/parsing 
> etc. Thing is, you've got to learn the tools available to you. And if 
> you're tackling something hard (it sounds like you are :-) then either 
> (a) the task is beyond your abilities, or (b) the task is beyond your 
> tools' abilities, or (c) the tools will be difficult and hard to learn.
>
> You say you're probably in "the top 2% of programmers". In other 
> words, if you think a tool "is great", the chances are that a lot (the 
> majority?) of programmers WON'T easily get it - in fact - quite likely 
> - CAN'T "get it" AT ALL!

I think a tool can be great while being simple enough for most 
programmers (e.g. Java).

>
> So don't dismiss tools because they're hard to grasp. My brother 
> thought Emacs was a user-friendly disaster-area until he really needed 
> a power-editor. Then he realised how friendly it really was ...

I'm not dismissing anything - just griping :)

I think Terence could make a huge leap forward by not thinking about 
ANTLR as "a tool to automate what
a guru would have written by hand", but rather "a tool that hides all 
the details of language manipulation, so that
most any programmer can do it". Most programmers use a compiler without 
ever knowing much more than
"it generates some lower-level code from my code". Similarly, it would 
be nice if most programmers working on
language transformation could use ANTLR without knowing much more than 
"it generates a lexer/parser from
my grammar".

>
>
> Cheers,
> Wol



From recoskie at ca.ibm.com  Mon Oct 30 06:32:39 2006
From: recoskie at ca.ibm.com (Chris Recoskie)
Date: Mon, 30 Oct 2006 09:32:39 -0500
Subject: [antlr-interest] Generated declaration?
In-Reply-To: <45449B73.4020105@gmail.com>
Message-ID: <OF8DC416B3.6438F66A-ON85257217.004F6DC6-85257217.004FDFD5@ca.ibm.com>

The type of cs depends on the return type of your classSpec rule.  If it
currently doesn't return anything then it's expected that ANTLR won't put a
declaration of your variable in there as there is nothing to store

===========================

Chris Recoskie
Team Lead, IBM CDT Team
IBM Toronto
http://www.eclipse.org/cdt



                                                                           
             Rick Morgan                                                   
             <rikmorgan at gmail.                                             
             com>                                                       To 
             Sent by:                  antlr-interest at antlr.org            
             antlr-interest-bo                                          cc 
             unces at antlr.org                                               
                                                                   Subject 
                                       [antlr-interest] Generated          
             29/10/2006 07:15          declaration?                        
             AM                                                            
                                                                           
                                                                           
             Please respond to                                             
             rikmorgan at gmail.c                                             
                    om                                                     
                                                                           
                                                                           




Hi, just discovered antlr 2 days ago, so pretty new at this... I'm
trying to discover how actions I specify are placed in the generated
code so I wrote the following inside a rule:
( cs:classSpec { initEntity( cs.getText() ); } )*

As expected, the generated code contained initEntity( cs.getText() );

Problem is there is no declaration of cs.  I could declare it myself
somewhere if I new what type it was but I doubt that is the correct
solution.  I ran this test using both the command line tool (java
antlr.Tool verbTest.g) and using an Eclipse plugin, both do not generate
a declaration for cs.

I reread the wiki entries for labels several times, but it doesn't go
into these details.  I'm using antlr version 2.7.7rc1.

thanks for any advice,
Rick



From r.morgan at verizonbusiness.com  Mon Oct 30 08:27:22 2006
From: r.morgan at verizonbusiness.com (Rick Morgan)
Date: Mon, 30 Oct 2006 09:27:22 -0700
Subject: [antlr-interest] Generated declaration?
In-Reply-To: <mailman.1677.1162218795.15912.antlr-interest@antlr.org>
Message-ID: <000201c6fc40$474ddef0$c28522a6@mcilink.com>

That sorta works because if I put a "returns [int cs]" on the rule, then
I get a declaration "int cs;" in the output.  But reading wiki examples, I
came away with the impression that when I put a label, say cs, on something,
then the method getText() becomes available for the variable cs.  For the
generated code to actually compile however, and using your suggestion, I
would have to know the internals of antlr so I can put a proper "returns
[xxx cs]" on whatever rule needs it.  Am I really expected to delve into the
internals of antlr to figure out what the node types are?

Maybe there's a disconnect between what I'm trying to do and a proper usage
of antlr.  I'm not trying to build an AST that I can later walk... I'm
working on a testing framework that needs to recognize a certain language
and fire off actions as the input is  recognized.  Seems like ANTLR could do
that, no?

By the way, I didn't say this earlier, but my target language is c++, and
the action I put in wasn't valid c++ code but that's easily fixed once I see
a valid "cs" declaration somewhere.

thanks,
Rick

>The type of cs depends on the return type of your classSpec rule.  If it
>currently doesn't return anything then it's expected that ANTLR won't put a
>declaration of your variable in there as there is nothing to store

>>Hi, just discovered antlr 2 days ago, so pretty new at this... I'm
>>trying to discover how actions I specify are placed in the generated
>>code so I wrote the following inside a rule:
>>( cs:classSpec { initEntity( cs.getText() ); } )*

>>As expected, the generated code contained initEntity( cs.getText() );

>>Problem is there is no declaration of cs.  I could declare it myself
>>somewhere if I new what type it was but I doubt that is the correct
>>solution.  I ran this test using both the command line tool (java
>>antlr.Tool verbTest.g) and using an Eclipse plugin, both do not generate
>>a declaration for cs.

>>I reread the wiki entries for labels several times, but it doesn't go
>>into these details.  I'm using antlr version 2.7.7rc1.




From open.zone at virgin.net  Mon Oct 30 08:52:38 2006
From: open.zone at virgin.net (Micheal J)
Date: Mon, 30 Oct 2006 16:52:38 -0000
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <4546084B.1080607@jazillian.com>
Message-ID: <00e201c6fc43$cf91e010$c704a8c0@hercules>

Hi,

> Anthony W. Youngman wrote:
> 
> >
> > I think you've missed my point :-) "Regardless of how inherently
> > beautiful it is, if a lot of programmers don't easily "get 
> it", then 
> > it's not that great."
> >
> > If it really *is* great, then the chances are the majority of
> > programmers *can't* 'easily "get it" '.
> 
> I disagree. Object Oriented Design is, and always was, great, for 
> example. Yet it languished in Smalltalk80 for all those 
> years, and didn't even really catch on completely with C++, 
> and only became mainstream 
> with Java. I myself didn't really "get" OO,
> even using C++, until Java came along. It took a mix of a great idea 
> *and* a good implementation for OO to become mainstream.

Many would argue that Java is a limited implementation of OO principles as
pioneered in LISP et al and later Smalltalk. Everything inherits from
System.Object is plain ugly and, no multiple inheritance?. AOD (AspectJ and
cousins) can be viewed as a series of hacks to try and simulate some of the
important OO bits that were thrown out to make Java.

So, I'm tending to agree with Anthony here. Great tools often require
in-depth domain expertise that the majority simply don't have.

> > You say you're probably in "the top 2% of programmers". In other
> > words, if you think a tool "is great", the chances are that 
> a lot (the 
> > majority?) of programmers WON'T easily get it - in fact - 
> quite likely 
> > - CAN'T "get it" AT ALL!
> 
> I think a tool can be great while being simple enough for most 
> programmers (e.g. Java).

Not without limiting it's power.

> > So don't dismiss tools because they're hard to grasp. My brother
> > thought Emacs was a user-friendly disaster-area until he 
> really needed 
> > a power-editor. Then he realised how friendly it really was ...
> 
> I'm not dismissing anything - just griping :)
> 
> I think Terence could make a huge leap forward by not thinking about 
> ANTLR as "a tool to automate what
> a guru would have written by hand", but rather "a tool that hides all 
> the details of language manipulation, so that
> most any programmer can do it".

Don't think so. My point about domain expertise is relevant here. Joe
Average just can't start developing language recognition tools with an
appreciation of the theory that underlies that subject area.

> Most programmers use a 
> compiler without 
> ever knowing much more than
> "it generates some lower-level code from my code". Similarly, 
> it would 
> be nice if most programmers working on
> language transformation could use ANTLR without knowing much 
> more than 
> "it generates a lexer/parser from
> my grammar".

The analogy isn't quite apples-to-apples. Programmers using a compiler [for
a programming language like C/C++] have to understand the syntax and
semantics of the language the compiler recognises. Plus the rules for using
other related tools such as linkers, loaders etc. True, an IDE and the OS
can hide much of that these days but they still exist. 

Similarly with ANTLR. ANTLR users have to understand the syntax and
semantics of the grammars they develop. ANTLR projects involve *two*
languages - ANTLR's grammar language and a general purpose programming
language such as Java/C/C#/ObjC etc.

Beyond that, it's the same user experience: "I feed in some code and this
tool (compiler or ANTLR) generates a whole lotta stuff I don't need to
understand".

Micheal


From lgcraymer at yahoo.com  Mon Oct 30 09:51:23 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Mon, 30 Oct 2006 09:51:23 -0800 (PST)
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <FpqzI4FOQRRFFw1a@thewolery.demon.co.uk>
Message-ID: <20061030175123.35570.qmail@web55905.mail.re3.yahoo.com>

Wol--

To your list, I would add d.) tools exist to do the
job, but you have to do some research and thinking to
gain the understanding to use them.  And I would
probably put it towards the top of the list. 
Knowledge is what separates the master from the herd,
and hard problems are usually solved by up front
analysis to define both the skills needed for the
solution and the design approach to be taken.

--Loring


--- "Anthony W. Youngman"
<antlr at thewolery.demon.co.uk> wrote:

> In message <45421853.3080907 at jazillian.com>, Andy
> Tripp 
> <antlr at jazillian.com> writes
> >>> For the record, I had no trouble "getting" LISP
> when I learned it 25 
> >>>years ago. When I started with C++, I don't think
> I
> >>> really "got" OOD, and only started writing real
> OO code when 
> >>>learning Java forced me to. I think the fact that
> LISP never
> >>> became "mainstream" means that it failed to be
> easy enough to grasp. 
> >>>Regardless of how inherently beautiful it is,
> >>> if a lot of programmers don't easily "get it",
> then it's not that great.
> >>
> >>
> >> The trouble is, the "average" programmer is just
> that, average.
> >>
> >> A great programmer can do the work of ten
> ordinary programmers. The 
> >>trouble is, he probably does it with tools that
> are beyond the ability 
> >>the ordinary programmer to "get".
> >
> >Just to be clear, I'm not saying I'm an "average"
> programmer or looking 
> >for tools for the "average" programmer.
> >I might be in the top 2% of all programmers, but
> I'm not in the top 
> >0.1% of language-tools-gurus as Terence is.
> >So I want tools that helps us
> good-programmers-but-not-compiler-gurus 
> >build stuff.
> >I'm not a Terence looking to automate my
> parser-creation task;
> >I'm just an Andy looking to build a language
> translator while barely 
> >knowing the difference between LL(*) and LL(k).
> 
> I think you've missed my point :-) "Regardless of
> how inherently 
> beautiful it is, if a lot of programmers don't
> easily "get it", then 
> it's not that great."
> 
> If it really *is* great, then the chances are the
> majority of 
> programmers *can't* 'easily "get it" '.
> 
> I understand your problems with language translation
> - I still haven't 
> got to grips with Java, and I'm struggling with
> Antlr, lexing/parsing 
> etc. Thing is, you've got to learn the tools
> available to you. And if 
> you're tackling something hard (it sounds like you
> are :-) then either 
> (a) the task is beyond your abilities, or (b) the
> task is beyond your 
> tools' abilities, or (c) the tools will be difficult
> and hard to learn.
> 
> You say you're probably in "the top 2% of
> programmers". In other words, 
> if you think a tool "is great", the chances are that
> a lot (the 
> majority?) of programmers WON'T easily get it - in
> fact - quite likely - 
> CAN'T "get it" AT ALL!
> 
> So don't dismiss tools because they're hard to
> grasp. My brother thought 
> Emacs was a user-friendly disaster-area until he
> really needed a 
> power-editor. Then he realised how friendly it
> really was ...
> 
> Cheers,
> Wol
> -- 
> Anthony W. Youngman - anthony at thewolery.demon.co.uk
> 
> 



 
____________________________________________________________________________________
Want to start your own business? Learn how on Yahoo! Small Business 
(http://smallbusiness.yahoo.com) 


From parrt at cs.usfca.edu  Mon Oct 30 11:18:16 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 30 Oct 2006 11:18:16 -0800
Subject: [antlr-interest] [Fwd:  Can't find template]
In-Reply-To: <2155.125.31.29.122.1162184287.squirrel@webmail.iist.unu.edu>
References: <2155.125.31.29.122.1162184287.squirrel@webmail.iist.unu.edu>
Message-ID: <34B33916-8EFF-4D03-B46F-177462128932@cs.usfca.edu>


On Oct 29, 2006, at 8:58 PM, Joseph wrote:
> Dear All,
>
> I am a new user of ANTLR and String Template. I am developing a  
> translator
> and
> using the example cminus as a starting point. I get the following  
> error which
> i cannot figure out why its there even when the "type_int" is  
> specified in
> the .stg file.

It is looking for type_int in a file, which probably means you made a  
group that did not read from a group file.

Ter

From jimi at intersystems.com  Mon Oct 30 11:49:39 2006
From: jimi at intersystems.com (Jim Idle)
Date: Mon, 30 Oct 2006 14:49:39 -0500
Subject: [antlr-interest] ANTLR 3.0b4 code generation question
In-Reply-To: <BAY107-F1470656C192A96BEDC27A3C0050@phx.gbl>
Message-ID: <20061030194940.776551602@mail.intersystems.com>

You are assigning the value of a rule return (command) to a label, but your parser is not producing a tree (in which case the return value is the tree) and your rule is not returning anything (returns clause). The return type of command is therefore void and you get the code you see. 

Admittedly, ANTLR should point this out to you, but I believe such things are being deferred until the point where the ANTLR3 grammar parser is written in ANTLR3.

Jim

-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Foolish Ewe
Sent: Friday, October 27, 2006 6:10 PM
To: antlr-interest at antlr.org
Subject: [antlr-interest] ANTLR 3.0b4 code generation question

Hello All:

Thanks for the wonderful hints so far.  I've noticed some unusual java code 
generated
under ANTLR3, and I'm wondering if it is a cockpit error or if I might be 
tickling an ANTLR3 bug.

The MIME attached smalltest.g using my recently downloaded version of 
ANTLRworks creates
the following line in the parser:
       void c = null;

Is this correct Java, or did I do something wrong to cause this?

Regards:

Bill Maniatty

_________________________________________________________________
All-in-one security and maintenance for your PC.  Get a free 90-day trial! 
http://clk.atdmt.com/MSN/go/msnnkwlo0050000002msn/direct/01/?href=http://www.windowsonecare.com/?sc_cid=msn_hotmail

-- 
No virus found in this incoming message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.17/505 - Release Date: 10/27/2006
 
  

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.408 / Virus Database: 268.13.17/505 - Release Date: 10/27/2006
 

From rob.hill at blueyonder.co.uk  Mon Oct 30 12:22:46 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Mon, 30 Oct 2006 20:22:46 -0000
Subject: [antlr-interest] disabling portions of a rule?
Message-ID: <20061030202258.8A97F190759@www.antlr.org>

Hi all, 
I Have a rule like this

exampleRule
@init {
	Symbol s = null;
}
	: ^(MAP Identifier { s = Symbol.Resolve($Identifier.text);
				if (s==null) 
					ShowError();
			}
		({s==null}? Subrule[s]);
	)

So , basically if the identifier isn't in the symbol table we don't call the
subrule. The predicate does the job but when a symbol isn't found I get a
whole bunch of errors about mismatched tree nodes.. - how do I either

a) exit the rule early without displaying the antlr errors, or
b) consume the tokens that follow even though I cant call the subrule to get
rid of them?

The subrule assumes it will always be passed a valid symbol, and has quite a
few alts in it, so I don't want to add a if (s!=null) before all of the code
in the subrule.
I'd like to prevent antlr from showing its mismatched tree errors, whilst
preferably not exiting with a null pointer exception  from within the
subrule...

Whats the neat/preferable way of handling this?
Cheers!

Rob

	



From parrt at cs.usfca.edu  Mon Oct 30 13:01:35 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Mon, 30 Oct 2006 13:01:35 -0800
Subject: [antlr-interest] What if you want errors to exit the parser? (v3)
Message-ID: <8E99F8BC-BB90-44E6-B5CF-C585B84038FD@cs.usfca.edu>

currently, you can specify what to do upon exception.

@rulecatch {
catch (RecognitionException e) {
         throw e;
}
}
will change the default code generated at the end of each rule's  
method that reports and recovers:

catch (RecognitionException re) {
         reportError(re);
         recover(input,re);
}

but, it tries to recover from token mismatches by insertion/ 
deletion....do we need an option afterall to tell ANTLR to let errors  
cause exceptions in middle of alts?

Ter

From rob.hill at blueyonder.co.uk  Mon Oct 30 13:24:59 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Mon, 30 Oct 2006 21:24:59 -0000
Subject: [antlr-interest] What if you want errors to exit the parser?
	(v3)
In-Reply-To: <8E99F8BC-BB90-44E6-B5CF-C585B84038FD@cs.usfca.edu>
Message-ID: <20061030212505.B38FC190736@www.antlr.org>

Thanks Ter, that's sorted it, I added a specific clause for the failed
predicate exception, although the recognition exception catch also caught
that too.. I assume its derived.
Anyhoo, its sorted :)

Cheers!

Rob


> -----Original Message-----
> From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-
> bounces at antlr.org] On Behalf Of Terence Parr
> Sent: 30 October 2006 21:02
> To: ANTLR Interest
> Subject: [antlr-interest] What if you want errors to exit the parser? (v3)
> 
> currently, you can specify what to do upon exception.
> 
> @rulecatch {
> catch (RecognitionException e) {
>          throw e;
> }
> }
> will change the default code generated at the end of each rule's
> method that reports and recovers:
> 
> catch (RecognitionException re) {
>          reportError(re);
>          recover(input,re);
> }
> 
> but, it tries to recover from token mismatches by insertion/
> deletion....do we need an option afterall to tell ANTLR to let errors
> cause exceptions in middle of alts?
> 
> Ter



From rob.hill at blueyonder.co.uk  Mon Oct 30 13:26:45 2006
From: rob.hill at blueyonder.co.uk (Robert Hill)
Date: Mon, 30 Oct 2006 21:26:45 -0000
Subject: [antlr-interest] What if you want errors to exit the parser?
	(v3)
In-Reply-To: <8E99F8BC-BB90-44E6-B5CF-C585B84038FD@cs.usfca.edu>
Message-ID: <20061030212649.1A4F419073A@www.antlr.org>

Forgot this bit..


[snip]

> 
> but, it tries to recover from token mismatches by insertion/
> deletion....do we need an option afterall to tell ANTLR to let errors
> cause exceptions in middle of alts?
> 
> Ter

In my case it would be a bit neater, and I could see me wanting to catch
various exceptions on a per rule basis. The @rulecatch seems a bit like
using a chainsaw when a pen knife would do ;)

Cheers!

Rob
 




From lgcraymer at yahoo.com  Mon Oct 30 18:11:37 2006
From: lgcraymer at yahoo.com (Loring Craymer)
Date: Mon, 30 Oct 2006 18:11:37 -0800 (PST)
Subject: [antlr-interest] disabling portions of a rule?
In-Reply-To: <20061030202258.8A97F190759@www.antlr.org>
Message-ID: <20061031021137.35491.qmail@web55912.mail.re3.yahoo.com>

ANTLR 3 does an inorder traversal of the tree being
walked; shortcuts are not supported.  This is
different from ANTLR 2, where you could match a node
and then ignore its children (and siblings).  The big
gain for the inorder traversal is that you can support
k>1 for tree walkers.  A secondary benefit is that you
get strong checking of tree structure, but that is
counterbalanced by the inability to do shortcutting. 
[I consider this a gain, but I start with automtically
generated tree grammars.]

The best you can do right now is to have two versions
of the subrule--one with actions and one without--and
use the sempred to pick which one to use.

--Loring

--- Robert Hill <rob.hill at blueyonder.co.uk> wrote:

> Hi all, 
> I Have a rule like this
> 
> exampleRule
> @init {
> 	Symbol s = null;
> }
> 	: ^(MAP Identifier { s =
> Symbol.Resolve($Identifier.text);
> 				if (s==null) 
> 					ShowError();
> 			}
> 		({s==null}? Subrule[s]);
> 	)
> 
> So , basically if the identifier isn't in the symbol
> table we don't call the
> subrule. The predicate does the job but when a
> symbol isn't found I get a
> whole bunch of errors about mismatched tree nodes..
> - how do I either
> 
> a) exit the rule early without displaying the antlr
> errors, or
> b) consume the tokens that follow even though I cant
> call the subrule to get
> rid of them?
> 
> The subrule assumes it will always be passed a valid
> symbol, and has quite a
> few alts in it, so I don't want to add a if
> (s!=null) before all of the code
> in the subrule.
> I'd like to prevent antlr from showing its
> mismatched tree errors, whilst
> preferably not exiting with a null pointer exception
>  from within the
> subrule...
> 
> Whats the neat/preferable way of handling this?
> Cheers!
> 
> Rob
> 
> 	
> 
> 
> 



 
____________________________________________________________________________________
Cheap Talk? Check out Yahoo! Messenger's low PC-to-Phone call rates 
(http://voice.yahoo.com)


From rhill03 at eds.com  Mon Oct 30 23:13:50 2006
From: rhill03 at eds.com (Hill, Robert)
Date: Tue, 31 Oct 2006 07:13:50 -0000
Subject: [antlr-interest] disabling portions of a rule?
In-Reply-To: <20061031021137.35491.qmail@web55912.mail.re3.yahoo.com>
Message-ID: <2E909902FD3A03419E3A905908AE3DD402862C44@UKNSM201.emea.corp.eds.com>

Thanks Loring, I've already gone with the re-throwing of the
failedPredicate Exception, its not really nescessary that I continue,
since the problem with the parsed file is a fatal error at this point
anyway. I didn't think about using a predicate for 2 rules, one being
empty - neat another tool to remember!.

I see now why we cant skip nodes(I'd used that in V2 so wondered why,
but have been too busy using it to pay attention as to the reasons why
:) )
Thanks for the explanation, it all makes sense now! 

Cheers!
Rob

Robert Hill
Information Engineer
EDS	UKIMEA DWP ACU, Hallamshire Business Park, 100 Napier St,
Sheffield. S11 8HD
email:	rhill03 at eds.com
Office:	+44 114 291 1928
Mobile:	+44 7903 185 516

 

>-----Original Message-----
>From: antlr-interest-bounces at antlr.org 
>[mailto:antlr-interest-bounces at antlr.org] On Behalf Of Loring Craymer
>Sent: 31 October 2006 02:12
>To: Robert Hill; 'ANTLR Interest'
>Subject: Re: [antlr-interest] disabling portions of a rule?
>
>ANTLR 3 does an inorder traversal of the tree being walked; 
>shortcuts are not supported.  This is different from ANTLR 2, 
>where you could match a node and then ignore its children (and 
>siblings).  The big gain for the inorder traversal is that you 
>can support
>k>1 for tree walkers.  A secondary benefit is that you
>get strong checking of tree structure, but that is 
>counterbalanced by the inability to do shortcutting. 
>[I consider this a gain, but I start with automtically 
>generated tree grammars.]
>
>The best you can do right now is to have two versions of the 
>subrule--one with actions and one without--and use the sempred 
>to pick which one to use.
>
>--Loring
>
>--- Robert Hill <rob.hill at blueyonder.co.uk> wrote:
>
>> Hi all,
>> I Have a rule like this
>> 
>> exampleRule
>> @init {
>> 	Symbol s = null;
>> }
>> 	: ^(MAP Identifier { s =
>> Symbol.Resolve($Identifier.text);
>> 				if (s==null) 
>> 					ShowError();
>> 			}
>> 		({s==null}? Subrule[s]);
>> 	)
>> 
>> So , basically if the identifier isn't in the symbol table we don't 
>> call the subrule. The predicate does the job but when a symbol isn't 
>> found I get a whole bunch of errors about mismatched tree nodes..
>> - how do I either
>> 
>> a) exit the rule early without displaying the antlr errors, or
>> b) consume the tokens that follow even though I cant call 
>the subrule 
>> to get rid of them?
>> 
>> The subrule assumes it will always be passed a valid symbol, and has 
>> quite a few alts in it, so I don't want to add a if
>> (s!=null) before all of the code
>> in the subrule.
>> I'd like to prevent antlr from showing its mismatched tree errors, 
>> whilst preferably not exiting with a null pointer exception  from 
>> within the subrule...
>> 
>> Whats the neat/preferable way of handling this?
>> Cheers!
>> 
>> Rob
>> 
>> 	
>> 
>> 
>> 
>
>
>
> 
>_______________________________________________________________
>_____________________
>Cheap Talk? Check out Yahoo! Messenger's low PC-to-Phone call rates
>(http://voice.yahoo.com)
>
>

From Gerz at fgan.de  Tue Oct 31 04:41:51 2006
From: Gerz at fgan.de (Gerz, Michael)
Date: Tue, 31 Oct 2006 13:41:51 +0100
Subject: [antlr-interest] Capturing lexer exceptions
Message-ID: <EF2ED99C54B0FD4188B64423658925EDAA775A@mailserv.lorien.fkie.fgan.de>

Terence,

I am sorry for bothering you again but my project team is still struggling with ANTLR's clever error recovery. 

Our problem is that we don't want ANTLR to do any error handling at all. This includes errors thrown by the lexer. My colleague didn't find a way to make her ANTLR parser _not_ to catch lexer exceptions.

Unfortunately, the ANTLR 3 wiki (http://www.antlr.org/wiki/display/ANTLR3/Migrating+from+ANTLR+2+to+ANTLR+3) doesn't answer the question how to ignore lexer exceptions (and you can no longer set "defaultErrorHandler=false").

Terence, could you please speak to us?

A thousand thanks in advance,

Michael

************************************************************************
Dr. Michael Gerz                                                        
FGAN e.V.                                      Phone:  +49 228 9435-414 
Department FKIE/ITF                            Fax:    +49 228 9435-685 
Neuenahrer Stra?e 20                           E-Mail: gerz at fgan.de     
53343 Wachtberg-Werthhoven                     WWW:    www.fgan.de     

From Gerz at fgan.de  Tue Oct 31 04:48:36 2006
From: Gerz at fgan.de (Gerz, Michael)
Date: Tue, 31 Oct 2006 13:48:36 +0100
Subject: [antlr-interest] ANTLR-generated code & Findbugs
Message-ID: <EF2ED99C54B0FD4188B64423658925EDBE1D68@mailserv.lorien.fkie.fgan.de>

Hello,

Findbugs (http://findbugs.sf.net; see also http://fb-contrib.sf.net) is a very popular and powerful static analysis tool that helps to identify bugs in Java code.

One of my colleagues reported that the parser code generated by ANTLR triggers many findbugs warnings. Do you have any plans to address those warnings? Of course, automatically generated code is not meant for human inspection but OTOH: the less warnings, the better :-)

It would also be a very nice exercise to apply findbugs to ANTLR and ist runtime library itself. You will be surprised by its output, no doubt!

Regards, 

Michael 

************************************************************************
Dr. Michael Gerz                                                        
FGAN e.V.                                      Phone:  +49 228 9435-414 
Department FKIE/ITF                            Fax:    +49 228 9435-685 
Neuenahrer Stra?e 20                           E-Mail: gerz at fgan.de     
53343 Wachtberg-Werthhoven                     WWW:    www.fgan.de     

From kroepke at classdump.org  Tue Oct 31 06:10:27 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Tue, 31 Oct 2006 15:10:27 +0100
Subject: [antlr-interest] ANTLR-generated code & Findbugs
In-Reply-To: <EF2ED99C54B0FD4188B64423658925EDBE1D68@mailserv.lorien.fkie.fgan.de>
References: <EF2ED99C54B0FD4188B64423658925EDBE1D68@mailserv.lorien.fkie.fgan.de>
Message-ID: <092B6BFC-F6AC-492C-A33F-183839BE9683@classdump.org>

Hi Michael!

On 31. Oct 2006, at 13:48 , Gerz, Michael wrote:

> Findbugs (http://findbugs.sf.net; see also http://fb- 
> contrib.sf.net) is a very popular and powerful static analysis tool  
> that helps to identify bugs in Java code.

Haven't seen that one, I will take a closer look at that tonight :)

> One of my colleagues reported that the parser code generated by  
> ANTLR triggers many findbugs warnings. Do you have any plans to  
> address those warnings? Of course, automatically generated code is  
> not meant for human inspection but OTOH: the less warnings, the  
> better :-)

I have brought up the matter with Terence and others on the antlr-dev  
list. The most irritating thing for me is the fact that there are so  
many unused variables and lists. For me in Objective-C it's a more a  
performance issue, though I'd like to get rid of the warnings, too.  
It's easy to get a couple hundred warnings from a moderately large  
grammar. Irritating at times. This, however, will be quite difficult  
to do and AFAIK is not on the short-term todo list. IMHO it's more  
important to fix some outstanding issues first. Of course I cannot  
speak for Terence here, it's simply my personal opinion.

> It would also be a very nice exercise to apply findbugs to ANTLR  
> and ist runtime library itself. You will be surprised by its  
> output, no doubt!

I will try it tonight and see what shows up. Might be a very nice way  
to further improve the quality of the core code. Always good to know  
thy tools :)

Thanks for the pointer!

cheers,
-k

P.S.: Everything I mentioned applies to ANTLR v3, not 2.7.x which I'm  
not using anymore.


From antlr at jazillian.com  Tue Oct 31 06:29:20 2006
From: antlr at jazillian.com (Andy Tripp)
Date: Tue, 31 Oct 2006 09:29:20 -0500
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <00e201c6fc43$cf91e010$c704a8c0@hercules>
References: <00e201c6fc43$cf91e010$c704a8c0@hercules>
Message-ID: <45475DC0.9070206@jazillian.com>

Micheal J wrote:

> [snip]
>
>Many would argue that Java is a limited implementation of OO principles as
>pioneered in LISP et al and later Smalltalk. Everything inherits from
>System.Object is plain ugly and, no multiple inheritance?. AOD (AspectJ and
>cousins) can be viewed as a series of hacks to try and simulate some of the
>important OO bits that were thrown out to make Java.
>  
>
I view Java's decision to do a "limited implementation" by avoiding 
things like multiple inheritance
as exactly what made it successful. By avoiding being "completely pure", 
Java is accessible
to average programmers. And that's why Java is popular and Smalltalk and 
LISP are not.
It's also why people prefer Java over C++.

>So, I'm tending to agree with Anthony here. Great tools often require
>in-depth domain expertise that the majority simply don't have.
>  
>
Sometimes they do, but sometimes they don't. Compilers never require 
in-depth
domain expertise. I know almost nothing about byte-code generation, yet 
I use javac
every minute or two. I think the world would benefit from an ANTLR tool 
that was like that.

>  
>
>>>You say you're probably in "the top 2% of programmers". In other
>>>words, if you think a tool "is great", the chances are that 
>>>      
>>>
>>a lot (the 
>>    
>>
>>>majority?) of programmers WON'T easily get it - in fact - 
>>>      
>>>
>>quite likely 
>>    
>>
>>>- CAN'T "get it" AT ALL!
>>>      
>>>
>>I think a tool can be great while being simple enough for most 
>>programmers (e.g. Java).
>>    
>>
>
>Not without limiting it's power.
>  
>
Yes, just as Java's power is "limited" by not supporting MI, pointers, etc.
I love to have my power "limited" by not giving me lots of rope to hang 
myself with.
And so do most people, judging by the popularity of Java over C++ and 
every high-level
language over assembly.

>  
>
>>>So don't dismiss tools because they're hard to grasp. My brother
>>>thought Emacs was a user-friendly disaster-area until he 
>>>      
>>>
>>really needed 
>>    
>>
>>>a power-editor. Then he realised how friendly it really was ...
>>>      
>>>
>>I'm not dismissing anything - just griping :)
>>
>>I think Terence could make a huge leap forward by not thinking about 
>>ANTLR as "a tool to automate what
>>a guru would have written by hand", but rather "a tool that hides all 
>>the details of language manipulation, so that
>>most any programmer can do it".
>>    
>>
>
>Don't think so. My point about domain expertise is relevant here. Joe
>Average just can't start developing language recognition tools with an
>appreciation of the theory that underlies that subject area.
>  
>
Sure he could. Joe average could easily write:
a + b --> a.add(b)
and have his tool do the rest (and maybe warn him about cases that might 
match that he hadn't
thought about).

I've had a programmer working with me for a few months now, and he's had 
no trouble writing
translation rules without every learning ANTLR grammar or knowing 
anything about language
recognition tools.

>  
>
>>Most programmers use a 
>>compiler without 
>>ever knowing much more than
>>"it generates some lower-level code from my code". Similarly, 
>>it would 
>>be nice if most programmers working on
>>language transformation could use ANTLR without knowing much 
>>more than 
>>"it generates a lexer/parser from
>>my grammar".
>>    
>>
>
>The analogy isn't quite apples-to-apples. Programmers using a compiler [for
>a programming language like C/C++] have to understand the syntax and
>semantics of the language the compiler recognises. Plus the rules for using
>other related tools such as linkers, loaders etc. True, an IDE and the OS
>can hide much of that these days but they still exist. 
>
>Similarly with ANTLR. ANTLR users have to understand the syntax and
>semantics of the grammars they develop. ANTLR projects involve *two*
>languages - ANTLR's grammar language and a general purpose programming
>language such as Java/C/C#/ObjC etc.
>
>Beyond that, it's the same user experience: "I feed in some code and this
>tool (compiler or ANTLR) generates a whole lotta stuff I don't need to
>understand".
>  
>
No, there's a real difference. Yes, you have to know java syntax and 
semantics to use javac.
And you have to know ANTLR syntax and symantics to use ANTLR. But with 
ANTLR, it's
not enough to know the syntax and semantics of ANTLR. To do anything 
useful, you almost
always have to know something about the internals of what ANTLR is 
doing. I find that I
often have to look at the generated code to figure out what went wrong 
or how to do what
I want to do. I *never* have to look at java byte code - I'm completely 
hidden from that
by the design of the compiler.

>Micheal
>
>  
>


From parrt at cs.usfca.edu  Tue Oct 31 07:43:05 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 31 Oct 2006 07:43:05 -0800
Subject: [antlr-interest] Capturing lexer exceptions
In-Reply-To: <EF2ED99C54B0FD4188B64423658925EDAA775A@mailserv.lorien.fkie.fgan.de>
References: <EF2ED99C54B0FD4188B64423658925EDAA775A@mailserv.lorien.fkie.fgan.de>
Message-ID: <45D39BCB-8A10-469C-AC03-1ED604FD986B@cs.usfca.edu>


On Oct 31, 2006, at 4:41 AM, Gerz, Michael wrote:

> Terence,
>
> I am sorry for bothering you again but my project team is still  
> struggling with ANTLR's clever error recovery.
>
> Our problem is that we don't want ANTLR to do any error handling at  
> all. This includes errors thrown by the lexer. My colleague didn't  
> find a way to make her ANTLR parser _not_ to catch lexer exceptions.
>
> Unfortunately, the ANTLR 3 wiki (http://www.antlr.org/wiki/display/ 
> ANTLR3/Migrating+from+ANTLR+2+to+ANTLR+3) doesn't answer the  
> question how to ignore lexer exceptions (and you can no longer set  
> "defaultErrorHandler=false").
>
> Terence, could you please speak to us?

I would subclass and override nextToken() to not catch the  
exceptions.  That said, I posted email yesterday to which no one  
responded about how to deal with the error recovery that does inline  
insert/delete of tokens/chars.  Not sure if we need an option or what.

Ter


From VAUCHER at fermat.eu  Tue Oct 31 07:47:19 2006
From: VAUCHER at fermat.eu (VAUCHER Laurent)
Date: Tue, 31 Oct 2006 16:47:19 +0100
Subject: [antlr-interest] Conditional tree parsing
Message-ID: <200610311647496.SM06920@037f27dd816a40c>

  Hi.

  I'm currently implementing an expression evaluator as a TreeParser,
so,
for correct evaluation semantic, I need to conditionnally evaluate some
parts of the parse tree.

  For instance my parse tree for the equivalent of Java's 
(testexpr ? expr1 : expr2) is something like

#(IF_TOKEN testexprAST expr1AST expr2AST)

  When evaluating, I need to direct the tree parser to only walk the
correct branch of the tree (expr1AST is testexpr is true, expr2Ast
otherwise).

  My first try was to write:

#(IF_TOKEN t=expression v1=expression v2=expression)

  but then both expression are evaluated (wrong!)


  My second try was:

#(IF_TOKEN t=expression e1:expression e2:expression)
  { if (t) { result = eval(e1); } else { result = eval(e2); }}

  Well, it works, but expressions are still evaluated first.


  Is there a way to extract 'any' AST at a given position?
Something like:

#(IF_TOKEN t=expression e1:? e2:?)  



Laurent.



From aspitz at gmail.com  Tue Oct 31 07:51:56 2006
From: aspitz at gmail.com (Ayal Spitz)
Date: Tue, 31 Oct 2006 10:51:56 -0500
Subject: [antlr-interest] ANTLR 3.0b4 bug?
Message-ID: <a54e7a220610310751p3055e31bn28c804fdbdea4f56@mail.gmail.com>

Greetings -

I just started using ANTLR and I'm already a very big fan. I've been
experimenting with building a grammar and have come across a problem
I'm hopping someone out there might have a solution for.

I'm implementing a 'generic delimited input' from Ruby and have been
having 1 heck of a time. I finally came across the XRuby project and
their Ruby grammar work (Good stuff XRuby folks). I copied the segment
of their grammar that deals with generic delimited input. I changed it
to be ANTLR 3 compatible so it looks something like this:

QTest:
{ int dCount = 1; }
  '%q'	delimiter=.
    ({(dCount = trackDelimCount(input.LA(1), delimiter, dCount)) !=
0}? STRING_CHAR)*
    .{ channel = QTest; };

ANTLR seems to like it and goes ahead to generates the code. The
problem I've run into is in the lexer code for this entry. ANTLR
generates a method called mQTest and it has this code:

if ( !((dCount = trackDelimCount(input.LA(1), delimiter, dCount )) != 0) ) {
  throw new FailedPredicateException(input, "QTest", "(delimiterCount
=  trackDelimCount(input.LA(1), delimiter, dCount )) != 0");
}

If I leave the code as is then the results is a lexer that spits up
over my generic delimited input but if I replace the throw with a
'break loop' my problems appear to be solved.

My question is (1) Is this a bug in ANTLR 3.0b4, ie this is what you
get for playing with the bleeding edge? (2) Am I just getting lucky
that the 'break loop' code works? (3) is there a way for me to, in my
grammar, tell ANTLR to replace that throw statement with a 'break
loop'?

Thanks for any help in advance - AYAL

From open.zone at virgin.net  Tue Oct 31 08:38:48 2006
From: open.zone at virgin.net (Micheal J)
Date: Tue, 31 Oct 2006 16:38:48 -0000
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45475DC0.9070206@jazillian.com>
Message-ID: <001101c6fd0b$0b7173d0$c704a8c0@hercules>

Andy,

You seem to be changing your position on the issue of whether (as Anthony
put it):

"If it really *is* great, then the chances are the majority of programmers
*can't* 'easily "get it" '."

I'm leaning towards agreeing with Anthony as I said.

> >Many would argue that Java is a limited implementation of OO 
> principles 
> >as pioneered in LISP et al and later Smalltalk. Everything inherits 
> >from System.Object is plain ugly and, no multiple inheritance?. AOD 
> >(AspectJ and
> >cousins) can be viewed as a series of hacks to try and 
> simulate some of the
> >important OO bits that were thrown out to make Java.
> >  
> >
> I view Java's decision to do a "limited implementation" by avoiding 
> things like multiple inheritance
> as exactly what made it successful.

Being a great tool for the job doesn't guarantee popularity. Popularity is
ultimately a measure of the tool's accessibility to average programmers
(they are the majority). Great tools are often beyond the ability of the
average programmer. Certainly to build. And often to use too.

C++ is a great tool (Java was written using it). Most Java programmers
wouldn't be able to master it. Or the domain expertise needed to build Java
itself.

> By avoiding being 
> "completely pure", 
> Java is accessible
> to average programmers.

My point exactly (not sure about the "pure OO" label though). 

Incidentally "above average" Java programmers understand the value of the
missing features and are forever trying to add them back. As I suggested,
AspectOrientedDesign in Java can be viewed as attempts to hack some of them
back into Java.

> And that's why Java is popular and 
> Smalltalk and 
> LISP are not.
> It's also why people prefer Java over C++.

It is a easier tool to use. Less powerful. But easier.

> >So, I'm tending to agree with Anthony here. Great tools 
> often require 
> >in-depth domain expertise that the majority simply don't have.
> >  
> >
> Sometimes they do, but sometimes they don't. Compilers never require 
> in-depth
> domain expertise.

Try feeding Java code or an ANTLR grammar to a C++ compiler. ;-)

> I know almost nothing about byte-code 
> generation, yet 
> I use javac
> every minute or two. I think the world would benefit from an 
> ANTLR tool 
> that was like that.

For your examples of [general purpose language] compiler and ANTLR [grammar
language compiler], the domain expertise isn't primarily about the internals
of the tool. It's about the syntax, semantics and idioms of the language
recognized by the tool. Knowledge of the tool's internals can elevate those
who have it above the "average" user who doesn't.

> >>I think a tool can be great while being simple enough for most
> >>programmers (e.g. Java).
> >>    
> >>
> >
> >Not without limiting it's power.
> >  
> >
> Yes, just as Java's power is "limited" by not supporting MI, 
> pointers, etc. I love to have my power "limited" by not 
> giving me lots of rope to hang 
> myself with.
> And so do most people, judging by the popularity of Java over C++ and 
> every high-level
> language over assembly.

Java's swan song is productivity (for those problems to which to it can be
applied). Not power as in flexibility, expressivity or performance.

I use Java/C# for the productivity benefits. If performance, flexibility or
expressivity was *more* important in a particular project, there are better
tools than Java/C# (e.g. C++, Occaml).

> >>I think Terence could make a huge leap forward by not thinking about
> >>ANTLR as "a tool to automate what
> >>a guru would have written by hand", but rather "a tool that 
> hides all 
> >>the details of language manipulation, so that
> >>most any programmer can do it".
> >>    
> >>
> >
> >Don't think so. My point about domain expertise is relevant 
> here. Joe 
> >Average just can't start developing language recognition 
> tools with an 
> >appreciation of the theory that underlies that subject area.
> >  
> >
> Sure he could. Joe average could easily write:
> a + b --> a.add(b)
> and have his tool do the rest (and maybe warn him about cases 
> that might 
> match that he hadn't
> thought about).

Not without understanding the syntax and semantics of the DSL you created.
Not without understanding just what that input string instructs your DSL's
"compiler" to do.

Incidentally, your DSL is just a small part of your particular language
recognition toolkit. My comment refers to someone building the whole
toolkit. Examples abound of tools that offer multiple DSLs to tackle the
various phases/modules of a language processing toolkit (e.g. Cocktail,
Stratego).

> I've had a programmer working with me for a few months now, 
> and he's had 
> no trouble writing
> translation rules without every learning ANTLR grammar or knowing 
> anything about language
> recognition tools.

He isn't using ANTLR directly (i.e. creating/maintaining ANTLR grammars) so,
no surprise if he hasn't had to learn to use ANTLR. 

He isn't developing a language translation toolkit (you've done that
already) so, no surprise if he he has no grounding in formal language
theory.

He _is_ using a DSL you created to encode source-to-source transformations.
You just expressed the opinion that he has aquired the domain expertise
required to use your DSL.

> >>Most programmers use a
> >>compiler without 
> >>ever knowing much more than
> >>"it generates some lower-level code from my code". Similarly, 
> >>it would 
> >>be nice if most programmers working on
> >>language transformation could use ANTLR without knowing much 
> >>more than 
> >>"it generates a lexer/parser from
> >>my grammar".
> >>    
> >>
> >
> >The analogy isn't quite apples-to-apples. Programmers using 
> a compiler 
> >[for a programming language like C/C++] have to understand 
> the syntax 
> >and semantics of the language the compiler recognises. Plus 
> the rules 
> >for using other related tools such as linkers, loaders etc. True, an 
> >IDE and the OS can hide much of that these days but they still exist.
> >
> >Similarly with ANTLR. ANTLR users have to understand the syntax and 
> >semantics of the grammars they develop. ANTLR projects involve *two* 
> >languages - ANTLR's grammar language and a general purpose 
> programming 
> >language such as Java/C/C#/ObjC etc.
> >
> >Beyond that, it's the same user experience: "I feed in some code and 
> >this tool (compiler or ANTLR) generates a whole lotta stuff I don't 
> >need to understand".
> >  
> >
> No, there's a real difference. Yes, you have to know java syntax and 
> semantics to use javac.
> And you have to know ANTLR syntax and symantics to use ANTLR. 
> But with 
> ANTLR, it's
> not enough to know the syntax and semantics of ANTLR. To do anything 
> useful, you almost
> always have to know something about the internals of what ANTLR is 
> doing. I find that I
> often have to look at the generated code to figure out what 
> went wrong 
> or how to do what
> I want to do. I *never* have to look at java byte code - I'm 
> completely 
> hidden from that
> by the design of the compiler.

Not by the design of the compiler. But by how well tested it is. And by how
well documented Java (and javacc) is. Many Javacc users - who can and care
to look under hood - have tripped over bugs-a-plenty in it yet, "average"
Javacc users don't discover those same bugs in the same tool even when they
write code that triggers it.

Knowledge of Java and bytecode and how javacc works means "above average"
users can do more with Java and javacc than the average programmer can. 

Knowing more, lets you do more.

ANTLR is similar and different. Different because it suffers in comparison
by being a less popular tool with less resources behind it. Nevertheless,
for someone with a deep knowledge of ANTLR's grammar language, it's
limitations (e.g. no predicate hoisting and approximate-LLk in 2.x) and the
available documentation, there really is no need to look at the output code.
You develop your grammar, you develop your tests, you build the whole lot
and, the tests will alert you if you need to change anything. Unless you
trip over a bug in ANTLR of course...

Now with ANTLR V3, not only can you look at the output code it if you wish
but, for the price of a little more knowledge (i.e. domain expertise), you
can change it!. 

The "average" ANTLR user has no need to change the code and would never do
so but, others will.


Micheal


From dave at badgers-in-foil.co.uk  Tue Oct 31 08:43:46 2006
From: dave at badgers-in-foil.co.uk (David Holroyd)
Date: Tue, 31 Oct 2006 16:43:46 +0000
Subject: [antlr-interest] What if you want errors to exit the parser?
	(v3)
In-Reply-To: <8E99F8BC-BB90-44E6-B5CF-C585B84038FD@cs.usfca.edu>
References: <8E99F8BC-BB90-44E6-B5CF-C585B84038FD@cs.usfca.edu>
Message-ID: <20061031164346.GA1036@badgers-in-foil.co.uk>

On Mon, Oct 30, 2006 at 01:01:35PM -0800, Terence Parr wrote:
> but, it tries to recover from token mismatches by insertion/ 
> deletion....do we need an option afterall to tell ANTLR to let errors  
> cause exceptions in middle of alts?

Well, for my current project (programmatic code generation) I want to
know right away if the provided fragment of input didn't match the
grammar.  Unit testing the application code using my framework thereby
becomes much easier, as an application coding error is more likely to
immediately turn into an unexpected exception.

Adding an empty @rulectch seems to mostly do what I want at the moment.
In the future, since the same framework is used for both code generation
and code introspection, it may be useful to be able to choose at runtime
if the ANTLR-generated code should perform error recovery, so that it
can deal with wonkey input files.


ta,
dave

-- 
http://david.holroyd.me.uk/

From VAUCHER at fermat.eu  Tue Oct 31 09:24:58 2006
From: VAUCHER at fermat.eu (VAUCHER Laurent)
Date: Tue, 31 Oct 2006 18:24:58 +0100
Subject: [antlr-interest] Conditional tree parsing
Message-ID: <200610311825240.SM06920@037f27dd816a40c>

  To put it in simpler terms: is there a syntax in the grammar file for
TreeParsers to match 'any' subtree without trying to 'walk' it?



  #(TOKEN i:AST)
    {
      // Here I can operate on 'i' at the raw AST level without
      // the TreeParser trying to do anything else
    }


Laurent.


From parrt at cs.usfca.edu  Tue Oct 31 09:29:27 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 31 Oct 2006 09:29:27 -0800
Subject: [antlr-interest] What if you want errors to exit the parser?
	(v3)
In-Reply-To: <20061031164346.GA1036@badgers-in-foil.co.uk>
References: <8E99F8BC-BB90-44E6-B5CF-C585B84038FD@cs.usfca.edu>
	<20061031164346.GA1036@badgers-in-foil.co.uk>
Message-ID: <F8B29897-0A83-4AE6-82C0-4ED18E7B7058@cs.usfca.edu>


On Oct 31, 2006, at 8:43 AM, David Holroyd wrote:
> Adding an empty @rulectch seems to mostly do what I want at the  
> moment.

Hi David,

Yep, but this does not deal with mismatched tokens in the middle of  
alternative.  I'm pretty sure that it only deals with no viable  
alternatives. after having looked at the code I note that I foresaw  
this problem it turns out.  I made a method that factors out what  
happens in the middle of alternative when it mismatch is a token:

	/** factor out what to do upon token mismatch so tree parsers can  
behave
	 *  differently.
	 */
	protected void mismatch(IntStream input, int ttype, BitSet follow)
		throws RecognitionException
	{
		MismatchedTokenException mte =
			new MismatchedTokenException(ttype, input);
		recoverFromMismatchedToken(input, mte, ttype, follow);
	}

  so, all you have to do is subclass that and throw the exception  
instead of trying to recover.  Users may even do dynamic automatic  
recovery by adding a Boolean variable test.  In this way some rules  
in your grammar could do automatic recovery where it makes sense but  
all the rules could just blow out the exception and recover elsewhere.

Cool.   Okay, adding to the book instead of altering the code :)
Ter


From parrt at cs.usfca.edu  Tue Oct 31 09:29:46 2006
From: parrt at cs.usfca.edu (Terence Parr)
Date: Tue, 31 Oct 2006 09:29:46 -0800
Subject: [antlr-interest] Conditional tree parsing
In-Reply-To: <200610311825240.SM06920@037f27dd816a40c>
References: <200610311825240.SM06920@037f27dd816a40c>
Message-ID: <5CD68A94-500C-4ADD-A546-F3F3A1A3E277@cs.usfca.edu>

Try #(TOKEN .)

Ter

On Oct 31, 2006, at 9:24 AM, VAUCHER Laurent wrote:

>   To put it in simpler terms: is there a syntax in the grammar file  
> for
> TreeParsers to match 'any' subtree without trying to 'walk' it?
>
>
>
>   #(TOKEN i:AST)
>     {
>       // Here I can operate on 'i' at the raw AST level without
>       // the TreeParser trying to do anything else
>     }
>
>
> Laurent.
>


From VAUCHER at fermat.eu  Tue Oct 31 09:33:42 2006
From: VAUCHER at fermat.eu (VAUCHER Laurent)
Date: Tue, 31 Oct 2006 18:33:42 +0100
Subject: [antlr-interest] Conditional tree parsing
Message-ID: <200610311834955.SM06920@037f27dd816a40c>

 
Yep! 

#(TOKEN i:.) does the trick!

Thanks a lot!


-----Message d'origine-----
De : Terence Parr [mailto:parrt at cs.usfca.edu] 
Envoy? : 31 October 2006 18:30
? : VAUCHER Laurent
Cc : antlr-interest at antlr.org
Objet : Re: [antlr-interest] Conditional tree parsing

Try #(TOKEN .)

Ter

On Oct 31, 2006, at 9:24 AM, VAUCHER Laurent wrote:

>   To put it in simpler terms: is there a syntax in the grammar file 
> for TreeParsers to match 'any' subtree without trying to 'walk' it?
>
>
>
>   #(TOKEN i:AST)
>     {
>       // Here I can operate on 'i' at the raw AST level without
>       // the TreeParser trying to do anything else
>     }
>
>
> Laurent.
>




From andy at exchange.voelkel.us  Tue Oct 31 10:19:19 2006
From: andy at exchange.voelkel.us (Andy Voelkel)
Date: Tue, 31 Oct 2006 10:19:19 -0800
Subject: [antlr-interest] philosophy about translation
Message-ID: <7AE2E53336B37440A20C9590DB11BCB9054AE2D5@EXVS01.ex.dslextreme.net>

>>Many would argue that Java is a limited implementation of OO
principles as
>>pioneered in LISP et al and later Smalltalk. Everything inherits from
>>System.Object is plain ugly and, no multiple inheritance?. AOD
(AspectJ and
>>cousins) can be viewed as a series of hacks to try and simulate some
of the
>>important OO bits that were thrown out to make Java.
 
>I view Java's decision to do a "limited implementation" by avoiding
things 
>like multiple inheritance as exactly what made it successful. By
avoiding 
>being "completely pure", Java is accessible to average programmers. And

>that's why Java is popular and Smalltalk and LISP are not. It's also
why 
>people prefer Java over C++.
Having seen systems implemented that rely heavily on multiple
inheritance, I would make the observation that it is fraught with
difficulty. I view the move towards interface inheritance instead as a
positive development that has facilitated the widespread use of
component based programming. Component based programming is where the
real life promise of OO has finally been realized, IMO. It is
interesting that the two languages most widely used in real life
component based systems have been VB and Java (and now C#). It doesn't
say much for the language purist approach.
I think that one of the reasons that Java took off is that it gave you
automatic storage management and runtime type checking "out of the box".
In C++, you have to "roll your own" storage management. Having come from
LISP machines in the early eighties, C++ seemed like huge step backwards
for this reason. It also didn't help that the linker model was primitive
and reuse involved the use of shared header files. This made it
difficult to deliver components from one company or group to another.
The lack of multiple inheritance, in comparison, was a tiny tiny issue.
I suppose this is a bit off-topic.
- Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://www.antlr.org/pipermail/antlr-interest/attachments/20061031/e25b2964/attachment.html 

From open.zone at virgin.net  Tue Oct 31 11:50:31 2006
From: open.zone at virgin.net (Micheal J)
Date: Tue, 31 Oct 2006 19:50:31 -0000
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <7AE2E53336B37440A20C9590DB11BCB9054AE2D5@EXVS01.ex.dslextreme.net>
Message-ID: <000601c6fd25$d3b3efc0$c704a8c0@hercules>

Hi,

> >I view Java's decision to do a "limited implementation" by avoiding
things 
> >like multiple inheritance as exactly what made it successful. By avoiding

> >being "completely pure", Java is accessible to average programmers. And 
> >that's why Java is popular and Smalltalk and LISP are not. It's also why 
> >people prefer Java over C++.
> 
> Having seen systems implemented that rely heavily on multiple inheritance,
> I would make the observation that it is fraught with difficulty.

So is single inheritance in the wrong hands.

> I view 
> the move towards interface inheritance instead as a positive development 
> that has facilitated the widespread use of component based programming.

Interface inheritance predated VB/Java/C#. C++ had it before for instance.
It's proper use simply needed to be taught to "average" programmers.

> Component based programming is where the real life promise of OO has 
> finally been realized, IMO. It is interesting that the two languages most 
> widely used in real life component based systems have been VB and Java 
> (and now C#).

Not that surprising since the archetypal CBD developer is an "average"
developer consuming components written by others (usually developed in C++
for VB'ers to consume).

Java/C# fare better as tools used by component producers. Nevertheless, the
most flexible/performant components are still developed in C++.

> It doesn't say much for the language purist approach.

This isn't a religious debate (I hope). ;-)

> I think that one of the reasons that Java took off is that it gave you 
> automatic storage management and runtime type checking "out of the box".

As did many other systems before it. Having a big company (or a few if one
includes Netscape, IBM et al) aggressively pushing it probably had a much
greater impact.

> In C++, you have to "roll your own" storage management. Having come from 
> LISP machines in the early eighties, C++ seemed like huge step backwards 
> for this reason. It also didn't help that the linker model was primitive 
> and reuse involved the use of shared header files. This made it difficult 
> to deliver components from one company or group to another.

Yet C++ was the de facto tool for component producers during the period when
VB finally delivered on CBD's reuse promise.

> The lack of multiple inheritance, in comparison, was a tiny tiny issue.

For some people/projects, yes. Not so for others.

> I suppose this is a bit off-topic.

;-)


Micheal


-----------------------
The best way to contact me is via the list/forum. My time is very limited. 


From jimi at intersystems.com  Tue Oct 31 12:43:36 2006
From: jimi at intersystems.com (Jim Idle)
Date: Tue, 31 Oct 2006 15:43:36 -0500
Subject: [antlr-interest] Capturing lexer exceptions
In-Reply-To: <EF2ED99C54B0FD4188B64423658925EDAA775A@mailserv.lorien.fkie.fgan.de>
Message-ID: <20061031204336.E1165856@mail.intersystems.com>

Michael,

I think that really, you should not have a lexer that can generate errors, in that it should be able to handle anything thrown at it and produce some sort of token or handle it in some way. Hence the ANTLR3 lexer just reports the character it sees that it doesn't know what to do with and throws it away (consumes it). 

So, if your lexer spec does not cover all the characters that might come in to it, then this is what will happen. However, you can probably achieve what you are looking for by specifying:

UNKNOWN: . {do something, or not}

as the last lexer rule, and either looking in the parser for this and reporting the error in some way yourself, or just setting the token to be skipped.

You might also find the filter mode is what you are looking for in the lexer? Check the examples for a filtering lexer.

Yet another option is to override the lexer error handler, or more specifically error display using @lexer:: ...  and just don't print anything, which should cause the character to be consumes silently. 

However, my own opinion is that you should make sure your lexer is able to process all characters and perform some specific, deliberate action such as set the token to be skipped as you then comment it as to why you are doing this and it just feels more logical to me, unless you are specifically constructing some sort of filter.

Jim





-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Gerz, Michael
Sent: Tuesday, October 31, 2006 4:42 AM
To: antlr-interest at antlr.org
Cc: Schueller, Henriette
Subject: [antlr-interest] Capturing lexer exceptions

Terence,

I am sorry for bothering you again but my project team is still struggling with ANTLR's clever error recovery. 

Our problem is that we don't want ANTLR to do any error handling at all. This includes errors thrown by the lexer. My colleague didn't find a way to make her ANTLR parser _not_ to catch lexer exceptions.

Unfortunately, the ANTLR 3 wiki (http://www.antlr.org/wiki/display/ANTLR3/Migrating+from+ANTLR+2+to+ANTLR+3) doesn't answer the question how to ignore lexer exceptions (and you can no longer set "defaultErrorHandler=false").

Terence, could you please speak to us?

A thousand thanks in advance,

Michael

************************************************************************
Dr. Michael Gerz                                                        
FGAN e.V.                                      Phone:  +49 228 9435-414 
Department FKIE/ITF                            Fax:    +49 228 9435-685 
Neuenahrer Stra?e 20                           E-Mail: gerz at fgan.de     
53343 Wachtberg-Werthhoven                     WWW:    www.fgan.de     

-- 
No virus found in this incoming message.
Checked by AVG Free Edition.
Version: 7.1.409 / Virus Database: 268.13.19/507 - Release Date: 10/31/2006
 

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.409 / Virus Database: 268.13.19/507 - Release Date: 10/31/2006
 

From jimi at intersystems.com  Tue Oct 31 12:47:57 2006
From: jimi at intersystems.com (Jim Idle)
Date: Tue, 31 Oct 2006 15:47:57 -0500
Subject: [antlr-interest] ANTLR-generated code & Findbugs
In-Reply-To: <092B6BFC-F6AC-492C-A33F-183839BE9683@classdump.org>
Message-ID: <20061031204758.A356416A2@mail.intersystems.com>



-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Kay Roepke


> I have brought up the matter with Terence and others on the antlr-dev  
> list. The most irritating thing for me is the fact that there are so  
> many unused variables and lists. For me in Objective-C it's a more a  
> performance issue, 

Surely the objective C compiler does not generate code and overhead for unused stuff unless it is told to? Perhaps we should write a new one? ;-)


> though I'd like to get rid of the warnings, too.  

The C code generator generates code that compiles without warning at W4 mode in Visual C++. In some case though I rely on ensuring that all pointers etc are initialized, then turning off the warning about variables that are initialized and used, allowing the compiler to optimize them away. Perhaps you can do the same? I am sure that eventually Ter could identify these suckers and cull them from the codegen, but this seems effort that would be best spent elsewhere at the moment?

Jim

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.409 / Virus Database: 268.13.19/507 - Release Date: 10/31/2006
 

From jimi at intersystems.com  Tue Oct 31 12:58:49 2006
From: jimi at intersystems.com (Jim Idle)
Date: Tue, 31 Oct 2006 15:58:49 -0500
Subject: [antlr-interest] philosophy about translation
In-Reply-To: <45475DC0.9070206@jazillian.com>
Message-ID: <20061031205851.129DE1700@mail.intersystems.com>



-----Original Message-----
From: antlr-interest-bounces at antlr.org [mailto:antlr-interest-bounces at antlr.org] On Behalf Of Andy Tripp 

> Sometimes they do, but sometimes they don't. Compilers never require 
> in-depth domain expertise. 

I think that in order to write very efficient code they do. This is especially true of higher level languages given that optimizations must be conservative (always generate working code). Ignoring algorithms, you can still write code that executes slower written one way than another because of the way it causes the execution level code to be generated. Optimizers get better all the time, but there are always limits of one sort or another. Without in-depth domain knowledge you are doomed to randomness.

> I know almost nothing about byte-code generation, yet I use javac every minute or two. 

That makes you, and the guys that did the byte code generation for Java ;-). The problem with Java is that for a lot of real world stuff it just isn?t useable, with the VM crashing, garbage (collection)? and so on just getting in the way. as we get further way from the machine programming gets sloppier because as well as being easy to write code it is much easier to write sloppy code. Sure you don?t need to malloc anything, but that's why you need 3,243,242MB of memory and things like confluence crash whereas twiki doesn't. ;-)

Jim

-- 
No virus found in this outgoing message.
Checked by AVG Free Edition.
Version: 7.1.409 / Virus Database: 268.13.19/507 - Release Date: 10/31/2006
 

From kroepke at classdump.org  Tue Oct 31 14:42:55 2006
From: kroepke at classdump.org (Kay Roepke)
Date: Tue, 31 Oct 2006 23:42:55 +0100
Subject: [antlr-interest] ANTLR-generated code & Findbugs
In-Reply-To: <20061031204758.A356416A2@mail.intersystems.com>
References: <20061031204758.A356416A2@mail.intersystems.com>
Message-ID: <CB7F28E7-C5C8-4C94-98B0-931AAA220118@classdump.org>


On 31. Oct 2006, at 21:47 , Jim Idle wrote:

> Surely the objective C compiler does not generate code and overhead  
> for unused stuff unless it is told to? Perhaps we should write a  
> new one? ;-)

;) Before you ask, it's gcc 4.0.1 and yes it sucks...

I was talking about building up lists of matched tokens when building  
ASTs. Most of the time these lists are built up but not subsequently  
used in rewriting actions. I'm not totally sure whether I can  
influence this in codegen, or if ANTLR must detect this.
So in a sense, it is used, but useless...

>> though I'd like to get rid of the warnings, too.
>
> The C code generator generates code that compiles without warning  
> at W4 mode in Visual C++. In some case though I rely on ensuring  
> that all pointers etc are initialized, then turning off the warning  
> about variables that are initialized and used, allowing the  
> compiler to optimize them away. Perhaps you can do the same? I am  
> sure that eventually Ter could identify these suckers and cull them  
> from the codegen, but this seems effort that would be best spent  
> elsewhere at the moment?

I agree that time should be spent where it helps most. This is  
currently bugfixing and not getting rid of warnings about unused  
variables.

It surprises me that you don't have warnings about unused variables  
created for lookahead chars/tokens. They don't hurt and get optimized  
away properly but nevertheless they bug me. For my C grammar I get  
about 190 of the in the parser.
I could turn off these warnings, but I'd rather fix the cause than  
suppress the symptoms. But it is not pressing.

cheers,

-k





From niketa at Princeton.EDU  Tue Oct 31 19:25:42 2006
From: niketa at Princeton.EDU (Niket Agarwal (niketa@Princeton.EDU))
Date: Tue, 31 Oct 2006 22:25:42 -0500
Subject: [antlr-interest] Grammar needed
Message-ID: <f1cbf91a17055.4547cd66@Princeton.EDU>

Any one has any idea whether I can get a Grammar for EDIF. I want to write a parser for EDIF in ANTLR. 


Niket.

