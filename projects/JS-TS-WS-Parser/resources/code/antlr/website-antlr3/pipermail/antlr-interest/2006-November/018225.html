<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=004901c6fe4b%2491c30fc0%24c704a8c0%40hercules">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018217.html">
   <LINK REL="Next"  HREF="018195.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=004901c6fe4b%2491c30fc0%24c704a8c0%40hercules"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Thu Nov  2 07:35:36 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018217.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018195.html">[antlr-interest] Grammar File: Get text from token
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18225">[ date ]</a>
              <a href="thread.html#18225">[ thread ]</a>
              <a href="subject.html#18225">[ subject ]</a>
              <a href="author.html#18225">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Micheal J wrote:

&gt;<i>I should have been clearer: Popularity isn't a measure of greatness.
</I>&gt;<i>  
</I>&gt;<i>
</I>No, but popularity is a common result of greatness. If Terence wants to 
build
&quot;the Smalltalk80 of compiler-compilers&quot;, that's fine. But I think it's 
reasonable for
someone to request that he build &quot;the Java of compiler-compilers&quot;.

&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Then you should get out more. Talk to 10 co-workers about 
</I>&gt;&gt;<i>Java vs. C++, 
</I>&gt;&gt;<i>or go to a conference.
</I>&gt;&gt;<i>I'd say that less than 5% of those who've actually used both Java and 
</I>&gt;&gt;<i>C++ prefer C++.
</I>&gt;&gt;<i>That's from my experience of talking to perhaps a few hundred 
</I>&gt;&gt;<i>developers 
</I>&gt;&gt;<i>about it.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>A few hundred (even a few thousand) developers doesn't equate to the &quot;vast
</I>&gt;<i>majority&quot;.
</I>&gt;<i>  
</I>&gt;<i>
</I>You don't need to sample the whole population to know what they think.

Let's just agree to disagree. I think Java is generally better than C++. 
The Java designers
chose to leave out all the C++ nastyness, and I find myself several 
times more productive in Java.
My personal experience has been that most other developers prefer Java 
over C++, and I
do extrapolate that to all programmers.

&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>LL(*) is brand new to V3, so that has nothing to do with it. 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I disagree. V3 is the reason many ANTLR'ers aren't using some other tool.
</I>&gt;<i>  
</I>&gt;<i>
</I>I know you'll disagree, but I'd venture to guess that over 95% of ANTLR 
users started using
it before V3.

&gt;<i>Once I learned the syntax/semanics and prevailing idioms, javacc was easy
</I>&gt;<i>enough.
</I>&gt;<i>  
</I>&gt;<i>
</I>I'm not happy with &quot;easy enough&quot; - I'd prefer &quot;as easy as possible&quot;. 
Just my personality I guess.

&gt;<i>
</I>&gt;<i>It isn't a circular argument. It is perfectly possible to &quot;understand the
</I>&gt;<i>value&quot; of a feature and yet not want it. I &quot;understand the value&quot; of MI for
</I>&gt;<i>instance and I'm not calling for [standard] Java to include it bacause it
</I>&gt;<i>make makes dynamic class loading far more difficult to implement. I'd rather
</I>&gt;<i>not be introduced to another slew of Java bugs.
</I>&gt;<i>  
</I>&gt;<i>
</I>OK. With that definition, I'd then say that I do believe that the vast 
majority of those who
&quot;understand the value&quot; of C++ features do prefer Java.

&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>How would you change in ANTLR to make it easier?
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Short answer: hide all the details from me. Make it so that I have no 
</I>&gt;&gt;<i>idea that
</I>&gt;&gt;<i>there is code being generated to do lexing and parsing. Let 
</I>&gt;&gt;<i>me just give 
</I>&gt;&gt;<i>it a C grammar
</I>&gt;&gt;<i>and a Java grammar, and then dive in and start writing 
</I>&gt;&gt;<i>translation logic 
</I>&gt;&gt;<i>without any
</I>&gt;&gt;<i>generated code or even ASTs in sight. How to do that is left as an 
</I>&gt;&gt;<i>exercise for the reader.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Interesting idea. Don't know if it is possible but, interesting nonetheless.
</I>&gt;<i>;-)
</I>&gt;<i>  
</I>&gt;<i>
</I>The more I think about it, the easier it seems to me. I must be missing 
something.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>Quite often just getting &quot;something that works&quot; is all that is 
</I>&gt;&gt;&gt;<i>required. Getting the best output from a compiler requires 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>knowing more 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>about what goes on under the hood.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Yea, I know. You can do a better job at garbage collection 
</I>&gt;&gt;<i>than java's 
</I>&gt;&gt;<i>gc. You can write
</I>&gt;&gt;<i>better byte code than javac because you've studied javac and bytecode.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The Java JIT guys say the first rule of performance 
</I>&gt;&gt;<i>optimization is to 
</I>&gt;&gt;<i>STOP doing whatever
</I>&gt;&gt;<i>it is you're doing that you think is producing better 
</I>&gt;&gt;<i>bytecode. And what 
</I>&gt;&gt;<i>did Terence find
</I>&gt;&gt;<i>out about performance when he tried generating his own bytecode?
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Regardless of what Ter experienced while generating DFAs as bytecode, what
</I>&gt;<i>the Java JIT guys may have said or indeed whether I can beat javac's GC
</I>&gt;<i>strategy, what I actually said above remains a fact.
</I>&gt;<i>  
</I>&gt;<i>
</I>That you can write better code by knowing the details of bytecode 
generation? I doubt it.
The reason I responded the way I did is my way of saying &quot;I seriously 
doubt it&quot;.
I guess that's a separate discussion.

&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>If that's your definition of &quot;power&quot;, I don't see how it relates to 
</I>&gt;&gt;<i>anything.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I defined &quot;power&quot; in terms of performance, flexibility and expressivity
</I>&gt;<i>(it's still visible above).
</I>&gt;<i>
</I>&gt;<i>Performance: Given equivalent programs written in Java and asm/C/C++, the
</I>&gt;<i>Java version would be slower (or it is always possible to optimize the
</I>&gt;<i>asm/C/C++ version so it outperforms the Java version).
</I>&gt;<i>  
</I>&gt;<i>
</I>Wrong. The 1990's called and they want their &quot;Java is interpreted&quot; 
thinking back ;)

&gt;<i>Flexibility: Anything program that can be written in Java can be written in
</I>&gt;<i>asm/C/C++ (although one might not want to). The reverse is not true.
</I>&gt;<i>  
</I>&gt;<i>
</I>That's technically true, but I'd also add that that I think that 99.9% 
of real-world applications can
be written in Java, but perhaps 20% of the developers out there don't 
think that their app can be
written in Java. I'm just making up numbers, but you get the idea.

&gt;<i>Expressivity: Java is less expressive than C++ (even without macros). With
</I>&gt;<i>[really!] clever use of macros, the same can be said of C and perhaps asm
</I>&gt;<i>too.
</I>&gt;<i>  
</I>&gt;<i>
</I>Then I'd say &quot;expressivity&quot; is a negative attribute: C++ with macros or 
COBOL with lots of
preprocessors are &quot;most expressive&quot; and also &quot;least maintainable&quot;.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>- For some problems, Java/C# is more productive than assembler, C or 
</I>&gt;&gt;&gt;<i>C++.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>I'd say &quot;for almost all problems&quot; but OK.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Depends on what sort of programming problems you have to solve. A
</I>&gt;<i>Windows/Linux device driver developer wouldn't use Java for instance.
</I>&gt;<i>  
</I>&gt;<i>
</I>Right.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>I disagree. He is working with code generated by ANTLR. He 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>isn't using 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>ANTLR.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Ah, come on. When someone is using a lexer built using ANTLR, 
</I>&gt;&gt;<i>you won't 
</I>&gt;&gt;<i>consider that to be
</I>&gt;&gt;<i>&quot;using ANTLR?&quot; As in &quot;He's using ANTLR without ever seeing the input 
</I>&gt;&gt;<i>grammar&quot;. That's
</I>&gt;&gt;<i>like saying I'm not &quot;using javac&quot;, I'm just using the 
</I>&gt;&gt;<i>bytecode that it 
</I>&gt;&gt;<i>generates.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Which is precisely what many ANTLR users do when they download the binary
</I>&gt;<i>distribution. They aren't using javac (some probably don't even know what
</I>&gt;<i>javac is). They are just &quot;using bytecode generated by javac&quot;.
</I>&gt;<i>  
</I>&gt;<i>
</I> I consider myself to be &quot;using javac&quot; when doing Java development.
I think maybe you're trying to &quot;talk past me&quot; on purpose, but it 
worked...I don't remember or
care what the point was here ;)

&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>ANTLR *is* a compiler.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Right, and as such, I believe it can do what &quot;traditional&quot; 
</I>&gt;&gt;<i>compilers do: 
</I>&gt;&gt;<i>hide all the underlying
</I>&gt;&gt;<i>stuff from the users.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>It does. That's why your guy can use the code it generated without knowing
</I>&gt;<i>or caring about ANTLR.
</I>&gt;<i>  
</I>&gt;<i>
</I>The lexer part of ANTLR does hide the details well. It's parser part 
that doesn't do so well,
forcing me to really remember the original grammar and the shape of the 
ASTs that I'm creating.
And treewalkers have the same problem.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>Compiler designers take it as a given that users need only know the
</I>&gt;&gt;&gt;&gt;<i>syntax/semantics of the input
</I>&gt;&gt;&gt;&gt;<i>language. If Ter took it as a given that ANTLR4 users need 
</I>&gt;&gt;&gt;&gt;<i>only know the 
</I>&gt;&gt;&gt;&gt;<i>syntax/semantics
</I>&gt;&gt;&gt;&gt;<i>of the input language, he'd end up with a very different tool.
</I>&gt;&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>When using ANTLR, that is all one needs to know.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>No. To use ANTLR, you not only need to know the input 
</I>&gt;&gt;<i>language (say, C) 
</I>&gt;&gt;<i>syntax&amp;symantics, you
</I>&gt;&gt;<i>also need to know:
</I>&gt;&gt;<i>* The ANTLR syntax&amp;symantics
</I>&gt;&gt;<i>* How to hook in actions: where do they make sense? What language are 
</I>&gt;&gt;<i>they in?
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>ANTLR's input language is a customized variant of EBNF that can include
</I>&gt;<i>embedded &quot;action&quot; code written in one of a few general programming
</I>&gt;<i>languages. It is used to describe the syntactic structure of other languages
</I>&gt;<i>e.g. your ANTLR grammar for the C language.
</I>&gt;<i>  
</I>&gt;<i>
</I>Yes, I'm familiar with ANTLR.

&gt;<i>Learning where actions can be &quot;hooked in&quot; is part of learning about the
</I>&gt;<i>syntax/semantics of ANTLR's input language.
</I>&gt;<i>  
</I>&gt;<i>
</I>Not really. It requires that you know something about the code being 
generated.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>* You often need to know details about the code that's generated to 
</I>&gt;&gt;<i>resolve ambiguities
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>A test suite mitigates against this. I agree that approximate lookahead
</I>&gt;<i>generates spurious warnings.
</I>&gt;<i>  
</I>&gt;<i>
</I>A test suite is just an organized way to produce the ambiguity; it 
doesn't help you
avoid them in the first place, or even help you eliminate them.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>* You need to know how the grammar maps to an AST structure. It's not 
</I>&gt;&gt;<i>enough to have a mental
</I>&gt;&gt;<i>   picture of the input grammar, you need to be able to form a mental 
</I>&gt;&gt;<i>picture of the AST each time
</I>&gt;&gt;<i>   you see a chunk of code.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>ASTs are optional. You don't use them for instance. In any case, the user
</I>&gt;<i>designs an AST not ANTLR. ANTLR simply provides a language for specifying
</I>&gt;<i>AST construction.
</I>&gt;<i>  
</I>&gt;<i>
</I>Yea, well ASTs being optional doesn't change anything. Of course you're 
going to generate
ASTs if you're using ANTLR for language translation, the alternative is 
even worse.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>A compiler designer can't determine the best code to 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>generate for every 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>possible situation in advance.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>He doesn't need to always generate the best code. It's good 
</I>&gt;&gt;<i>enough that 
</I>&gt;&gt;<i>he just generally do
</I>&gt;&gt;<i>better than humans do.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>For some users/projects, that is enough. Not for everyone or every project.
</I>&gt;<i>  
</I>&gt;<i>
</I>There may be some projects out there that can't use a standard compiler, 
yes.
But probably 99.999% do. So I do think the days of people feeling that a 
standard compiler
is not good enough for them are over.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>This feature makes the tool more useful - for
</I>&gt;&gt;&gt;<i>those who care to acquire the knowledge required to use it 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>effectively. 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>It empowers knowledgeable users to tailor the output for any given 
</I>&gt;&gt;&gt;<i>situation.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>And yet, there is no equivalent in Java - no bytecode 
</I>&gt;&gt;<i>tweaking. And no 
</I>&gt;&gt;<i>one seems to mind.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Actually, there is. Not just with javac. Javaassist, BCEL etc do just that.
</I>&gt;<i>  
</I>&gt;<i>
</I>I say &quot;there are no pink elephants&quot;, and you find one. OK, I stand 
corrected. There are apps
for which the standard &quot;javac&quot; is not good enough, and there are apps 
that tweak bytecode with BCEL.

I think we're losing site of the point: Javac would not be better by 
becomeing &quot;more powerful&quot; and
allowing you to tweak bytecodes. ANTLR is not better than it could be 
because it's &quot;more powerful&quot;
and lets you tweak the underlying code it generates.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>And there is an equivalent in C/C++ - embedded asm code. That was 
</I>&gt;&gt;<i>popular 20 years ago,
</I>&gt;&gt;<i>but today's programmers realize that the assembler is 
</I>&gt;&gt;<i>probably better at 
</I>&gt;&gt;<i>producing good code,
</I>&gt;&gt;<i>and they don't need every last 1% of performance anyway.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Not all the time. When they do, it is reassuring to know that gcc/vc++ still
</I>&gt;<i>support it...  ;-)
</I>&gt;<i>  
</I>&gt;<i>
</I>It's also reassuring to know that those people who claim to need a 2% 
performance boost and
so use gcc instead of Java are simply wrong. For one thing, gcc is not 
one of the better compilers
out there for performance.

I recently converted a JPEG image processing app that runs on a mobile 
phone from C to Java.
I'm sure you can guess what I'm going to say about performance ;)

&gt;<i>
</I>&gt;<i>Micheal
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>-----------------------
</I>&gt;<i>The best way to contact me is via the list/forum. My time is very limited.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>
</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018217.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018195.html">[antlr-interest] Grammar File: Get text from token
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18225">[ date ]</a>
              <a href="thread.html#18225">[ thread ]</a>
              <a href="subject.html#18225">[ subject ]</a>
              <a href="author.html#18225">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
