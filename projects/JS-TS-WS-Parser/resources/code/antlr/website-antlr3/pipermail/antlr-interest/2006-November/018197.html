<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=4548F943.7070906%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018263.html">
   <LINK REL="Next"  HREF="018209.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Anthony W. Youngman</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=4548F943.7070906%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">antlr at thewolery.demon.co.uk
       </A><BR>
    <I>Wed Nov  1 12:54:50 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018263.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018209.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18197">[ date ]</a>
              <a href="thread.html#18197">[ thread ]</a>
              <a href="subject.html#18197">[ subject ]</a>
              <a href="author.html#18197">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In message &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">4548F943.7070906 at jazillian.com</A>&gt;, Andy Tripp 
&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; writes
&gt;<i>Micheal J wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>Andy,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>You seem to be changing your position on the issue of whether (as Anthony
</I>&gt;&gt;<i>put it):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>&quot;If it really *is* great, then the chances are the majority of programmers
</I>&gt;&gt;<i>*can't* 'easily &quot;get it&quot; '.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I'm leaning towards agreeing with Anthony as I said.
</I>&gt;&gt;<i>
</I>&gt;<i>I don't think I'm changing my position. I still disagree with that 
</I>&gt;<i>quote. I think almost all the great tools
</I>&gt;<i>are the ones that the majority of programmers to &quot;get&quot;. In fact, that's 
</I>&gt;<i>part of what makes them great.
</I>
I wouldn't describe &quot;popular&quot; as &quot;great&quot;.
&gt;<i>
</I>&gt;&gt;&gt;<i>I view Java's decision to do a &quot;limited implementation&quot; by avoiding 
</I>&gt;&gt;&gt;<i>things like multiple inheritance
</I>&gt;&gt;&gt;<i>as exactly what made it successful.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Being a great tool for the job doesn't guarantee popularity. Popularity is
</I>&gt;&gt;<i>ultimately a measure of the tool's accessibility to average programmers
</I>&gt;&gt;<i>(they are the majority). Great tools are often beyond the ability of the
</I>&gt;&gt;<i>average programmer. Certainly to build. And often to use too.
</I>&gt;&gt;<i>
</I>&gt;<i>I disagree. I view Java as being &quot;great&quot; and C++ not being &quot;great&quot;. And 
</I>&gt;<i>the main thing that makes
</I>&gt;<i>Java great is that all the features that made it inaccessible to 
</I>&gt;<i>average programmers were removed.
</I>&gt;<i>And, it's no coincidence that these same features are what always got 
</I>&gt;<i>the supposedly &quot;great programmers&quot;
</I>&gt;<i>into trouble: pointers, multiple inheritence, operator overloading, etc.
</I>&gt;<i>
</I>&gt;&gt;<i>C++ is a great tool (Java was written using it). Most Java programmers
</I>&gt;&gt;<i>wouldn't be able to master it. Or the domain expertise needed to build Java
</I>&gt;&gt;<i>itself.
</I>&gt;&gt;<i>
</I>&gt;<i>Well, I think Java is far better than C++, and I think the vast 
</I>&gt;<i>majority of programmers who know both
</I>&gt;<i>agree with me. Probably the main benefit is that it's easy to use for 
</I>&gt;<i>&quot;average programmers&quot;. That's also why
</I>&gt;<i>ANTLR is better than the competition - because it's easier to use.
</I>&gt;<i>
</I>You've just said Java doesn't have pointers. So how do you access a 
hardware register in Java? How do you access a screen buffer?
&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>By avoiding being &quot;completely pure&quot;, Java is accessible
</I>&gt;&gt;&gt;<i>to average programmers.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>My point exactly (not sure about the &quot;pure OO&quot; label though).
</I>&gt;&gt;<i>Incidentally &quot;above average&quot; Java programmers understand the value of the
</I>&gt;&gt;<i>missing features and are forever trying to add them back. As I suggested,
</I>&gt;&gt;<i>AspectOrientedDesign in Java can be viewed as attempts to hack some of them
</I>&gt;&gt;<i>back into Java.
</I>&gt;&gt;<i>
</I>&gt;<i>Yes, a few people want to add stuff back, but most do not. It's just 
</I>&gt;<i>that the few are very vocal.
</I>&gt;<i>The vast majority don't want MI, operator overloading, or built-in 
</I>&gt;<i>AspectOrientedDesign.
</I>&gt;<i>And of course, those who want them think they're &quot;above average&quot;, but 
</I>&gt;<i>then so does almost
</I>&gt;<i>everyone.
</I>&gt;<i>
</I>What about those who don't WANT those things, but NEED them?
&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>And that's why Java is popular and Smalltalk and LISP are not.
</I>&gt;&gt;&gt;<i>It's also why people prefer Java over C++.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>It is a easier tool to use. Less powerful. But easier.
</I>&gt;&gt;<i>
</I>&gt;<i>Right - so I hope there's nothing wrong with me pushing to make ANTLR 
</I>&gt;<i>(or some successor)
</I>&gt;<i>easier to use. A compiler is easier to use than compiling by hand, but 
</I>&gt;<i>also less powerful.
</I>&gt;<i>I'm ok with that.
</I>&gt;<i>
</I>So - you're quite happy to see Antlr crippled to suit you, ignoring the 
NEEDS of those who need its power!
&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>But required knowledge of the tool's internals limits the &quot;average&quot; 
</I>&gt;<i>user's productivity.
</I>&gt;<i>If I had done AST-based translation, I'd be spending way to much time 
</I>&gt;<i>worrying about the details
</I>&gt;<i>of the AST, rather than the syntax and semantics of the two languages. 
</I>&gt;<i>I demand to spend 95% of
</I>&gt;<i>my time on *what* to do, rather than *how* to do it. With ASTs, I found 
</I>&gt;<i>myself spending
</I>&gt;<i>95% of my time on *how*.
</I>&gt;<i>
</I>In other words, as you said earlier, ASTs are the wrong tool for you. So 
you seem happy to delete ASTs from Antlr because *you* don't need them, 
irregardless of what other people *NEED*.
&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>I think a tool can be great while being simple enough for most
</I>&gt;&gt;&gt;&gt;&gt;<i>programmers (e.g. Java).
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>Not without limiting it's power.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Yes, just as Java's power is &quot;limited&quot; by not supporting MI, 
</I>&gt;&gt;&gt;<i>pointers, etc. I love to have my power &quot;limited&quot; by not giving me 
</I>&gt;&gt;&gt;<i>lots of rope to hang myself with.
</I>&gt;&gt;&gt;<i>And so do most people, judging by the popularity of Java over C++ and 
</I>&gt;&gt;&gt;<i>every high-level
</I>&gt;&gt;&gt;<i>language over assembly.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Java's swan song is productivity (for those problems to which to it can be
</I>&gt;&gt;<i>applied). Not power as in flexibility, expressivity or performance.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I use Java/C# for the productivity benefits. If performance, flexibility or
</I>&gt;&gt;<i>expressivity was *more* important in a particular project, there are better
</I>&gt;&gt;<i>tools than Java/C# (e.g. C++, Occaml).
</I>&gt;&gt;<i>
</I>&gt;<i>Right, so you're just like the rest of us. You've chosen to limit your 
</I>&gt;<i>own &quot;power&quot; by using Java rather
</I>&gt;<i>than, say, assembly. So I'm sticking with my claim that
</I>&gt;<i>&quot;I think a tool can be great while being simple enough for most 
</I>&gt;<i>programmers (e.g. Java).&quot;
</I>&gt;<i>and not buying your &quot;Not without limiting it's power&quot; reply.
</I>&gt;<i>
</I>To my mind, that's not a &quot;great&quot; tool. As I said above, &quot;popular&quot;, 
maybe.

Let's ask a question ... how can a tool be &quot;great&quot; if it *relies* on 
other tools even for its existence?

A C compiler can compile itself. Can a Java system build itself? How 
much of Java is actually written in Java? (Oh and I'm including the 
supporting libraries here!)

Antlr v3 is due to be rewritten in Antlr v3. To my mind, that's a 
&quot;necessary but not sufficient&quot; condition for greatness.
&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>He _is_ using a DSL you created to encode source-to-source transformations.
</I>&gt;&gt;<i>You just expressed the opinion that he has aquired the domain expertise
</I>&gt;&gt;<i>required to use your DSL.
</I>&gt;&gt;<i>
</I>&gt;<i>Yes, so if you believe me when I say that my DSL is orders of magnitude 
</I>&gt;<i>easier to use than
</I>&gt;<i>to use ANTLR to build and walk ASTs, then you must see my point: He's 
</I>&gt;<i>much more productive.
</I>&gt;<i>So I'm building my DSL (and other code) on top of ANTLR/lexer. I think 
</I>&gt;<i>there's an opportunity
</I>&gt;<i>for Terence to build a better and different tool in place of the 
</I>&gt;<i>ANTLR/parser - one that doesn't
</I>&gt;<i>require users to know formal language theory or picture ASTs in their 
</I>&gt;<i>heads.
</I>
But what if the problem can only be specified in terms of formal 
language theory? There is something called &quot;intelligence&quot;. If you don't 
have sufficient intelligence, you *cannot* learn certain things. You 
want to give a programmer a tool, so you can set him a problem he is 
INCAPABLE of comprehending. I hope I never have to rely on (or even USE) 
code written by a coder like that !!!
&gt;<i>
</I>&gt;&gt;&gt;<i>I want to do. I *never* have to look at java byte code - I'm 
</I>&gt;&gt;&gt;<i>completely hidden from that
</I>&gt;&gt;&gt;<i>by the design of the compiler.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Not by the design of the compiler. But by how well tested it is. And by how
</I>&gt;&gt;<i>well documented Java (and javacc) is.
</I>&gt;<i>No, I do think it's by the design of the compiler - by the design of 
</I>&gt;<i>compilers in general.
</I>&gt;<i>Compiler designers take it as a given that users need only know the 
</I>&gt;<i>syntax/semantics of the input
</I>&gt;<i>language. If Ter took it as a given that ANTLR4 users need only know 
</I>&gt;<i>the syntax/semantics
</I>&gt;<i>of the input language, he'd end up with a very different tool.
</I>
That would appeal to a completely different set of users. He's written a 
tool that does what he needs, and it appeals to users with similar 
needs.

Maybe he will write your version of Antlr 4, but it will be a compiler 
not a lexer/parser - a completely different tool!
&gt;<i>
</I>&gt;&gt;<i>Many Javacc users - who can and care
</I>&gt;&gt;<i>to look under hood - have tripped over bugs-a-plenty in it yet, &quot;average&quot;
</I>&gt;&gt;<i>Javacc users don't discover those same bugs in the same tool even when they
</I>&gt;&gt;<i>write code that triggers it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Knowledge of Java and bytecode and how javacc works means &quot;above average&quot;
</I>&gt;&gt;<i>users can do more with Java and javacc than the average programmer 
</I>&gt;&gt;<i>can.
</I>&gt;&gt;<i>Knowing more, lets you do more.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>ANTLR is similar and different. Different because it suffers in comparison
</I>&gt;&gt;<i>by being a less popular tool with less resources behind it. Nevertheless,
</I>&gt;&gt;<i>for someone with a deep knowledge of ANTLR's grammar language, it's
</I>&gt;&gt;<i>limitations (e.g. no predicate hoisting and approximate-LLk in 2.x) and the
</I>&gt;&gt;<i>available documentation, there really is no need to look at the output code.
</I>&gt;&gt;<i>
</I>&gt;<i>Well, sure, it's mostly covered in the documentation. But that doesn't 
</I>&gt;<i>change the fact that it could be
</I>&gt;<i>made a lot easier (IMO). What makes Java great and C++ not-so-great is 
</I>&gt;<i>that Java programmers
</I>&gt;<i>never have to go look up the syntax for &quot;pointer to function that 
</I>&gt;<i>returns an int pointer&quot;. Similarly,
</I>&gt;<i>a tool that didn't make me look up how to figure out how many patterns 
</I>&gt;<i>a &quot;*&quot; matched would make
</I>&gt;<i>the tool great.
</I>&gt;<i>
</I>And then the programmer needs a pointer to write to a bit of hardware, 
and throws Java out in disgust because his &quot;great&quot; tool is useless for 
the job at hand ...

&gt;&gt;<i>You develop your grammar, you develop your tests, you build the whole lot
</I>&gt;&gt;<i>and, the tests will alert you if you need to change anything. Unless you
</I>&gt;&gt;<i>trip over a bug in ANTLR of course...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Now with ANTLR V3, not only can you look at the output code it if you wish
</I>&gt;&gt;<i>but, for the price of a little more knowledge (i.e. domain expertise), you
</I>&gt;&gt;<i>can change it!.
</I>&gt;<i>I can change the bytecode generated by javac, too. If javac let me do 
</I>&gt;<i>that, it would be an indication
</I>&gt;<i>to the javac designer that his design is less-than-great.
</I>&gt;<i>
</I>Because javac is meant to convert java source accurately to java 
bytecode. While Antlr is meant to (and does) accurately convert its 
sourcecode into a lexer/parser/treewalker, it is also designed to let 
you do things beyond the power of the tool. Both fit their design aims - 
javac creates a java program, Antlr creates an extensible 
lexer/parser/treewalker. Both are *good* tools, that doesn't necessarily 
mean they are *great* tools.

At the end of the day, I think your definition of &quot;great&quot; is badly 
flawed - &quot;a great tool lets a mediocre programmer do a decent job&quot;. A 
great programmer could probably outperform that mediocre programmer 
without that tool. To my mind, &quot;a great tool lets a great programmer 
give of his best&quot;. And a mediocre programmer would not be able to use 
that tool, because he would not be able to understand it.

There's a BIG difference between the RIGHT tool, and a GREAT tool. Would 
you call a hammer a *great* tool when you have a pack of nails? I don't 
know as I'd call a nailgun a great tool but it's certainly greater than 
a hammer. And it requires a greater level of *maturity* than a hammer to 
use safely.

The greater the tool, the greater the level of maturity required to be 
able to use it safely. And the fewer the number of programmers who are 
capable of reaching that level of maturity ... you go on about the 
&quot;dangerous features&quot; of C++ as opposed to Java. A mature C++ programmer 
would NOT USE those features if they weren't needed. Indeed, a mature 
C++ programmer would probably use Java if those features weren't needed.

Too many programmers use features like kids eat candy - the more the 
better! A great programmer likes a tool like a candy shop - but he has 
the self control to only take what he needs - not the entire shop!

Cheers,
Wol
-- 
Anthony W. Youngman - <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">anthony at thewolery.demon.co.uk</A>

</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018263.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018209.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18197">[ date ]</a>
              <a href="thread.html#18197">[ thread ]</a>
              <a href="subject.html#18197">[ subject ]</a>
              <a href="author.html#18197">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
