<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] link error with antlr(Klaren edition)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20link%20error%20with%20antlr%28Klaren%20edition%29&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004977.html">
   <LINK REL="Next"  HREF="004985.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] link error with antlr(Klaren edition)</H1>
    <B>lzy7886</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20link%20error%20with%20antlr%28Klaren%20edition%29&In-Reply-To="
       TITLE="[antlr-interest] link error with antlr(Klaren edition)">lzy7886 at yahoo.com
       </A><BR>
    <I>Thu Sep 18 19:20:25 PDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="004977.html">[antlr-interest] grammar for jdk1.5 parameterized types
</A></li>
        <LI>Next message: <A HREF="004985.html">[antlr-interest] Walking TreeParser question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4984">[ date ]</a>
              <a href="thread.html#4984">[ thread ]</a>
              <a href="subject.html#4984">[ subject ]</a>
              <a href="author.html#4984">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi:

I have used antlr on java platform for some days,thanks for the smart 
work of those clever guys.It's wonderful.

However,I try to shift ANTLR to MSVC70 for the work which must be 
done on Windows,the problems arise.

I first built the antlr 2.7.2(Klaren 20030911) under MSVC70 to static 
lib.It completed successfully.But when I wrote a small program and 
try to build it,the problems came into being,it couldn't be linked 
correctly.

The compiler said some construct had already defined in some default 
lib.
such as:
msvcprtd.lib(MSVCP60D.dll) : error LNK2005: &quot;class 
std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp; __cdecl 
std::operator&lt;&lt;(class std::basic_ostream&lt;char,struct 
std::char_traits&lt;char&gt; &gt; &amp;,char const *)&quot; (??6std@@YAAAV?
$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">basic_ostream at DU</A>?$cha
<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">r_traits at D</A>@std@@@<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">0 at AAV10</A>@<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">PBD at Z</A>) already defined in antlrlibd.lib
(LLkParser.obj)
msvcprtd.lib(MSVCP60D.dll) : error LNK2005: &quot;public: __thiscall 
std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class 
std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,struct 
std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;(void)&quot; (??1?
$basic_strin
<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">g at DU</A>?$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">char_traits at D</A>@std@@V?$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">allocator at D</A>@2@@std@@<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">QAE at XZ</A>) already 
defined in antlrlibd.lib(LLkParser.obj)
msvcprtd.lib(MSVCP60D.dll) : error LNK2005: &quot;public: class 
std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp; __thiscall 
std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;
(class std::basic_ostream&lt;char,struct std::char_traits
&lt;char&gt; &gt; &amp; (__cdecl*)(class std::basic_ostream&lt;char,struct 
std::char_traits&lt;char&gt; &gt; &amp;))&quot; (??6?$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">basic_ostream at DU</A>?
$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">char_traits at D</A>@std@@@std@@<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">QAEAAV01 at P6AAAV01</A>@AAV01@@<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">Z at Z</A>) already 
defined in antlrlibd.lib(LLkParser.obj)
msvcprtd.lib(MSVCP60D.dll) : error LNK2005: &quot;class 
std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp; __cdecl 
std::endl(class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; 
&gt;<i> &amp;)&quot; (?<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">endl at std</A>@@YAAAV?$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">basic_ostream at DU</A>?$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">char_traits at D</A>@std@@
</I>@<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">1 at AAV21</A>@@Z) already defined in antlrlibd.lib(LLkParser.obj)

I cannot figure out the solution to it.
Can anybody help me out?
Thanks very much in advance.

                                         Yours, 
                                         Rockson

Following is the my .g file,quite simple.


header &quot;pre_include_hpp&quot; {
    // gets inserted before antlr generated includes in the header 
file
    #include &lt;iostream&gt;
    #include &lt;string&gt;
}

options {
	language=&quot;Cpp&quot;;
}
{
ANTLR_USING_NAMESPACE(std)
}
class StclParser extends Parser;
options {
	importVocab=Stcl;  // call the vocabulary &quot;Stcl&quot;
	//buildAST = true;	// uses CommonAST by default
	genHashLines=false;
}
stats
	:(stat)*
	  EOF
	;	
stat
	: wait_stat
	 |waitto_stat
	 |pause_stat
	 |send_stat
	 |check_stat
	 |call_stat
	;
wait_stat
	:wait:WAIT n:NUM_INT
	{cout&lt;&lt;wait-&gt;getText()&lt;&lt;&quot; &quot;&lt;&lt;n-&gt;getText()&lt;&lt;endl;}
	;
waitto_stat 
	:w:WAITTO t:TIME
	{std::cout&lt;&lt;w-&gt;getText()&lt;&lt;&quot; &quot;&lt;&lt;t-&gt;getText()&lt;&lt;endl;}
	;
pause_stat
	:p:PAUSE
	{std::cout&lt;&lt;p-&gt;getText()&lt;&lt;endl;}
	;
send_stat
	:s:SEND i:IDENT {std::cout&lt;&lt;s-&gt;getText()&lt;&lt;&quot; &quot;&lt;&lt;i-&gt;getText()
&lt;&lt;&quot; &quot;;}
	(c:COMMA n:NUM_INT{std::cout&lt;&lt;c-&gt;getText()&lt;&lt;&quot; &quot;&lt;&lt;n-&gt;getText
();})?
	{std::cout&lt;&lt;endl;}
	 
	;
check_stat
{string c,n;}
	:check:CHECK ident:IDENT c=check_op n=num str:STRING_LITERAL
	{std::cout&lt;&lt;check-&gt;getText()&lt;&lt;&quot; &quot;&lt;&lt;ident-&gt;getText()
&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;str-&gt;getText()&lt;&lt;endl;}	
	;
check_op
returns[std::string op]
	: opE:EQUAL	{op=opE-&gt;getText();}
	 |opN:NOT_EQUAL {op=opN-&gt;getText();}
	 |opGE:GE	{op=opGE-&gt;getText();}
	 |opGT:GT	{op=opGT-&gt;getText();}
	 |opLE:LE	{op=opLE-&gt;getText();}
	 |opLT:LTHAN	{op=opLT-&gt;getText();}
	 ;	
call_stat
	:call:CALL ident:IDENT
	{std::cout&lt;&lt;call-&gt;getText()&lt;&lt;&quot; &quot;&lt;&lt;ident-&gt;getText()&lt;&lt;endl;}
	;
num
returns[std::string number]
{
std::string sign=&quot;&quot;;
}
	:
	 (p:PLUS{sign=p-&gt;getText();}|m:MINUS{sign=m-&gt;getText();})?
	 (
	   nI:NUM_INT	{number=sign+nI-&gt;getText();}
	  |nF:NUM_FLOAT	{number=sign+nF-&gt;getText()+sign;}
	  )	 	 
	;						
//--------------------------------------------------------------------
--------
// The Stcl scanner
//--------------------------------------------------------------------
--------
class StclLexer extends Lexer;

options {
	exportVocab=Stcl;  // call the vocabulary &quot;Stcl&quot;
	testLiterals=false;    // don't automatically test for 
literals
	k=2;                   // four characters of lookahead
	codeGenBitsetTestThreshold=5;
	//charVocabulary='\x00\x03'..'\xFF\xFE';//note:here exclude 
the \uFFFF(16bit -1:EOF)
	charVocabulary = '\3'..'\377';
	
}
tokens
{
CHECK	=&quot;CHECK&quot;	;
SEND	=&quot;SEND&quot;		;
WAIT	=&quot;WAIT&quot;		;
WAITTO	=&quot;WAITTO&quot;	;
PAUSE	=&quot;PAUSE&quot;	;
CALL	=&quot;CALL&quot;		;
NUM_FLOAT		;
TIME			;
DOT			;
}


// OPERATORS

LPAREN			:	'('		;
RPAREN			:	')'		;
COMMA			:	','		;
EQUAL			:	&quot;==&quot;		;
NOT_EQUAL		:	&quot;!=&quot;		;
GE			:	&quot;&gt;=&quot;		;
GT			:	&quot;&gt;&quot;		;
LE			:	&quot;&lt;=&quot;		;
LTHAN			:	'&lt;'		;
PLUS			:	'+'		;
MINUS			:	'-'		;

	

// Whitespace -- ignored
WS	:	(	' '
		|	'\t'
		|	'\f'
		// handle newlines
		|	(	&quot;\r\n&quot;  // Evil DOS
			|	'\r'    // Macintosh
			|	'\n'    // Unix (the right way)
			)
			{ newline(); }
		)
		{ _ttype = ANTLR_USE_NAMESPACE(antlr)Token::SKIP; }
	;

// Single-line comments
SL_COMMENT
	:	&quot;--&quot;
		(~('\n'|'\r'))* ('\n'|'\r'('\n')?)
		{$setType(ANTLR_USE_NAMESPACE(antlr)Token::SKIP); 
newline();}
	;
// character literals
CHAR_LITERAL
	:	'\'' ( ESC | ~'\'' ) '\''
	;

// std::string literals
STRING_LITERAL
	:	'&quot;' (ESC|~('&quot;'|'\\'))* '&quot;'
	;


// escape sequence -- note that this is protected; it can only be 
called
//   from another lexer rule -- it will not ever directly return a 
token to
//   the parser
// There are various ambiguities hushed in this rule.  The optional
// '0'...'9' digit matches should be matched here rather than letting
// them go back to STRING_LITERAL to be matched.  ANTLR does the
// right thing by matching immediately; hence, it's ok to shut off
// the FOLLOW ambig warnings.
protected
ESC
	:	'\\'
		(	'n'
		|	'r'
		|	't'
		|	'b'
		|	'f'
		|	'&quot;'
		|	'\''
		|	'\\'
		|	('u')+ HEX_DIGIT HEX_DIGIT HEX_DIGIT 
HEX_DIGIT 
		|	('0'..'3')
			(
				options {
					warnWhenFollowAmbig = 
false;
				}
			:	('0'..'7')
				(	
					options {
					
	warnWhenFollowAmbig = false;
					}
				:	'0'..'7'
				)?
			)?
		|	('4'..'7')
			(
				options {
					warnWhenFollowAmbig = 
false;
				}
			:	('0'..'9')
			)?
		)
	;
protected
DIGIT
	:'0'..'9'
	;

// hexadecimal digit (again, note it's protected!)
protected
HEX_DIGIT
	:	('0'..'9'|'A'..'F'|'a'..'f')
	;

// an identifier.  Note that testLiterals is set to true!  This means
// that after we match the rule, we look in the literals table to see
// if it's a literal or really an identifer
IDENT
	options {testLiterals=true;}
	:	('a'..'z'|'A'..'Z'|'_'|'$') 
('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'$')*
	;


// a numeric literal
NUM_INT
	{bool isDecimal=false;}
	:
	  
	  '.' {_ttype = DOT;}
		(('0'..'9')+ (EXPONENT)? (FLOAT_SUFFIX)? { _ttype 
= NUM_FLOAT; })?	
	  |((DIGIT)+ 'd' DIGIT (DIGIT)? 'h')=&gt;
			(DIGIT)+ 'd' DIGIT (DIGIT)? 'h' DIGIT 
(DIGIT)? 'm' DIGIT (DIGIT)? 's'
		{$setType(TIME);}	  	
	  |	(	'0' {isDecimal = true;} // special case 
for just '0'
			(	('x'|'X')
				(			
				// hex
					// the 'e'|'E' and 
float suffix stuff look
					// like hex digits, 
hence the (...)+ doesn't
					// know when to stop: 
ambig.  ANTLR resolves
					// it correctly by 
matching immediately.  It
					// is therefor ok to 
hush warning.
					options {
					
	warnWhenFollowAmbig=false;
					}
				:	HEX_DIGIT
				)+
			//|	('0'..'7')+		
				// NO octal
			)?
		|	('1'..'9') ('0'..'9')*  {isDecimal=true;}
		// non-zero decimal
		)
		(	('l'|'L')
		
		// only check to see if it's a float if looks like 
decimal so far
		|	{isDecimal}?
			(	'.' ('0'..'9')* (EXPONENT)? 
(FLOAT_SUFFIX)?
			|	EXPONENT (FLOAT_SUFFIX)?
			|	FLOAT_SUFFIX
			)
			{ _ttype = NUM_FLOAT; }
		)?	   	   		
	;


// a couple protected methods to assist in matching floating point 
numbers
protected
EXPONENT
	:	('e'|'E') ('+'|'-')? ('0'..'9')+
	;


protected
FLOAT_SUFFIX
	:	'f'|'F'|'d'|'D'
	;

	
	








 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004977.html">[antlr-interest] grammar for jdk1.5 parameterized types
</A></li>
	<LI>Next message: <A HREF="004985.html">[antlr-interest] Walking TreeParser question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4984">[ date ]</a>
              <a href="thread.html#4984">[ thread ]</a>
              <a href="subject.html#4984">[ subject ]</a>
              <a href="author.html#4984">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
