<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=454A1879.6040802%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018240.html">
   <LINK REL="Next"  HREF="018264.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Anthony W. Youngman</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=454A1879.6040802%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">antlr at thewolery.demon.co.uk
       </A><BR>
    <I>Thu Nov  2 17:16:49 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018240.html">[antlr-interest] Java boolean type storage
</A></li>
        <LI>Next message: <A HREF="018264.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18238">[ date ]</a>
              <a href="thread.html#18238">[ thread ]</a>
              <a href="subject.html#18238">[ subject ]</a>
              <a href="author.html#18238">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In message &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">454A1879.6040802 at jazillian.com</A>&gt;, Andy Tripp 
&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; writes
&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Every time I've heard anyone say they NEED MI, operator overloading, 
</I>&gt;&gt;&gt;<i>or Aspects, I've thought
</I>&gt;&gt;&gt;<i> that they really don't need them, they're just not good enough 
</I>&gt;&gt;&gt;<i>programmers to see a clean way
</I>&gt;&gt;&gt;<i> to do without them. I've been programming for 25 years without ever 
</I>&gt;&gt;&gt;<i>NEEDING any of these,
</I>&gt;&gt;&gt;<i> and so have most other programmers.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> I programmed for many years without needing pointers. FORTRAN didn't 
</I>&gt;&gt;<i>have them, so I tended not to use them in C. I notice you said *MOST* 
</I>&gt;&gt;<i>other programmers. You're jumping to conclusions - because &quot;all the 
</I>&gt;&gt;<i>programmers I know are too stupid to live without these features&quot; you 
</I>&gt;&gt;<i>conclude that these features &quot;mostly aren't needed&quot;. So you'd like to 
</I>&gt;&gt;<i>see them removed from any tool you use ... :-(
</I>&gt;<i>
</I>&gt;<i>I conclude that these features &quot;mostly aren't needed&quot; (really more like 
</I>&gt;<i>&quot;almost never&quot; or even &quot;never&quot;) from personal
</I>&gt;<i>experience, not from something you or I said.
</I>&gt;<i>
</I>I thought that was what I said - your personal experience leads you to 
believe they're not necessary ... (and you ignore other people's 
experiences to the contrary :-)
&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> So - you're quite happy to see Antlr crippled to suit you, ignoring 
</I>&gt;&gt;&gt;&gt;<i>the NEEDS of those who need its power!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Don't worry, I can't cripple ANTLR.  But yes, I'd be happy to see 
</I>&gt;&gt;&gt;<i>ANTLR4 become a &quot;crippled&quot; version,
</I>&gt;&gt;&gt;<i> in the same sense that Java is a &quot;crippled&quot; version of C++.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> And as I said, you're quite happy to ruin the tool for all those 
</I>&gt;&gt;<i>people who need that power ...
</I>&gt;<i>
</I>&gt;<i>Yes, if you consider Java to be &quot;ruining&quot; C++. New tool without all the 
</I>&gt;<i>warts. Those
</I>&gt;<i>who &quot;need the power&quot; of the warts can keep using the old tool.
</I>&gt;<i>
</I>Except you seem to be saying that C++ is unnecessary because Java can do 
everything that C++ is used for.
&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> But required knowledge of the tool's internals limits the 
</I>&gt;&gt;&gt;&gt;&gt;<i>&quot;average&quot; user's productivity.
</I>&gt;&gt;&gt;&gt;&gt;<i> If I had done AST-based translation, I'd be spending way to much 
</I>&gt;&gt;&gt;&gt;&gt;<i>time worrying about the details
</I>&gt;&gt;&gt;&gt;&gt;<i> of the AST, rather than the syntax and semantics of the two 
</I>&gt;&gt;&gt;&gt;&gt;<i>languages. I demand to spend 95% of
</I>&gt;&gt;&gt;&gt;&gt;<i> my time on *what* to do, rather than *how* to do it. With ASTs, I 
</I>&gt;&gt;&gt;&gt;&gt;<i>found myself spending
</I>&gt;&gt;&gt;&gt;&gt;<i> 95% of my time on *how*.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> In other words, as you said earlier, ASTs are the wrong tool for 
</I>&gt;&gt;&gt;&gt;<i>you. So you seem happy to delete ASTs from Antlr because *you* don't 
</I>&gt;&gt;&gt;&gt;<i>need them, irregardless of what other people *NEED*.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yes, just as I railed against operator overloading and MI in C++, 
</I>&gt;&gt;&gt;<i>and found bliss in Java.
</I>&gt;&gt;&gt;<i> I don't much care that other people think they *NEED* MI. They can 
</I>&gt;&gt;&gt;<i>always stick with C++.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Or you could find some other language instead of Java? You'd much 
</I>&gt;&gt;<i>rather inconvenience all the other Java programmers by removing 
</I>&gt;&gt;<i>features they need, rather than convenience yourself by finding 
</I>&gt;&gt;<i>something that suits you better?
</I>&gt;<i>
</I>&gt;<i>No, you're messing up the metaphor. I'm proposing that the next version 
</I>&gt;<i>of ANTLR (or maybe it's a completely new tool)
</I>&gt;<i>be to today's ANTLR as Java is to C++: a new and improved version 
</I>&gt;<i>that's really better, in part because it takes programming
</I>&gt;<i>to a higher level.
</I>&gt;<i>
</I>If you want to write a new tool, go ahead. But it won't be Antlr. And 
the people who know Antlr will go on using it because it's better :-)
&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Let's ask a question ... how can a tool be &quot;great&quot; if it *relies* 
</I>&gt;&gt;&gt;&gt;<i>other tools even for its existence?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Sure, of course! Virtually all software relies on other tools 
</I>&gt;&gt;&gt;<i>(compilers, operating systems, etc) for their existence.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> A C compiler can compile itself. Can a Java system build itself? 
</I>&gt;&gt;&gt;&gt;<i>How much of Java is actually written in Java? (Oh and I'm including 
</I>&gt;&gt;&gt;&gt;<i>the supporting libraries here!)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Almost all of Java is written in Java. The only part that's not is 
</I>&gt;&gt;&gt;<i>the lowest layer, which is OS and hardware specific.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Assembler is written in assembler, pretty much without exception. C 
</I>&gt;&gt;<i>is written in C, pretty much without exception.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The reason for demanding that a great tool be written in itself is 
</I>&gt;&gt;<i>exemplified by my databasic example above - the primitives for the 
</I>&gt;&gt;<i>version I initially used were written in machine code, and followed 
</I>&gt;&gt;<i>the spec. The C rewrite introduced loads of subtle bugs, because the 
</I>&gt;&gt;<i>characteristics of the C environment were different. How much of Java 
</I>&gt;&gt;<i>DEPENDS on the lowest layer? How much knowledge do you need to 
</I>&gt;&gt;<i>understand that layer?
</I>&gt;<i>
</I>&gt;<i>Heheh...didn't know that most of Java was written in Java, did you? ;)
</I>&gt;<i>Yes, all of Java DEPENDS on C.  All of C DEPENDS on object code. All of 
</I>&gt;<i>object code DEPENDS on
</I>&gt;<i>the operating system. All of the operating system DEPENDS on the hardware.
</I>&gt;<i>
</I>Can you separate DEPENDS and IS? Java *depends* on C because at its base 
it's written in C. Neither Java nor C *depend* on object code, because 
at base they *are* object code. (Java twice over, because it's JVM 
object code interpreted by a JVM which is CPU object code :-)

Oh. And I've never met object code that depends on the operating system. 
On the hardware, yes, because it relies on the CPU to execute it 
correctly. But the OS? Not at all.

Actually, I'm beginning to think this is part of your problem. You've 
used the word DEPENDS four times in the paragraph above. With, to my 
mind, at least three different meanings! Everybody's trying to help you, 
but we don't seem able to understand what you're trying to say.
&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Antlr v3 is due to be rewritten in Antlr v3. To my mind, that's a 
</I>&gt;&gt;&gt;&gt;<i>&quot;necessary but not sufficient&quot; condition for greatness.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Wow. Only software that's written in itself can be &quot;great&quot;? Are you 
</I>&gt;&gt;&gt;<i>really saying that?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Yes I am. Because otherwise it requires you to understand much more 
</I>&gt;&gt;<i>than you want about the execution environment. Note my comments about 
</I>&gt;&gt;<i>subtle bugs. Because it requires the system guys to be *experts* in 
</I>&gt;&gt;<i>two completely different environments!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I note that you think a &quot;great tool&quot; is one that means you *don't* 
</I>&gt;&gt;<i>*need* to be an expert. By your logic, Java therefore has to be a crap 
</I>&gt;&gt;<i>tool for Java system programmers ...
</I>&gt;<i>
</I>&gt;<i>No, I don't mean &quot;...*dont need* to be an expert&quot;, but rather &quot;dont 
</I>&gt;<i>need to know about the layers below&quot;. Java is great
</I>&gt;<i>because it doesn't require any knowledge about memory management, for 
</I>&gt;<i>example. The tool should let you
</I>&gt;<i>only be an expert *at one level of abstraction*. I can program in Java 
</I>&gt;<i>without knowing (almost) any details about
</I>&gt;<i>any of the underlying layers.
</I>&gt;<i>
</I>Welcome to your imaginary world! By training, I'm a scientist. Your 
world just doesn't exist in reality! In order to be an expert at, say, 
Chemistry (my speciality) you need to know a hell of a lot about 
Physics. And depending on your branch of Chemistry, you also almost 
certainly need to know a hell of a lot about Biology, or Geology, or 
loads of other stuff.
&gt;&gt;<i>
</I>&gt;&gt;<i> Which is why, in the system I want to build with Antlr, it's very 
</I>&gt;&gt;<i>important to me that AS MUCH AS POSSIBLE of the system is built using 
</I>&gt;&gt;<i>DATABASIC, because that's what the programmers using it will have 
</I>&gt;&gt;<i>experience in. *THAT* is why a great tool must be built using itself.
</I>&gt;<i>
</I>&gt;<i>I think maybe you're only picturing cases where the tool developer is 
</I>&gt;<i>the same person as the tool user.
</I>&gt;<i>I don't care at all whether ANTLR (Or Java, or anything else I use) is 
</I>&gt;<i>built with itself. I'm sure Terence cares,
</I>&gt;<i>but he's the exception.
</I>&gt;<i>
</I>You should care. Otherwise you'll get bitten by paradigm bugs.
&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Well, virtually every coder in the world is like that. Only a 
</I>&gt;&gt;&gt;<i>handful  of people in the world know the details of what their
</I>&gt;&gt;&gt;<i> compiler is doing as they use it every day. Same goes for the OS and 
</I>&gt;&gt;&gt;<i>the hardware. Same goes for  the car you drive
</I>&gt;&gt;&gt;<i> and just about everything other non-trivial machine you use: you use 
</I>&gt;&gt;&gt;<i>it without knowing much about how it works.
</I>&gt;&gt;&gt;<i> That's what makes the world go round :)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> You miss the point. Let's take the car example. There's a big 
</I>&gt;&gt;<i>difference between what I wrote and you responded to. As far as I can 
</I>&gt;&gt;<i>see, you're saying that if a guy has a driving licence, you're quite 
</I>&gt;&gt;<i>happy to get him to repair your car brakes ... WHAT...!!!
</I>&gt;<i>
</I>&gt;<i>No, I'm just saying that what makes the car useful is that you don't 
</I>&gt;<i>have to understand it to use it. You're
</I>&gt;<i>hidden from the layers below.
</I>&gt;<i>
</I>And if you don't have basic mechanical knowledge you are a liability and 
a danger to other road users. The UK driving test now includes 
elementary car maintenance as a mandatory component. Fail that, and you 
fail your test.

And as I said above, to be an expert you need a considerable amount of 
knowledge in realms close to your specialist subject ... if that's true 
in the scientific world, I doubt it's any different in the programming 
world.
&gt;&gt;<i>
</I>&gt;&gt;<i> You do not give a problem to someone to solve, if they do not have 
</I>&gt;&gt;<i>the mental capacity to understand the problem. You do not ask a guy to 
</I>&gt;&gt;<i>repair the brakes on your car if he has no experience of being a 
</I>&gt;&gt;<i>mechanic, even if he does have a driving licence (and there's a lot of 
</I>&gt;&gt;<i>people I would hate to have service my car, even if they do have a 
</I>&gt;&gt;<i>mechanics qualification, because they learnt to follow the diagrams in 
</I>&gt;&gt;<i>the book and didn't learn to work through what was *actually* *happening*!).
</I>&gt;<i>
</I>&gt;<i>I agree.
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> And then the programmer needs a pointer to write to a bit of 
</I>&gt;&gt;&gt;&gt;<i>hardware, and throws Java out in disgust because his &quot;great&quot; tool is 
</I>&gt;&gt;&gt;&gt;<i>useless for the job at hand ...
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Right. And probably gets fired if his boss finds out that he's 
</I>&gt;&gt;&gt;<i>trying  to write a bit directly to hardware.
</I>&gt;&gt;&gt;<i> He thinks he needs to do that, and he thinks he's smart, but he's 
</I>&gt;&gt;&gt;<i>not. That's pretty rare these days to
</I>&gt;&gt;&gt;<i> have anyone feel that they need direct access to the hardware. We're 
</I>&gt;&gt;&gt;<i>many levels beyond that now.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Given the ability of many bosses, I bet the boss gave him the job, 
</I>&gt;&gt;<i>and told him to use the wrong tool ...
</I>&gt;<i>
</I>&gt;<i>Maybe. From my experience, almost always when someone says &quot;I need to 
</I>&gt;<i>set individual bits by hand,
</I>&gt;<i>so Java isn't a good fit&quot;, it turns out that in fact he does not need 
</I>&gt;<i>to set individual bits by hand, and Java will
</I>&gt;<i>work just fine. He just thinks he needs to bit-twiddle because that's 
</I>&gt;<i>how he's used to doing things, and he
</I>&gt;<i>wouldn't even think to just use an array of booleans because he can't 
</I>&gt;<i>make that mental leap.
</I>&gt;<i>
</I>Or maybe, just maybe, an array of booleans is a crap fit for the job. I 
don't know how Java stores booleans internally - I know C stores one 
boolean per byte. Crap, because it wastes a hell of a lot of (maybe) 
precious memory. Maybe Java's crap the same way, maybe not.

I've used PL/1. That stores booleans efficiently (as bits). But it bit 
(sorry for the pun) many programmers, because it went from most to least 
significant. Pass &quot;true&quot; between PL/1 and FORTRAN and the result was a 
disaster because FORTRAN, iirc, went from least to most - anyway, on the 
system I used there were big red warnings to be careful everywhere.
&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Because javac is meant to convert java source accurately to java 
</I>&gt;&gt;&gt;&gt;<i>bytecode. While Antlr is meant to (and does) accurately convert its 
</I>&gt;&gt;&gt;&gt;<i>sourcecode into a lexer/parser/treewalker, it is also designed to 
</I>&gt;&gt;&gt;&gt;<i>let do things beyond the power of the tool. Both fit their design 
</I>&gt;&gt;&gt;&gt;<i>aims  - javac creates a java program, Antlr creates an extensible 
</I>&gt;&gt;&gt;&gt;<i>lexer/parser/treewalker. Both are *good* tools, that doesn't 
</I>&gt;&gt;&gt;&gt;<i>necessarily mean they are *great* tools.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> At the end of the day, I think your definition of &quot;great&quot; is badly 
</I>&gt;&gt;&gt;&gt;<i>flawed - &quot;a great tool lets a mediocre programmer do a decent job&quot;. 
</I>&gt;&gt;&gt;&gt;<i>A great programmer could probably outperform that mediocre 
</I>&gt;&gt;&gt;&gt;<i>programmer without that tool.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Heh, it's been a while since I heard the &quot;A great programmer can 
</I>&gt;&gt;&gt;<i>write better code than the compiler&quot; line.
</I>&gt;&gt;&gt;<i> Used to hear that a lot 20 years ago, not much any more.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I gather the statistics still hold true. The best programmers still 
</I>&gt;&gt;<i>outperform the average ones by about 1000% ... that's a MASSIVE 
</I>&gt;&gt;<i>difference.
</I>&gt;<i>
</I>&gt;<i>Yea, that's about right. But the best compilers now outperform the best 
</I>&gt;<i>programmers at compiling. We're
</I>&gt;<i>comparing people to tools above, not people to people.
</I>&gt;<i>
</I>Forth, anyone?

But, to get back to Antlr, Antlr is a compiler for grammars. There are 
things we cannot tell Antlr how to do, because we don't have the 
knowledge to be able to specify it. So Antlr is the best compiler 
possible, but it can't do the full job. So we design Antlr so that 
people can build on what Antlr has done ...
&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The greater the tool, the greater the level of maturity required to 
</I>&gt;&gt;&gt;&gt;<i>able to use it safely.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If you want to use that meaning for &quot;great&quot;, that's fine. But I do 
</I>&gt;&gt;&gt;<i>disagree. If you had one space shuttle
</I>&gt;&gt;&gt;<i> that was completely safe and automated, that would be a &quot;greater&quot; 
</I>&gt;&gt;&gt;<i>tool than one that requires maturity, IMO.
</I>&gt;&gt;&gt;<i> Especially if you have millions of shuttle pilots, and not just a few.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You've obviously not read Dick Feynmann then ... :-) even *I* could 
</I>&gt;&gt;<i>fly the space shuttle :-)
</I>&gt;<i>
</I>&gt;<i>&quot;Surely You're Joking!&quot; ;) Maybe you could point me to where he talks 
</I>&gt;<i>about this issue,
</I>&gt;<i>because I don't remember it.
</I>&gt;<i>
</I>Well, the take-off is all done by George. Flying it in space is just a 
matter of pointing it where you want to go. And the landing was mostly 
done by George - the only thing the pilot (used to) did was press the 
red button to lower the landing gear.

And Dick said &quot;Whatever for? Either let the guy fly the thing properly, 
or take responsibility for it away completely&quot;.

So, basically, while the pilot is also the captain of the shuttle, his 
job is 99.99% being captain, and 0.01% being pilot ... being pilot means 
sitting back and letting George do the job.
&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Fine. Since Java is such a great language, let's see you write the 
</I>&gt;&gt;<i>BIOS for all new computers in it ... what? you mean all new computers 
</I>&gt;&gt;<i>will be bricks if you do? What a crap tool ...
</I>&gt;<i>
</I>&gt;<i>Just because a car can't fly doesn't mean it's not a great tool. ;)
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Oh - and as for &quot;we smart programmers&quot;, you do realise you've just 
</I>&gt;&gt;<i>disqualified yourself as a member of that set? You used the word &quot;we&quot;! 
</I>&gt;&gt;<i>If the &quot;other&quot; guy respects you, he'll do as you say. I've done some 
</I>&gt;&gt;<i>crazy things in my time, like using a goto in C :-) But when other 
</I>&gt;&gt;<i>programmers have said &quot;you shouldn't do that&quot; I've just said &quot;well, 
</I>&gt;&gt;<i>you do better&quot;. Usually, they've looked at the problem to be solved, 
</I>&gt;&gt;<i>and backed down. If you're a smart programmer, you'll show the other 
</I>&gt;&gt;<i>guy how to do it better. If you can't, he's smarter than you thought!
</I>&gt;<i>
</I>&gt;<i>I'll take that challenge...show me a piece of code that really needs a 
</I>&gt;<i>goto, and I'll remove it (assuming you let me rewrite
</I>&gt;<i>the whole darn thing if I need to).
</I>&gt;<i>
</I>I won't let you rewrite the spec, because I didn't write that. It 
contained two fairly convoluted flow charts, with a goto jumping across 
from one path into the other. Basically, an outer if/then/else, and 
then, at just one point half way down the if, under a certain condition 
it jumped across into the else.

I have no doubt you could refactor the code to remove the goto. But you 
would have quadrupled the size of the source, and destroyed any 
resemblance to the specification. And imho, clarity of the source and 
visible adherence to the client spec are much more important than 
&quot;theoretical purity&quot;. Oh - and despite the goto, the spec was provably 
correct and the simplest definition of the client's problem.
&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;Perfection is achieved, not when everything that is necessary has 
</I>&gt;&gt;<i>been added, but when everything that is unnecessary has been taken 
</I>&gt;&gt;<i>away&quot;.
</I>&gt;<i>
</I>&gt;<i>And so it is with C++ and Java.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I *know* I'm an expert in DATABASIC. I would *like* to *think* I'm a 
</I>&gt;&gt;<i>guru, but until somebody like Jim, or Rob, or Monty, tells me I am 
</I>&gt;&gt;<i>(and I probably wouldn't believe Monty), then I'm not! And even then, 
</I>&gt;&gt;<i>I wouldn't believe them unless other people I trusted agreed with them.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ask Loring what unnecessary stuff can be removed from Antlr. Ask Ter. 
</I>&gt;&gt;<i>Ask Jim. Ask Monty. Ask the people *YOU* *RESPECT* *AS* *EXPERTS* (or 
</I>&gt;&gt;<i>aren't there any such on this list? :-)
</I>&gt;<i>
</I>&gt;<i>Ask Bjourne what unnecessary stuff can be removed from C++. Now ask 
</I>&gt;<i>Gosling. Often, the experts are the
</I>&gt;<i>exact wrong people to ask.
</I>&gt;<i>
</I>I went on about &quot;completeness&quot;. Yes I know Godel's theorem (well, sort 
of), but a lot of things may be like the top quark, or the Higgs Boson. 
As far as we know, they don't exist and we don't need them, but we need 
a place for them to exist or the theory is incomplete. The reason C++ is 
bigger than Java may be because the extra stuff is &quot;needed&quot; for 
completeness. I strongly suspect it is.

Programmers are very poor at seeing the &quot;problem space&quot;. That's why so 
many programs crash when they hit an error. Those features you see as 
&quot;superfluous&quot; may well exist because Bjarne (spell his name right - it 
took me several attempts before I realised who you were talking about) 
mapped out the problem space, and there was a feature-shaped hole.

I've regularly come across &quot;neat features&quot; that someone wants to add to 
a tool, and my immediate reaction is &quot;you don't understand the 
philosophy behind the tool. That feature doesn't exist because it 
doesn't belong!&quot;. I'm not saying those sort of features haven't made 
their way into C++ or Java. But it wouldn't surprise me if many features 
are there because they DO belong, even if they LOOK superfluous.

And Antlr looks to me as though Ter *has* thought things through, and it 
has the features it has precisely because they DO belong, whether they 
seem superfluous or not. And if they're not what you want, it's because 
you've picked the wrong tool for the job.
&gt;&gt;<i>
</I>&gt;&gt;<i> I think you'll find everything in Antlr is there because it's needed. 
</I>&gt;&gt;<i>Like ASTs for example - I think they happen to be a perfect solution 
</I>&gt;&gt;<i>to my problem :-)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I know Antlr doesn't do what you want. So stop trying to drive screws 
</I>&gt;&gt;<i>with a hammer, and go find yourself a screwdriver :-) Don't try and 
</I>&gt;&gt;<i>ban hammers :-)
</I>&gt;<i>
</I>&gt;<i>You do understand that I'm not trying to &quot;disable&quot; or &quot;take away 
</I>&gt;<i>features&quot; from ANTLR, right?
</I>&gt;<i>I think it's perfectly reasonable for someone to post his crazy dreams 
</I>&gt;<i>for an &quot;electric hammer&quot; on
</I>&gt;<i>a &quot;Joe's hammer&quot; forum. If you don't want to read it, then don't.
</I>&gt;<i>
</I>Then why go on about a possible future Antlr v4, that isn't &quot;Antlr as we 
know it&quot;?

Cheers,
Wol
-- 
Anthony W. Youngman - <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">anthony at thewolery.demon.co.uk</A>

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018240.html">[antlr-interest] Java boolean type storage
</A></li>
	<LI>Next message: <A HREF="018264.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18238">[ date ]</a>
              <a href="thread.html#18238">[ thread ]</a>
              <a href="subject.html#18238">[ subject ]</a>
              <a href="author.html#18238">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
