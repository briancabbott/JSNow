<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] C++ code target
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20C%2B%2B%20code%20target&In-Reply-To=%3C00a801c77898%247534b8a0%245f9e29e0%24%40com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020060.html">
   <LINK REL="Next"  HREF="020061.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] C++ code target</H1>
    <B>Don Caton</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20C%2B%2B%20code%20target&In-Reply-To=%3C00a801c77898%247534b8a0%245f9e29e0%24%40com%3E"
       TITLE="[antlr-interest] C++ code target">dcaton at shorelinesoftware.com
       </A><BR>
    <I>Fri Apr  6 15:10:58 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="020060.html">[antlr-interest] C++ code target
</A></li>
        <LI>Next message: <A HREF="020061.html">[antlr-interest] Manipulating lexer text output
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20105">[ date ]</a>
              <a href="thread.html#20105">[ thread ]</a>
              <a href="subject.html#20105">[ subject ]</a>
              <a href="author.html#20105">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jim:

I don't really _need_ a C++ interface, I was just hoping to convince Ric not
to make the same mistake again with Antlr 3.  I can understand not going
back and adding Unicode support to Antlr 2.x, but IMO there is no good
reason for not building in Unicode support right from the start in any new
implementation.  

This is 2007 after all.  Unicode isn't something new, and we're long past
the point where everyone using a computer uses an 8-bit character set.  It
just doesn't make sense for a parsing tool like Antlr to be restricted to
parsing 8-bit characters.  I have a feeling most of the people around here
aren't Windows programmers, but surely the Mac and Linux are Unicode by now,
aren't they?

In any case, sounds like you've got it covered in the C implementation.
Unfortunately, it's too late to consider using Antlr 3 for our product as we
are going to ship by July 30 and it would be suicide to rewrite all our
parsers right now (there are 5 of them).  I'll have a look at the C
implementation for our next release though.

--
Don


&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Jim Idle
</I>&gt;<i> Sent: Tuesday, April 03, 2007 2:49 PM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Subject: Re: [antlr-interest] C++ code target
</I>&gt;<i> 
</I>&gt;<i> What the C implementation does is deal with everything internally a
</I>&gt;<i> UTF-32, you can then supply an input stream that provides each
</I>&gt;<i> character
</I>&gt;<i> as a 32 bit value, regardless of the input encoding (which the input
</I>&gt;<i> stream is responsible for dealing with). Because all the library code
</I>&gt;<i> then deal with 32 bit characters regardless of the input stream,
</I>&gt;<i> there
</I>&gt;<i> is no need for anything to know about the size of th incoming
</I>&gt;<i> characters
</I>&gt;<i> except the input stream itself, which may need to know how to rest to
</I>&gt;<i> a
</I>&gt;<i> specific character offset etc. The advantage is that there is little
</I>&gt;<i> if
</I>&gt;<i> any overhead. The token stream holds offsets that the input stream
</I>&gt;<i> knows
</I>&gt;<i> how to convert to 'strings' if they are referenced. There is
</I>&gt;<i> currently
</I>&gt;<i> support for latin-1 and UTF-16 (UCS2 I suppose) input streams and
</I>&gt;<i> string
</I>&gt;<i> manipulations for both (which will probably be easier to handle in
</I>&gt;<i> C++ I
</I>&gt;<i> suspect ;-).
</I>&gt;<i> 
</I>&gt;<i> If you really need a C++ interface and cannot wait for Ric's
</I>&gt;<i> implementation, then you could use the C output and create a wrapper
</I>&gt;<i> class for it? I was thinking of adding this to the output for C
</I>&gt;<i> anyway
</I>&gt;<i> in fact so that you could include the header and it would be a class
</I>&gt;<i> definition if asked for.
</I>&gt;<i> 
</I>&gt;<i> Ter - perhaps we can consider that ability for a target to define
</I>&gt;<i> multiple output files (call lots of templates like headerfile() with
</I>&gt;<i> the
</I>&gt;<i> same input as headerfile/outputfile ?). This would make it a bit
</I>&gt;<i> neater
</I>&gt;<i> to generate a COM interface for instance - however it can all be done
</I>&gt;<i> in
</I>&gt;<i> the same header file in the end of course, with # define.
</I>&gt;<i> 
</I>&gt;<i> Jim
</I>&gt;<i> 
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020060.html">[antlr-interest] C++ code target
</A></li>
	<LI>Next message: <A HREF="020061.html">[antlr-interest] Manipulating lexer text output
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20105">[ date ]</a>
              <a href="thread.html#20105">[ thread ]</a>
              <a href="subject.html#20105">[ subject ]</a>
              <a href="author.html#20105">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
