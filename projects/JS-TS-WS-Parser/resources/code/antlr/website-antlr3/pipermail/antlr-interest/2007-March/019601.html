<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] C# parser grammar problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20C%23%20parser%20grammar%20problem&In-Reply-To=%3CC9B1CEEA-8C06-4A08-88CE-A99D44718227%40cs.usfca.edu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019600.html">
   <LINK REL="Next"  HREF="019603.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] C# parser grammar problem</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20C%23%20parser%20grammar%20problem&In-Reply-To=%3CC9B1CEEA-8C06-4A08-88CE-A99D44718227%40cs.usfca.edu%3E"
       TITLE="[antlr-interest] C# parser grammar problem">parrt at cs.usfca.edu
       </A><BR>
    <I>Tue Mar  6 10:44:50 PST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="019600.html">[antlr-interest] C# parser grammar problem
</A></li>
        <LI>Next message: <A HREF="019603.html">[antlr-interest] C# parser grammar problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19601">[ date ]</a>
              <a href="thread.html#19601">[ thread ]</a>
              <a href="subject.html#19601">[ subject ]</a>
              <a href="author.html#19601">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi.  That line in the code indicates a malformed \uxxxx cha ref.  Do  
you see one in your code?

Ter
On Mar 6, 2007, at 9:33 AM, Johannes Luber wrote:

&gt;<i> Hello,
</I>&gt;<i>
</I>&gt;<i> I've converted all the rules in chapter 9 of the Ecma334-PDF, so I
</I>&gt;<i> wanted to check, if I wrote the grammar correctly so far. The grammar
</I>&gt;<i> check is successful, but still I can't generate the corresponding java
</I>&gt;<i> files. The console spits the following out exception out:
</I>&gt;<i>
</I>&gt;<i> java.lang.StringIndexOutOfBoundsException: String index out of  
</I>&gt;<i> range: 7
</I>&gt;<i> 	at java.lang.String.substring(Unknown Source)
</I>&gt;<i> 	at
</I>&gt;<i> org.antlr.tool.Grammar.getUnescapedStringFromGrammarStringLiteral 
</I>&gt;<i> (Grammar.java:1432)
</I>&gt;<i> 	at org.antlr.tool.ANTLRLexer.mCHAR_LITERAL(ANTLRLexer.java:957)
</I>&gt;<i> 	at org.antlr.tool.ANTLRLexer.nextToken(ANTLRLexer.java:215)
</I>&gt;<i> 	at
</I>&gt;<i> antlr.TokenStreamRewriteEngine.nextToken 
</I>&gt;<i> (TokenStreamRewriteEngine.java:161)
</I>&gt;<i> 	at antlr.TokenBuffer.fill(TokenBuffer.java:69)
</I>&gt;<i> 	at antlr.TokenBuffer.LA(TokenBuffer.java:80)
</I>&gt;<i> 	at antlr.LLkParser.LA(LLkParser.java:52)
</I>&gt;<i> 	at org.antlr.tool.ANTLRParser.ruleScopeSpec(ANTLRParser.java:1509)
</I>&gt;<i> 	at org.antlr.tool.ANTLRParser.rule(ANTLRParser.java:1310)
</I>&gt;<i> 	at org.antlr.tool.ANTLRParser.rules(ANTLRParser.java:702)
</I>&gt;<i> 	at org.antlr.tool.ANTLRParser.grammar(ANTLRParser.java:392)
</I>&gt;<i> 	at org.antlr.tool.Grammar.setGrammarContent(Grammar.java:507)
</I>&gt;<i> 	at org.antlr.tool.Grammar.setGrammarContent(Grammar.java:484)
</I>&gt;<i> 	at org.antlr.works.grammar.EngineGrammar.createNewGrammar(Unknown  
</I>&gt;<i> Source)
</I>&gt;<i> 	at org.antlr.works.grammar.EngineGrammar.createCombinedGrammar 
</I>&gt;<i> (Unknown
</I>&gt;<i> Source)
</I>&gt;<i> 	at org.antlr.works.grammar.EngineGrammar.createGrammars(Unknown  
</I>&gt;<i> Source)
</I>&gt;<i> 	at org.antlr.works.grammar.EngineGrammar.getParserGrammar(Unknown  
</I>&gt;<i> Source)
</I>&gt;<i> 	at org.antlr.works.generate.CodeGenerate.getGrammarLanguage 
</I>&gt;<i> (Unknown Source)
</I>&gt;<i> 	at org.antlr.works.menu.MenuGenerate.isKnownLanguage(Unknown Source)
</I>&gt;<i> 	at org.antlr.works.menu.MenuGenerate.checkLanguage(Unknown Source)
</I>&gt;<i> 	at
</I>&gt;<i> org.antlr.works.menu.MenuGenerate.generateCodeProcessContinued(Unknown
</I>&gt;<i> Source)
</I>&gt;<i> 	at org.antlr.works.menu.MenuGenerate.checkGrammarDidEnd(Unknown  
</I>&gt;<i> Source)
</I>&gt;<i> 	at org.antlr.works.grammar.CheckGrammar.run(Unknown Source)
</I>&gt;<i> 	at java.lang.Thread.run(Unknown Source)
</I>&gt;<i>
</I>&gt;<i> I have no idea, where my mistake could lie. I hope that someone can  
</I>&gt;<i> shed
</I>&gt;<i> some light onto this. The grammar is attached to the email.
</I>&gt;<i>
</I>&gt;<i> Thanks in advance,
</I>&gt;<i> Johannes Luber
</I>&gt;<i> /* By Johannes Luber, 2007. All rights reserved.
</I>&gt;<i>
</I>&gt;<i> Converted original grammar in Ecma 334 into ANTLR syntax, removed  
</I>&gt;<i> left recursion and
</I>&gt;<i> collapsed rules like A:B?, B: C+ into A: C*.
</I>&gt;<i>
</I>&gt;<i> TBD: Convert rules containing only token references like 'd' or 'a'  
</I>&gt;<i> |'b' in lexer rules (ALL_UPPER_CASE)
</I>&gt;<i>
</I>&gt;<i> */
</I>&gt;<i>
</I>&gt;<i> grammar CSharp3;
</I>&gt;<i>
</I>&gt;<i> // Grammar Ambiguities described in &#167;9.2.3 in Ecma 334
</I>&gt;<i>
</I>&gt;<i> // Intrinsic Datatypes: object, string, bool, char, decimal, sbyte,  
</I>&gt;<i> short,
</I>&gt;<i> // int, long, byte, ushort, unit, ulong, float, double
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i> 	language=CSharp;
</I>&gt;<i> 	output=template;
</I>&gt;<i> 	//namespace	= &quot;CSharpML.CSharpParser&quot;;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @header {
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> input
</I>&gt;<i> 	:	input_section*
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> input_section
</I>&gt;<i> 	:	input_element* NEW_LINE
</I>&gt;<i> 	|	pp_directive
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> input_element
</I>&gt;<i> 	:	whitespace
</I>&gt;<i> 	|	comment
</I>&gt;<i> 	|	token
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> whitespace
</I>&gt;<i> 	:	WHITESPACE_CHARACTER*
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment WHITESPACE_CHARACTER
</I>&gt;<i> 	:	UNICODE_CLASS_Zs
</I>&gt;<i> 	|	'\u0009' // Horizontal tab character
</I>&gt;<i> 	|	'\u000B' // Vertical tab character
</I>&gt;<i> 	|	'\u000C' // Form feed character
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> NEW_LINE
</I>&gt;<i> 	:	'\u000D' // Carriage return character
</I>&gt;<i> 	|	'\u000A' // Line feed character
</I>&gt;<i> 	|	'\u000D\u000A' // Carriage return character followed by line  
</I>&gt;<i> feed character
</I>&gt;<i> 	|	'\u2085' // Next line character
</I>&gt;<i> 	|	'\u2028' // Line separator character
</I>&gt;<i> 	|	'\u2029' // Paragraph separator character
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> comment
</I>&gt;<i> 	:	single_line_comment
</I>&gt;<i> 	|	delimited_comment
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> single_line_comment
</I>&gt;<i> 	:	'//' INPUT_CHARACTER*
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> 	
</I>&gt;<i> fragment INPUT_CHARACTER
</I>&gt;<i> 	:	~NEW_LINE_CHARACTER // Any Unicode character except a  
</I>&gt;<i> new_line_character
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> NEW_LINE_CHARACTER
</I>&gt;<i> 	:	'\u000D' // Carriage return character
</I>&gt;<i> 	|	'\u000A' // Line feed character
</I>&gt;<i> 	|	'\u0085' // Next line character
</I>&gt;<i> 	|	'\u2028' // Line separator character
</I>&gt;<i> 	|	'\u2029' // Paragraph separator character
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> delimited_comment
</I>&gt;<i> 	:	'/*' DELIMITED_COMMENT_SECTION* ASTERISKS '/'
</I>&gt;<i> 	;
</I>&gt;<i> 		
</I>&gt;<i> fragment DELIMITED_COMMENT_SECTION
</I>&gt;<i> 	:	NOT_ASTERISK
</I>&gt;<i> 	|	ASTERISKS NOT_SLASH
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment ASTERISKS
</I>&gt;<i> 	:	('*') ('*')*
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment NOT_ASTERISK
</I>&gt;<i> 	:	~'*' // Any Unicode character except *
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment NOT_SLASH
</I>&gt;<i> 	:	~'/' // Any Unicode character except /
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment UNICODE_CLASS_Zs // Any character with Unicode class Zs  
</I>&gt;<i> (18 characters known)
</I>&gt;<i> 	:	'\u0020' // SPACE
</I>&gt;<i> 	|	'\u00A0' // NO_BREAK SPACE
</I>&gt;<i> 	|	'\u1680' // OGHAM SPACE MARK
</I>&gt;<i> 	|	'\u180E' // MONGOLIAN VOWEL SEPARATOR
</I>&gt;<i> 	|	'\u2000' // EN QUAD
</I>&gt;<i> 	|	'\u2001' // EM QUAD
</I>&gt;<i> 	|	'\u2002' // EN SPACE
</I>&gt;<i> 	|	'\u2003' // EM SPACE
</I>&gt;<i> 	|	'\u2004' // THREE_PER_EM SPACE
</I>&gt;<i> 	|	'\u2005' // FOUR_PER_EM SPACE
</I>&gt;<i> 	|	'\u2006' // SIX_PER_EM SPACE
</I>&gt;<i> 	|	'\u2008' // PUNCTUATION SPACE
</I>&gt;<i> 	|	'\u2009' // THIN SPACE
</I>&gt;<i> 	|	'\u200A' // HAIR SPACE
</I>&gt;<i> 	|	'\u202F' // NARROW NO_BREAK SPACE
</I>&gt;<i> 	|	'\u3000' // IDEOGRAPHIC SPACE
</I>&gt;<i> 	|	'\u205F' // MEDIUM MATHEMATICAL SPACE
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all uppercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassLu.g.
</I>&gt;<i> fragment UNICODE_CLASS_Lu
</I>&gt;<i> 	:	'\u0041'..'\u005A' // LATIN CAPITAL LETTER A_Z
</I>&gt;<i> 	|	'\u00C0'..'\u00DE' // ACCENTED CAPITAL LETTERS
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all lowercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassLl.g.
</I>&gt;<i> fragment UNICODE_CLASS_Ll
</I>&gt;<i> 	:	'\u0061'..'\u007A' // LATIN SMALL LETTER a_z
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all titlecase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassLt.g.
</I>&gt;<i> fragment UNICODE_CLASS_Lt
</I>&gt;<i> 	:	'\u01C5' // LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
</I>&gt;<i> 	|	'\u01C8' // LATIN CAPITAL LETTER L WITH SMALL LETTER J
</I>&gt;<i> 	|	'\u01CB' // LATIN CAPITAL LETTER N WITH SMALL LETTER J
</I>&gt;<i> 	|	'\u01F2' // LATIN CAPITAL LETTER D WITH SMALL LETTER Z
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all modifier letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassLm.g.
</I>&gt;<i> fragment UNICODE_CLASS_Lm
</I>&gt;<i> 	:	'\u02B0'..'\u02EE' // MODIFIER LETTERS
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all other letter characters. Replace this rule  
</I>&gt;<i> with the one in UnicodeClassLo.g.
</I>&gt;<i> fragment UNICODE_CLASS_Lo
</I>&gt;<i> 	:	'\u01BB' // LATIN LETTER TWO WITH STROKE
</I>&gt;<i> 	|	'\u01C0' // LATIN LETTER DENTAL CLICK
</I>&gt;<i> 	|	'\u01C1' // LATIN LETTER LATERAL CLICK
</I>&gt;<i> 	|	'\u01C2' // LATIN LETTER ALVEOLAR CLICK
</I>&gt;<i> 	|	'\u01C3' // LATIN LETTER RETROFLEX CLICK
</I>&gt;<i> 	|	'\u0294' // LATIN LETTER GLOTTAL STOP
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all uppercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassNl.g.
</I>&gt;<i> fragment UNICODE_CLASS_Nl
</I>&gt;<i> 	:	'\u16EE' // RUNIC ARLAUG SYMBOL
</I>&gt;<i> 	|	'\u16EF' // RUNIC TVIMADUR SYMBOL
</I>&gt;<i> 	|	'\u16F0' // RUNIC BELGTHOR SYMBOL
</I>&gt;<i> 	|	'\u2160' // ROMAN NUMERAL ONE
</I>&gt;<i> 	|	'\u2161' // ROMAN NUMERAL TWO
</I>&gt;<i> 	|	'\u2162' // ROMAN NUMERAL THREE
</I>&gt;<i> 	|	'\u2163' // ROMAN NUMERAL FOUR
</I>&gt;<i> 	|	'\u2164' // ROMAN NUMERAL FIVE
</I>&gt;<i> 	|	'\u2165' // ROMAN NUMERAL SIX
</I>&gt;<i> 	|	'\u2166' // ROMAN NUMERAL SEVEN
</I>&gt;<i> 	|	'\u2167' // ROMAN NUMERAL EIGHT
</I>&gt;<i> 	|	'\u2168' // ROMAN NUMERAL NINE
</I>&gt;<i> 	|	'\u2169' // ROMAN NUMERAL TEN
</I>&gt;<i> 	|	'\u216A' // ROMAN NUMERAL ELEVEN
</I>&gt;<i> 	|	'\u216B' // ROMAN NUMERAL TWELVE
</I>&gt;<i> 	|	'\u216C' // ROMAN NUMERAL FIFTY
</I>&gt;<i> 	|	'\u216D' // ROMAN NUMERAL ONE HUNDRED
</I>&gt;<i> 	|	'\u216E' // ROMAN NUMERAL FIVE HUNDRED
</I>&gt;<i> 	|	'\u216F' // ROMAN NUMERAL ONE THOUSAND
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all uppercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassMn.g.
</I>&gt;<i> fragment UNICODE_CLASS_Mn
</I>&gt;<i> 	:	'\u0300' // COMBINING GRAVE ACCENT
</I>&gt;<i> 	|	'\u0301' // COMBINING ACUTE ACCENT
</I>&gt;<i> 	|	'\u0302' // COMBINING CIRCUMFLEX ACCENT
</I>&gt;<i> 	|	'\u0303' // COMBINING TILDE
</I>&gt;<i> 	|	'\u0304' // COMBINING MACRON
</I>&gt;<i> 	|	'\u0305' // COMBINING OVERLINE
</I>&gt;<i> 	|	'\u0306' // COMBINING BREVE
</I>&gt;<i> 	|	'\u0307' // COMBINING DOT ABOVE
</I>&gt;<i> 	|	'\u0308' // COMBINING DIAERESIS
</I>&gt;<i> 	|	'\u0309' // COMBINING HOOK ABOVE
</I>&gt;<i> 	|	'\u030A' // COMBINING RING ABOVE
</I>&gt;<i> 	|	'\u030B' // COMBINING DOUBLE ACUTE ACCENT
</I>&gt;<i> 	|	'\u030C' // COMBINING CARON
</I>&gt;<i> 	|	'\u030D' // COMBINING VERTICAL LINE ABOVE
</I>&gt;<i> 	|	'\u030E' // COMBINING DOUBLE VERTICAL LINE ABOVE
</I>&gt;<i> 	|	'\u030F' // COMBINING DOUBLE GRAVE ACCENT
</I>&gt;<i> 	|	'\u0310' // COMBINING CANDRABINDU
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all uppercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassMc.g.
</I>&gt;<i> fragment UNICODE_CLASS_Mc
</I>&gt;<i> 	:	'\u0903' // DEVANAGARI SIGN VISARGA
</I>&gt;<i> 	|	'\u093E' // DEVANAGARI VOWEL SIGN AA
</I>&gt;<i> 	|	'\u093F' // DEVANAGARI VOWEL SIGN I
</I>&gt;<i> 	|	'\u0940' // DEVANAGARI VOWEL SIGN II
</I>&gt;<i> 	|	'\u0949' // DEVANAGARI VOWEL SIGN CANDRA O
</I>&gt;<i> 	|	'\u094A' // DEVANAGARI VOWEL SIGN SHORT O
</I>&gt;<i> 	|	'\u094B' // DEVANAGARI VOWEL SIGN O
</I>&gt;<i> 	|	'\u094C' // DEVANAGARI VOWEL SIGN AU
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all uppercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassCf.g.
</I>&gt;<i> fragment UNICODE_CLASS_Cf
</I>&gt;<i> 	:	'\u00AD' // SOFT HYPHEN
</I>&gt;<i> 	|	'\u0600' // ARABIC NUMBER SIGN
</I>&gt;<i> 	|	'\u0601' // ARABIC SIGN SANAH
</I>&gt;<i> 	|	'\u0602' // ARABIC FOOTNOTE MARKER
</I>&gt;<i> 	|	'\u0603' // ARABIC SIGN SAFHA
</I>&gt;<i> 	|	'\u06DD' // ARABIC END OF AYAH
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // This definition contains all known characters
</I>&gt;<i> fragment UNICODE_CLASS_Pc
</I>&gt;<i> 	:	'\u005F' // LOW LINE
</I>&gt;<i> 	|	'\u203F' // UNDERTIE
</I>&gt;<i> 	|	'\u2040' // CHARACTER TIE
</I>&gt;<i> 	|	'\u2054' // INVERTED UNDERTIE
</I>&gt;<i> 	|	'\uFE33' // PRESENTATION FORM FOR VERTICAL LOW LINE
</I>&gt;<i> 	|	'\uFE34' // PRESENTATION FORM FOR VERTICAL WAVY LOW LINE
</I>&gt;<i> 	|	'\uFE4D' // DASHED LOW LINE
</I>&gt;<i> 	|	'\uFE4E' // CENTRELINE LOW LINE
</I>&gt;<i> 	|	'\uFE4F' // WAVY LOW LINE
</I>&gt;<i> 	|	'\uFF3F' // FULLWIDTH LOW LINE
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // TBD: Inclusion of all uppercase letter characters. Replace this  
</I>&gt;<i> rule with the one in UnicodeClassNd.g.
</I>&gt;<i> fragment UNICODE_CLASS_Nd
</I>&gt;<i> 	:	'\u0030' // DIGIT ZERO
</I>&gt;<i> 	|	'\u0031' // DIGIT ONE
</I>&gt;<i> 	|	'\u0032' // DIGIT TWO
</I>&gt;<i> 	|	'\u0033' // DIGIT THREE
</I>&gt;<i> 	|	'\u0034' // DIGIT FOUR
</I>&gt;<i> 	|	'\u0035' // DIGIT FIVE
</I>&gt;<i> 	|	'\u0036' // DIGIT SIX
</I>&gt;<i> 	|	'\u0037' // DIGIT SEVEN
</I>&gt;<i> 	|	'\u0038' // DIGIT EIGHT
</I>&gt;<i> 	|	'\u0039' // DIGIT NINE
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> token
</I>&gt;<i> 	:	identifier
</I>&gt;<i> 	|	KEYWORD[true] // Use all keywords
</I>&gt;<i> 	|	integer_literal
</I>&gt;<i> 	|	real_literal
</I>&gt;<i> 	|	character_literal
</I>&gt;<i> 	|	string_literal
</I>&gt;<i> 	|	OPREATER_OR_PUNCTUATOR
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> identifier
</I>&gt;<i> 	:	available_identifier
</I>&gt;<i> 	|	'@' identifier_or_keyword[true]
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment available_identifier
</I>&gt;<i> 	:	identifier_or_keyword[false] // An identifier_or_keyword that is  
</I>&gt;<i> not a keyword
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // The booleean allowKeywords determines, if identifier_or_keyword  
</I>&gt;<i> may actually include keywords in the current context.
</I>&gt;<i> fragment identifier_or_keyword[bool allowKeywords]
</I>&gt;<i> 	:	identifier_start_character identifier_part_character*
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment identifier_start_character
</I>&gt;<i> 	:	letter_character
</I>&gt;<i> 	|	'_' // (the underscore character U+005F)
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment identifier_part_character
</I>&gt;<i> 	:	letter_character
</I>&gt;<i> 	|	decimal_digit_character
</I>&gt;<i> 	|	connecting_character
</I>&gt;<i> 	|	combining_character
</I>&gt;<i> 	|	formatting_character
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment letter_character
</I>&gt;<i> 	:	UNICODE_CLASS_Lu // A Unicode character of classes Lu, Ll, Lt,  
</I>&gt;<i> Lm, Lo, or Nl
</I>&gt;<i> 	|	UNICODE_CLASS_Ll
</I>&gt;<i> 	|	UNICODE_CLASS_Lt
</I>&gt;<i> 	|	UNICODE_CLASS_Lm
</I>&gt;<i> 	|	UNICODE_CLASS_Lo
</I>&gt;<i> 	|	UNICODE_CLASS_Nl
</I>&gt;<i> 	|	unicode_escape_sequence[&quot;LAndNl&quot;] // An encoded character of  
</I>&gt;<i> classes Lu, Ll, Lt, Lm, Lo, or Nl
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment combining_character
</I>&gt;<i> 	:	UNICODE_CLASS_Mn // A Unicode character of classes Mn or Mc
</I>&gt;<i> 	|	UNICODE_CLASS_Mc
</I>&gt;<i> 	|	unicode_escape_sequence[&quot;MnAndMc&quot;] // An encoded character of  
</I>&gt;<i> classes Mn or Mc
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment decimal_digit_character
</I>&gt;<i> 	:	UNICODE_CLASS_Nd // A Unicode character of the class Nd
</I>&gt;<i> 	|	unicode_escape_sequence[&quot;Nd&quot;] // An encoded character of classes Nd
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment connecting_character
</I>&gt;<i> 	:	UNICODE_CLASS_Pc // A Unicode character of the class Pc
</I>&gt;<i> 	|	unicode_escape_sequence[&quot;Pc&quot;] // An encoded character of classes Pc
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment formatting_character
</I>&gt;<i> 	:	UNICODE_CLASS_Cf // A Unicode character of the class Cf
</I>&gt;<i> 	|	unicode_escape_sequence[&quot;Cf&quot;] // An encoded character of classes Cf
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> // Allowed unicodeClasses values are &quot;LandNl&quot;, &quot;MnAndMc&quot;, &quot;Nd&quot;,  
</I>&gt;<i> &quot;Pc&quot;, &quot;Cf&quot; and &quot;SingleCharacter&quot;
</I>&gt;<i> // The classes restrict the possible unicode values according the  
</I>&gt;<i> Unicode standard.
</I>&gt;<i> // &quot;SingleCharacter&quot; allows every value between U+0000 and U+FFFF  
</I>&gt;<i> inclusive.
</I>&gt;<i> // Detect if '\' is followed by a character not of this group: ',  
</I>&gt;<i> &quot;, \, 0, a, b, f, n, r, t, u, U, x, v
</I>&gt;<i> fragment unicode_escape_sequence[string unicodeClasses]
</I>&gt;<i> 	:	'\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
</I>&gt;<i> 	|	'\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT  
</I>&gt;<i> HEX_DIGIT HEX_DIGIT
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // This boolean allows the exclusion of the keywords 'true' and  
</I>&gt;<i> 'false'
</I>&gt;<i> KEYWORD[bool useBooleanKeywords]
</I>&gt;<i> 	:	'abstract'
</I>&gt;<i> 	|	'as'
</I>&gt;<i> 	|	'base'
</I>&gt;<i> 	|	'bool'
</I>&gt;<i> 	|	'break'
</I>&gt;<i> 	|	'byte'
</I>&gt;<i> 	|	'case'
</I>&gt;<i> 	|	'catch'
</I>&gt;<i> 	|	'char'
</I>&gt;<i> 	|	'checked'
</I>&gt;<i> 	|	'class'
</I>&gt;<i> 	|	'const'
</I>&gt;<i> 	|	'continue'
</I>&gt;<i> 	|	'decimal'
</I>&gt;<i> 	|	'default'
</I>&gt;<i> 	|	'delegate'
</I>&gt;<i> 	|	'do'
</I>&gt;<i> 	|	'double'
</I>&gt;<i> 	|	'else'
</I>&gt;<i> 	|	'enum'
</I>&gt;<i> 	|	'event'
</I>&gt;<i> 	|	'explicit'
</I>&gt;<i> 	|	'extern'
</I>&gt;<i> 	|	'false'
</I>&gt;<i> 	|	'finally'
</I>&gt;<i> 	|	'fixed'
</I>&gt;<i> 	|	'float'
</I>&gt;<i> 	|	'for'
</I>&gt;<i> 	|	'foreach'
</I>&gt;<i> 	|	'goto'
</I>&gt;<i> 	|	'if'
</I>&gt;<i> 	|	'implicit'
</I>&gt;<i> 	|	'in'
</I>&gt;<i> 	|	'int'
</I>&gt;<i> 	|	'interface'
</I>&gt;<i> 	|	'internal'
</I>&gt;<i> 	|	'is'
</I>&gt;<i> 	|	'lock'
</I>&gt;<i> 	|	'long'
</I>&gt;<i> 	|	'namespace'
</I>&gt;<i> 	|	'new'
</I>&gt;<i> 	|	'null'
</I>&gt;<i> 	|	'object'
</I>&gt;<i> 	|	'operator'
</I>&gt;<i> 	|	'out'
</I>&gt;<i> 	|	'override'
</I>&gt;<i> 	|	'params'
</I>&gt;<i> 	|	'private'
</I>&gt;<i> 	|	'protected'
</I>&gt;<i> 	|	'public'
</I>&gt;<i> 	|	'readonly'
</I>&gt;<i> 	|	'ref'
</I>&gt;<i> 	|	'return'
</I>&gt;<i> 	|	'sbyte'
</I>&gt;<i> 	|	'sealed'
</I>&gt;<i> 	|	'short'
</I>&gt;<i> 	|	'sizeof'
</I>&gt;<i> 	|	'stackalloc'
</I>&gt;<i> 	|	'static'
</I>&gt;<i> 	|	'string'
</I>&gt;<i> 	|	'struct'
</I>&gt;<i> 	|	'switch'
</I>&gt;<i> 	|	'this'
</I>&gt;<i> 	|	'throw'
</I>&gt;<i> 	|	'true'
</I>&gt;<i> 	|	'try'
</I>&gt;<i> 	|	'typeof'
</I>&gt;<i> 	|	'uint'
</I>&gt;<i> 	|	'ulong'
</I>&gt;<i> 	|	'unchecked'
</I>&gt;<i> 	|	'unsafe'
</I>&gt;<i> 	|	'ushort'
</I>&gt;<i> 	|	'using'
</I>&gt;<i> 	|	'virtual'
</I>&gt;<i> 	|	'void'
</I>&gt;<i> 	|	'volatile'
</I>&gt;<i> 	|	'while'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> BOOLEAN_LITERAL
</I>&gt;<i> 	:	'true'
</I>&gt;<i> 	|	'false'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> integer_literal
</I>&gt;<i> 	:	decimal_integer_literal
</I>&gt;<i> 	|	hexadecimal_integer_literal
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment decimal_integer_literal
</I>&gt;<i> 	:	DECIMAL_DIGIT+   INTEGER_TYPE_SUFFIX?
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment DECIMAL_DIGIT
</I>&gt;<i> 	: '0'..'9'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment INTEGER_TYPE_SUFFIX
</I>&gt;<i> 	:	'U'
</I>&gt;<i> 	|	'u'
</I>&gt;<i> 	|	'L'
</I>&gt;<i> 	|	'l'
</I>&gt;<i> 	|	'UL'
</I>&gt;<i> 	|	'Ul'
</I>&gt;<i> 	|	'uL'
</I>&gt;<i> 	|	'ul'
</I>&gt;<i> 	|	'LU'
</I>&gt;<i> 	|	'Lu'
</I>&gt;<i> 	|	'lU'
</I>&gt;<i> 	|	'lu'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment hexadecimal_integer_literal
</I>&gt;<i> 	:	'0x'   HEX_DIGIT+   INTEGER_TYPE_SUFFIX?
</I>&gt;<i> 	|	'0X'   HEX_DIGIT+   INTEGER_TYPE_SUFFIX?
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment HEX_DIGIT
</I>&gt;<i> 	:	'0'..'9'
</I>&gt;<i> 	|	'A'..'F'
</I>&gt;<i> 	|	'a'..'f'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> real_literal
</I>&gt;<i> 	:	DECIMAL_DIGIT+ '.' DECIMAL_DIGIT+ exponent_part? REAL_TYPE_SUFFIX?
</I>&gt;<i> 	|	'.' DECIMAL_DIGIT+ exponent_part? REAL_TYPE_SUFFIX?
</I>&gt;<i> 	|	DECIMAL_DIGIT+ exponent_part REAL_TYPE_SUFFIX?
</I>&gt;<i> 	|	DECIMAL_DIGIT+ REAL_TYPE_SUFFIX
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment exponent_part
</I>&gt;<i> 	:	'e' SIGN? DECIMAL_DIGIT+
</I>&gt;<i> 	|	'E' SIGN? DECIMAL_DIGIT+
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment SIGN
</I>&gt;<i> 	:	'+'
</I>&gt;<i> 	|	'-'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment REAL_TYPE_SUFFIX
</I>&gt;<i> 	:	'F'
</I>&gt;<i> 	|	'f'
</I>&gt;<i> 	|	'D'
</I>&gt;<i> 	|	'd'
</I>&gt;<i> 	|	'M'
</I>&gt;<i> 	|	'm'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> character_literal
</I>&gt;<i> 	:	''' character '''
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment character
</I>&gt;<i> 	:	SINGLE_CHARACTER
</I>&gt;<i> 	|	SIMPLE_ESCAPE_SEQUENCE
</I>&gt;<i> 	|	hexadecimal_escape_sequence
</I>&gt;<i> 	|	unicode_escape_sequence
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment SINGLE_CHARACTER
</I>&gt;<i> 	:	~(''' | '\' | NEW_LINE_CHARACTER )
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // Detect if '\' is followed by a character not of this group: ',  
</I>&gt;<i> &quot;, \, 0, a, b, f, n, r, t, u, U, x, v
</I>&gt;<i> fragment SIMPLE_ESCAPE_SEQUENCE
</I>&gt;<i> 	:	'\''
</I>&gt;<i> 	|	'\&quot;'
</I>&gt;<i> 	|	'\\'
</I>&gt;<i> 	|	'\0'
</I>&gt;<i> 	|	'\a'
</I>&gt;<i> 	|	'\b'
</I>&gt;<i> 	|	'\f'
</I>&gt;<i> 	|	'\n'
</I>&gt;<i> 	|	'\r'
</I>&gt;<i> 	|	'\t'
</I>&gt;<i> 	|	'\v'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> // Detect if '\' is followed by a character not of this group: ',  
</I>&gt;<i> &quot;, \, 0, a, b, f, n, r, t, u, U, x, v
</I>&gt;<i> fragment hexadecimal_escape_sequence
</I>&gt;<i> 	:	'\x' HEX_DIGIT HEX_DIGIT? HEX_DIGIT? HEX_DIGIT?
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> string_literal
</I>&gt;<i> 	:	regular_string_literal
</I>&gt;<i> 	|	verbatim_string_literal
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> regular_string_literal
</I>&gt;<i> 	:	'&quot;' regular_string_literal_character* '&quot;'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment regular_string_literal_character
</I>&gt;<i> 	:	SINGLE_REGULAR_STRING_LITERAL_CHARACTER
</I>&gt;<i> 	|	SIMPLE_ESCAPE_SEQUENCE
</I>&gt;<i> 	|	hexadecimal_escape_sequence
</I>&gt;<i> 	|	unicode_escape_sequence
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment SINGLE_REGULAR_STRING_LITERAL_CHARACTER
</I>&gt;<i> 	:	~( '&quot;' | '\' | NEW_LINE_CHARACTER )
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> verbatim_string_literal
</I>&gt;<i> 	:	'@&quot;' verbatim_string_literal_character* '&quot;'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> fragment verbatim_string_literal_character
</I>&gt;<i> 	:	SINGLE_VERBATIM_STRING_LITERAL_CHARACTER
</I>&gt;<i> 	|	QUTOE_ESCAPE_SEQUENCE
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment SINGLE_VERBATIM_STRING_LITERAL_CHARACTER
</I>&gt;<i> 	:	~'&quot;'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment QUTOE_ESCAPE_SEQUENCE
</I>&gt;<i> 	:	'&quot;&quot;'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> NULL_LITERAL
</I>&gt;<i> 	:	'null'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> OPREATER_OR_PUNCTUATOR
</I>&gt;<i> 	:	'{'
</I>&gt;<i> 	|	'}'
</I>&gt;<i> 	|	'['
</I>&gt;<i> 	|	']'
</I>&gt;<i> 	|	'('
</I>&gt;<i> 	|	')'
</I>&gt;<i> 	|	'.'
</I>&gt;<i> 	|	','
</I>&gt;<i> 	|	':'
</I>&gt;<i> 	|	';'
</I>&gt;<i> 	|	'+'
</I>&gt;<i> 	|	'-'
</I>&gt;<i> 	|	'*'
</I>&gt;<i> 	|	'/'
</I>&gt;<i> 	|	'%'
</I>&gt;<i> 	|	'&amp;'
</I>&gt;<i> 	|	'|'
</I>&gt;<i> 	|	'^'
</I>&gt;<i> 	|	'!'
</I>&gt;<i> 	|	'~'
</I>&gt;<i> 	|	'='
</I>&gt;<i> 	|	'&lt;'
</I>&gt;<i> 	|	'&gt;'
</I>&gt;<i> 	|	'?'
</I>&gt;<i> 	|	'??'
</I>&gt;<i> 	|	'::'
</I>&gt;<i> 	|	'++'
</I>&gt;<i> 	|	'--'
</I>&gt;<i> 	|	'&amp;&amp;'
</I>&gt;<i> 	|	'||'
</I>&gt;<i> 	|	'-&gt;'
</I>&gt;<i> 	|	'=='
</I>&gt;<i> 	|	'!='
</I>&gt;<i> 	|	'&lt;='
</I>&gt;<i> 	|	'&gt;='
</I>&gt;<i> 	|	'+='
</I>&gt;<i> 	|	'-='
</I>&gt;<i> 	|	'*='
</I>&gt;<i> 	|	'/='
</I>&gt;<i> 	|	'%='
</I>&gt;<i> 	|	'&amp;='
</I>&gt;<i> 	|	'|='
</I>&gt;<i> 	|	'^='
</I>&gt;<i> 	|	'&lt;&lt;'
</I>&gt;<i> 	|	'&lt;&lt;='
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment right_shift
</I>&gt;<i> 	:	'&gt;' '&gt;'
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> fragment right_shift_assignment
</I>&gt;<i> 	:	'&gt;' '&gt;='
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> // The compiler has to tell, if some preprocessor directives are  
</I>&gt;<i> missing or out of order (regions and conditionals)
</I>&gt;<i> pp_directive
</I>&gt;<i> 	:	pp_declaration
</I>&gt;<i> 	|	pp_conditional
</I>&gt;<i> 	|	pp_line
</I>&gt;<i> 	|	pp_diagnostic
</I>&gt;<i> 	|	pp_region
</I>&gt;<i> 	|	pp_pragma
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> conditional_symbol
</I>&gt;<i> 	:	identifier
</I>&gt;<i> 	|	KEYWORD[false] // Any keyword except 'true' or 'false'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_expression
</I>&gt;<i> 	:	whitespace? pp_or_expression whitespace?
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> pp_or_expression
</I>&gt;<i> 	:	pp_and_expression
</I>&gt;<i> 	:	pp_or_expression whitespace? '||' whitespace? pp_and_expression
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_and_expression
</I>&gt;<i> 	:	(pp_equality_expression) (whitespace? '&amp;&amp;' whitespace?  
</I>&gt;<i> pp_equality_expression)*
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_equality_expression
</I>&gt;<i> 	:	(pp_unary_expression) (whitespace? '==' whitespace?  
</I>&gt;<i> pp_unary_expression | whitespace? '!=' whitespace?  
</I>&gt;<i> pp_unary_expression)*
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_unary_expression
</I>&gt;<i> 	:	pp_primary_expression
</I>&gt;<i> 	|	'!' whitespace? pp_unary_expression
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_primary_expression
</I>&gt;<i> 	:	'true'
</I>&gt;<i> 	|	'false'
</I>&gt;<i> 	|	conditional_symbol
</I>&gt;<i> 	|	'(' whitespace? pp_expression whitespace? ')'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> The processing of a #define directive causes the given conditional  
</I>&gt;<i> compilation symbol to become defined,
</I>&gt;<i> starting with the source line that follows the directive. Likewise,  
</I>&gt;<i> the processing of a #undef directive
</I>&gt;<i> causes the given conditional compilation symbol to become  
</I>&gt;<i> undefined, starting with the source line that
</I>&gt;<i> follows the directive.
</I>&gt;<i>
</I>&gt;<i> Any #define and #undef directives in a source file shall occur  
</I>&gt;<i> before the first token (&#167;9.4) in the source
</I>&gt;<i> file; otherwise a compile-time error occurs. In intuitive terms,  
</I>&gt;<i> #define and #undef directives shall
</I>&gt;<i> precede any &#8220;real code&#8221; in the source file.
</I>&gt;<i> */
</I>&gt;<i> pp_declaration
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'define' whitespace  
</I>&gt;<i> conditional_symbol pp_new_line
</I>&gt;<i> 	|	whitespace? '#' whitespace? 'undef' whitespace  
</I>&gt;<i> conditional_symbol pp_new_line
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_new_line
</I>&gt;<i> 	:	whitespace? single_line_comment? NEW_LINE
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> A pp-conditional selects at most one of the contained conditional- 
</I>&gt;<i> sections for normal lexical processing:
</I>&gt;<i>
</I>&gt;<i> - The pp-expressions of the #if and #elif directives are evaluated  
</I>&gt;<i> in order until one yields true. If an
</I>&gt;<i> expression yields true, the conditional-section of the  
</I>&gt;<i> corresponding directive is selected.
</I>&gt;<i> - If all pp-expressions yield false, and if a #else directive is  
</I>&gt;<i> present, the conditional-section of the
</I>&gt;<i> #else directive is selected.
</I>&gt;<i> - Otherwise, no conditional-section is selected.
</I>&gt;<i>
</I>&gt;<i> The selected conditional-section, if any, is processed as a normal  
</I>&gt;<i> input-section: the source code contained in
</I>&gt;<i> the section shall adhere to the lexical grammar; tokens are  
</I>&gt;<i> generated from the source code in the section; and
</I>&gt;<i> pre-processing directives in the section have the prescribed effects.
</I>&gt;<i>
</I>&gt;<i> The remaining conditional-sections, if any, are processed as  
</I>&gt;<i> skipped-sections: except for pre-processing
</I>&gt;<i> directives, the source code in the section need not adhere to the  
</I>&gt;<i> lexical grammar; no tokens are generated
</I>&gt;<i> from the source code in the section; and pre-processing directives  
</I>&gt;<i> in the section shall be lexically correct but
</I>&gt;<i> are not otherwise processed. Within a conditional-section that is  
</I>&gt;<i> being processed as a skipped-section, any
</I>&gt;<i> nested conditional-sections (contained in nested #if...#endif and  
</I>&gt;<i> #region...#endregion constructs) are
</I>&gt;<i> also processed as skipped-sections.
</I>&gt;<i> */
</I>&gt;<i> pp_conditional
</I>&gt;<i> 	:	pp_if_section pp_elif_section* pp_else_section? pp_endif
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_if_section
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'if' whitespace pp_expression  
</I>&gt;<i> pp_new_line conditional_section?
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_elif_section
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'elif' whitespace pp_expression  
</I>&gt;<i> pp_new_line conditional_section?
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_else_section
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'else' pp_new_line conditional_section?
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_endif
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'endif' pp_new_line
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> conditional_section
</I>&gt;<i> 	:	input_section
</I>&gt;<i> 	|	skipped_section+
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> 	
</I>&gt;<i> skipped_section
</I>&gt;<i> 	:	whitespace? skipped_characters? NEW_LINE
</I>&gt;<i> 	|	pp_directive
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> skipped_characters
</I>&gt;<i> 	:	NOT_NUMBER_SIGN  INPUT_CHARACTER*
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> NOT_NUMBER_SIGN
</I>&gt;<i> 	:	~'#' // Any input_character except #
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> pp_diagnostic
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'error' pp_message
</I>&gt;<i> 	|	whitespace? '#' whitespace? 'warning' pp_message
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_message
</I>&gt;<i> 	:	NEW_LINE
</I>&gt;<i> 	|	whitespace INPUT_CHARACTER* NEW_LINE
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> No semantic meaning is attached to a region; regions are intended  
</I>&gt;<i> for use by the programmer or by
</I>&gt;<i> automated tools to mark a section of source code. The message  
</I>&gt;<i> specified in a #region or #endregion
</I>&gt;<i> directive likewise has no semantic meaning; it merely serves to  
</I>&gt;<i> identify the region. Matching
</I>&gt;<i> #region and #endregion directives can have different pp-messages.
</I>&gt;<i>
</I>&gt;<i> The lexical processing of a region:
</I>&gt;<i>
</I>&gt;<i> #region
</I>&gt;<i> ...
</I>&gt;<i> #endregion
</I>&gt;<i>
</I>&gt;<i> corresponds exactly to the lexical processing of a conditional  
</I>&gt;<i> compilation directive of the form:
</I>&gt;<i>
</I>&gt;<i> #if true
</I>&gt;<i> ...
</I>&gt;<i> #endif
</I>&gt;<i> */
</I>&gt;<i> pp_region
</I>&gt;<i> 	:	pp_start_region conditional_section? pp_end_region
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_start_region
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'region' pp_message
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_end_region
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'endregion' pp_message
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> When no #line directives are present, the compiler reports true  
</I>&gt;<i> line numbers and source file names in its
</I>&gt;<i> output. When processing a #line directive that includes a line- 
</I>&gt;<i> indicator that is not identifier-or-keyword,
</I>&gt;<i> the compiler treats the line after the directive as having the  
</I>&gt;<i> given line number (and file name, if specified).
</I>&gt;<i>
</I>&gt;<i> A #line directive in which the line-indicator is an identifier-or- 
</I>&gt;<i> keyword whose value equals default
</I>&gt;<i> (using equality as specified in &#167;9.4.2) reverses the effect of all  
</I>&gt;<i> preceding #line directives. The compiler
</I>&gt;<i> reports true line information for subsequent lines, precisely as if  
</I>&gt;<i> no #line directives had been processed.
</I>&gt;<i>
</I>&gt;<i> The purpose of a line-indicator with an identifier-or-keyword whose  
</I>&gt;<i> value does not equal default is
</I>&gt;<i> implementation-defined. An implementation that does not recognize  
</I>&gt;<i> such an identifier-or-keyword in a line-
</I>&gt;<i> indicator shall issue a warning.
</I>&gt;<i> */
</I>&gt;<i> pp_line
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'line' whitespace line_indicator  
</I>&gt;<i> pp_new_line
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> line_indicator
</I>&gt;<i> 	:	DECIMAL_DIGIT+ whitespace file_name
</I>&gt;<i>  	|	DECIMAL_DIGIT+
</I>&gt;<i>  	|	identifier_or_keyword
</I>&gt;<i>  	;
</I>&gt;<i>
</I>&gt;<i> file_name
</I>&gt;<i> 	:	'&quot;' FILE_NAME_CHARACTER+ '&quot;'
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> FILE_NAME_CHARACTER
</I>&gt;<i> 	:	~( '&quot;' | NEW_LINE_CHARACTER ) // Any character except &quot; (U 
</I>&gt;<i> +0022), and new_line_character
</I>&gt;<i> 	;
</I>&gt;<i>
</I>&gt;<i> pp_pragma
</I>&gt;<i> 	:	whitespace? '#' whitespace? 'pragma' pp_pragma_text
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i> pp_pragma_text
</I>&gt;<i> 	:	NEW_LINE
</I>&gt;<i> 	|	whitespace INPUT_CHARACTER* NEW_LINE
</I>&gt;<i> 	;
</I>
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019600.html">[antlr-interest] C# parser grammar problem
</A></li>
	<LI>Next message: <A HREF="019603.html">[antlr-interest] C# parser grammar problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19601">[ date ]</a>
              <a href="thread.html#19601">[ thread ]</a>
              <a href="subject.html#19601">[ subject ]</a>
              <a href="author.html#19601">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
