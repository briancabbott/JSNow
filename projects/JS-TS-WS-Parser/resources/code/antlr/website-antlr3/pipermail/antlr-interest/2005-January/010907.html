<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] ANTLR vs lex/yacc
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20ANTLR%20vs%20lex/yacc&In-Reply-To=EKEJKOHPOIIALFJMKEIGAEPEGBAA.mike%40fruitioninc.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010903.html">
   <LINK REL="Next"  HREF="010911.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] ANTLR vs lex/yacc</H1>
    <B>Nigel Sheridan-Smith</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20ANTLR%20vs%20lex/yacc&In-Reply-To=EKEJKOHPOIIALFJMKEIGAEPEGBAA.mike%40fruitioninc.com"
       TITLE="[antlr-interest] ANTLR vs lex/yacc">nbsherid at secsme.org.au
       </A><BR>
    <I>Sun Jan 16 15:07:52 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010903.html">[antlr-interest] ANTLR vs lex/yacc
</A></li>
        <LI>Next message: <A HREF="010911.html">[antlr-interest] ANTLR vs lex/yacc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10907">[ date ]</a>
              <a href="thread.html#10907">[ thread ]</a>
              <a href="subject.html#10907">[ subject ]</a>
              <a href="author.html#10907">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Mike Bresnahan
</I>&gt;<i> Sent: Monday, 10 January 2005 2:49 PM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Subject: [antlr-interest] ANTLR vs lex/yacc
</I>&gt;<i> 
</I>&gt;<i> I have seen many people comment on how they dislike yacc/lex vs ANTLR.
</I>&gt;<i> I'm
</I>&gt;<i> curious why people think this.  My limited experience hasn't been so black
</I>&gt;<i> and white.  I first learned yacc/lex about 9 years ago and I haven't used
</I>&gt;<i> them since.  At the time I found them wonderful tools.  I bought the
</I>&gt;<i> O'Reilly nutshell book and within a very short period of time I could whip
</I>&gt;<i> out a simple parser in one day.  I found the tools very intiutive.
</I>&gt;<i> 
</I>&gt;<i> Speed forward to today.  I first started using ANTLR a few months ago.  I
</I>&gt;<i> chose it because it generates C# and that is what I needed.  My experience
</I>&gt;<i> with ANTLR has been much different than my experience with yacc/lex.  I
</I>&gt;<i> have
</I>&gt;<i> found it extremely difficult to get my head around the tool.  I don't
</I>&gt;<i> think
</I>&gt;<i> the problem is the tool per se, but rather LL(k) grammers.  I don't find
</I>&gt;<i> them to be intuitive.  The grammers are harder for me to read and write.
</I>&gt;<i> 
</I>&gt;<i> One very hard concept is that I cannot use left recursion, however &quot;middle
</I>&gt;<i> recursion&quot; and &quot;right recursion&quot; are just fine.  Why is left recursion
</I>&gt;<i> treated differently?  It just seems asymeteric and ad-hoc to me.
</I>&gt;<i> 
</I>&gt;<i> So either I've gotten stupider over the years, my brain is more in tune
</I>&gt;<i> with
</I>&gt;<i> LALR grammers, or LL(k) grammers are simply harder to understand than LALR
</I>&gt;<i> grammers.  Why is it that people like ANTLR more than yacc/lex?  Why have
</I>&gt;<i> I
</I>&gt;<i> had a different experience?
</I>&gt;<i> 
</I>&gt;<i> Background note: I've never studied the theory of compilers nor do I have
</I>&gt;<i> a
</I>&gt;<i> degree in computer science.  However, I have been programming for 20 years
</I>&gt;<i> or so; 10 professionally.
</I>&gt;<i> 
</I>

Well I have been using ANTLR for around 6 months now, although mostly in the
last month has it become essential to the things I am doing. I have been a
(casual, non-commercial) programmer for around 15 years in various
languages.

I learnt LL(k) first because of ANTLR, and although ANTLR can take some time
to learn, I think that anyone with some Compiler Toolkit experience will
quickly be able to understand the concepts. I think maybe clearer
documentation and HOWTO guides might be the way to go since I found the
reference guide too heavy-handed and the tutorials are only sufficient to
get someone started on simple problems. For example, once I got to Abstract
Syntax Trees it was difficult to understand how then to use them to achieve
different results, particularly when it comes to building a complete
compiler for a programming language. However, ASTs are a common approach
used in probably just about every compiler. 

Anyway, in the last two weeks, I tried learning LR and its variants, like
LALR, because of the LL(k) left-grammar problem. However, I found *LR* to be
quite non-intuitive, because they are bottom-up, rather than top-down, and
my ANTLR-centric way of thinking made it hard to visualise what was going
on. However, once I sat down with a decent book or two from the library, it
became very simple to see how both types of parsers work.

The key thing to remember with both LL(k) and LR is that they have to match
terminals - the non-terminals are simply there to group
terminals/non-terminals into patterns (with/without recursion). With LL(k)
you have to look at every possible alternative diving down into the rules -
if I see TOKEN1 then I will match one path but if I see TOKEN2 then I will
match a different path. Non-determinisms result from not being able to
predict a path with the current amount of look-ahead - this occurs because
of explicit choices in a rule, or because of a ()?, ()* or ()+ component
where you might match the alternative or &quot;exit&quot;. 

Similarly, with LR you have to match one or more terminals before a &quot;reduce&quot;
can occur. You have to use the top-down approach first to &quot;predict&quot; what
alternatives might follow, especially in LR(1) and LALR(1) parsers.
Terminals at the front of the stream that cannot be matched are pushed down
into the stack temporarily until a suitable non-terminal can be matched
later on. This type of approach favours left-recursion, because you want to
match as much on the left first so that you can then match more complicated
non-terminals over time.

So its unfortunate that most grammars are LR-oriented, because
left-recursion is a pain to eliminate in LL(k) parsers. However, I think the
results are going to be fairly equivalent whether you choose LL(k) or LR.
Personally, I find that ANTLR is a fantastic tool, and can deal with all
sorts of conflicts and ambiguities using the syntactic predicates and
semantic predicates, and my (limited) experience with other tools is that
they cannot match ANTLR in terms of flexibility and power. It's really just
a matter of diving in and learning how best to use the tools! Whenever I
create a grammar of my own, I think I would prefer it to be LL(k) because it
makes it many times easier to see where the grammar is ambiguous.

Regards 

Nigel

--
Nigel Sheridan-Smith
PhD research student

Faculty of Engineering
University of Technology, Sydney
Phone: 02 9514 7946
Fax: 02 9514 2435 


</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010903.html">[antlr-interest] ANTLR vs lex/yacc
</A></li>
	<LI>Next message: <A HREF="010911.html">[antlr-interest] ANTLR vs lex/yacc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10907">[ date ]</a>
              <a href="thread.html#10907">[ thread ]</a>
              <a href="subject.html#10907">[ subject ]</a>
              <a href="author.html#10907">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
