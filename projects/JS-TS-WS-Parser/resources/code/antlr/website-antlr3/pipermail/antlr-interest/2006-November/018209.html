<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=5ts8pRRamQSFFw6h%40thewolery.demon.co.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018197.html">
   <LINK REL="Next"  HREF="018212.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=5ts8pRRamQSFFw6h%40thewolery.demon.co.uk"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Wed Nov  1 19:30:57 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018197.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018212.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18209">[ date ]</a>
              <a href="thread.html#18209">[ thread ]</a>
              <a href="subject.html#18209">[ subject ]</a>
              <a href="author.html#18209">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Anthony W. Youngman wrote:

&gt;<i> In message &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">4548F943.7070906 at jazillian.com</A>&gt;, Andy Tripp 
</I>&gt;<i> &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; writ
</I>&gt;<i> I wouldn't describe &quot;popular&quot; as &quot;great&quot;.
</I>
I would say popularity is a pretty good indicator or &quot;greatness&quot;. By 
&quot;popular&quot;, I mean &quot;widely seen
as good from a technology point of view&quot;. So Java is &quot;popular&quot; that way: 
a lot of people use it
because of its technical merits. COBOL is widely used, but almost no one 
uses it because of its
technical merits.

&gt;&gt;<i> Well, I think Java is far better than C++, and I think the vast 
</I>&gt;&gt;<i> majority of programmers who know both
</I>&gt;&gt;<i> agree with me. Probably the main benefit is that it's easy to use for 
</I>&gt;&gt;<i> &quot;average programmers&quot;. That's also why
</I>&gt;&gt;<i> ANTLR is better than the competition - because it's easier to use.
</I>&gt;&gt;<i>
</I>&gt;<i> You've just said Java doesn't have pointers. So how do you access a 
</I>&gt;<i> hardware register in Java? How do you access a screen buffer?
</I>
You access them indirectly. Leave the underlying details to a lower layer.

&gt;&gt;<i> Yes, a few people want to add stuff back, but most do not. It's just 
</I>&gt;&gt;<i> that the few are very vocal.
</I>&gt;&gt;<i> The vast majority don't want MI, operator overloading, or built-in 
</I>&gt;&gt;<i> AspectOrientedDesign.
</I>&gt;&gt;<i> And of course, those who want them think they're &quot;above average&quot;, but 
</I>&gt;&gt;<i> then so does almost
</I>&gt;&gt;<i> everyone.
</I>&gt;&gt;<i>
</I>&gt;<i> What about those who don't WANT those things, but NEED them?
</I>
Every time I've heard anyone say they NEED MI, operator overloading, or 
Aspects, I've thought
that they really don't need them, they're just not good enough 
programmers to see a clean way
to do without them. I've been programming for 25 years without ever 
NEEDING any of these,
and so have most other programmers.

&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> And that's why Java is popular and Smalltalk and LISP are not.
</I>&gt;&gt;&gt;&gt;<i> It's also why people prefer Java over C++.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It is a easier tool to use. Less powerful. But easier.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Right - so I hope there's nothing wrong with me pushing to make ANTLR 
</I>&gt;&gt;<i> (or some successor)
</I>&gt;&gt;<i> easier to use. A compiler is easier to use than compiling by hand, 
</I>&gt;&gt;<i> but also less powerful.
</I>&gt;&gt;<i> I'm ok with that.
</I>&gt;&gt;<i>
</I>&gt;<i> So - you're quite happy to see Antlr crippled to suit you, ignoring 
</I>&gt;<i> the NEEDS of those who need its power!
</I>
Don't worry, I can't cripple ANTLR.  But yes, I'd be happy to see ANTLR4 
become a &quot;crippled&quot; version,
in the same sense that Java is a &quot;crippled&quot; version of C++.

&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> But required knowledge of the tool's internals limits the &quot;average&quot; 
</I>&gt;&gt;<i> user's productivity.
</I>&gt;&gt;<i> If I had done AST-based translation, I'd be spending way to much time 
</I>&gt;&gt;<i> worrying about the details
</I>&gt;&gt;<i> of the AST, rather than the syntax and semantics of the two 
</I>&gt;&gt;<i> languages. I demand to spend 95% of
</I>&gt;&gt;<i> my time on *what* to do, rather than *how* to do it. With ASTs, I 
</I>&gt;&gt;<i> found myself spending
</I>&gt;&gt;<i> 95% of my time on *how*.
</I>&gt;&gt;<i>
</I>&gt;<i> In other words, as you said earlier, ASTs are the wrong tool for you. 
</I>&gt;<i> So you seem happy to delete ASTs from Antlr because *you* don't need 
</I>&gt;<i> them, irregardless of what other people *NEED*.
</I>
Yes, just as I railed against operator overloading and MI in C++, and 
found bliss in Java.
I don't much care that other people think they *NEED* MI. They can 
always stick with C++.

&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Right, so you're just like the rest of us. You've chosen to limit 
</I>&gt;&gt;<i> your own &quot;power&quot; by using Java rather
</I>&gt;&gt;<i> than, say, assembly. So I'm sticking with my claim that
</I>&gt;&gt;<i> &quot;I think a tool can be great while being simple enough for most 
</I>&gt;&gt;<i> programmers (e.g. Java).&quot;
</I>&gt;&gt;<i> and not buying your &quot;Not without limiting it's power&quot; reply.
</I>&gt;&gt;<i>
</I>&gt;<i> To my mind, that's not a &quot;great&quot; tool. As I said above, &quot;popular&quot;, maybe.
</I>
Right, so let's just agree to disagree on that. If we can't agree that 
Java is &quot;greater&quot; than assembly,
we won't agree on much else.

&gt;<i>
</I>&gt;<i> Let's ask a question ... how can a tool be &quot;great&quot; if it *relies* on 
</I>&gt;<i> other tools even for its existence?
</I>
Sure, of course! Virtually all software relies on other tools 
(compilers, operating systems, etc) for their existence.

&gt;<i>
</I>&gt;<i> A C compiler can compile itself. Can a Java system build itself? How 
</I>&gt;<i> much of Java is actually written in Java? (Oh and I'm including the 
</I>&gt;<i> supporting libraries here!)
</I>
Almost all of Java is written in Java. The only part that's not is the 
lowest layer, which is OS and hardware specific.

&gt;<i>
</I>&gt;<i> Antlr v3 is due to be rewritten in Antlr v3. To my mind, that's a 
</I>&gt;<i> &quot;necessary but not sufficient&quot; condition for greatness.
</I>
Wow. Only software that's written in itself can be &quot;great&quot;? Are you 
really saying that?

&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> He _is_ using a DSL you created to encode source-to-source 
</I>&gt;&gt;&gt;<i> transformations.
</I>&gt;&gt;&gt;<i> You just expressed the opinion that he has aquired the domain expertise
</I>&gt;&gt;&gt;<i> required to use your DSL.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, so if you believe me when I say that my DSL is orders of 
</I>&gt;&gt;<i> magnitude easier to use than
</I>&gt;&gt;<i> to use ANTLR to build and walk ASTs, then you must see my point: He's 
</I>&gt;&gt;<i> much more productive.
</I>&gt;&gt;<i> So I'm building my DSL (and other code) on top of ANTLR/lexer. I 
</I>&gt;&gt;<i> think there's an opportunity
</I>&gt;&gt;<i> for Terence to build a better and different tool in place of the 
</I>&gt;&gt;<i> ANTLR/parser - one that doesn't
</I>&gt;&gt;<i> require users to know formal language theory or picture ASTs in their 
</I>&gt;&gt;<i> heads.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> But what if the problem can only be specified in terms of formal 
</I>&gt;<i> language theory? 
</I>
Then you'd have a different situation. But surely you're not saying that 
a language-to-language translator
can only be specified in terms of formal language theory, are you?

&gt;<i> There is something called &quot;intelligence&quot;. If you don't have sufficient 
</I>&gt;<i> intelligence, you *cannot* learn certain things. You want to give a 
</I>&gt;<i> programmer a tool, so you can set him a problem he is INCAPABLE of 
</I>&gt;<i> comprehending. I hope I never have to rely on (or even USE) code 
</I>&gt;<i> written by a coder like that !!!
</I>
Well, virtually every coder in the world is like that. Only a handful of 
people in the world know the details of what their
compiler is doing as they use it every day. Same goes for the OS and the 
hardware. Same goes for  the car you drive
and just about everything other non-trivial machine you use: you use it 
without knowing much about how it works.
That's what makes the world go round :)

&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I want to do. I *never* have to look at java byte code - I'm 
</I>&gt;&gt;&gt;&gt;<i> completely hidden from that
</I>&gt;&gt;&gt;&gt;<i> by the design of the compiler.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Not by the design of the compiler. But by how well tested it is. And 
</I>&gt;&gt;&gt;<i> by how
</I>&gt;&gt;&gt;<i> well documented Java (and javacc) is.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No, I do think it's by the design of the compiler - by the design of 
</I>&gt;&gt;<i> compilers in general.
</I>&gt;&gt;<i> Compiler designers take it as a given that users need only know the 
</I>&gt;&gt;<i> syntax/semantics of the input
</I>&gt;&gt;<i> language. If Ter took it as a given that ANTLR4 users need only know 
</I>&gt;&gt;<i> the syntax/semantics
</I>&gt;&gt;<i> of the input language, he'd end up with a very different tool.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That would appeal to a completely different set of users. He's written 
</I>&gt;<i> a tool that does what he needs, and it appeals to users with similar 
</I>&gt;<i> needs.
</I>
Just as the first assembler writers built tools that solved their own 
needs. Eventually, they were able to completely hide
the lower level detail, and attack problems at a whole higher level of 
thinking. Same for compiler writers.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Maybe he will write your version of Antlr 4, but it will be a compiler 
</I>&gt;<i> not a lexer/parser - a completely different tool!
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Many Javacc users - who can and care
</I>&gt;&gt;&gt;<i> to look under hood - have tripped over bugs-a-plenty in it yet, 
</I>&gt;&gt;&gt;<i> &quot;average&quot;
</I>&gt;&gt;&gt;<i> Javacc users don't discover those same bugs in the same tool even 
</I>&gt;&gt;&gt;<i> when they
</I>&gt;&gt;&gt;<i> write code that triggers it.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Knowledge of Java and bytecode and how javacc works means &quot;above 
</I>&gt;&gt;&gt;<i> average&quot;
</I>&gt;&gt;&gt;<i> users can do more with Java and javacc than the average programmer can.
</I>&gt;&gt;&gt;<i> Knowing more, lets you do more.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ANTLR is similar and different. Different because it suffers in 
</I>&gt;&gt;&gt;<i> comparison
</I>&gt;&gt;&gt;<i> by being a less popular tool with less resources behind it. 
</I>&gt;&gt;&gt;<i> Nevertheless,
</I>&gt;&gt;&gt;<i> for someone with a deep knowledge of ANTLR's grammar language, it's
</I>&gt;&gt;&gt;<i> limitations (e.g. no predicate hoisting and approximate-LLk in 2.x) 
</I>&gt;&gt;&gt;<i> and the
</I>&gt;&gt;&gt;<i> available documentation, there really is no need to look at the 
</I>&gt;&gt;&gt;<i> output code.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Well, sure, it's mostly covered in the documentation. But that 
</I>&gt;&gt;<i> doesn't change the fact that it could be
</I>&gt;&gt;<i> made a lot easier (IMO). What makes Java great and C++ not-so-great 
</I>&gt;&gt;<i> is that Java programmers
</I>&gt;&gt;<i> never have to go look up the syntax for &quot;pointer to function that 
</I>&gt;&gt;<i> returns an int pointer&quot;. Similarly,
</I>&gt;&gt;<i> a tool that didn't make me look up how to figure out how many 
</I>&gt;&gt;<i> patterns a &quot;*&quot; matched would make
</I>&gt;&gt;<i> the tool great.
</I>&gt;&gt;<i>
</I>&gt;<i> And then the programmer needs a pointer to write to a bit of hardware, 
</I>&gt;<i> and throws Java out in disgust because his &quot;great&quot; tool is useless for 
</I>&gt;<i> the job at hand ...
</I>
Right. And probably gets fired if his boss finds out that he's trying to 
write a bit directly to hardware.
He thinks he needs to do that, and he thinks he's smart, but he's not. 
That's pretty rare these days to
have anyone feel that they need direct access to the hardware. We're 
many levels beyond that now.

&gt;<i>
</I>&gt;&gt;&gt;<i> You develop your grammar, you develop your tests, you build the 
</I>&gt;&gt;&gt;<i> whole lot
</I>&gt;&gt;&gt;<i> and, the tests will alert you if you need to change anything. Unless 
</I>&gt;&gt;&gt;<i> you
</I>&gt;&gt;&gt;<i> trip over a bug in ANTLR of course...
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Now with ANTLR V3, not only can you look at the output code it if 
</I>&gt;&gt;&gt;<i> you wish
</I>&gt;&gt;&gt;<i> but, for the price of a little more knowledge (i.e. domain 
</I>&gt;&gt;&gt;<i> expertise), you
</I>&gt;&gt;&gt;<i> can change it!.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I can change the bytecode generated by javac, too. If javac let me do 
</I>&gt;&gt;<i> that, it would be an indication
</I>&gt;&gt;<i> to the javac designer that his design is less-than-great.
</I>&gt;&gt;<i>
</I>&gt;<i> Because javac is meant to convert java source accurately to java 
</I>&gt;<i> bytecode. While Antlr is meant to (and does) accurately convert its 
</I>&gt;<i> sourcecode into a lexer/parser/treewalker, it is also designed to let 
</I>&gt;<i> you do things beyond the power of the tool. Both fit their design aims 
</I>&gt;<i> - javac creates a java program, Antlr creates an extensible 
</I>&gt;<i> lexer/parser/treewalker. Both are *good* tools, that doesn't 
</I>&gt;<i> necessarily mean they are *great* tools.
</I>&gt;<i>
</I>&gt;<i> At the end of the day, I think your definition of &quot;great&quot; is badly 
</I>&gt;<i> flawed - &quot;a great tool lets a mediocre programmer do a decent job&quot;. A 
</I>&gt;<i> great programmer could probably outperform that mediocre programmer 
</I>&gt;<i> without that tool. 
</I>
Heh, it's been a while since I heard the &quot;A great programmer can write 
better code than the compiler&quot; line.
Used to hear that a lot 20 years ago, not much any more.

&gt;<i> To my mind, &quot;a great tool lets a great programmer give of his best&quot;. 
</I>&gt;<i> And a mediocre programmer would not be able to use that tool, because 
</I>&gt;<i> he would not be able to understand it.
</I>&gt;<i>
</I>&gt;<i> There's a BIG difference between the RIGHT tool, and a GREAT tool. 
</I>&gt;<i> Would you call a hammer a *great* tool when you have a pack of nails? 
</I>&gt;<i> I don't know as I'd call a nailgun a great tool but it's certainly 
</I>&gt;<i> greater than a hammer. And it requires a greater level of *maturity* 
</I>&gt;<i> than a hammer to use safely.
</I>
The nailgun is greater than the hammer because it does the same job 
better *without* forcing the user to know the details
(how it works internally). If you had to constantly tweak the nailgun 
internals to get things done, it might still be &quot;good&quot; or
even &quot;great&quot;, but not as good as it could be.

&gt;<i>
</I>&gt;<i> The greater the tool, the greater the level of maturity required to be 
</I>&gt;<i> able to use it safely. 
</I>
If you want to use that meaning for &quot;great&quot;, that's fine. But I do 
disagree. If you had one space shuttle
that was completely safe and automated, that would be a &quot;greater&quot; tool 
than one that requires maturity, IMO.
Especially if you have millions of shuttle pilots, and not just a few.

&gt;<i> And the fewer the number of programmers who are capable of reaching 
</I>&gt;<i> that level of maturity ... you go on about the &quot;dangerous features&quot; of 
</I>&gt;<i> C++ as opposed to Java. A mature C++ programmer would NOT USE those 
</I>&gt;<i> features if they weren't needed. Indeed, a mature C++ programmer would 
</I>&gt;<i> probably use Java if those features weren't needed.
</I>
Haven't heard that one in a while either. Yes, yes, I know, it's not C++ 
that's dangerous, it's just those *other* guys
who are bad programmers and are misusing it. And we Java fans are just 
not manly enough to handle
MI and operator overloading.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Too many programmers use features like kids eat candy - the more the 
</I>&gt;<i> better! A great programmer likes a tool like a candy shop - but he has 
</I>&gt;<i> the self control to only take what he needs - not the entire shop!
</I>
Yea, yea, heard it all before. It's all those *other*, less-intelligent 
programmers that are using operator overloading
to apply the &quot;+&quot; operator to the &quot;Person&quot; class. We smart programmers 
know that we *NEED* operator overloading
for our matrix multiplication. Bleh. :)

&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Wol
</I>

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018197.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018212.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18209">[ date ]</a>
              <a href="thread.html#18209">[ thread ]</a>
              <a href="subject.html#18209">[ subject ]</a>
              <a href="author.html#18209">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
