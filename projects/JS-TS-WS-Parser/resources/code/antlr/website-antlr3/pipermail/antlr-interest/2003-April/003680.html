<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] NON-reserved Words
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20NON-reserved%20Words&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003676.html">
   <LINK REL="Next"  HREF="003682.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] NON-reserved Words</H1>
    <B>Brian Hagenbuch</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20NON-reserved%20Words&In-Reply-To="
       TITLE="[antlr-interest] NON-reserved Words">bhagenbuch at didera.com
       </A><BR>
    <I>Mon Apr 28 16:53:31 PDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="003676.html">[antlr-interest] undeserved nondeterminism warning
</A></li>
        <LI>Next message: <A HREF="003682.html">[antlr-interest] NON-reserved Words
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3680">[ date ]</a>
              <a href="thread.html#3680">[ thread ]</a>
              <a href="subject.html#3680">[ subject ]</a>
              <a href="author.html#3680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm trying to parse a a dialect of SQL in which there are both
reserved and &quot;non-reserved&quot; words.  A non-reserved word is one
that can be an identifier or a syntactic marker depending on the
context.  For example CASE can be a variable, as in

  ... WHERE CASE=12 AND...

or it can begin an expression, as in

  SELECT CASE WHEN AGE&lt;20 THEN 'kid' ELSE 'geezer' END, ...

The language has about 100 such non-reserved words and about 100
reserved words.

The approach suggested by the FAQ and the Yahoo Group seems to
something like

- Have the lexer treat non-reserved words (like CASE) as ordinary
  identifiers, i.e., don't represent them in the literals table.

- Use semantic predicates in the parser to distinguish the cases.

I started down this road, but found it to be complicated to
implement and hard/impossible to remove non-determinism.  So I'm 
considering a different approach:

- Have the lexer treat non-reserved words as keywords and collect
  them under a parser rule such as maybeIdentifier.

- In the parser, include maybeIdentifer in the rule for variable.

- Use syntactic predicates to distinguish the cases.

So far this seems to be easier, but I'm inexperienced with Antlr
and parsing in general and I'm concerned that there's some GOTCHA
lurking in there somewhere.

Ideas?  Experiences?  Thank you.


 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003676.html">[antlr-interest] undeserved nondeterminism warning
</A></li>
	<LI>Next message: <A HREF="003682.html">[antlr-interest] NON-reserved Words
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3680">[ date ]</a>
              <a href="thread.html#3680">[ thread ]</a>
              <a href="subject.html#3680">[ subject ]</a>
              <a href="author.html#3680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
