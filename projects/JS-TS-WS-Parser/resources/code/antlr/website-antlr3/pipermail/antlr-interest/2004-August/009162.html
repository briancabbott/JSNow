<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Re: yet another java 1.5 grammar
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20yet%20another%20java%201.5%20grammar&In-Reply-To=cgga5t%241fv%241%40sea.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009161.html">
   <LINK REL="Next"  HREF="009163.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Re: yet another java 1.5 grammar</H1>
    <B>lgcraymer</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20yet%20another%20java%201.5%20grammar&In-Reply-To=cgga5t%241fv%241%40sea.gmane.org"
       TITLE="[antlr-interest] Re: yet another java 1.5 grammar">lgc at mail1.jpl.nasa.gov
       </A><BR>
    <I>Tue Aug 24 16:46:21 PDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009161.html">[antlr-interest] yet another java 1.5 grammar
</A></li>
        <LI>Next message: <A HREF="009163.html">[antlr-interest] Re: yet another java 1.5 grammar
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9162">[ date ]</a>
              <a href="thread.html#9162">[ thread ]</a>
              <a href="subject.html#9162">[ subject ]</a>
              <a href="author.html#9162">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Michael--

Please send Ter a copy so that he can put it in the &quot;sharing&quot; section
of antlr.org.

--Loring


--- In <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>, Michael Stahl
&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">gcpa-antlr-interest at m...</A>&gt; wrote:
&gt;<i> 
</I>&gt;<i> [posting via gmane, hope that works and does not mess up attachments]
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> hello!
</I>&gt;<i> 
</I>&gt;<i> this is the java 1.5 grammar which i thought i would post 3 weeks ago :)
</I>&gt;<i> it took so long mostly because the proposed final draft version of JSR14
</I>&gt;<i> came out on july 27 and that had some changes relative to the public
</I>&gt;<i> review that came out in 2001 (!). i finally found the time for looking
</I>&gt;<i> through the draft 3rd ed. of JLS that comes with JSR14-pfd last week.
</I>&gt;<i> 
</I>&gt;<i> oh, and thanks to michael studman, without your java15.g i would not
</I>&gt;<i> even have noticed that! a superficial look at that yielded some weird
</I>&gt;<i> WILDCARD thing which my grammar was missing...
</I>&gt;<i> 
</I>&gt;<i> since i need my grammar anyway (because i have a whitespace preserving
</I>&gt;<i> grammar that is based on it and a serializing tree parser to match)
</I>&gt;<i> i thought i might as well post it here despite java15.g being available.
</I>&gt;<i> 
</I>&gt;<i> also, i have some issues with java15.g, which are fixed in my grammar:
</I>&gt;<i> 
</I>&gt;<i> - the gtToReconcile stuff is way overkill. i replaced this with
</I>&gt;<i>   a simple semantic predicate in typeArguments:
</I>&gt;<i>         {inputState.guessing !=0 || ltCounter == currentLtLevel + 1}?
</I>&gt;<i>   (oh, and thanks anyway, because i did not actually notice that
</I>&gt;<i>   tree construction was broken in the first place)
</I>&gt;<i> 
</I>&gt;<i> - the typeArguments for method calls was missing in rule identPrimary:
</I>&gt;<i>   i found adding this rather difficult because unfortunately there is a
</I>&gt;<i>   conflict between the (DOT typeArgs IDENT)* loop in identPrimary
</I>&gt;<i>   and (DOT typeArgs &quot;super&quot;)* in rule postfixExpression which was not
</I>&gt;<i>   there before (k=2). 
</I>&gt;<i>   my first idea was to put a syntactic predicate in the loop, but
</I>&gt;<i>   then antlr (2.7.4) gave me a warning that this does not make sense.
</I>&gt;<i>   so what i came up with is this, and it is rather ugly:
</I>&gt;<i>     (   (DOT typeArguments IDENT) =&gt;
</I>&gt;<i>                 DOT^ ta2:typeArguments! IDENT
</I>&gt;<i>     |   {false}?        // FIXME: this is very ugly but it seems to
</I>work...
&gt;<i>     )*
</I>&gt;<i>   This generates two warnings, one of which i could disable, the other
</I>&gt;<i>   says that empty alternative does not make any sense in a loop.
</I>&gt;<i>   Obvious feature request for the antlr authors:
</I>&gt;<i>   Would it be possible to handle the case of a syntactic predicate in a
</I>&gt;<i>   loop with only one alternative differently in antlr, i.e. such that
</I>&gt;<i>   not matching the syntax predicate means the loop is broken out of?
</I>&gt;<i> 
</I>&gt;<i> - newExpression is also missing typeArguments, but that is easy to fix
</I>&gt;<i> 
</I>&gt;<i> - the handling of the various different field types has a lot of
</I>&gt;<i>   duplication. this is factored a bit better in my grammar.
</I>&gt;<i> 
</I>&gt;<i> a cool feature i have added is switchable keyword support. the
</I>&gt;<i> &quot;assert&quot; and &quot;enum&quot; keywords can be dis/enabled at runtime. this is
</I>&gt;<i> done via a string comparison in the lexer IDENT rule. i think this
</I>&gt;<i> should not harm performance too much, but i have not benchmarked
</I>&gt;<i> anything and do not particularly care anyway.
</I>&gt;<i> 
</I>&gt;<i> oh, and i have also cleaned up the formatting to always use tabs instead
</I>&gt;<i> of the hideous tabs/spaces mix it was before.
</I>&gt;<i> 
</I>&gt;<i> my grammar is actually not much tested, but the whitespace preserving
</I>&gt;<i> grammar based on it parses and serializes the entire aspectix cvs
</I>&gt;<i> source tree (almost 3000 java 1.4 files) and also the sources of
</I>&gt;<i> findbugs (which uses generics), as well as some custom written test
</I>&gt;<i> cases.
</I>&gt;<i> 
</I>&gt;<i> btw, does anyone know of a sizable code base that uses java 1.5
</I>&gt;<i> features and is licensed under some kind of free software license?
</I>&gt;<i> i.e. not the sun jdk 1.5 source...
</I>&gt;<i> 
</I>&gt;<i> so, if anybody wants to comment on this or finds a bug, i'd be happy
</I>&gt;<i> to hear from you.
</I>&gt;<i> 
</I>&gt;<i> michael stahl
</I>&gt;<i> 
</I>&gt;<i> PS: i hereby donate the code in the attached files, which was written
</I>&gt;<i>     by myself except for the parts that are from the antlr distribution
</I>&gt;<i>     and the parts taken from javaG.g by Matt Quail, to the public
</I>&gt;<i>     domain.
</I>&gt;<i> 
</I>&gt;<i> /** Java 1.5/JSR14/JSR201/JSR175 Recognizer
</I>&gt;<i>  *
</I>&gt;<i>  * Run 'java Main [-showtree] directory-full-of-java-files'
</I>&gt;<i>  *
</I>&gt;<i>  * [The -showtree option pops up a Swing frame that shows
</I>&gt;<i>  *  the AST constructed from the parser.]
</I>&gt;<i>  *
</I>&gt;<i>  * Run 'java Main &lt;directory full of java files&gt;'
</I>&gt;<i>  *
</I>&gt;<i>  * Contributing authors:
</I>&gt;<i>  *		John Mitchell		<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">johnm at n...</A>
</I>&gt;<i>  *		Terence Parr		<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at m...</A>
</I>&gt;<i>  *		John Lilley			<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jlilley at e...</A>
</I>&gt;<i>  *		Scott Stanchfield	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">thetick at m...</A>
</I>&gt;<i>  *		Markus Mohnen       <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">mohnen at i...</A>
</I>&gt;<i>  *      Peter Williams      <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">pete.williams at s...</A>
</I>&gt;<i>  *      Allan Jacobs        <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">Allan.Jacobs at e...</A>
</I>&gt;<i>  *      Steve Messick       <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">messick at r...</A>
</I>&gt;<i>  *      John Pybus			<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">john at p...</A>
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.00 December 9, 1997 -- initial release
</I>&gt;<i>  * Version 1.01 December 10, 1997
</I>&gt;<i>  *		fixed bug in octal def (0..7 not 0..8)
</I>&gt;<i>  * Version 1.10 August 1998 (parrt)
</I>&gt;<i>  *		added tree construction
</I>&gt;<i>  *		fixed definition of WS,comments for mac,pc,unix newlines
</I>&gt;<i>  *		added unary plus
</I>&gt;<i>  * Version 1.11 (Nov 20, 1998)
</I>&gt;<i>  *		Added &quot;shutup&quot; option to turn off last ambig warning.
</I>&gt;<i>  *		Fixed inner class def to allow named class defs as statements
</I>&gt;<i>  *		synchronized requires compound not simple statement
</I>&gt;<i>  *		add [] after builtInType DOT class in primaryExpression
</I>&gt;<i>  *		&quot;const&quot; is reserved but not valid..removed from modifiers
</I>&gt;<i>  * Version 1.12 (Feb 2, 1999)
</I>&gt;<i>  *		Changed LITERAL_xxx to xxx in tree grammar.
</I>&gt;<i>  *		Updated java.g to use tokens {...} now for 2.6.0 (new feature).
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.13 (Apr 23, 1999)
</I>&gt;<i>  *		Didn't have (stat)? for else clause in tree parser.
</I>&gt;<i>  *		Didn't gen ASTs for interface extends.  Updated tree parser too.
</I>&gt;<i>  *		Updated to 2.6.0.
</I>&gt;<i>  * Version 1.14 (Jun 20, 1999)
</I>&gt;<i>  *		Allowed final/abstract on local classes.
</I>&gt;<i>  *		Removed local interfaces from methods
</I>&gt;<i>  *		Put instanceof precedence where it belongs...in relationalExpr
</I>&gt;<i>  *			It also had expr not type as arg; fixed it.
</I>&gt;<i>  *		Missing ! on SEMI in classBlock
</I>&gt;<i>  *		fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus).
</I>&gt;<i>  *		fixed: didn't like Object[].class in parser or tree parser
</I>&gt;<i>  * Version 1.15 (Jun 26, 1999)
</I>&gt;<i>  *		Screwed up rule with instanceof in it. :(  Fixed.
</I>&gt;<i>  *		Tree parser didn't like (expr).something; fixed.
</I>&gt;<i>  *		Allowed multiple inheritance in tree grammar. oops.
</I>&gt;<i>  * Version 1.16 (August 22, 1999)
</I>&gt;<i>  *		Extending an interface built a wacky tree: had extra EXTENDS.
</I>&gt;<i>  *		Tree grammar didn't allow multiple superinterfaces.
</I>&gt;<i>  *		Tree grammar didn't allow empty var initializer: {}
</I>&gt;<i>  * Version 1.17 (October 12, 1999)
</I>&gt;<i>  *		ESC lexer rule allowed 399 max not 377 max.
</I>&gt;<i>  *		java.tree.g didn't handle the expression of synchronized
</I>&gt;<i>  *		statements.
</I>&gt;<i>  * Version 1.18 (August 12, 2001)
</I>&gt;<i>  *      	Terence updated to Java 2 Version 1.3 by
</I>&gt;<i>  *		observing/combining work of Allan Jacobs and Steve
</I>&gt;<i>  *		Messick.  Handles 1.3 src.  Summary:
</I>&gt;<i>  *		o  primary didn't include boolean.class kind of thing
</I>&gt;<i>  *      	o  constructor calls parsed explicitly now:
</I>&gt;<i>  * 		   see explicitConstructorInvocation
</I>&gt;<i>  *		o  add strictfp modifier
</I>&gt;<i>  *      	o  missing objBlock after new expression in tree grammar
</I>&gt;<i>  *		o  merged local class definition alternatives, moved after
</I>declaration
&gt;<i>  *		o  fixed problem with ClassName.super.field
</I>&gt;<i>  *      	o  reordered some alternatives to make things more efficient
</I>&gt;<i>  *		o  long and double constants were not differentiated from int/float
</I>&gt;<i>  *		o  whitespace rule was inefficient: matched only one char
</I>&gt;<i>  *		o  add an examples directory with some nasty 1.3 cases
</I>&gt;<i>  *		o  made Main.java use buffered IO and a Reader for Unicode support
</I>&gt;<i>  *		o  supports UNICODE?
</I>&gt;<i>  *		   Using Unicode charVocabulay makes code file big, but only
</I>&gt;<i>  *		   in the bitsets at the end. I need to make ANTLR generate
</I>&gt;<i>  *		   unicode bitsets more efficiently.
</I>&gt;<i>  * Version 1.19 (April 25, 2002)
</I>&gt;<i>  *		Terence added in nice fixes by John Pybus concerning floating
</I>&gt;<i>  *		constants and problems with super() calls.  John did a nice
</I>&gt;<i>  *		reorg of the primary/postfix expression stuff to read better
</I>&gt;<i>  *		and makes f.g.super() parse properly (it was METHOD_CALL not
</I>&gt;<i>  *		a SUPER_CTOR_CALL).  Also:
</I>&gt;<i>  *
</I>&gt;<i>  *		o  &quot;finally&quot; clause was a root...made it a child of &quot;try&quot;
</I>&gt;<i>  *		o  Added stuff for asserts too for Java 1.4, but *commented out*
</I>&gt;<i>  *		   as it is not backward compatible.
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.20 (October 27, 2002)
</I>&gt;<i>  *
</I>&gt;<i>  *      Terence ended up reorging John Pybus' stuff to
</I>&gt;<i>  *      remove some nondeterminisms and some syntactic predicates.
</I>&gt;<i>  *      Note that the grammar is stricter now; e.g., this(...) must
</I>&gt;<i>  *	be the first statement.
</I>&gt;<i>  *
</I>&gt;<i>  *      Trinary ?: operator wasn't working as array name:
</I>&gt;<i>  *          (isBig ? bigDigits : digits)[i];
</I>&gt;<i>  *
</I>&gt;<i>  *      Checked parser/tree parser on source for
</I>&gt;<i>  *          Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4,
</I>&gt;<i>  *	    and the 110k-line jGuru server source.
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.21 (October 17, 2003)
</I>&gt;<i>  *	Fixed lots of problems including:
</I>&gt;<i>  *	Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g
</I>&gt;<i>  *  He found a problem/fix with floating point that start with 0
</I>&gt;<i>  *  Ray also fixed problem that (int.class) was not recognized.
</I>&gt;<i>  *  Thorsten van Ellen noticed that \n are allowed incorrectly in
</I>strings.
&gt;<i>  *  TJP fixed CHAR_LITERAL analogously.
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.22 (April 14, 2004)
</I>&gt;<i>  *  Changed vocab to be ..\uFFFE to avoid -1 char. removed dummy
</I>VOCAB rule.
&gt;<i>  *
</I>&gt;<i>  * Version 1.21.2 (March, 2003)
</I>&gt;<i>  *      Changes by Matt Quail to support generics (as per JDK1.5/JSR14)
</I>&gt;<i>  *      Notes:
</I>&gt;<i>  *      o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot;
</I>&gt;<i>  *        keyword, since thats what JSR14 seems to imply.
</I>&gt;<i>  *      o Thanks to Monty Zukowski for his help on the antlr-interest
</I>&gt;<i>  *        mail list.
</I>&gt;<i>  *      o Thanks to Alan Eliasen for testing the grammar over his
</I>&gt;<i>  *        Fink source base
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.22+assert+JSR14 (2004-06-10)
</I>&gt;<i>  *      Merged ANTLR version 1.22 with javaG.g version 1.21.2 and added
</I>&gt;<i>  *      the ability to enable the &quot;assert&quot; keyword at runtime via
</I>the lexer.
&gt;<i>  *      Also made changes to generics rules for a saner AST creation.
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.22+assert+JSR14+JSR201 (2004-06-12)
</I>&gt;<i>  *      Added support for enums, varargs, enhanced for loop, and
</I>import static
&gt;<i>  *
</I>&gt;<i>  * Version 1.22+assert+JSR14+JSR201+JSR175 (2004-06-14)
</I>&gt;<i>  *      Added support for metadata (JSR 175). Refactored the field
</I>rule into
&gt;<i>  *      classField and interfaceField.
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.22+assert+JSR14+JSR201+JSR175+AST (2004-07-02)
</I>&gt;<i>  *      Various changes to improve AST generation; also made the
</I>tree parser
&gt;<i>  *      recognize all the fancy new stuff. Added the ability to
</I>enable the
&gt;<i>  *      &quot;enum&quot; keyword at runtime (just like &quot;assert&quot;).
</I>&gt;<i>  *
</I>&gt;<i>  * Version 1.22+assert+JSR14+JSR201+JSR175+AST+fixes (2004-08-17)
</I>&gt;<i>  *      Bug fixes and support for wildcard type arguments and
</I>constructor
&gt;<i>  *      type parameters (new in final draft of JSR 14). Formatting
</I>cleanup.
&gt;<i>  *
</I>&gt;<i>  * This grammar is in the PUBLIC DOMAIN
</I>&gt;<i>  */
</I>&gt;<i> class JavaRecognizer extends Parser;
</I>&gt;<i> options {
</I>&gt;<i> 	k = 2;                           // two token lookahead
</I>&gt;<i> 	exportVocab=Java;                // Call its vocabulary &quot;Java&quot;
</I>&gt;<i> 	codeGenMakeSwitchThreshold = 2;  // Some optimizations
</I>&gt;<i> 	codeGenBitsetTestThreshold = 3;
</I>&gt;<i> 	defaultErrorHandler = false;     // Don't generate parser error
</I>handlers
&gt;<i> 	buildAST = true;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> tokens {
</I>&gt;<i> 	BLOCK; MODIFIERS; OBJBLOCK; SLIST; CTOR_DEF; METHOD_DEF; VARIABLE_DEF;
</I>&gt;<i> 	INSTANCE_INIT; STATIC_INIT; TYPE; CLASS_DEF; INTERFACE_DEF;
</I>&gt;<i> 	PACKAGE_DEF; ARRAY_DECLARATOR; EXTENDS_CLAUSE; IMPLEMENTS_CLAUSE;
</I>&gt;<i> 	PARAMETERS; PARAMETER_DEF; LABELED_STAT; TYPECAST; INDEX_OP;
</I>&gt;<i> 	POST_INC; POST_DEC; METHOD_CALL; EXPR; ARRAY_INIT;
</I>&gt;<i> 	IMPORT; UNARY_MINUS; UNARY_PLUS; CASE_GROUP; ELIST; FOR_INIT;
</I>FOR_CONDITION;
&gt;<i> 	FOR_ITERATOR; EMPTY_STAT; FINAL=&quot;final&quot;; ABSTRACT=&quot;abstract&quot;;
</I>&gt;<i> 	STRICTFP=&quot;strictfp&quot;; SUPER_CTOR_CALL; CTOR_CALL;
</I>&gt;<i> 	ASSERT; TYPE_ARGS; TYPE_ARGS_END; TYPE_PARAMS; ENUM; ENUM_DEF;
</I>ENUM_CONST;
&gt;<i> 	ANNOTATION_DEF; ANNOTATION_MEMBER_DEF; ANNOTATION; ANNOTATIONS;
</I>&gt;<i> 	ANNOTATION_INIT_EMPTY; ANNOTATION_INIT_VALUE; ANNOTATION_INIT_LIST;
</I>&gt;<i> 	ANNOTATION_INIT_MEMBER; WILDCARD;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i>     /**
</I>&gt;<i>      * Counts the number of LT seen in the typeArguments production.
</I>&gt;<i>      * It is used in semantic predicates to ensure we have seen
</I>&gt;<i>      * enough closing '&gt;' characters; which actually may have been
</I>&gt;<i>      * either GT, SR or BSR tokens.
</I>&gt;<i>      */
</I>&gt;<i>     private int ltCounter = 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> // Compilation Unit: In Java, this is a single file.  This is the start
</I>&gt;<i> //   rule for this parser
</I>&gt;<i> compilationUnit
</I>&gt;<i> 	:	// A compilation unit starts with an optional package definition
</I>&gt;<i> 		// Metadata makes a mess of things: even package definitions can be
</I>&gt;<i> 		// annotated, although _only_ in one file (not enforced here ;))
</I>&gt;<i> 		(	( annotations &quot;package&quot; ) =&gt; packageDefinition
</I>&gt;<i> 		|	/* nothing */
</I>&gt;<i> 		)
</I>&gt;<i> 
</I>&gt;<i> 		// Next we have a series of zero or more import statements
</I>&gt;<i> 		( importDefinition )*
</I>&gt;<i> 
</I>&gt;<i> 		// Wrapping things up with any number of class or interface
</I>&gt;<i> 		//    definitions
</I>&gt;<i> 		( typeDefinition )*
</I>&gt;<i> 
</I>&gt;<i> 		EOF!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // Package statement: &quot;package&quot; followed by an identifier.
</I>&gt;<i> packageDefinition
</I>&gt;<i> 	options {defaultErrorHandler = true;} // let ANTLR handle errors
</I>&gt;<i> 	:	annotations p:&quot;package&quot;^ {#p.setType(PACKAGE_DEF);} identifier SEMI!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // Import statement: import followed by a package or class name
</I>&gt;<i> // JSR 201 allows the optional &quot;static&quot; keyword
</I>&gt;<i> importDefinition
</I>&gt;<i> 	options {defaultErrorHandler = true;}
</I>&gt;<i> 	:	i:&quot;import&quot;^ {#i.setType(IMPORT);} (&quot;static&quot;)? identifierStar SEMI!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A type definition in a file is either a class, interface,
</I>enumeration or
&gt;<i> // annotation type definition.
</I>&gt;<i> typeDefinition
</I>&gt;<i> 	options {defaultErrorHandler = true;}
</I>&gt;<i> 	:	m:modifiers!
</I>&gt;<i> 		( classDefinition[#m]
</I>&gt;<i> 		| enumDefinition[#m]
</I>&gt;<i> 		| interfaceDefinition[#m]
</I>&gt;<i> 		| annotationTypeDefinition[#m]
</I>&gt;<i> 		)
</I>&gt;<i> 	|	SEMI!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> /** A declaration is the creation of a reference or primitive-type
</I>variable
&gt;<i>  *  Create a separate Type/Var tree for each var in the var list.
</I>&gt;<i>  */
</I>&gt;<i> declaration!
</I>&gt;<i> 	:	m:modifiers t:typeSpec[false] v:variableDefinitions[#m,#t]
</I>&gt;<i> 		{#declaration = #v;}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A type specification is a type name with possible brackets afterwards
</I>&gt;<i> //   (which would make it an array type).
</I>&gt;<i> typeSpec[boolean addImagNode]
</I>&gt;<i> 	: classTypeSpec[addImagNode]
</I>&gt;<i> 	| builtInTypeSpec[addImagNode]
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // built in types are not reference types, everything else is
</I>&gt;<i> referenceTypeSpec[boolean addImagNode]
</I>&gt;<i> 	: classTypeSpec[addImagNode]
</I>&gt;<i> 	| arrayTypeSpec[addImagNode]
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A class type specification is a class type with either:
</I>&gt;<i> // - possible brackets afterwards
</I>&gt;<i> //   (which would make it an array type).
</I>&gt;<i> // - generic type arguments after
</I>&gt;<i> classTypeSpec[boolean addImagNode]
</I>&gt;<i> 	:	classOrInterfaceType[false]
</I>&gt;<i> 		(options{greedy=true;}: // match as many as possible
</I>&gt;<i> 			lb:LBRACK^ {#lb.setType(ARRAY_DECLARATOR);} RBRACK!
</I>&gt;<i> 		)*
</I>&gt;<i> 		{
</I>&gt;<i> 			if ( addImagNode ) {
</I>&gt;<i> 				#classTypeSpec = #(#[TYPE,&quot;TYPE&quot;], #classTypeSpec);
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> classOrInterfaceType[boolean addImagNode]
</I>&gt;<i> 	:	IDENT typeArguments
</I>&gt;<i> 		(options{greedy=true;}: // match as many as possible
</I>&gt;<i> 			DOT^
</I>&gt;<i> 			IDENT typeArguments
</I>&gt;<i> 		)*
</I>&gt;<i> 		{
</I>&gt;<i> 			if ( addImagNode ) {
</I>&gt;<i> 				#classOrInterfaceType = #(#[TYPE,&quot;TYPE&quot;],
</I>&gt;<i> 					#classOrInterfaceType);
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> typeArguments
</I>&gt;<i> {int currentLtLevel = 0;}
</I>&gt;<i> 	:
</I>&gt;<i> 		{currentLtLevel = ltCounter;}
</I>&gt;<i> 		(
</I>&gt;<i> 			lt:LT^	{ ltCounter++; #lt.setType(TYPE_ARGS); }
</I>&gt;<i> 			typeArgument
</I>&gt;<i> 			(options{greedy=true;}: // match as many as possible
</I>&gt;<i> 				// The second test is needed to construct trees properly
</I>&gt;<i> 				// in the case when we have &quot;&gt;&gt;&quot; or &quot;&gt;&gt;&gt;&quot; tokens
</I>&gt;<i> 				// (test case: &quot;var&lt;O1&lt;I1&lt;M1&gt;&gt;, O2&lt;I2&gt;&gt; a;&quot;
</I>&gt;<i> 				// The first test is needed because otherwise
</I>&gt;<i> 				// stuff breaks when guessing (e.g. declaration)
</I>&gt;<i> 				// because semantic actions are not executed and the
</I>&gt;<i> 				// second test would always fail (trees are not constructed
</I>&gt;<i> 				// while guessing, so no problem there).
</I>&gt;<i> 				{inputState.guessing !=0 || ltCounter == currentLtLevel + 1}?
</I>&gt;<i> 					COMMA! typeArgument
</I>&gt;<i> 			)*
</I>&gt;<i> 
</I>&gt;<i> 			(   // turn warning off since Antlr generates the right code,
</I>&gt;<i> 				// plus we have our semantic predicate below
</I>&gt;<i> 				options{generateAmbigWarnings=false;}:
</I>&gt;<i> 				typeArgumentsEnd!
</I>&gt;<i> 			)?
</I>&gt;<i> 		)
</I>&gt;<i> 		// make sure we have gobbled up enough '&gt;' characters
</I>&gt;<i> 		// if we are at the &quot;top level&quot; of nested typeArgument productions
</I>&gt;<i> 		{(currentLtLevel != 0) || ltCounter == currentLtLevel}?
</I>&gt;<i> 	|	{#typeArguments = #(#[TYPE_ARGS,&quot;TYPE_ARGS&quot;], #typeArguments);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // either reference type or wildcard type with optional lower or
</I>upper bound
&gt;<i> typeArgument
</I>&gt;<i> 	:	(	q:QUESTION^ {#q.setType(WILDCARD);}
</I>&gt;<i> 			( // faux conflict on &quot;extends&quot; because typeArgsEnd may be empty
</I>&gt;<i> 				options{greedy=true;}:
</I>&gt;<i> 				&quot;extends&quot; referenceTypeSpec[true]
</I>&gt;<i> 			|	&quot;super&quot; referenceTypeSpec[true]
</I>&gt;<i> 			)?
</I>&gt;<i> 		)
</I>&gt;<i> 	|	referenceTypeSpec[true]
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // this gobbles up *some* amount of '&gt;' characters, and counts how many
</I>&gt;<i> // it gobbled.
</I>&gt;<i> protected
</I>&gt;<i> typeArgumentsEnd
</I>&gt;<i> 	:	(	GT {ltCounter-=1;}
</I>&gt;<i> 		|	SR {ltCounter-=2;}
</I>&gt;<i> 		|	BSR {ltCounter-=3;}
</I>&gt;<i> 		)
</I>&gt;<i> 		{ #typeArgumentsEnd.setType(TYPE_ARGS_END); }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A builtin type specification is a builtin type with possible brackets
</I>&gt;<i> // afterwards (which would make it an array type).
</I>&gt;<i> builtInTypeSpec[boolean addImagNode]
</I>&gt;<i> 	:	builtInType
</I>&gt;<i> 		(options{greedy=true;}: // match as many as possible
</I>&gt;<i> 			lb:LBRACK^ {#lb.setType(ARRAY_DECLARATOR);} RBRACK!
</I>&gt;<i> 		)*
</I>&gt;<i> 		{
</I>&gt;<i> 			if ( addImagNode ) {
</I>&gt;<i> 				#builtInTypeSpec = #(#[TYPE,&quot;TYPE&quot;], #builtInTypeSpec);
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // An array type specification is a builtin type with brackets
</I>afterwards
&gt;<i> arrayTypeSpec[boolean addImagNode]
</I>&gt;<i> 	:	builtInType
</I>&gt;<i> 		(options{greedy=true;}: // match as many as possible
</I>&gt;<i> 			lb:LBRACK^ {#lb.setType(ARRAY_DECLARATOR);} RBRACK!
</I>&gt;<i> 		)+
</I>&gt;<i> 		{
</I>&gt;<i> 			if ( addImagNode ) {
</I>&gt;<i> 				#arrayTypeSpec = #(#[TYPE,&quot;TYPE&quot;], #arrayTypeSpec);
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A type name. which is either a (possibly qualified and parameterized)
</I>&gt;<i> // class name or a primitive (builtin) type
</I>&gt;<i> type
</I>&gt;<i> 	:	classOrInterfaceType[false]
</I>&gt;<i> 	|	builtInType
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // The primitive types.
</I>&gt;<i> builtInType
</I>&gt;<i> 	:	&quot;void&quot;
</I>&gt;<i> 	|	&quot;boolean&quot;
</I>&gt;<i> 	|	&quot;byte&quot;
</I>&gt;<i> 	|	&quot;char&quot;
</I>&gt;<i> 	|	&quot;short&quot;
</I>&gt;<i> 	|	&quot;int&quot;
</I>&gt;<i> 	|	&quot;float&quot;
</I>&gt;<i> 	|	&quot;long&quot;
</I>&gt;<i> 	|	&quot;double&quot;
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A (possibly-qualified) java identifier.  We start with the first
</I>IDENT
&gt;<i> //   and expand its name by adding dots and following IDENTS
</I>&gt;<i> identifier
</I>&gt;<i> 	:	IDENT  ( DOT^ IDENT )*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> identifierStar
</I>&gt;<i> 	:	IDENT
</I>&gt;<i> 		( DOT^ IDENT )*
</I>&gt;<i> 		( DOT^ STAR  )?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A list of zero or more modifiers.  We could have used (modifier)* in
</I>&gt;<i> //   place of a call to modifiers, but I thought it was a good idea
</I>to keep
&gt;<i> //   this rule separate so they can easily be collected in a Vector if
</I>&gt;<i> //   someone so desires
</I>&gt;<i> // JSR 175 says that annotations are allowed everywhere modifiers are.
</I>&gt;<i> // A nondeterminism warning is masked by the greedy option.
</I>&gt;<i> modifiers
</I>&gt;<i> 	:	( options{greedy=true;} : modifier | annotation )*
</I>&gt;<i> 		{#modifiers = #([MODIFIERS, &quot;MODIFIERS&quot;], #modifiers);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // modifiers for Java classes, interfaces, class/instance vars and
</I>methods
&gt;<i> modifier
</I>&gt;<i> 	:	&quot;private&quot;
</I>&gt;<i> 	|	&quot;public&quot;
</I>&gt;<i> 	|	&quot;protected&quot;
</I>&gt;<i> 	|	&quot;static&quot;
</I>&gt;<i> 	|	&quot;transient&quot;
</I>&gt;<i> 	|	&quot;final&quot;
</I>&gt;<i> 	|	&quot;abstract&quot;
</I>&gt;<i> 	|	&quot;native&quot;
</I>&gt;<i> 	|	&quot;threadsafe&quot;
</I>&gt;<i> 	|	&quot;synchronized&quot;
</I>&gt;<i> //	|	&quot;const&quot;			// reserved word, but not valid
</I>&gt;<i> 	|	&quot;volatile&quot;
</I>&gt;<i> 	|	&quot;strictfp&quot;
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Definition of an enumeration (JSR 201)
</I>&gt;<i> enumDefinition![AST modifiers]
</I>&gt;<i> 	:	ENUM IDENT
</I>&gt;<i> 		// it might implement some interfaces...
</I>&gt;<i> 		ic:implementsClause
</I>&gt;<i> 		// now parse the body of the enum
</I>&gt;<i> 		eb:enumBlock
</I>&gt;<i> 		{#enumDefinition = #(#[ENUM_DEF,&quot;ENUM_DEF&quot;], modifiers,IDENT,ic,eb);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is the body of an enumeration.  It can contain a list of comma
</I>&gt;<i> // separated identifiers (the enum values), and optionally,
</I>seperated by a
&gt;<i> // semicolon, some declarations like in a class at the end.
</I>&gt;<i> // The values of the enumeration may be annotated.
</I>&gt;<i> enumBlock
</I>&gt;<i> 	:	LCURLY! // next line has a nondeterminism warning without option
</I>greedy
&gt;<i> 			( enumConst ( options {greedy=true;} : COMMA! enumConst )* )?
</I>&gt;<i> 			( COMMA! )?	// optional comma at end of value list
</I>&gt;<i> 			( SEMI! ( classField | SEMI! )* )?
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 		{#enumBlock = #([OBJBLOCK, &quot;OBJBLOCK&quot;], #enumBlock);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Each enum value is in fact a class instance, and can be followed
</I>by the
&gt;<i> // usual class declarations.
</I>&gt;<i> enumConst
</I>&gt;<i> 	:	annotations IDENT enumConstInit ( classBlock )?
</I>&gt;<i> 		{#enumConst = #([ENUM_CONST, &quot;ENUM_CONST&quot;], #enumConst );}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is really a constructor invocation.
</I>&gt;<i> enumConstInit
</I>&gt;<i> 	: ( lp:LPAREN^ argList RPAREN! { #lp.setType(CTOR_CALL); } )?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Definition of an annotation type (JSR 175)
</I>&gt;<i> annotationTypeDefinition![AST modifiers]
</I>&gt;<i> 	:	AT &quot;interface&quot; IDENT
</I>&gt;<i> 		// now parse the body of the annotation type
</I>&gt;<i> 		ab:annotationBlock
</I>&gt;<i> 		{#annotationTypeDefinition = #(#[ANNOTATION_DEF,&quot;ANNOTATION_DEF&quot;],
</I>&gt;<i> 									modifiers,IDENT,ab);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is the body of an annotation type. Only inner type
</I>definitions and
&gt;<i> // members (which use a notation similar to methods) are allowed.
</I>&gt;<i> annotationBlock
</I>&gt;<i> 	:	LCURLY!
</I>&gt;<i> 			( annotationField | SEMI! )*
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 		{#annotationBlock = #([OBJBLOCK, &quot;OBJBLOCK&quot;], #annotationBlock);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> annotationField!
</I>&gt;<i> 	:
</I>&gt;<i> 		mods:modifiers
</I>&gt;<i> 		(	it:innerTypeDef[#mods]		// inner type definition
</I>&gt;<i> 			{#annotationField = #it;}
</I>&gt;<i> 		|	ts:typeSpec[false]
</I>&gt;<i> 			(	i:IDENT LPAREN RPAREN dv:defaultValue SEMI
</I>&gt;<i> 				{#annotationField =
</I>&gt;<i> 						#(#[ANNOTATION_MEMBER_DEF,&quot;ANNOTATION_MEMBER_DEF&quot;],
</I>&gt;<i> 						mods, #(#[TYPE,&quot;TYPE&quot;],ts), i, dv); }
</I>&gt;<i> 			|	v:variableDefinitions[#mods,#ts] SEMI
</I>&gt;<i> 				{#annotationField = #v;}
</I>&gt;<i> 			)
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Annotation members may have optional default values.
</I>&gt;<i> defaultValue
</I>&gt;<i> 	:	( &quot;default&quot;^ annotationMemberValue )?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> annotations
</I>&gt;<i> 	:	( annotation )*
</I>&gt;<i> 		{#annotations = #([ANNOTATIONS, &quot;ANNOTATIONS&quot;], #annotations);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> annotation
</I>&gt;<i> 	:	AT^ identifier annotationInit
</I>&gt;<i> 		{#AT.setType(ANNOTATION);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // The initialization (list of assignments, single value, or nothing).
</I>&gt;<i> annotationInit
</I>&gt;<i> 	:	(	lp:LPAREN^
</I>&gt;<i> 			(	annotationMemberInit
</I>&gt;<i> 				( COMMA! annotationMemberInit )*
</I>&gt;<i> 				{#lp.setType(ANNOTATION_INIT_LIST);}
</I>&gt;<i> 			|	annotationMemberValue	{#lp.setType(ANNOTATION_INIT_VALUE);}
</I>&gt;<i> 			)
</I>&gt;<i> 			RPAREN!
</I>&gt;<i> 		)
</I>&gt;<i> 	|	{#annotationInit = #([ANNOTATION_INIT_EMPTY, &quot;AN_INIT_EMPTY&quot;]);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> annotationMemberInit
</I>&gt;<i> 	:	IDENT ASSIGN! annotationMemberValue
</I>&gt;<i> 		{#annotationMemberInit =
</I>&gt;<i> 		 #([ANNOTATION_INIT_MEMBER, &quot;AN_INIT_MEMBER&quot;],
</I>#annotationMemberInit);}
&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> annotationMemberValue
</I>&gt;<i> 	:	annotation
</I>&gt;<i> 	|	conditionalExpression
</I>&gt;<i> 		{#annotationMemberValue = #(#[EXPR,&quot;EXPR&quot;],#annotationMemberValue);}
</I>&gt;<i> 	|	arrayInitializer
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Definition of a Java class
</I>&gt;<i> classDefinition![AST modifiers]
</I>&gt;<i> 	:	&quot;class&quot; IDENT
</I>&gt;<i> 		// it _might_ have type paramaters
</I>&gt;<i> 		tp:typeParameters
</I>&gt;<i> 		// it _might_ have a superclass...
</I>&gt;<i> 		sc:superClassClause
</I>&gt;<i> 		// it might implement some interfaces...
</I>&gt;<i> 		ic:implementsClause
</I>&gt;<i> 		// now parse the body of the class
</I>&gt;<i> 		cb:classBlock
</I>&gt;<i> 		{#classDefinition = #(#[CLASS_DEF,&quot;CLASS_DEF&quot;],
</I>&gt;<i> 							   modifiers,IDENT,tp,sc,ic,cb);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> superClassClause!
</I>&gt;<i> 	:	( &quot;extends&quot; classOrInterfaceType[false] )?
</I>&gt;<i> 		{#superClassClause = #(#[EXTENDS_CLAUSE,&quot;EXTENDS_CLAUSE&quot;],
</I>&gt;<i> 			#superClassClause);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Definition of a Java Interface
</I>&gt;<i> interfaceDefinition![AST modifiers]
</I>&gt;<i> 	:	&quot;interface&quot; IDENT
</I>&gt;<i> 		// it _might_ have type paramaters
</I>&gt;<i> 		tp:typeParameters
</I>&gt;<i> 		// it might extend some other interfaces
</I>&gt;<i> 		ie:interfaceExtends
</I>&gt;<i> 		// now parse the body of the interface
</I>&gt;<i> 		ib:interfaceBlock
</I>&gt;<i> 		{#interfaceDefinition = #(#[INTERFACE_DEF,&quot;INTERFACE_DEF&quot;],
</I>&gt;<i> 									modifiers,IDENT,tp,ie,ib);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> typeParameters
</I>&gt;<i> {int currentLtLevel = 0;}
</I>&gt;<i> 	:
</I>&gt;<i> 		{currentLtLevel = ltCounter;}
</I>&gt;<i> 		(
</I>&gt;<i> 			lt:LT^	{ ltCounter++; #lt.setType(TYPE_PARAMS); }
</I>&gt;<i> 			typeParameter (COMMA! typeParameter)*
</I>&gt;<i> 			(typeArgumentsEnd!)?
</I>&gt;<i> 		)
</I>&gt;<i> 		// make sure we have gobbled up enough '&gt;' characters
</I>&gt;<i> 		// if we are at the &quot;top level&quot; of nested typeArgument productions
</I>&gt;<i> 		{(currentLtLevel != 0) || ltCounter == currentLtLevel}?
</I>&gt;<i> 	|	{#typeParameters = #(#[TYPE_PARAMS,&quot;TYPE_PARAMS&quot;], #typeParameters);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> typeParameter
</I>&gt;<i> 	:	IDENT
</I>&gt;<i> 		(   // I'm pretty sure Antlr generates the right thing here:
</I>&gt;<i> 			options{generateAmbigWarnings=false;}:
</I>&gt;<i> 			&quot;extends&quot; classOrInterfaceType[true]
</I>&gt;<i> 			(BAND! classOrInterfaceType[true])*
</I>&gt;<i> 		)?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is the body of an interface.
</I>&gt;<i> interfaceBlock
</I>&gt;<i> 	:	LCURLY!
</I>&gt;<i> 			( interfaceField | SEMI! )*
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 		{#interfaceBlock = #([OBJBLOCK, &quot;OBJBLOCK&quot;], #interfaceBlock);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is the body of a class.  You can have fields and extra
</I>semicolons,
&gt;<i> // That's about it (until you see what a field is...)
</I>&gt;<i> classBlock
</I>&gt;<i> 	:	LCURLY!
</I>&gt;<i> 			( classField | SEMI! )*
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 		{#classBlock = #([OBJBLOCK, &quot;OBJBLOCK&quot;], #classBlock);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // An interface can extend several other interfaces...
</I>&gt;<i> interfaceExtends
</I>&gt;<i> 	:	(
</I>&gt;<i> 		e:&quot;extends&quot;!
</I>&gt;<i> 		classOrInterfaceType[false] ( COMMA! classOrInterfaceType[false] )*
</I>&gt;<i> 		)?
</I>&gt;<i> 		{#interfaceExtends = #(#[EXTENDS_CLAUSE,&quot;EXTENDS_CLAUSE&quot;],
</I>&gt;<i> 							#interfaceExtends);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A class can implement several interfaces...
</I>&gt;<i> implementsClause
</I>&gt;<i> 	:	(
</I>&gt;<i> 			i:&quot;implements&quot;! classOrInterfaceType[false]
</I>&gt;<i> 							( COMMA! classOrInterfaceType[false] )*
</I>&gt;<i> 		)?
</I>&gt;<i> 		{#implementsClause = #(#[IMPLEMENTS_CLAUSE,&quot;IMPLEMENTS_CLAUSE&quot;],
</I>&gt;<i> 								 #implementsClause);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Fields that are type definitions.
</I>&gt;<i> protected
</I>&gt;<i> innerTypeDef![AST modifiers]
</I>&gt;<i> 	: 	(	ed:enumDefinition[modifiers]        // inner enum
</I>&gt;<i> 			{#innerTypeDef = #ed;}
</I>&gt;<i> 
</I>&gt;<i> 		|	cd:classDefinition[modifiers]       // inner class
</I>&gt;<i> 			{#innerTypeDef = #cd;}
</I>&gt;<i> 
</I>&gt;<i> 		|	id:interfaceDefinition[modifiers]   // inner interface
</I>&gt;<i> 			{#innerTypeDef = #id;}
</I>&gt;<i> 
</I>&gt;<i> 		|	ad:annotationTypeDefinition[modifiers]   // inner annotation type
</I>&gt;<i> 			{#innerTypeDef = #ad;}
</I>&gt;<i> 		)
</I>&gt;<i> 		;
</I>&gt;<i> 
</I>&gt;<i> protected
</I>&gt;<i> memberDef![AST modifiers, AST typeParams, boolean allowMethodBody]
</I>&gt;<i> 	:
</I>&gt;<i> 		// A generic method has the typeParameters before the return type.
</I>&gt;<i> 		// This is not allowed for variable definitions, but this production
</I>&gt;<i> 		// allows it; a semantic check could be used if you wanted.
</I>&gt;<i> 		t:typeSpec[false]  // method or variable declaration(s)
</I>&gt;<i> 		(	IDENT  // the name of the method
</I>&gt;<i> 
</I>&gt;<i> 			// parse the formal parameter declarations.
</I>&gt;<i> 			LPAREN! param:parameterDeclarationList RPAREN!
</I>&gt;<i> 
</I>&gt;<i> 			rt:declaratorBrackets[#t]
</I>&gt;<i> 
</I>&gt;<i> 			// get the list of exceptions that this method is
</I>&gt;<i> 			// declared to throw
</I>&gt;<i> 			(tc:throwsClause)?
</I>&gt;<i> 
</I>&gt;<i> 			( SEMI | {allowMethodBody}? s2:compoundStatement )
</I>&gt;<i> 			{#memberDef = #(#[METHOD_DEF,&quot;METHOD_DEF&quot;],
</I>&gt;<i> 							 modifiers,
</I>&gt;<i> 							 typeParams,
</I>&gt;<i> 							 #(#[TYPE,&quot;TYPE&quot;],rt),
</I>&gt;<i> 							 IDENT,
</I>&gt;<i> 							 param,
</I>&gt;<i> 							 tc,
</I>&gt;<i> 							 s2);}
</I>&gt;<i> 		|	v:variableDefinitions[modifiers,#t] SEMI
</I>&gt;<i> //			{#field = #(#[VARIABLE_DEF,&quot;VARIABLE_DEF&quot;], v);}
</I>&gt;<i> 			{#memberDef = #v;} // omit tp here, as it is not legal anyway
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // An interface can contain inner type definitions, methods and constant
</I>&gt;<i> // definitions. Generalizing the latter, memberDef allows member
</I>variables.
&gt;<i> // To detect and prevent that, use a semantic check.
</I>&gt;<i> interfaceField!
</I>&gt;<i> 	:
</I>&gt;<i> 		mods:modifiers
</I>&gt;<i> 		(	it:innerTypeDef[#mods]		// inner type definition
</I>&gt;<i> 			{#interfaceField = #it;}
</I>&gt;<i> 		|	tp:typeParameters md:memberDef[#mods, #tp, false]
</I>&gt;<i> 			// method or variable definition
</I>&gt;<i> 			{#interfaceField = #md;}
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Now the various things that can be defined inside a class...
</I>&gt;<i> classField!
</I>&gt;<i> 	:	// method, constructor, or variable declaration
</I>&gt;<i> 		mods:modifiers
</I>&gt;<i> 		(	it:innerTypeDef[#mods]	// inner type definition
</I>&gt;<i> 			{#classField = #it;}
</I>&gt;<i> 
</I>&gt;<i> 		|	tp:typeParameters
</I>&gt;<i> 			(	h:ctorHead s:constructorBody // constructor
</I>&gt;<i> 				{#classField = #(#[CTOR_DEF,&quot;CTOR_DEF&quot;], mods, tp, h, s);}
</I>&gt;<i> 
</I>&gt;<i> 			|	md:memberDef[#mods, #tp, true] // method or variable definition
</I>&gt;<i> 				{#classField = #md;}
</I>&gt;<i> 			)
</I>&gt;<i> 		)
</I>&gt;<i> 
</I>&gt;<i> 	// &quot;static { ... }&quot; class initializer
</I>&gt;<i> 	|	&quot;static&quot; s3:compoundStatement
</I>&gt;<i> 		{#classField = #(#[STATIC_INIT,&quot;STATIC_INIT&quot;], s3);}
</I>&gt;<i> 
</I>&gt;<i> 	// &quot;{ ... }&quot; instance initializer
</I>&gt;<i> 	|	s4:compoundStatement
</I>&gt;<i> 		{#classField = #(#[INSTANCE_INIT,&quot;INSTANCE_INIT&quot;], s4);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> constructorBody
</I>&gt;<i> 	:	lc:LCURLY^ {#lc.setType(SLIST);}
</I>&gt;<i> 			( options { greedy=true; } : explicitConstructorInvocation)?
</I>&gt;<i> 			(statement)*
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> /** Catch obvious constructor calls, but not the expr.super(...)
</I>calls */
&gt;<i> explicitConstructorInvocation
</I>&gt;<i> 	:	typeArguments
</I>&gt;<i> 		(	&quot;this&quot;! lp1:LPAREN^ argList RPAREN! SEMI!
</I>&gt;<i> 			{#lp1.setType(CTOR_CALL);}
</I>&gt;<i> 		|	&quot;super&quot;! lp2:LPAREN^ argList RPAREN! SEMI!
</I>&gt;<i> 			{#lp2.setType(SUPER_CTOR_CALL);}
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> variableDefinitions[AST mods, AST t]
</I>&gt;<i> 	:	variableDeclarator[getASTFactory().dupTree(mods),
</I>&gt;<i> 						   getASTFactory().dupList(t)]
</I>&gt;<i> 		(	COMMA!
</I>&gt;<i> 			variableDeclarator[getASTFactory().dupTree(mods),
</I>&gt;<i> 							   getASTFactory().dupList(t)]
</I>&gt;<i> 		)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> /** Declaration of a variable.  This can be a class/instance variable,
</I>&gt;<i>  *   or a local variable in a method
</I>&gt;<i>  * It can also include possible initialization.
</I>&gt;<i>  */
</I>&gt;<i> variableDeclarator![AST mods, AST t]
</I>&gt;<i> 	:	id:IDENT d:declaratorBrackets[t] v:varInitializer
</I>&gt;<i> 		{#variableDeclarator = #(#[VARIABLE_DEF,&quot;VARIABLE_DEF&quot;],
</I>&gt;<i> 								mods, #(#[TYPE,&quot;TYPE&quot;],d), id, v);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> declaratorBrackets[AST typ]
</I>&gt;<i> 	:	{#declaratorBrackets=typ;}
</I>&gt;<i> 		(lb:LBRACK^ {#lb.setType(ARRAY_DECLARATOR);} RBRACK!)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> varInitializer
</I>&gt;<i> 	:	( ASSIGN^ initializer )?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is an initializer used to set up an array.
</I>&gt;<i> arrayInitializer
</I>&gt;<i> 	:	lc:LCURLY^ {#lc.setType(ARRAY_INIT);}
</I>&gt;<i> 			(	initializer
</I>&gt;<i> 				(
</I>&gt;<i> 					// CONFLICT: does a COMMA after an initializer start a new
</I>&gt;<i> 					//           initializer or start the option ',' at end?
</I>&gt;<i> 					//           ANTLR generates proper code by matching
</I>&gt;<i> 					//           the comma as soon as possible.
</I>&gt;<i> 					options {
</I>&gt;<i> 						warnWhenFollowAmbig = false;
</I>&gt;<i> 					}
</I>&gt;<i> 				:
</I>&gt;<i> 					COMMA! initializer
</I>&gt;<i> 				)*
</I>&gt;<i> 			)?
</I>&gt;<i> 			(COMMA!)?
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // The two &quot;things&quot; that can initialize an array element are an
</I>expression
&gt;<i> //   and another (nested) array initializer.
</I>&gt;<i> initializer
</I>&gt;<i> 	:	expression
</I>&gt;<i> 	|	arrayInitializer
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is the header of a method.  It includes the name and parameters
</I>&gt;<i> //   for the method.
</I>&gt;<i> //   This also watches for a list of exception classes in a &quot;throws&quot;
</I>clause.
&gt;<i> ctorHead
</I>&gt;<i> 	:	IDENT  // the name of the method
</I>&gt;<i> 
</I>&gt;<i> 		// parse the formal parameter declarations.
</I>&gt;<i> 		LPAREN! parameterDeclarationList RPAREN!
</I>&gt;<i> 
</I>&gt;<i> 		// get the list of exceptions that this method is declared to throw
</I>&gt;<i> 		(throwsClause)?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // This is a list of exception classes that the method is declared
</I>to throw
&gt;<i> throwsClause
</I>&gt;<i> 	:	&quot;throws&quot;^ identifier ( COMMA! identifier )*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // A list of formal parameters
</I>&gt;<i> parameterDeclarationList
</I>&gt;<i> 	:	( parameterDeclaration ( COMMA! parameterDeclaration )* )?
</I>&gt;<i> 		{#parameterDeclarationList = #(#[PARAMETERS,&quot;PARAMETERS&quot;],
</I>&gt;<i> 									#parameterDeclarationList);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // A formal parameter.
</I>&gt;<i> // The ellipsis is the support for varargs (JSR 201)
</I>&gt;<i> // This rule allows ellipsis on any parameter, not just the last (as
</I>specified
&gt;<i> // by JSR 201), so a semantic check is needed for that.
</I>&gt;<i> parameterDeclaration!
</I>&gt;<i> 	:	pm:parameterModifier t:typeSpec[false] ( el:ELLIPSIS )? id:IDENT
</I>&gt;<i> 		pd:declaratorBrackets[#t]
</I>&gt;<i> 		{#parameterDeclaration = #(#[PARAMETER_DEF,&quot;PARAMETER_DEF&quot;],
</I>&gt;<i> 									pm, #([TYPE,&quot;TYPE&quot;],pd,el), id);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Parameters can be final. And annotated. Or even both.
</I>&gt;<i> parameterModifier
</I>&gt;<i> 	:	( &quot;final&quot; | annotation )*
</I>&gt;<i> 		{#parameterModifier = #(#[MODIFIERS,&quot;MODIFIERS&quot;],
</I>#parameterModifier);}
&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Compound statement.  This is used in many contexts:
</I>&gt;<i> //   Inside a class definition prefixed with &quot;static&quot;:
</I>&gt;<i> //      it is a class initializer
</I>&gt;<i> //   Inside a class definition without &quot;static&quot;:
</I>&gt;<i> //      it is an instance initializer
</I>&gt;<i> //   As the body of a method
</I>&gt;<i> //   As a completely indepdent braced block of code inside a method
</I>&gt;<i> //      it starts a new scope for variable definitions
</I>&gt;<i> 
</I>&gt;<i> compoundStatement
</I>&gt;<i> 	:	lc:LCURLY^ {#lc.setType(SLIST);}
</I>&gt;<i> 			// include the (possibly-empty) list of statements
</I>&gt;<i> 			(statement)*
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> statement
</I>&gt;<i> 	// A list of statements in curly braces -- start a new scope!
</I>&gt;<i> 	:	compoundStatement
</I>&gt;<i> 
</I>&gt;<i> 	// declarations are ambiguous with &quot;ID DOT&quot; relative to expression
</I>&gt;<i> 	// statements.  Must backtrack to be sure.  Could use a semantic
</I>&gt;<i> 	// predicate to test symbol table to see what the type was coming
</I>&gt;<i> 	// up, but that's pretty hard without a symbol table ;)
</I>&gt;<i> 	|	(declaration)=&gt; declaration SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// An expression statement.  This could be a method call,
</I>&gt;<i> 	// assignment statement, or any other expression evaluated for
</I>&gt;<i> 	// side-effects.
</I>&gt;<i> 	|	expression SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// class or enum definition
</I>&gt;<i> 	|	m:modifiers! ( enumDefinition[#m] |	classDefinition[#m] )
</I>&gt;<i> 
</I>&gt;<i> 	// Attach a label to the front of a statement
</I>&gt;<i> 	|	IDENT c:COLON^ {#c.setType(LABELED_STAT);} statement
</I>&gt;<i> 
</I>&gt;<i> 	// If-else statement
</I>&gt;<i> 	|	&quot;if&quot;^ LPAREN! expression RPAREN! statement
</I>&gt;<i> 		(
</I>&gt;<i> 			// CONFLICT: the old &quot;dangling-else&quot; problem...
</I>&gt;<i> 			//           ANTLR generates proper code matching
</I>&gt;<i> 			//           as soon as possible.  Hush warning.
</I>&gt;<i> 			options {
</I>&gt;<i> 				warnWhenFollowAmbig = false;
</I>&gt;<i> 			}
</I>&gt;<i> 		:
</I>&gt;<i> 			&quot;else&quot;! statement
</I>&gt;<i> 		)?
</I>&gt;<i> 
</I>&gt;<i> 	// For statement, with support for the enhanced variant (JSR 201)
</I>&gt;<i> 	|	&quot;for&quot;^
</I>&gt;<i> 			LPAREN!
</I>&gt;<i> 			(
</I>&gt;<i> 				( parameterDeclaration COLON ) =&gt;
</I>&gt;<i> 				parameterDeclaration COLON! expression
</I>&gt;<i> 			|
</I>&gt;<i> 				forInit SEMI!   // initializer
</I>&gt;<i> 				forCond	SEMI!   // condition test
</I>&gt;<i> 				forIter         // updater
</I>&gt;<i> 			)
</I>&gt;<i> 			RPAREN!
</I>&gt;<i> 			statement                     // statement to loop over
</I>&gt;<i> 
</I>&gt;<i> 	// While statement
</I>&gt;<i> 	|	&quot;while&quot;^ LPAREN! expression RPAREN! statement
</I>&gt;<i> 
</I>&gt;<i> 	// do-while statement
</I>&gt;<i> 	|	&quot;do&quot;^ statement &quot;while&quot;! LPAREN! expression RPAREN! SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// get out of a loop (or switch)
</I>&gt;<i> 	|	&quot;break&quot;^ (IDENT)? SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// do next iteration of a loop
</I>&gt;<i> 	|	&quot;continue&quot;^ (IDENT)? SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// Return an expression
</I>&gt;<i> 	|	&quot;return&quot;^ (expression)? SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// switch/case statement
</I>&gt;<i> 	|	&quot;switch&quot;^ LPAREN! expression RPAREN! LCURLY!
</I>&gt;<i> 			( casesGroup )*
</I>&gt;<i> 		RCURLY!
</I>&gt;<i> 
</I>&gt;<i> 	// exception try-catch block
</I>&gt;<i> 	|	tryBlock
</I>&gt;<i> 
</I>&gt;<i> 	// throw an exception
</I>&gt;<i> 	|	&quot;throw&quot;^ expression SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// synchronize a statement
</I>&gt;<i> 	|	&quot;synchronized&quot;^ LPAREN! expression RPAREN! compoundStatement
</I>&gt;<i> 
</I>&gt;<i> 	// asserts (this can be enabled/disabled via the lexer)
</I>&gt;<i> 	|	ASSERT^ expression ( COLON! expression )? SEMI!
</I>&gt;<i> 
</I>&gt;<i> 	// empty statement
</I>&gt;<i> 	|	s:SEMI {#s.setType(EMPTY_STAT);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> casesGroup
</I>&gt;<i> 	:	(	// CONFLICT: to which case group do the statements bind?
</I>&gt;<i> 			//           ANTLR generates proper code: it groups the
</I>&gt;<i> 			//           many &quot;case&quot;/&quot;default&quot; labels together then
</I>&gt;<i> 			//           follows them with the statements
</I>&gt;<i> 			options {
</I>&gt;<i> 				greedy = true;
</I>&gt;<i> 			}
</I>&gt;<i> 			:
</I>&gt;<i> 			aCase
</I>&gt;<i> 		)+
</I>&gt;<i> 		caseSList
</I>&gt;<i> 		{#casesGroup = #([CASE_GROUP, &quot;CASE_GROUP&quot;], #casesGroup);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> aCase
</I>&gt;<i> 	:	(&quot;case&quot;^ expression | &quot;default&quot;) COLON!
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> caseSList
</I>&gt;<i> 	:	(statement)*
</I>&gt;<i> 		{#caseSList = #(#[SLIST,&quot;SLIST&quot;],#caseSList);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // The initializer for a for loop
</I>&gt;<i> forInit
</I>&gt;<i> 		// if it looks like a declaration, it is
</I>&gt;<i> 	:	(	(declaration)=&gt; declaration
</I>&gt;<i> 		// otherwise it could be an expression list...
</I>&gt;<i> 		|	expressionList
</I>&gt;<i> 		)?
</I>&gt;<i> 		{#forInit = #(#[FOR_INIT,&quot;FOR_INIT&quot;],#forInit);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> forCond
</I>&gt;<i> 	:	(expression)?
</I>&gt;<i> 		{#forCond = #(#[FOR_CONDITION,&quot;FOR_CONDITION&quot;],#forCond);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> forIter
</I>&gt;<i> 	:	(expressionList)?
</I>&gt;<i> 		{#forIter = #(#[FOR_ITERATOR,&quot;FOR_ITERATOR&quot;],#forIter);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // an exception handler try/catch block
</I>&gt;<i> tryBlock
</I>&gt;<i> 	:	&quot;try&quot;^ compoundStatement
</I>&gt;<i> 		(handler)*
</I>&gt;<i> 		( finallyClause )?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> finallyClause
</I>&gt;<i> 	:	&quot;finally&quot;^ compoundStatement
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // an exception handler
</I>&gt;<i> handler
</I>&gt;<i> 	:	&quot;catch&quot;^ LPAREN! parameterDeclaration RPAREN! compoundStatement
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // expressions
</I>&gt;<i> // Note that most of these expressions follow the pattern
</I>&gt;<i> //   thisLevelExpression :
</I>&gt;<i> //       nextHigherPrecedenceExpression
</I>&gt;<i> //           (OPERATOR nextHigherPrecedenceExpression)*
</I>&gt;<i> // which is a standard recursive definition for a parsing an expression.
</I>&gt;<i> // The operators in java have the following precedences:
</I>&gt;<i> //    lowest  (13)  = *= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=
</I>&gt;<i> //            (12)  ?:
</I>&gt;<i> //            (11)  ||
</I>&gt;<i> //            (10)  &amp;&amp;
</I>&gt;<i> //            ( 9)  |
</I>&gt;<i> //            ( 8)  ^
</I>&gt;<i> //            ( 7)  &amp;
</I>&gt;<i> //            ( 6)  == !=
</I>&gt;<i> //            ( 5)  &lt; &lt;= &gt; &gt;=
</I>&gt;<i> //            ( 4)  &lt;&lt; &gt;&gt;
</I>&gt;<i> //            ( 3)  +(binary) -(binary)
</I>&gt;<i> //            ( 2)  * / %
</I>&gt;<i> //            ( 1)  ++ -- +(unary) -(unary)  ~  !  (type)
</I>&gt;<i> //                  []   () (method call)  . (dot -- identifier
</I>qualification)
&gt;<i> //                  new   ()  (explicit parenthesis)
</I>&gt;<i> //
</I>&gt;<i> // the last two are not usually on a precedence chart; I put them in
</I>&gt;<i> // to point out that new has a higher precedence than '.', so you
</I>&gt;<i> // can validy use
</I>&gt;<i> //     new Frame().show()
</I>&gt;<i> //
</I>&gt;<i> // Note that the above precedence levels map to the rules below...
</I>&gt;<i> // Once you have a precedence chart, writing the appropriate rules
</I>as below
&gt;<i> //   is usually very straightfoward
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // the mother of all expressions
</I>&gt;<i> expression
</I>&gt;<i> 	:	assignmentExpression
</I>&gt;<i> 		{#expression = #(#[EXPR,&quot;EXPR&quot;],#expression);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // This is a list of expressions.
</I>&gt;<i> expressionList
</I>&gt;<i> 	:	expression (COMMA! expression)*
</I>&gt;<i> 		{#expressionList = #(#[ELIST,&quot;ELIST&quot;], expressionList);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // assignment expression (level 13)
</I>&gt;<i> assignmentExpression
</I>&gt;<i> 	:	conditionalExpression
</I>&gt;<i> 		(	(	ASSIGN^
</I>&gt;<i> 			|	PLUS_ASSIGN^
</I>&gt;<i> 			|	MINUS_ASSIGN^
</I>&gt;<i> 			|	STAR_ASSIGN^
</I>&gt;<i> 			|	DIV_ASSIGN^
</I>&gt;<i> 			|	MOD_ASSIGN^
</I>&gt;<i> 			|	SR_ASSIGN^
</I>&gt;<i> 			|	BSR_ASSIGN^
</I>&gt;<i> 			|	SL_ASSIGN^
</I>&gt;<i> 			|	BAND_ASSIGN^
</I>&gt;<i> 			|	BXOR_ASSIGN^
</I>&gt;<i> 			|	BOR_ASSIGN^
</I>&gt;<i> 			)
</I>&gt;<i> 			assignmentExpression
</I>&gt;<i> 		)?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // conditional test (level 12)
</I>&gt;<i> conditionalExpression
</I>&gt;<i> 	:	logicalOrExpression
</I>&gt;<i> 		( QUESTION^ assignmentExpression COLON! conditionalExpression )?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // logical or (||)  (level 11)
</I>&gt;<i> logicalOrExpression
</I>&gt;<i> 	:	logicalAndExpression (LOR^ logicalAndExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // logical and (&amp;&amp;)  (level 10)
</I>&gt;<i> logicalAndExpression
</I>&gt;<i> 	:	inclusiveOrExpression (LAND^ inclusiveOrExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // bitwise or non-short-circuiting or (|)  (level 9)
</I>&gt;<i> inclusiveOrExpression
</I>&gt;<i> 	:	exclusiveOrExpression (BOR^ exclusiveOrExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // exclusive or (^)  (level 8)
</I>&gt;<i> exclusiveOrExpression
</I>&gt;<i> 	:	andExpression (BXOR^ andExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // bitwise or non-short-circuiting and (&amp;)  (level 7)
</I>&gt;<i> andExpression
</I>&gt;<i> 	:	equalityExpression (BAND^ equalityExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // equality/inequality (==/!=) (level 6)
</I>&gt;<i> equalityExpression
</I>&gt;<i> 	:	relationalExpression ((NOT_EQUAL^ | EQUAL^) relationalExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // boolean relational expressions (level 5)
</I>&gt;<i> relationalExpression
</I>&gt;<i> 	:	shiftExpression
</I>&gt;<i> 		(	(	(	LT^
</I>&gt;<i> 				|	GT^
</I>&gt;<i> 				|	LE^
</I>&gt;<i> 				|	GE^
</I>&gt;<i> 				)
</I>&gt;<i> 				shiftExpression
</I>&gt;<i> 			)*
</I>&gt;<i> 		|	&quot;instanceof&quot;^ typeSpec[true]
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // bit shift expressions (level 4)
</I>&gt;<i> shiftExpression
</I>&gt;<i> 	:	additiveExpression ((SL^ | SR^ | BSR^) additiveExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // binary addition/subtraction (level 3)
</I>&gt;<i> additiveExpression
</I>&gt;<i> 	:	multiplicativeExpression ((PLUS^ | MINUS^) multiplicativeExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // multiplication/division/modulo (level 2)
</I>&gt;<i> multiplicativeExpression
</I>&gt;<i> 	:	unaryExpression ((STAR^ | DIV^ | MOD^ ) unaryExpression)*
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> unaryExpression
</I>&gt;<i> 	:	INC^ unaryExpression
</I>&gt;<i> 	|	DEC^ unaryExpression
</I>&gt;<i> 	|	MINUS^ {#MINUS.setType(UNARY_MINUS);} unaryExpression
</I>&gt;<i> 	|	PLUS^  {#PLUS.setType(UNARY_PLUS);} unaryExpression
</I>&gt;<i> 	|	unaryExpressionNotPlusMinus
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> unaryExpressionNotPlusMinus
</I>&gt;<i> 	:	BNOT^ unaryExpression
</I>&gt;<i> 	|	LNOT^ unaryExpression
</I>&gt;<i> 
</I>&gt;<i> 		// use predicate to skip cases like: (int.class)
</I>&gt;<i> 	|	(LPAREN builtInTypeSpec[true] RPAREN) =&gt;
</I>&gt;<i> 		lpb:LPAREN^ {#lpb.setType(TYPECAST);} builtInTypeSpec[true] RPAREN!
</I>&gt;<i> 		unaryExpression
</I>&gt;<i> 
</I>&gt;<i> 		// Have to backtrack to see if operator follows.  If no operator
</I>&gt;<i> 		// follows, it's a typecast.  No semantic checking needed to parse.
</I>&gt;<i> 		// if it _looks_ like a cast, it _is_ a cast; else it's a &quot;(expr)&quot;
</I>&gt;<i> 	|	(LPAREN classTypeSpec[true] RPAREN unaryExpressionNotPlusMinus)=&gt;
</I>&gt;<i> 		lp:LPAREN^ {#lp.setType(TYPECAST);} classTypeSpec[true] RPAREN!
</I>&gt;<i> 		unaryExpressionNotPlusMinus
</I>&gt;<i> 
</I>&gt;<i> 	|	postfixExpression
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // qualified names, array expressions, method invocation, post inc/dec
</I>&gt;<i> postfixExpression
</I>&gt;<i> 	:
</I>&gt;<i> 	/*
</I>&gt;<i> 	&quot;this&quot;! lp1:LPAREN^ argList RPAREN!
</I>&gt;<i> 		{#lp1.setType(CTOR_CALL);}
</I>&gt;<i> 
</I>&gt;<i> 	|	&quot;super&quot;! lp2:LPAREN^ argList RPAREN!
</I>&gt;<i> 		{#lp2.setType(SUPER_CTOR_CALL);}
</I>&gt;<i> 	|
</I>&gt;<i> 	*/
</I>&gt;<i> 		primaryExpression
</I>&gt;<i> 
</I>&gt;<i> 		(
</I>&gt;<i> 			/*
</I>&gt;<i> 			options {
</I>&gt;<i> 				// the use of postfixExpression in SUPER_CTOR_CALL adds DOT
</I>&gt;<i> 				// to the lookahead set, and gives loads of false non-det
</I>&gt;<i> 				// warnings.
</I>&gt;<i> 				// shut them off.
</I>&gt;<i> 				generateAmbigWarnings=false;
</I>&gt;<i> 			}
</I>&gt;<i> 		:	*/
</I>&gt;<i> 			DOT^ &quot;this&quot;
</I>&gt;<i> 
</I>&gt;<i> 		|	DOT^ ta1:typeArguments!
</I>&gt;<i> 			(	IDENT
</I>&gt;<i> 				(	lp:LPAREN^ {#lp.setType(METHOD_CALL);}
</I>&gt;<i> 					{astFactory.addASTChild(currentAST, #ta1);}
</I>&gt;<i> 					argList
</I>&gt;<i> 					RPAREN!
</I>&gt;<i> 				)?
</I>&gt;<i> 			|	&quot;super&quot;
</I>&gt;<i> 				(	// (new Outer()).super()  (create enclosing instance)
</I>&gt;<i> 					lp3:LPAREN^ {#lp3.setType(SUPER_CTOR_CALL);}
</I>&gt;<i> 					{astFactory.addASTChild(currentAST, #ta1);}
</I>&gt;<i> 					argList
</I>&gt;<i> 					RPAREN!
</I>&gt;<i> 				|	DOT^ ta2:typeArguments! IDENT
</I>&gt;<i> 					(	lps:LPAREN^ {#lps.setType(METHOD_CALL);}
</I>&gt;<i> 						{astFactory.addASTChild(currentAST, #ta2);}
</I>&gt;<i> 						argList
</I>&gt;<i> 						RPAREN!
</I>&gt;<i> 					)?
</I>&gt;<i> 				)
</I>&gt;<i> 			)
</I>&gt;<i> 		|	DOT^ newExpression
</I>&gt;<i> 		|	lb:LBRACK^ {#lb.setType(INDEX_OP);} expression RBRACK!
</I>&gt;<i> 		)*
</I>&gt;<i> 
</I>&gt;<i> 		(	// possibly add on a post-increment or post-decrement.
</I>&gt;<i> 			// allows INC/DEC on too much, but semantics can check
</I>&gt;<i> 			in:INC^ {#in.setType(POST_INC);}
</I>&gt;<i> 	 	|	de:DEC^ {#de.setType(POST_DEC);}
</I>&gt;<i> 		)?
</I>&gt;<i>  	;
</I>&gt;<i> 
</I>&gt;<i> // the basic element of an expression
</I>&gt;<i> primaryExpression
</I>&gt;<i> 	:	identPrimary ( options {greedy=true;} : DOT^ &quot;class&quot; )?
</I>&gt;<i> 	|	constant
</I>&gt;<i> 	|	&quot;true&quot;
</I>&gt;<i> 	|	&quot;false&quot;
</I>&gt;<i> 	|	&quot;null&quot;
</I>&gt;<i> 	|	newExpression
</I>&gt;<i> 	|	&quot;this&quot;
</I>&gt;<i> 	|	&quot;super&quot;
</I>&gt;<i> 	|	LPAREN! assignmentExpression RPAREN!
</I>&gt;<i> 		// look for int.class and int[].class
</I>&gt;<i> 	|	builtInType
</I>&gt;<i> 		( lbt:LBRACK^ {#lbt.setType(ARRAY_DECLARATOR);} RBRACK! )*
</I>&gt;<i> 		DOT^ &quot;class&quot;
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> /** Match a, a.b.c refs, a.b.c(...) refs, a.b.c[], a.b.c[].class,
</I>&gt;<i>  *  and a.b.c.class refs.  Also this(...) and super(...).  Match
</I>&gt;<i>  *  this or super.
</I>&gt;<i>  */
</I>&gt;<i> identPrimary
</I>&gt;<i> 	:	ta1:typeArguments!
</I>&gt;<i> 		IDENT
</I>&gt;<i> 		// Further proof that java designers should lay off the drugs:
</I>&gt;<i> 		// Syntax for method invocation with type arguments is
</I>&gt;<i> 		//   &lt;String&gt; foo (&quot;bla&quot;)  instead of  foo &lt;String&gt; (&quot;bla&quot;)
</I>&gt;<i> 		(
</I>&gt;<i> 			options {
</I>&gt;<i> 				// .ident could match here or in postfixExpression.
</I>&gt;<i> 				// We do want to match here.  Turn off warning.
</I>&gt;<i> 				greedy=true;
</I>&gt;<i> 				// This turns the ambiguity warning of the second alternative
</I>&gt;<i> 				// off. See below. (The &quot;false&quot; predicate makes it non-issue)
</I>&gt;<i> 				warnWhenFollowAmbig=false;
</I>&gt;<i> 			}
</I>&gt;<i> 			// bah, great, we have a new nondeterminism because of those
</I>&gt;<i> 			// stupid typeArguments... only a syntactic predicate will help...
</I>&gt;<i> 			// The problem is that this loop here conflicts with
</I>&gt;<i> 			//  DOT typeArguments &quot;super&quot;  in postfixExpression (k=2)
</I>&gt;<i> 			// A proper solution would require a lot of refactoring...
</I>&gt;<i> 		:	(DOT typeArguments IDENT) =&gt;
</I>&gt;<i> 				DOT^ ta2:typeArguments! IDENT
</I>&gt;<i> 		|	{false}?	// FIXME: this is very ugly but it seems to work...
</I>&gt;<i> 						// this will also produce an ANTLR warning!
</I>&gt;<i> 				// Unfortunately a syntactic predicate can only select one of
</I>&gt;<i> 				// multiple alternatives on the same level, not break out of
</I>&gt;<i> 				// an enclosing loop, which is why this ugly hack (a fake
</I>&gt;<i> 				// empty alternative with always-false semantic predicate)
</I>&gt;<i> 				// is necessary.
</I>&gt;<i> 		)*
</I>&gt;<i> 		(
</I>&gt;<i> 			options {
</I>&gt;<i> 				// ARRAY_DECLARATOR here conflicts with INDEX_OP in
</I>&gt;<i> 				// postfixExpression on LBRACK RBRACK.
</I>&gt;<i> 				// We want to match [] here, so greedy.  This overcomes
</I>&gt;<i> 				// limitation of linear approximate lookahead.
</I>&gt;<i> 				greedy=true;
</I>&gt;<i> 			}
</I>&gt;<i> 		:	(	lp:LPAREN^ {#lp.setType(METHOD_CALL);}
</I>&gt;<i> 				// if the input is valid, only the last IDENT may
</I>&gt;<i> 				// have preceding typeArguments... rather hacky, this is...
</I>&gt;<i> 				{if (#ta2 != null) astFactory.addASTChild(currentAST, #ta2);}
</I>&gt;<i> 				{if (#ta2 == null) astFactory.addASTChild(currentAST, #ta1);}
</I>&gt;<i> 				argList RPAREN!
</I>&gt;<i> 			)
</I>&gt;<i> 		|	( options {greedy=true;} :
</I>&gt;<i> 				lbc:LBRACK^ {#lbc.setType(ARRAY_DECLARATOR);} RBRACK!
</I>&gt;<i> 			)+
</I>&gt;<i> 		)?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> /** object instantiation.
</I>&gt;<i>  *  Trees are built as illustrated by the following input/tree pairs:
</I>&gt;<i>  *
</I>&gt;<i>  *  new T()
</I>&gt;<i>  *
</I>&gt;<i>  *  new
</I>&gt;<i>  *   |
</I>&gt;<i>  *   T --  ELIST
</I>&gt;<i>  *           |
</I>&gt;<i>  *          arg1 -- arg2 -- .. -- argn
</I>&gt;<i>  *
</I>&gt;<i>  *  new int[]
</I>&gt;<i>  *
</I>&gt;<i>  *  new
</I>&gt;<i>  *   |
</I>&gt;<i>  *  int -- ARRAY_DECLARATOR
</I>&gt;<i>  *
</I>&gt;<i>  *  new int[] {1,2}
</I>&gt;<i>  *
</I>&gt;<i>  *  new
</I>&gt;<i>  *   |
</I>&gt;<i>  *  int -- ARRAY_DECLARATOR -- ARRAY_INIT
</I>&gt;<i>  *                                  |
</I>&gt;<i>  *                                EXPR -- EXPR
</I>&gt;<i>  *                                  |      |
</I>&gt;<i>  *                                  1      2
</I>&gt;<i>  *
</I>&gt;<i>  *  new int[3]
</I>&gt;<i>  *  new
</I>&gt;<i>  *   |
</I>&gt;<i>  *  int -- ARRAY_DECLARATOR
</I>&gt;<i>  *                |
</I>&gt;<i>  *              EXPR
</I>&gt;<i>  *                |
</I>&gt;<i>  *                3
</I>&gt;<i>  *
</I>&gt;<i>  *  new int[1][2]
</I>&gt;<i>  *
</I>&gt;<i>  *  new
</I>&gt;<i>  *   |
</I>&gt;<i>  *  int -- ARRAY_DECLARATOR
</I>&gt;<i>  *               |
</I>&gt;<i>  *         ARRAY_DECLARATOR -- EXPR
</I>&gt;<i>  *               |              |
</I>&gt;<i>  *             EXPR             1
</I>&gt;<i>  *               |
</I>&gt;<i>  *               2
</I>&gt;<i>  *
</I>&gt;<i>  * Note that the typeArguments are no error here, you can write
</I>things like:
&gt;<i>  * 		Foo f = new &lt;Bar&gt; Foo &lt;Baz&gt; ();
</I>&gt;<i>  * The first type arguments are for the constructor, the second for
</I>the class.
&gt;<i>  */
</I>&gt;<i> newExpression
</I>&gt;<i> 	:	&quot;new&quot;^ typeArguments type
</I>&gt;<i> 		(	LPAREN! argList RPAREN! (classBlock)?
</I>&gt;<i> 
</I>&gt;<i> 			//java 1.1
</I>&gt;<i> 			// Note: This will allow bad constructs like
</I>&gt;<i> 			//    new int[4][][3] {exp,exp}.
</I>&gt;<i> 			//    There needs to be a semantic check here...
</I>&gt;<i> 			// to make sure:
</I>&gt;<i> 			//   a) [ expr ] and [ ] are not mixed
</I>&gt;<i> 			//   b) [ expr ] and an init are not used together
</I>&gt;<i> 
</I>&gt;<i> 		|	newArrayDeclarator (arrayInitializer)?
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> argList
</I>&gt;<i> 	:	(	expressionList
</I>&gt;<i> 		|	/*nothing*/
</I>&gt;<i> 			{#argList = #[ELIST,&quot;ELIST&quot;];}
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> newArrayDeclarator
</I>&gt;<i> 	:	(
</I>&gt;<i> 			// CONFLICT:
</I>&gt;<i> 			// newExpression is a primaryExpression which can be
</I>&gt;<i> 			// followed by an array index reference.  This is ok,
</I>&gt;<i> 			// as the generated code will stay in this loop as
</I>&gt;<i> 			// long as it sees an LBRACK (proper behavior)
</I>&gt;<i> 			options {
</I>&gt;<i> 				warnWhenFollowAmbig = false;
</I>&gt;<i> 			}
</I>&gt;<i> 		:
</I>&gt;<i> 			lb:LBRACK^ {#lb.setType(ARRAY_DECLARATOR);}
</I>&gt;<i> 				(expression)?
</I>&gt;<i> 			RBRACK!
</I>&gt;<i> 		)+
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> constant
</I>&gt;<i> 	:	NUM_INT
</I>&gt;<i> 	|	CHAR_LITERAL
</I>&gt;<i> 	|	STRING_LITERAL
</I>&gt;<i> 	|	NUM_FLOAT
</I>&gt;<i> 	|	NUM_LONG
</I>&gt;<i> 	|	NUM_DOUBLE
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>
</I>//----------------------------------------------------------------------------
&gt;<i> // The Java scanner
</I>&gt;<i>
</I>//----------------------------------------------------------------------------
&gt;<i> class JavaLexer extends Lexer;
</I>&gt;<i> 
</I>&gt;<i> options {
</I>&gt;<i> 	exportVocab=Java;      // call the vocabulary &quot;Java&quot;
</I>&gt;<i> 	testLiterals=false;    // don't automatically test for literals
</I>&gt;<i> 	k=4;                   // four characters of lookahead
</I>&gt;<i> 	charVocabulary='\u0003'..'\u7FFE';
</I>&gt;<i> 	// without inlining some bitset tests, couldn't do unicode;
</I>&gt;<i> 	// I need to make ANTLR generate smaller bitsets; see
</I>&gt;<i> 	// bottom of JavaLexer.java
</I>&gt;<i> 	codeGenBitsetTestThreshold=20;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i> 	/** flag for enabling the &quot;assert&quot; keyword */
</I>&gt;<i> 	private boolean assertEnabled = false;
</I>&gt;<i> 	/** flag for enabling the &quot;enum&quot; keyword */
</I>&gt;<i> 	private boolean enumEnabled = false;
</I>&gt;<i> 
</I>&gt;<i> 	/** Enable the &quot;assert&quot; keyword */
</I>&gt;<i> 	public void enableAssert() { assertEnabled = true; }
</I>&gt;<i> 	/** Disable the &quot;assert&quot; keyword */
</I>&gt;<i> 	public void disableAssert() { assertEnabled = false; }
</I>&gt;<i> 	/** Query the &quot;assert&quot; keyword state */
</I>&gt;<i> 	public boolean isAssertEnabled() { return assertEnabled; }
</I>&gt;<i> 	/** Enable the &quot;enum&quot; keyword */
</I>&gt;<i> 	public void enableEnum() { enumEnabled = true; }
</I>&gt;<i> 	/** Disable the &quot;enum&quot; keyword */
</I>&gt;<i> 	public void disableEnum() { enumEnabled = false; }
</I>&gt;<i> 	/** Query the &quot;enum&quot; keyword state */
</I>&gt;<i> 	public boolean isEnumEnabled() { return enumEnabled; }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // OPERATORS
</I>&gt;<i> QUESTION		:	'?'		;
</I>&gt;<i> LPAREN			:	'('		;
</I>&gt;<i> RPAREN			:	')'		;
</I>&gt;<i> LBRACK			:	'['		;
</I>&gt;<i> RBRACK			:	']'		;
</I>&gt;<i> LCURLY			:	'{'		;
</I>&gt;<i> RCURLY			:	'}'		;
</I>&gt;<i> COLON			:	':'		;
</I>&gt;<i> COMMA			:	','		;
</I>&gt;<i> //DOT			:	'.'		;
</I>&gt;<i> //ELLIPSIS		:	&quot;...&quot;	;
</I>&gt;<i> ASSIGN			:	'='		;
</I>&gt;<i> EQUAL			:	&quot;==&quot;	;
</I>&gt;<i> LNOT			:	'!'		;
</I>&gt;<i> BNOT			:	'~'		;
</I>&gt;<i> NOT_EQUAL		:	&quot;!=&quot;	;
</I>&gt;<i> DIV				:	'/'		;
</I>&gt;<i> DIV_ASSIGN		:	&quot;/=&quot;	;
</I>&gt;<i> PLUS			:	'+'		;
</I>&gt;<i> PLUS_ASSIGN		:	&quot;+=&quot;	;
</I>&gt;<i> INC				:	&quot;++&quot;	;
</I>&gt;<i> MINUS			:	'-'		;
</I>&gt;<i> MINUS_ASSIGN	:	&quot;-=&quot;	;
</I>&gt;<i> DEC				:	&quot;--&quot;	;
</I>&gt;<i> STAR			:	'*'		;
</I>&gt;<i> STAR_ASSIGN		:	&quot;*=&quot;	;
</I>&gt;<i> MOD				:	'%'		;
</I>&gt;<i> MOD_ASSIGN		:	&quot;%=&quot;	;
</I>&gt;<i> SR				:	&quot;&gt;&gt;&quot;	;
</I>&gt;<i> SR_ASSIGN		:	&quot;&gt;&gt;=&quot;	;
</I>&gt;<i> BSR				:	&quot;&gt;&gt;&gt;&quot;	;
</I>&gt;<i> BSR_ASSIGN		:	&quot;&gt;&gt;&gt;=&quot;	;
</I>&gt;<i> GE				:	&quot;&gt;=&quot;	;
</I>&gt;<i> GT				:	&quot;&gt;&quot;		;
</I>&gt;<i> SL				:	&quot;&lt;&lt;&quot;	;
</I>&gt;<i> SL_ASSIGN		:	&quot;&lt;&lt;=&quot;	;
</I>&gt;<i> LE				:	&quot;&lt;=&quot;	;
</I>&gt;<i> LT				:	'&lt;'		;
</I>&gt;<i> BXOR			:	'^'		;
</I>&gt;<i> BXOR_ASSIGN		:	&quot;^=&quot;	;
</I>&gt;<i> BOR				:	'|'		;
</I>&gt;<i> BOR_ASSIGN		:	&quot;|=&quot;	;
</I>&gt;<i> LOR				:	&quot;||&quot;	;
</I>&gt;<i> BAND			:	'&amp;'		;
</I>&gt;<i> BAND_ASSIGN		:	&quot;&amp;=&quot;	;
</I>&gt;<i> LAND			:	&quot;&amp;&amp;&quot;	;
</I>&gt;<i> SEMI			:	';'		;
</I>&gt;<i> AT				:	'@'		;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // Whitespace -- ignored
</I>&gt;<i> WS	:	(	' '
</I>&gt;<i> 		|	'\t'
</I>&gt;<i> 		|	'\f'
</I>&gt;<i> 			// handle newlines
</I>&gt;<i> 		|	(	options {generateAmbigWarnings=false;}
</I>&gt;<i> 			:	&quot;\r\n&quot;  // Evil DOS
</I>&gt;<i> 			|	'\r'    // Macintosh
</I>&gt;<i> 			|	'\n'    // Unix (the right way)
</I>&gt;<i> 			)
</I>&gt;<i> 			{ newline(); }
</I>&gt;<i> 		)+
</I>&gt;<i> 		{ _ttype = Token.SKIP; }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // Single-line comments
</I>&gt;<i> SL_COMMENT
</I>&gt;<i> 	:	&quot;//&quot;
</I>&gt;<i> 		(~('\n'|'\r'))* ('\n'|'\r'('\n')?)?
</I>&gt;<i> 		{$setType(Token.SKIP); newline();}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // multiple-line comments
</I>&gt;<i> ML_COMMENT
</I>&gt;<i> 	:	&quot;/*&quot;
</I>&gt;<i> 		(	/*	'\r' '\n' can be matched in one alternative or by matching
</I>&gt;<i> 				'\r' in one iteration and '\n' in another.  I am trying to
</I>&gt;<i> 				handle any flavor of newline that comes in, but the language
</I>&gt;<i> 				that allows both &quot;\r\n&quot; and &quot;\r&quot; and &quot;\n&quot; to all be valid
</I>&gt;<i> 				newline is ambiguous.  Consequently, the resulting grammar
</I>&gt;<i> 				must be ambiguous.  I'm shutting this warning off.
</I>&gt;<i> 			 */
</I>&gt;<i> 			options {
</I>&gt;<i> 				generateAmbigWarnings=false;
</I>&gt;<i> 			}
</I>&gt;<i> 		:
</I>&gt;<i> 			{ LA(2)!='/' }? '*'
</I>&gt;<i> 		|	'\r' '\n'		{newline();}
</I>&gt;<i> 		|	'\r'			{newline();}
</I>&gt;<i> 		|	'\n'			{newline();}
</I>&gt;<i> 		|	~('*'|'\n'|'\r')
</I>&gt;<i> 		)*
</I>&gt;<i> 		&quot;*/&quot;
</I>&gt;<i> 		{$setType(Token.SKIP);}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // character literals
</I>&gt;<i> CHAR_LITERAL
</I>&gt;<i> 	:	'\'' ( ESC | ~('\''|'\n'|'\r'|'\\') ) '\''
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> // string literals
</I>&gt;<i> STRING_LITERAL
</I>&gt;<i> 	:	'&quot;' (ESC|~('&quot;'|'\\'|'\n'|'\r'))* '&quot;'
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // escape sequence -- note that this is protected; it can only be called
</I>&gt;<i> //   from another lexer rule -- it will not ever directly return a
</I>token to
&gt;<i> //   the parser
</I>&gt;<i> // There are various ambiguities hushed in this rule.  The optional
</I>&gt;<i> // '0'...'9' digit matches should be matched here rather than letting
</I>&gt;<i> // them go back to STRING_LITERAL to be matched.  ANTLR does the
</I>&gt;<i> // right thing by matching immediately; hence, it's ok to shut off
</I>&gt;<i> // the FOLLOW ambig warnings.
</I>&gt;<i> protected
</I>&gt;<i> ESC
</I>&gt;<i> 	:	'\\'
</I>&gt;<i> 		(	'n'
</I>&gt;<i> 		|	'r'
</I>&gt;<i> 		|	't'
</I>&gt;<i> 		|	'b'
</I>&gt;<i> 		|	'f'
</I>&gt;<i> 		|	'&quot;'
</I>&gt;<i> 		|	'\''
</I>&gt;<i> 		|	'\\'
</I>&gt;<i> 		|	('u')+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
</I>&gt;<i> 		|	'0'..'3'
</I>&gt;<i> 			(
</I>&gt;<i> 				options {
</I>&gt;<i> 					warnWhenFollowAmbig = false;
</I>&gt;<i> 				}
</I>&gt;<i> 			:	'0'..'7'
</I>&gt;<i> 				(
</I>&gt;<i> 					options {
</I>&gt;<i> 						warnWhenFollowAmbig = false;
</I>&gt;<i> 					}
</I>&gt;<i> 				:	'0'..'7'
</I>&gt;<i> 				)?
</I>&gt;<i> 			)?
</I>&gt;<i> 		|	'4'..'7'
</I>&gt;<i> 			(
</I>&gt;<i> 				options {
</I>&gt;<i> 					warnWhenFollowAmbig = false;
</I>&gt;<i> 				}
</I>&gt;<i> 			:	'0'..'7'
</I>&gt;<i> 			)?
</I>&gt;<i> 		)
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // hexadecimal digit (again, note it's protected!)
</I>&gt;<i> protected
</I>&gt;<i> HEX_DIGIT
</I>&gt;<i> 	:	('0'..'9'|'A'..'F'|'a'..'f')
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // an identifier.  Note that testLiterals is set to true!  This means
</I>&gt;<i> // that after we match the rule, we look in the literals table to see
</I>&gt;<i> // if it's a literal or really an identifer
</I>&gt;<i> IDENT
</I>&gt;<i> 	options {testLiterals=true;}
</I>&gt;<i> 	:	('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'$')*
</I>&gt;<i> 		{
</I>&gt;<i> 			// check if &quot;assert&quot; keyword is enabled
</I>&gt;<i> 			if (assertEnabled &amp;&amp; &quot;assert&quot;.equals($getText)) {
</I>&gt;<i> 				$setType(ASSERT); // set token type for the rule in the parser
</I>&gt;<i> 			}
</I>&gt;<i> 			// check if &quot;enum&quot; keyword is enabled
</I>&gt;<i> 			if (enumEnabled &amp;&amp; &quot;enum&quot;.equals($getText)) {
</I>&gt;<i> 				$setType(ENUM); // set token type for the rule in the parser
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // a numeric literal
</I>&gt;<i> NUM_INT
</I>&gt;<i> 	{boolean isDecimal=false; Token t=null;}
</I>&gt;<i> 	:	'.' {_ttype = DOT;}
</I>&gt;<i> 		(	'.' '.' {_ttype = ELLIPSIS;}
</I>&gt;<i> 		|	(	('0'..'9')+ (EXPONENT)? (f1:FLOAT_SUFFIX {t=f1;})?
</I>&gt;<i> 				{
</I>&gt;<i> 				if (t != null &amp;&amp; t.getText().toUpperCase().indexOf('F')&gt;=0) {
</I>&gt;<i> 					_ttype = NUM_FLOAT;
</I>&gt;<i> 				}
</I>&gt;<i> 				else {
</I>&gt;<i> 					_ttype = NUM_DOUBLE; // assume double
</I>&gt;<i> 				}
</I>&gt;<i> 				}
</I>&gt;<i> 			)?
</I>&gt;<i> 		)
</I>&gt;<i> 
</I>&gt;<i> 	|	(	'0' {isDecimal = true;} // special case for just '0'
</I>&gt;<i> 			(	('x'|'X')
</I>&gt;<i> 				(											// hex
</I>&gt;<i> 					// the 'e'|'E' and float suffix stuff look
</I>&gt;<i> 					// like hex digits, hence the (...)+ doesn't
</I>&gt;<i> 					// know when to stop: ambig.  ANTLR resolves
</I>&gt;<i> 					// it correctly by matching immediately.  It
</I>&gt;<i> 					// is therefor ok to hush warning.
</I>&gt;<i> 					options {
</I>&gt;<i> 						warnWhenFollowAmbig=false;
</I>&gt;<i> 					}
</I>&gt;<i> 				:	HEX_DIGIT
</I>&gt;<i> 				)+
</I>&gt;<i> 
</I>&gt;<i> 			|	//float or double with leading zero
</I>&gt;<i> 				(('0'..'9')+ ('.'|EXPONENT|FLOAT_SUFFIX)) =&gt; ('0'..'9')+
</I>&gt;<i> 
</I>&gt;<i> 			|	('0'..'7')+									// octal
</I>&gt;<i> 			)?
</I>&gt;<i> 		|	('1'..'9') ('0'..'9')*  {isDecimal=true;}		// non-zero decimal
</I>&gt;<i> 		)
</I>&gt;<i> 		(	('l'|'L') { _ttype = NUM_LONG; }
</I>&gt;<i> 
</I>&gt;<i> 		// only check to see if it's a float if looks like decimal so far
</I>&gt;<i> 		|	{isDecimal}?
</I>&gt;<i> 			(	'.' ('0'..'9')* (EXPONENT)? (f2:FLOAT_SUFFIX {t=f2;})?
</I>&gt;<i> 			|	EXPONENT (f3:FLOAT_SUFFIX {t=f3;})?
</I>&gt;<i> 			|	f4:FLOAT_SUFFIX {t=f4;}
</I>&gt;<i> 			)
</I>&gt;<i> 			{
</I>&gt;<i> 			if (t != null &amp;&amp; t.getText().toUpperCase() .indexOf('F') &gt;= 0) {
</I>&gt;<i> 				_ttype = NUM_FLOAT;
</I>&gt;<i> 			}
</I>&gt;<i> 			else {
</I>&gt;<i> 				_ttype = NUM_DOUBLE; // assume double
</I>&gt;<i> 			}
</I>&gt;<i> 			}
</I>&gt;<i> 		)?
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> // a couple protected methods to assist in matching floating point
</I>numbers
&gt;<i> protected
</I>&gt;<i> EXPONENT
</I>&gt;<i> 	:	('e'|'E') ('+'|'-')? ('0'..'9')+
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> protected
</I>&gt;<i> FLOAT_SUFFIX
</I>&gt;<i> 	:	'f'|'F'|'d'|'D'
</I>&gt;<i> 	;
</I>


 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
    <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
    <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
    <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009161.html">[antlr-interest] yet another java 1.5 grammar
</A></li>
	<LI>Next message: <A HREF="009163.html">[antlr-interest] Re: yet another java 1.5 grammar
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9162">[ date ]</a>
              <a href="thread.html#9162">[ thread ]</a>
              <a href="subject.html#9162">[ subject ]</a>
              <a href="author.html#9162">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
