<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Re: updated &quot;antlr 2 bashing list&quot;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20updated%20%22antlr%202%20bashing%20list%22&In-Reply-To=639AAFCE-7231-11D8-8C5A-000A95891192%40cs.usfca.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006820.html">
   <LINK REL="Next"  HREF="006819.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Re: updated &quot;antlr 2 bashing list&quot;</H1>
    <B>Ric Klaren</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20updated%20%22antlr%202%20bashing%20list%22&In-Reply-To=639AAFCE-7231-11D8-8C5A-000A95891192%40cs.usfca.edu"
       TITLE="[antlr-interest] Re: updated &quot;antlr 2 bashing list&quot;">klaren at cs.utwente.nl
       </A><BR>
    <I>Wed Mar 10 03:49:06 PST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006820.html">[antlr-interest] Re: updated &quot;antlr 2 bashing list&quot;
</A></li>
        <LI>Next message: <A HREF="006819.html">[antlr-interest] updated &quot;antlr 2 bashing list&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6824">[ date ]</a>
              <a href="thread.html#6824">[ thread ]</a>
              <a href="subject.html#6824">[ subject ]</a>
              <a href="author.html#6824">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, Mar 09, 2004 at 05:22:25PM -0800, Terence Parr wrote:
&gt;<i> &gt; I hate to say it, but I think that that's a cop out.  Building
</I>&gt;<i> &gt; exception objects and stack frames costs, and there is no point when
</I>&gt;<i> &gt; in guessing mode.
</I>
Have to agree with Loring here.

&gt;<i> This never happens unless you fail and is a minor cost compared to the
</I>&gt;<i> cost of nested predicates, right?
</I>
Well in C++ you can compile without exception support which gives you a
faster and smaller binary, people in the embedded business might like that.
I'm not sure though wether I would support two versions of the runtime...

&gt;<i> Doesn't bother me in Java, but other languages might be a drag.
</I>
The argument for retargeting to a exceptionless generated code would also
make a C codegenerator an (easy) option. (Hmm wonder how far you'd get with
longjmp and co. talk about ugly...)

&gt;<i> I can investigate not using exceptions to see what the code looks like.
</I>&gt;<i>   Actually somebody who has used JavaCC could tell us what it looks like
</I>&gt;<i> ;)  They do not use exceptions.
</I>
What I recall of the code generated by ell from cocktail it's not that bad
although it seems to have an advantage due to its error recovery code. It
doesn't even return an error code for a rule. Basically it looks like
(simplified of course and a bit translated to antlr-ish data structures the
original uses C with a distinct modula2-to-C convertor taste)

void rule( Token incomingtoken, BitSet recoverySet )
{
   Token someTokenInRule;
   Token someOtherTokenInRule;

	for(;;) {
		if( curToken.getType() == .. ) { }
		if( curToken.getType() == .. ) { }
		unexpectedTokenHandler( recoverySet );
	}
	unexpectedTokenHandler( anotherRecoverySet );
}

It would use labels and goto's to jump over unexpectedHandlers but that's
something that could be done differently. Similar to our guessing mode
counter it has a RepairMode flag which is set when the parser is
inserting/skipping tokens to get to a restart point. At certain points
repairmode is reset (probably for the rules that are at restart points).
Sometimes inside rules some extra checks for repairmode and recovery are
inserted. In between rule invocations the recovery sets are 'tweaked' (all
simple index updating). There are a few flavours of unexpectedTokenHandlers
used (think mostly to handle negated bitsets).

The unexpectedTokenHandler calls would correspond to antlr's catch blocks
and to some extend match calls. I guess the guessing could also be wrapped
into them. Most (all more likely) guessing handling could be done in antlr
with shuffling around a few if/else parts. Maybe add a stack of active
predicates (to replace the guessing counter) then maintain the stack during
guessing and you can even keep track of what predicate failed where. Or
make the predicate a parameter to the rule.

&gt;<i> &gt; and hamper code generation for languages which do not have
</I>&gt;<i> &gt; exceptions.  It would be better to have a &quot;synpredFailed flag as part
</I>&gt;<i> &gt; of the generated classes-the flag will always be in cache, so is not a
</I>&gt;<i> &gt; performance issue--or to have a return flag from rules and wrap rule
</I>&gt;<i> &gt; invocations (foo) in
</I>&gt;<i> &gt; if (foo() == false) return;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; and add
</I>&gt;<i> &gt; if (guessing)
</I>&gt;<i> &gt;     return false;
</I>&gt;<i> &gt; else {
</I>&gt;<i> &gt;     &lt;throw exception&gt;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; around the &lt;throw exception&gt;s in ANTLR.  Come to think of it,
</I>&gt;<i> &gt; implementing this with the current ANTLR runtime would be only about
</I>&gt;<i> &gt; 10 lines of code or so (maybe a little more--I think that each
</I>&gt;<i> &gt; exception would have to be fixed separately).
</I>&gt;<i>
</I>&gt;<i> Uh...how you gonna redo return values in 10 lines ;)
</I>
I don't think you'd even need return values (other than how we use them
already for rule return values). An error attribute on the parser class
would probably already do the trick or a queue of them. Or suppose you'd
use something like:

rule { int val; } :
	( NUM NUM NUM (ID|COMMA) ) =&gt; val=someRule
	| NUM NUM NUM
;

-- start of predicate test --
Predicate p = new Predicate(&quot;NUM NUM NUM (ID|COMMA)&quot;);
val = someRule( p )
if( p.failed() )
 ...
-- end --

In the rule itself

----snip----
int someRule( Predicate p ) {
 ...
 if( p != null )  // equivalent to our inputState.guessing != 0
----snip----

When nested predicates occur you could create a linked list of predicates
giving you a fail trace. Or just pass the failed status. If you tinker with
the predicate class you can probably do some nice stuff too (debugging vs.
production code version).

The average syntactic predicate check now looks like:

--------snip--------
         boolean synPredMatched6 = false;
         if (((LA(1)==TK_int||LA(1)==TK_char||LA(1)==ID))) {
            int _m6 = mark();
            synPredMatched6 = true;
            inputState.guessing++;
            ///// doesn't this bit look a bit excessive ? ///////////
				try {
               {
                  variable();
                  otherrule();
                  otherrule();
                  match(SOME_TOKEN);
               }
            }
            catch (RecognitionException pe) {
               synPredMatched6 = false;
            }
            /////////////////////////////////////////////////////////
            rewind(_m6);
            inputState.guessing--;
         }
         if ( synPredMatched6 ) {
            variable();
         }
--------snip--------

The exception is always caught in the level directly above the call. So a
bunch of if-else-if's would be just as practical.

In C++ mode the approach with the predicate class could be quite nice. I
could probably do the mark/rewind stuff in the constructor/destructor and
get automatic rewinding for free (and exception safe to boot). Java is out
of luck there though ;)

Another option is to generate rules like:

RULE_RETURN_VALUE_TYPE
   someRule( InternalReturnValue ret, Predicate p, &lt;other rule params&gt;  )
{
 ...
}

or

InternalReturnValue
   someRule( RULE_RETURN_VALUE_TYPE ret, Predicate p, &lt;other rule params&gt;  )
{
 ...
}

In java you'd have to use an Integer wrapper or something for the internal
return value.

Cheers,

Ric
--
-----+++++*****************************************************+++++++++-------
    ---- Ric Klaren ----- <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">j.klaren at utwente.nl</A> ----- +31 53 4893722  ----
-----+++++*****************************************************+++++++++-------
  Wo das Chaos auf die Ordnung trifft, gewinnt meist das Chaos, weil es
  besser organisiert ist. --- Friedrich Nietzsche



 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
     <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
     <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
     <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006820.html">[antlr-interest] Re: updated &quot;antlr 2 bashing list&quot;
</A></li>
	<LI>Next message: <A HREF="006819.html">[antlr-interest] updated &quot;antlr 2 bashing list&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6824">[ date ]</a>
              <a href="thread.html#6824">[ thread ]</a>
              <a href="subject.html#6824">[ subject ]</a>
              <a href="author.html#6824">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
