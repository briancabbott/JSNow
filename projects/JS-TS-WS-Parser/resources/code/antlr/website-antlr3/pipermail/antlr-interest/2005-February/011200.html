<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Antlr vs Spirit
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Antlr%20vs%20Spirit&In-Reply-To=001001c51738%24176d1780%240100a8c0%40hrvoje">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011198.html">
   <LINK REL="Next"  HREF="011259.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Antlr vs Spirit</H1>
    <B>Loring Craymer</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Antlr%20vs%20Spirit&In-Reply-To=001001c51738%24176d1780%240100a8c0%40hrvoje"
       TITLE="[antlr-interest] Antlr vs Spirit">Loring.G.Craymer at jpl.nasa.gov
       </A><BR>
    <I>Sun Feb 20 13:41:23 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011198.html">[antlr-interest] Antlr vs Spirit
</A></li>
        <LI>Next message: <A HREF="011259.html">[antlr-interest] Antlr vs Spirit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11200">[ date ]</a>
              <a href="thread.html#11200">[ thread ]</a>
              <a href="subject.html#11200">[ subject ]</a>
              <a href="author.html#11200">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I consider Spirit to be one of those &quot;ultimate hacks&quot; that attracts a
following just because it is an impressive accomplishment in the
implementation language.  I, too, am impressed that it can be done.  As John
points out, it is a language-specific (although someone has done a C#
version) solution, and is technically weaker than ANTLR because it lacks
ANTLR's analysis pass during translation from grammar to target language
source.  At the same time, it has added power just because it is built on
C++ and all the C++ features are available to the programmer.

 

Spirit does not support trees, and I haven't looked in sufficient depth to
understand how it does garbage collection during backtracking (I assume that
it is done with catch/throw and C++ normal memory cleanup) to see how you
could implement trees.  It is probably doable, but then you would be stuck
without tree grammars and might be driven to a custom visitor solution.

 

I note that they marry functional programming support (through Phoenix) with
Spirit for some things.  There are advantages for doing that:  some of the
more interesting language translation packages have a functional programming
base because of the added power-see, for example, Phillips Labs' Elegant.
At the same time, this looks like another &quot;clever hack&quot; that attracts the
C++ language aficionados.

 

It is impressive that you can fold the capability into C++, but I am a
believer in using multiple small languages for solving problems.  The &quot;my
language fits everything, even if I have to do more work in some places&quot;
does not appeal.  ANTLR lets you build small languages relatively quickly,
and ANTLR 3 will significantly improve this capability by design.  I much
prefer having domain-specific solutions in larger problem contexts; for my
tastes, C++ is too big and unwieldy already.

 

--Loring

 

  _____  

From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>
[mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] On Behalf Of Hrvoje Nezic
Sent: Sunday, February 20, 2005 2:37 AM
To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
Subject: [antlr-interest] Antlr vs Spirit

 

I hope that this subject is not off topic (please excuse me if it is). 

 

A few days ago I had a heated discussion with my colleagues

at work about parser generators. I use Antlr while some other people use
Spirit. It seems that Spirit is rather popular in the C++ community.

 

&quot;Spirit is an object oriented recursive descent parser generator framework
implemented using template meta-programming techniques.&quot;  &quot; Parser objects
are composed through operator overloading and the result is a backtracking
LL(inf) parser that is capable of parsing rather ambiguous grammars. &quot;

 

Antlr documentation or web site mentions other parser generators like
JavaCC, but it doesn't mention Spirit. Does Spirit bring something new
regarding computation of lookahead sets (like Antlr's approximate
lookahead)?

 

Actually I don't understand how complex algorithms that should analyze
complex grammars could be implemented with C++ templates, but that is
another question.

 

Perhaps I should address these questions to the Spirit mailing list, but I
thought it would be interesting to hear opinions from Antlr community. BTW,
I don't intend to move to Spirit :)

 

Best regards,

Hrvoje Nezic

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20050220/3b57232f/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20050220/3b57232f/attachment.html</A>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011198.html">[antlr-interest] Antlr vs Spirit
</A></li>
	<LI>Next message: <A HREF="011259.html">[antlr-interest] Antlr vs Spirit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11200">[ date ]</a>
              <a href="thread.html#11200">[ thread ]</a>
              <a href="subject.html#11200">[ subject ]</a>
              <a href="author.html#11200">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
