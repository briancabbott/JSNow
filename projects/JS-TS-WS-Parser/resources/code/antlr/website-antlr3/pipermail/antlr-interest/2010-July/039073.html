<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Basic predicate question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Basic%20predicate%20question&In-Reply-To=%3C1278015765.6976.12.camel%40gecko.home.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="039072.html">
   <LINK REL="Next"  HREF="039087.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Basic predicate question</H1>
    <B>John B. Brodie</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Basic%20predicate%20question&In-Reply-To=%3C1278015765.6976.12.camel%40gecko.home.org%3E"
       TITLE="[antlr-interest] Basic predicate question">jbb at acm.org
       </A><BR>
    <I>Thu Jul  1 13:22:45 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="039072.html">[antlr-interest] Basic predicate question
</A></li>
        <LI>Next message: <A HREF="039087.html">[antlr-interest] Basic predicate question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39073">[ date ]</a>
              <a href="thread.html#39073">[ thread ]</a>
              <a href="subject.html#39073">[ subject ]</a>
              <a href="author.html#39073">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Greetings!
On Thu, 2010-07-01 at 14:03 -0400, Zeafla, Larry wrote:
&gt;<i> I am new to Antlr, which I am trying to use to parse simple existing
</I>&gt;<i> messages.  The message structure is exceptionally simple and
</I>&gt;<i> straightforward.  Message fields include integer and floating-point
</I>&gt;<i> numbers, single letter codes, and field separator characters.  Each
</I>&gt;<i> individual message type has a narrowly defined structure, needs no look
</I>&gt;<i> ahead, and typically has at most 2 possible tokens for any location in
</I>&gt;<i> the message.
</I>&gt;<i> 
</I>Welcome!

Respectfully, in my opinion, using ANTLR for this task seems to be
overkill. Why not just read each message into a String. Use the split()
method on the comma in order to get the fields. And then analyze the
array returned by split(&quot;,&quot;)? (or maybe regular expressions?)
 

&gt;<i> My problem is that one of the fields is a 2-digit (in ASCII)
</I>&gt;<i> representation of a hex number.  This is known purely from context.  It
</I>&gt;<i> seems there should be a simple technique (probably a predicate), to
</I>&gt;<i> force this behavior.  I just can't seem to find it.
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i> 
</I>&gt;<i> Here is a short sample grammar to illustrate:
</I>&gt;<i> 
</I>&gt;<i>           grammar sample;
</I>&gt;<i>           prog   :   test+ ;
</I>&gt;<i>           test    :   'TEST' COMMA INT COMMA FLOAT ( 'A' | 'B' ) 
</I>&gt;<i> 
</I>&gt;<i>                               COMMA HEX_DIGIT  HEX_DIGIT    ;
</I>&gt;<i> 
</I>&gt;<i>           HEX_DIGIT   :  '0'..'9' | 'A'..'F' | 'a'..'f'  ;
</I>&gt;<i>           INT         :  '0'..'9'+ ;
</I>&gt;<i>           FLOAT       :  '0'..'9'+ ('.' '0'..'9'*)? ; 
</I>&gt;<i>           COMMA       :  ',' ;
</I>&gt;<i> 
</I>&gt;<i> The associated test input is:
</I>&gt;<i> 
</I>&gt;<i>           TEST,123,5.6A,2D
</I>&gt;<i> 
</I>&gt;<i>           TEST,321,4.20A,3B
</I>&gt;<i> 
</I>&gt;<i>           TEST,45,5.68B,78            
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> For this example, the hex digits are the last 2 characters on each line.
</I>&gt;<i> For the first test statement, parsing is successful.  For the second, I
</I>&gt;<i> get a MismatchedTokenException (0!=0) on the B (the last character).
</I>&gt;<i> For the third, I get a MismatchedTokenException(0!=0)  on the 7 (the
</I>&gt;<i> next to last character).  I am definitely confused.
</I>
as pointed out in another message in this thread. you have specified
that 'A' and 'B' are keywords in your language and yet you also want
them to be HEX_DIGITs. the lexer can not work out this ambiguity (i
believe). same problem with '0' .. '9' ---- are they a HEX_DIGIT or are
they a single digit INT?

if you really really want to do this task using ANTLR (see above rant
regarding split() and regex's) I think you will have to do all of the
work in the parser.

usually manipulating individual characters in parser rules quickly leads
to parsing ambiguities. but your problem as stated seems to be simple
enough that it will not be a problem (unless you are gonna add more
stuff).

attached please find an alternative grammar of your sample that
illustrates this approach tested with just your 3 sample inputs.

Hope this helps...
   -jbb

-------------- next part --------------
grammar Sample;

options {
   output = AST;
   ASTLabelType = CommonTree;
}

@members {
   private static final String [] x = new String[] {
      &quot;TEST,123,5.6A,2D&quot;,
      &quot;TEST,321,4.20A,3B&quot;,
      &quot;TEST,45,5.68B,78&quot;
  };

   public static void main(String [] args) {
      for( int i = 0; i &lt; x.length; ++i ) {
         try {
            System.out.println(&quot;about to parse:`&quot;+x[i]+&quot;`&quot;);
            SampleLexer lexer = new SampleLexer(new ANTLRStringStream(x[i]));
            CommonTokenStream tokens = new CommonTokenStream(lexer);

            SampleParser parser = new SampleParser(tokens);
            SampleParser.start_return p_result = parser.start();

            CommonTree ast = p_result.tree;
            if( ast == null ) {
               System.out.println(&quot;resultant tree: is NULL&quot;);
            } else {
               System.out.println(&quot;resultant tree: &quot; + ast.toStringTree());
            }
            System.out.println();
         } catch(Exception e) {
            e.printStackTrace();
         }
      }
   }
}

start   :   test+ ;
test    :   T E S T comma integer comma flonum ( A | B ) 
                   comma hex_digit  hex_digit    ;

hex_digit   :  DIGIT | A | B | C | D | E | F ;
integer     :  DIGIT+ ;
flonum      :  DIGIT+ ('.' DIGIT*)? ; 
comma       :  ',' ;

DIGIT : '0'..'9';

A : 'A' | 'a' ;
B : 'B' | 'b' ;
C : 'C' | 'c' ;
D : 'D' | 'd' ;
E : 'E' | 'e' ;
F : 'F' | 'f' ;
G : 'G' | 'g' ;
H : 'H' | 'h' ;
I : 'I' | 'i' ;
J : 'J' | 'j' ;
K : 'K' | 'k' ;
L : 'L' | 'l' ;
M : 'M' | 'm' ;
N : 'N' | 'n' ;
O : 'O' | 'o' ;
P : 'P' | 'p' ;
Q : 'Q' | 'q' ;
R : 'R' | 'r' ;
S : 'S' | 's' ;
T : 'T' | 't' ;
U : 'U' | 'u' ;
V : 'V' | 'v' ;
W : 'W' | 'w' ;
X : 'X' | 'x' ;
Y : 'Y' | 'y' ;
Z : 'Z' | 'z' ;
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="039072.html">[antlr-interest] Basic predicate question
</A></li>
	<LI>Next message: <A HREF="039087.html">[antlr-interest] Basic predicate question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39073">[ date ]</a>
              <a href="thread.html#39073">[ thread ]</a>
              <a href="subject.html#39073">[ subject ]</a>
              <a href="author.html#39073">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
