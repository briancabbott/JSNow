<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=F89BA86F375B2F43B05CB04E01B199BA0AAF13%40castor-srvr1.benchmarkcanada.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018224.html">
   <LINK REL="Next"  HREF="018233.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Anthony W. Youngman</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=F89BA86F375B2F43B05CB04E01B199BA0AAF13%40castor-srvr1.benchmarkcanada.com"
       TITLE="[antlr-interest] philosophy about translation">antlr at thewolery.demon.co.uk
       </A><BR>
    <I>Thu Nov  2 08:13:09 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018224.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018233.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18227">[ date ]</a>
              <a href="thread.html#18227">[ thread ]</a>
              <a href="subject.html#18227">[ subject ]</a>
              <a href="author.html#18227">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In message 
&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">F89BA86F375B2F43B05CB04E01B199BA0AAF13 at castor-srvr1.benchmarkcanada.com</A>&gt;
, Oliver Wong &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">owong at benchmarkconsulting.com</A>&gt; writes
&gt;<i>
</I>&gt;<i>
</I>&gt;<i>-----Original Message-----
</I>&gt;<i>From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>
</I>&gt;<i>[mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] On Behalf Of Anthony W.
</I>&gt;<i>Youngman
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> A C compiler can compile itself. Can a Java system build itself?
</I>&gt;&gt;&gt;&gt;<i> How much of Java is actually written in Java? (Oh and I'm
</I>&gt;&gt;&gt;&gt;<i> including the supporting libraries here!)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Almost all of Java is written in Java. The only part that's not
</I>&gt;&gt;&gt;<i>is the lowest layer, which is OS and hardware specific.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Assembler is written in assembler, pretty much without exception.
</I>&gt;&gt;<i> C is written in C, pretty much without exception.
</I>&gt;<i>
</I>&gt;<i>       I think you (plural) might be conflating a language with an
</I>&gt;<i>implementation of the toolset for that language. Java, C and assembler
</I>&gt;<i>are languages, and you can't &quot;write&quot; (in the sense of program) a
</I>&gt;<i>language. You could program a compiler or an interpreter for these
</I>&gt;<i>languages. But you can't &quot;write&quot; the languages themselves.
</I>
Ummm ... I see what you're getting at ... the C spec is written in 
English, not C ... (plus, of course, BNF :-)
&gt;<i>
</I>&gt;<i>       And yes, there are assembler &quot;compilers&quot; (though an &quot;assembler
</I>&gt;<i>compiler&quot; is typically called &quot;an assembler&quot;) written in assembler, but
</I>&gt;<i>there are also assembler compilers written in C, and possibly in Java.
</I>&gt;<i>
</I>&gt;<i>       Similarly, there are C compilers written in C, but there may
</I>&gt;<i>also be C compilers written in assembler, and there's definitely C
</I>&gt;<i>compilers written in Java.
</I>
This is what I'm getting at. The C compiler should, itself, be written 
using the C language. I must admit, you could almost certainly write a C 
compiler in Java using Antlr :-)
&gt;<i>
</I>&gt;<i>       And there are Java compilers and Java virtual machines written
</I>&gt;<i>in C, but there are also Java compilers and Java virtual machines
</I>&gt;<i>written in Java (see the SableCC and SableVM projects).
</I>&gt;<i>
</I>&gt;<i>[...]
</I>&gt;&gt;<i> Fine. Since Java is such a great language, let's see you write
</I>&gt;&gt;<i> the BIOS for all new computers in it ... what? you mean all new
</I>&gt;&gt;<i> computers will be bricks if you do? What a crap tool ...
</I>&gt;<i>
</I>&gt;<i>       The fact that Sun's javac compiler takes Java as an input
</I>&gt;<i>language and emits JVM Bytecode as an output language is a
</I>&gt;<i>characteristic of the compiler, and not of the Java language itself.
</I>&gt;<i>There's no reason why you couldn't have a compiler take Java as an input
</I>&gt;<i>language, and machine code as an output language (The gcj compiler does
</I>&gt;<i>exactly this).
</I>&gt;<i>
</I>&gt;<i>       I don't know what's involved in writing BIOSes, but I suspect
</I>&gt;<i>that if you can program a BIOS in software (as opposed to fiddling with
</I>&gt;<i>wiring at the hardware level), then you essentially need to &quot;burn&quot; a
</I>&gt;<i>bytestream representing the BIOS program into the FlashROM containing
</I>&gt;<i>the BIOS. Well, you can write a compiler which takes Java as its source
</I>&gt;<i>language, and emits the appropriate bytestream in whatever format the
</I>&gt;<i>FlashROM expects (which may or may not be machine code; I don't know).
</I>&gt;<i>
</I>The point I was trying to make there, is that even if you change the 
compiler output from bytecode to machine code, there is NO WAY - using 
Java - to express the concepts needed by a BIOS in Java source code.

Java enforces a virtual-mode paradigm onto the executable, be it 
bytecode, machinecode, p-code or whatever, where it does not need to 
know anything about the underlying hardware. The whole point of a BIOS 
is to provide the layer between the underlying hardware and the 
overlaying application. Therefore, you cannot write a BIOS in Java 
because the basic philosophy of the language says &quot;what you need to do, 
I've been designed to make sure you can't do it&quot;.

I don't know whether Java is or isn't a great tool. What seems apparent 
from this discussion is that it is a simple, popular tool, that is just 
perfect for many situations. But to my mind that doesn't make it great.

To give a concrete example of what I *do* consider a great tool, take 
WordPerfect. (Not the modern versions, they've been bastardised :-( On 
the surface, it was an incredibly simple tool - start it up, start 
typing, &lt;alt-f7&gt; print. Out comes your document (okay, dos tools weren't 
that simple :-)

But it presented a very simple interface to novices. Start scratching 
beneath the surface, however, and it was amazingly complex and powerful 
- and easy to use with it! My opinions on Word (and OOo Writer) are 
unprintable, in comparison.

Java, to me, presents me with an incomprehensible interface (though I 
admit that may simply be because it's object-oriented, with which I 
haven't really got to grips), and it strikes me as being fundamentally 
limited. It's been DESIGNED to be fundamentally limited. I don't know 
what half the missing stuff the other people are going on about even IS, 
but I do know, if I wanted to use it and it weren't there, I'd be 
slating Java as crap. Oh - and like pointers in C - I'd only want to use 
it if I thought it were the simplest solution to my problem.

At the end of the day, it always comes back to using the right tool for 
the job. And while a deliberately crippled tool may be great for the job 
in hand, I don't see how it can be a great tool full stop.

At the end of the day, I know I said a great tool &quot;has to be written in 
itself&quot;. I think I'll add to that. It has to be self-contained, and 
complete in its own world. FORTRAN didn't have pointers, because they're 
meaningless when doing maths, but it does now have operator overloading 
- you can do matrix arithmetic using +, * etc, because it DOES make 
sense within FORTRAN's problem space. Java doesn't have pointers because 
it doesn't make sense within its security paradigm. I don't know enough 
about Java to comment on other stuff.

But it seems to me that Andy thinks the &quot;great&quot;ness of Java, and Antlr, 
would be *improved* by deleting features that lie within their problem 
space. No!!! That merely gives us crippleware.

Cheers,
Wol
-- 
Anthony W. Youngman - <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">anthony at thewolery.demon.co.uk</A>

</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018224.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018233.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18227">[ date ]</a>
              <a href="thread.html#18227">[ thread ]</a>
              <a href="subject.html#18227">[ subject ]</a>
              <a href="author.html#18227">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
