<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Re: special c/c++ parsing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20special%20c/c%2B%2B%20parsing&In-Reply-To=b9u2kv%2Borbt%40eGroups.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003872.html">
   <LINK REL="Next"  HREF="003876.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Re: special c/c++ parsing</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20special%20c/c%2B%2B%20parsing&In-Reply-To=b9u2kv%2Borbt%40eGroups.com"
       TITLE="[antlr-interest] Re: special c/c++ parsing">parrt at jguru.com
       </A><BR>
    <I>Wed May 14 11:50:30 PDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="003872.html">[antlr-interest] Re: special c/c++ parsing
</A></li>
        <LI>Next message: <A HREF="003876.html">[antlr-interest] Re: special c/c++ parsing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3873">[ date ]</a>
              <a href="thread.html#3873">[ thread ]</a>
              <a href="subject.html#3873">[ subject ]</a>
              <a href="author.html#3873">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Wednesday, May 14, 2003, at 11:41  AM, lgcraymer wrote:

&gt;<i> I'll echo Monty's comment.  Function calls can appear in enough places
</I>&gt;<i> (including complex expressions and argument lists to functions) that
</I>&gt;<i> it would be difficult to identify a subset grammar.  It is much easier
</I>&gt;<i> to prune, even when you are dealing with a language as cumbersome as
</I>&gt;<i> C++.
</I>
I've often wondered if something like the following (insanely slow) 
approach would work:

1. You provide a set of possible top-level match rules you are 
interested in matching like expr and method.

2. You provide a lexer that knows how to ignore comments and how to 
identify all tokens that could be seen (not just ones you are 
interested in).

3. Start walking the input token-by-token, attempting to match one of 
the top-level rules starting at token i.  If an attempt fails, try 
another top-level rule.  Failing that, move to next token and try again.

This mirrors the naive string search algorithm done by freshman CS 
students, but might actually work.  If you didn't care about speed, 
just ease of building the translator, I wonder if this would work.  It 
sounds actually like a very simple TokenStream object :)

Anybody wanna comment on the cases where this would fail?

Ter
--
Co-founder, <A HREF="http://www.jguru.com">http://www.jguru.com</A>
Creator, ANTLR Parser Generator: <A HREF="http://www.antlr.org">http://www.antlr.org</A>
Co-founder, <A HREF="http://www.peerscope.com">http://www.peerscope.com</A> link sharing, pure-n-simple
Lecturer in Comp. Sci., University of San Francisco


 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003872.html">[antlr-interest] Re: special c/c++ parsing
</A></li>
	<LI>Next message: <A HREF="003876.html">[antlr-interest] Re: special c/c++ parsing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3873">[ date ]</a>
              <a href="thread.html#3873">[ thread ]</a>
              <a href="subject.html#3873">[ subject ]</a>
              <a href="author.html#3873">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
