<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=45496671.9010008%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018212.html">
   <LINK REL="Next"  HREF="018226.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Anthony W. Youngman</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=45496671.9010008%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">antlr at thewolery.demon.co.uk
       </A><BR>
    <I>Thu Nov  2 01:21:32 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018212.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018226.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18220">[ date ]</a>
              <a href="thread.html#18220">[ thread ]</a>
              <a href="subject.html#18220">[ subject ]</a>
              <a href="author.html#18220">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In message &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">45496671.9010008 at jazillian.com</A>&gt;, Andy Tripp 
&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; writes
&gt;<i>Anthony W. Youngman wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> In message &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">4548F943.7070906 at jazillian.com</A>&gt;, Andy Tripp 
</I>&gt;&gt;<i>&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; writ
</I>&gt;&gt;<i> I wouldn't describe &quot;popular&quot; as &quot;great&quot;.
</I>&gt;<i>
</I>&gt;<i>I would say popularity is a pretty good indicator or &quot;greatness&quot;. By 
</I>&gt;<i>&quot;popular&quot;, I mean &quot;widely seen
</I>&gt;<i>as good from a technology point of view&quot;. So Java is &quot;popular&quot; that 
</I>&gt;<i>way: a lot of people use it
</I>&gt;<i>because of its technical merits. COBOL is widely used, but almost no 
</I>&gt;<i>one uses it because of its
</I>&gt;<i>technical merits.
</I>
Actually, I think you'll find that COBOL has technical merits that the 
average programmer has been brainwashed into ignoring. COBOL does what 
it was designed for very well. I've written an accounts package in 
FORTRAN. I've also written one in DATABASIC (which pinched a lot of 
ideas from COBOL). No question as to which one was the right tool for 
the job ...

And I've also used a version of DATABASIC where some bright spark 
rewrote the system primitives in C. Blech!!!! the number of times I've 
seen people scream because they got bitten by subtle bugs ...

Come to think of it, how many people get bitten by subtle bugs in Java 
because they don't understand that, underneath, it's written in C++? As 
someone said, not many, because it's been well tested, but that's still 
a few too many ...
&gt;<i>
</I>&gt;&gt;&gt;<i> Yes, a few people want to add stuff back, but most do not. It's just 
</I>&gt;&gt;&gt;<i>that the few are very vocal.
</I>&gt;&gt;&gt;<i> The vast majority don't want MI, operator overloading, or built-in 
</I>&gt;&gt;&gt;<i>AspectOrientedDesign.
</I>&gt;&gt;&gt;<i> And of course, those who want them think they're &quot;above average&quot;, 
</I>&gt;&gt;&gt;<i>but  then so does almost
</I>&gt;&gt;&gt;<i> everyone.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> What about those who don't WANT those things, but NEED them?
</I>&gt;<i>
</I>&gt;<i>Every time I've heard anyone say they NEED MI, operator overloading, or 
</I>&gt;<i>Aspects, I've thought
</I>&gt;<i>that they really don't need them, they're just not good enough 
</I>&gt;<i>programmers to see a clean way
</I>&gt;<i>to do without them. I've been programming for 25 years without ever 
</I>&gt;<i>NEEDING any of these,
</I>&gt;<i>and so have most other programmers.
</I>&gt;<i>
</I>I programmed for many years without needing pointers. FORTRAN didn't 
have them, so I tended not to use them in C. I notice you said *MOST* 
other programmers. You're jumping to conclusions - because &quot;all the 
programmers I know are too stupid to live without these features&quot; you 
conclude that these features &quot;mostly aren't needed&quot;. So you'd like to 
see them removed from any tool you use ... :-(
&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> So - you're quite happy to see Antlr crippled to suit you, ignoring 
</I>&gt;&gt;<i>the NEEDS of those who need its power!
</I>&gt;<i>
</I>&gt;<i>Don't worry, I can't cripple ANTLR.  But yes, I'd be happy to see 
</I>&gt;<i>ANTLR4 become a &quot;crippled&quot; version,
</I>&gt;<i>in the same sense that Java is a &quot;crippled&quot; version of C++.
</I>&gt;<i>
</I>And as I said, you're quite happy to ruin the tool for all those people 
who need that power ...
&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But required knowledge of the tool's internals limits the &quot;average&quot; 
</I>&gt;&gt;&gt;<i>user's productivity.
</I>&gt;&gt;&gt;<i> If I had done AST-based translation, I'd be spending way to much 
</I>&gt;&gt;&gt;<i>time worrying about the details
</I>&gt;&gt;&gt;<i> of the AST, rather than the syntax and semantics of the two 
</I>&gt;&gt;&gt;<i>languages. I demand to spend 95% of
</I>&gt;&gt;&gt;<i> my time on *what* to do, rather than *how* to do it. With ASTs, I 
</I>&gt;&gt;&gt;<i>found myself spending
</I>&gt;&gt;&gt;<i> 95% of my time on *how*.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> In other words, as you said earlier, ASTs are the wrong tool for you. 
</I>&gt;&gt;<i>So you seem happy to delete ASTs from Antlr because *you* don't need 
</I>&gt;&gt;<i>them, irregardless of what other people *NEED*.
</I>&gt;<i>
</I>&gt;<i>Yes, just as I railed against operator overloading and MI in C++, and 
</I>&gt;<i>found bliss in Java.
</I>&gt;<i>I don't much care that other people think they *NEED* MI. They can 
</I>&gt;<i>always stick with C++.
</I>&gt;<i>
</I>Or you could find some other language instead of Java? You'd much rather 
inconvenience all the other Java programmers by removing features they 
need, rather than convenience yourself by finding something that suits 
you better?
&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Let's ask a question ... how can a tool be &quot;great&quot; if it *relies* on 
</I>&gt;&gt;<i>other tools even for its existence?
</I>&gt;<i>
</I>&gt;<i>Sure, of course! Virtually all software relies on other tools 
</I>&gt;<i>(compilers, operating systems, etc) for their existence.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A C compiler can compile itself. Can a Java system build itself? How 
</I>&gt;&gt;<i>much of Java is actually written in Java? (Oh and I'm including the 
</I>&gt;&gt;<i>supporting libraries here!)
</I>&gt;<i>
</I>&gt;<i>Almost all of Java is written in Java. The only part that's not is the 
</I>&gt;<i>lowest layer, which is OS and hardware specific.
</I>&gt;<i>
</I>Assembler is written in assembler, pretty much without exception. C is 
written in C, pretty much without exception.

The reason for demanding that a great tool be written in itself is 
exemplified by my databasic example above - the primitives for the 
version I initially used were written in machine code, and followed the 
spec. The C rewrite introduced loads of subtle bugs, because the 
characteristics of the C environment were different. How much of Java 
DEPENDS on the lowest layer? How much knowledge do you need to 
understand that layer?
&gt;&gt;<i>
</I>&gt;&gt;<i> Antlr v3 is due to be rewritten in Antlr v3. To my mind, that's a 
</I>&gt;&gt;<i>&quot;necessary but not sufficient&quot; condition for greatness.
</I>&gt;<i>
</I>&gt;<i>Wow. Only software that's written in itself can be &quot;great&quot;? Are you 
</I>&gt;<i>really saying that?
</I>&gt;<i>
</I>Yes I am. Because otherwise it requires you to understand much more than 
you want about the execution environment. Note my comments about subtle 
bugs. Because it requires the system guys to be *experts* in two 
completely different environments!

I note that you think a &quot;great tool&quot; is one that means you *don't* 
*need* to be an expert. By your logic, Java therefore has to be a crap 
tool for Java system programmers ...

Which is why, in the system I want to build with Antlr, it's very 
important to me that AS MUCH AS POSSIBLE of the system is built using 
DATABASIC, because that's what the programmers using it will have 
experience in. *THAT* is why a great tool must be built using itself.
&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But what if the problem can only be specified in terms of formal 
</I>&gt;&gt;<i>language theory?
</I>&gt;<i>
</I>&gt;<i>Then you'd have a different situation. But surely you're not saying 
</I>&gt;<i>that a language-to-language translator
</I>&gt;<i>can only be specified in terms of formal language theory, are you?
</I>&gt;<i>
</I>&gt;&gt;<i> There is something called &quot;intelligence&quot;. If you don't have 
</I>&gt;&gt;<i>sufficient intelligence, you *cannot* learn certain things. You want 
</I>&gt;&gt;<i>to give a programmer a tool, so you can set him a problem he is 
</I>&gt;&gt;<i>INCAPABLE of comprehending. I hope I never have to rely on (or even 
</I>&gt;&gt;<i>USE) code written by a coder like that !!!
</I>&gt;<i>
</I>&gt;<i>Well, virtually every coder in the world is like that. Only a handful 
</I>&gt;<i>of people in the world know the details of what their
</I>&gt;<i>compiler is doing as they use it every day. Same goes for the OS and 
</I>&gt;<i>the hardware. Same goes for  the car you drive
</I>&gt;<i>and just about everything other non-trivial machine you use: you use it 
</I>&gt;<i>without knowing much about how it works.
</I>&gt;<i>That's what makes the world go round :)
</I>&gt;<i>
</I>You miss the point. Let's take the car example. There's a big difference 
between what I wrote and you responded to. As far as I can see, you're 
saying that if a guy has a driving licence, you're quite happy to get 
him to repair your car brakes ... WHAT...!!!

You do not give a problem to someone to solve, if they do not have the 
mental capacity to understand the problem. You do not ask a guy to 
repair the brakes on your car if he has no experience of being a 
mechanic, even if he does have a driving licence (and there's a lot of 
people I would hate to have service my car, even if they do have a 
mechanics qualification, because they learnt to follow the diagrams in 
the book and didn't learn to work through what was *actually* 
*happening*!).
&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> And then the programmer needs a pointer to write to a bit of 
</I>&gt;&gt;<i>hardware, and throws Java out in disgust because his &quot;great&quot; tool is 
</I>&gt;&gt;<i>useless for the job at hand ...
</I>&gt;<i>
</I>&gt;<i>Right. And probably gets fired if his boss finds out that he's trying 
</I>&gt;<i>to write a bit directly to hardware.
</I>&gt;<i>He thinks he needs to do that, and he thinks he's smart, but he's not. 
</I>&gt;<i>That's pretty rare these days to
</I>&gt;<i>have anyone feel that they need direct access to the hardware. We're 
</I>&gt;<i>many levels beyond that now.
</I>&gt;<i>
</I>Given the ability of many bosses, I bet the boss gave him the job, and 
told him to use the wrong tool ...
&gt;&gt;<i>
</I>&gt;&gt;<i> Because javac is meant to convert java source accurately to java 
</I>&gt;&gt;<i>bytecode. While Antlr is meant to (and does) accurately convert its 
</I>&gt;&gt;<i>sourcecode into a lexer/parser/treewalker, it is also designed to let 
</I>&gt;&gt;<i>do things beyond the power of the tool. Both fit their design aims  - 
</I>&gt;&gt;<i>javac creates a java program, Antlr creates an extensible 
</I>&gt;&gt;<i>lexer/parser/treewalker. Both are *good* tools, that doesn't 
</I>&gt;&gt;<i>necessarily mean they are *great* tools.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> At the end of the day, I think your definition of &quot;great&quot; is badly 
</I>&gt;&gt;<i>flawed - &quot;a great tool lets a mediocre programmer do a decent job&quot;. A 
</I>&gt;&gt;<i>great programmer could probably outperform that mediocre programmer 
</I>&gt;&gt;<i>without that tool.
</I>&gt;<i>
</I>&gt;<i>Heh, it's been a while since I heard the &quot;A great programmer can write 
</I>&gt;<i>better code than the compiler&quot; line.
</I>&gt;<i>Used to hear that a lot 20 years ago, not much any more.
</I>
I gather the statistics still hold true. The best programmers still 
outperform the average ones by about 1000% ... that's a MASSIVE 
difference.
&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The greater the tool, the greater the level of maturity required to 
</I>&gt;&gt;<i>be able to use it safely.
</I>&gt;<i>
</I>&gt;<i>If you want to use that meaning for &quot;great&quot;, that's fine. But I do 
</I>&gt;<i>disagree. If you had one space shuttle
</I>&gt;<i>that was completely safe and automated, that would be a &quot;greater&quot; tool 
</I>&gt;<i>than one that requires maturity, IMO.
</I>&gt;<i>Especially if you have millions of shuttle pilots, and not just a few.
</I>
You've obviously not read Dick Feynmann then ... :-) even *I* could fly 
the space shuttle :-)

Hint - in a former life, the Shuttle's pilot was known as &quot;George&quot; :-)
&gt;<i>
</I>&gt;&gt;<i> And the fewer the number of programmers who are capable of reaching 
</I>&gt;&gt;<i>that level of maturity ... you go on about the &quot;dangerous features&quot; of 
</I>&gt;&gt;<i>C++ as opposed to Java. A mature C++ programmer would NOT USE those 
</I>&gt;&gt;<i>features if they weren't needed. Indeed, a mature C++ programmer would 
</I>&gt;&gt;<i>probably use Java if those features weren't needed.
</I>&gt;<i>
</I>&gt;<i>Haven't heard that one in a while either. Yes, yes, I know, it's not 
</I>&gt;<i>C++ that's dangerous, it's just those *other* guys
</I>&gt;<i>who are bad programmers and are misusing it. And we Java fans are just 
</I>&gt;<i>not manly enough to handle
</I>&gt;<i>MI and operator overloading.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Too many programmers use features like kids eat candy - the more the 
</I>&gt;&gt;<i>better! A great programmer likes a tool like a candy shop - but he has 
</I>&gt;&gt;<i>the self control to only take what he needs - not the entire shop!
</I>&gt;<i>
</I>&gt;<i>Yea, yea, heard it all before. It's all those *other*, less-intelligent 
</I>&gt;<i>programmers that are using operator overloading
</I>&gt;<i>to apply the &quot;+&quot; operator to the &quot;Person&quot; class. We smart programmers 
</I>&gt;<i>know that we *NEED* operator overloading
</I>&gt;<i>for our matrix multiplication. Bleh. :)
</I>&gt;<i>
</I>Fine. Since Java is such a great language, let's see you write the BIOS 
for all new computers in it ... what? you mean all new computers will be 
bricks if you do? What a crap tool ...

Oh - and as for &quot;we smart programmers&quot;, you do realise you've just 
disqualified yourself as a member of that set? You used the word &quot;we&quot;! 
If the &quot;other&quot; guy respects you, he'll do as you say. I've done some 
crazy things in my time, like using a goto in C :-) But when other 
programmers have said &quot;you shouldn't do that&quot; I've just said &quot;well, you 
do better&quot;. Usually, they've looked at the problem to be solved, and 
backed down. If you're a smart programmer, you'll show the other guy how 
to do it better. If you can't, he's smarter than you thought!

&quot;Perfection is achieved, not when everything that is necessary has been 
added, but when everything that is unnecessary has been taken away&quot;.

I *know* I'm an expert in DATABASIC. I would *like* to *think* I'm a 
guru, but until somebody like Jim, or Rob, or Monty, tells me I am (and 
I probably wouldn't believe Monty), then I'm not! And even then, I 
wouldn't believe them unless other people I trusted agreed with them.

Ask Loring what unnecessary stuff can be removed from Antlr. Ask Ter. 
Ask Jim. Ask Monty. Ask the people *YOU* *RESPECT* *AS* *EXPERTS* (or 
aren't there any such on this list? :-)

I think you'll find everything in Antlr is there because it's needed. 
Like ASTs for example - I think they happen to be a perfect solution to 
my problem :-)

I know Antlr doesn't do what you want. So stop trying to drive screws 
with a hammer, and go find yourself a screwdriver :-) Don't try and ban 
hammers :-)

(Incidentally, one of the features I found Antlr lacked - or rather 
seemed incredibly complex to implement - in v2 was a stream rewriter - I 
wanted a state engine to flip token types - certain types may or may not 
follow other types and I could do it a lot easier in a stream rewriter 
than by tracking state in the lexer. Maybe that would be a useful tool 
for you, maybe not.)

Cheers,
Wol
-- 
Anthony W. Youngman - <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">anthony at thewolery.demon.co.uk</A>

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018212.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018226.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18220">[ date ]</a>
              <a href="thread.html#18220">[ thread ]</a>
              <a href="subject.html#18220">[ subject ]</a>
              <a href="author.html#18220">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
