<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] postmortem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3Cebc876d70803131140s10f54308madeab78d8a65f02b%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027198.html">
   <LINK REL="Next"  HREF="027218.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] postmortem</H1>
    <B>Thomas Brandon</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3Cebc876d70803131140s10f54308madeab78d8a65f02b%40mail.gmail.com%3E"
       TITLE="[antlr-interest] postmortem">tbrandonau at gmail.com
       </A><BR>
    <I>Thu Mar 13 11:40:45 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027198.html">[antlr-interest] postmortem
</A></li>
        <LI>Next message: <A HREF="027218.html">[antlr-interest] postmortem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27203">[ date ]</a>
              <a href="thread.html#27203">[ thread ]</a>
              <a href="subject.html#27203">[ subject ]</a>
              <a href="author.html#27203">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Mar 14, 2008 at 2:00 AM, Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> &gt; Thomas Brandon wrote:
</I>&gt;<i>  On Thu, Mar 13, 2008 at 7:58 AM, Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
</I>&gt;<i> &gt;  Yes, most ANTLR users want a non-flat tree. But most (if not all) of
</I>&gt;<i> &gt; these users do not want a parse tree.
</I>&gt;<i>  Agreed. But keep in mind that for many applications, simply walking the AST
</I>&gt;<i> by hand is enough.
</I>I'm familiar with your views so I tried to though it's a rather alien
approach to me so forgive any oversights..
&gt;<i>
</I>&gt;<i> &gt;  The parse trees generated by
</I>&gt;<i> &gt; ANTLR are not just like ASTs and cannot be used as such. Parse trees
</I>&gt;<i> &gt; consist of standard AST nodes for all the actual language nodes and
</I>&gt;<i> &gt; special parse tree nodes (of type ParseTree extending CommonTree) for
</I>&gt;<i> &gt; the rule references. These parse tree nodes have a token type of 0.
</I>&gt;<i> &gt; Thus you cannot use a tree parser against a parse tree and manually
</I>&gt;<i> &gt; walking the tree would be complicated. Parse trees (as generated by
</I>&gt;<i> &gt; ANTLR) are more of a debugging aid than a type of AST that
</I>&gt;<i> &gt; automatically adds structure.
</I>&gt;<i>
</I>&gt;<i>  ...I think that in many cases processing the parse tree would be very
</I>&gt;<i> simple:
</I>&gt;<i>
</I>&gt;<i>  if (!(ast instanceof ParseTree)) {
</I>&gt;<i>     doSomethingWith(ast);
</I>&gt;<i>  } else {
</I>&gt;<i>     // ignore ParseTree nodes
</I>&gt;<i>  }
</I>&gt;<i>
</I>Well, that's not going to process the children of parse trees which is
presumably not what you want. And if you're skipping them then what
use are they exactly?
But my point was that with no token type you can switch on token
types. So you'd have to switch on the string name, which gets rather
nasty to maintain, and means changing a rule name will break your tree
walker but give no compile time errors. Not especially easy or
desirable.

&lt;SNIP&gt;A fair bit of going round in circles with proposed heuristics&lt;/SNIP&gt;

&gt;<i>  ...but I guess maybe that puts us where we started - generating a full
</I>&gt;<i> parse tree.
</I>&gt;<i>  But even without solving this problem - go ahead and leave the tree as
</I>&gt;<i> being hard to walk -
</I>&gt;<i>  we're still ahead. The goal here is not to generate a &quot;good&quot; AST, but
</I>&gt;<i> rather just produce something
</I>&gt;<i>  that's better than nothing (i.e. a flat tree). So the newbie gets this
</I>&gt;<i> tree, sees that it's hard to
</I>&gt;<i>  distinguish the various cases where he's got an ID node, and starts reading
</I>&gt;<i> up on how to build
</I>&gt;<i>  an AST. He's better off here than the alternative: a blank stare at a flat
</I>&gt;<i> ast.
</I>&lt;SNIP&gt;more circles&lt;/SNIP&gt;
&gt;<i>  Thanks for writing this up. Let me know if you think the replies I gave
</I>&gt;<i> would work.
</I>&gt;<i>  As I said, if they work, but only make things somewhat better, but not a
</I>&gt;<i> completely usable AST, that's
</I>&gt;<i>  still a win IMO. If they don't work, then how about simply say &quot;if there
</I>&gt;<i> are no ^'s, I'll just use
</I>&gt;<i>  the existing code to get a parse tree and return that&quot;?
</I>&gt;<i>
</I>&gt;<i>  Andy
</I>(Can you please stop HTML posting or at least use a client with decent
quoting in it's HTML. Gmail can't handle your quoting and I've found
it's generally pretty good at that.)
I could go through your various proposed rules and point out the case
where they produce a structure I can't see anyone wanting but I gather
you admit that point.

The detect ^ and switch off automatic rules doesn't work because the
user may want a flat AST.

And I don't accept your view that producing a bad AST is better than
producing a flat AST. Is anyone going to use a bad AST? I can't see
why they would and don't think they should. Is it easy to allow such
auto-generation to be mixed with explicit construction to generate a
good AST? I don't think so. At best you end up with a grammar that's
messier and harder to understand than if you'd just used manual
construction. So you've spent all the time developing a system that no
one is ever going to use for more than the first grammar run that's
only purpose is to avoid giving someone a flat AST. And if they don't
look at enough docs\examples first and, heaven forbid, get a flat AST
they either go to the docs and quickly recognise their flawed
expectations of what output=AST will do or send a message to the list
that requires all of two or three sentences to answer. How is this in
anyway a good use of time or a justifiable addition of code
complexity?

Tom.
</PRE>























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027198.html">[antlr-interest] postmortem
</A></li>
	<LI>Next message: <A HREF="027218.html">[antlr-interest] postmortem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27203">[ date ]</a>
              <a href="thread.html#27203">[ thread ]</a>
              <a href="subject.html#27203">[ subject ]</a>
              <a href="author.html#27203">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
