<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Is &quot;-debug&quot; command line option broken with	language=CSharp?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Is%20%22-debug%22%20command%20line%20option%20broken%20with%0A%09language%3DCSharp%3F&In-Reply-To=%3C8a0c37020705241712j3d653934j54a49decb5347320%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020863.html">
   <LINK REL="Next"  HREF="020860.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Is &quot;-debug&quot; command line option broken with	language=CSharp?</H1>
    <B>Takashi Oguma</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Is%20%22-debug%22%20command%20line%20option%20broken%20with%0A%09language%3DCSharp%3F&In-Reply-To=%3C8a0c37020705241712j3d653934j54a49decb5347320%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Is &quot;-debug&quot; command line option broken with	language=CSharp?">bear.mini at gmail.com
       </A><BR>
    <I>Thu May 24 17:12:50 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="020863.html">[antlr-interest] Mantra grammar warning.
</A></li>
        <LI>Next message: <A HREF="020860.html">[antlr-interest] Is &quot;-debug&quot; command line option broken with	language=CSharp?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20855">[ date ]</a>
              <a href="thread.html#20855">[ thread ]</a>
              <a href="subject.html#20855">[ subject ]</a>
              <a href="author.html#20855">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

I want to build a parse tree with my grammar, and as my first step, I
refer to this Wiki page:
<A HREF="http://www.antlr.org/wiki/pages/viewpage.action?pageId=1760">http://www.antlr.org/wiki/pages/viewpage.action?pageId=1760</A>

I want a lexer and a parser in C# language, so I added &quot;option {
language = CSharp }&quot; to the grammar P.g.

Then I compiled the P.g with -debug option and I got PLexer.cs and
PParser.cs successfully.

But when I compiled PParser.cs, I got 2 types of error messages:

1st:
error CS0117: 'Antlr.Runtime.Debug.IDebugEventListener' does not
contain a definition for 'location'
(this error occurred 5 times)

2nd:
error CS0103: The name 'nvae' does not exist in the current context
(this erro occurred 1 time)


Can anyone tell me the cause of the problem?


I attached complete P.g and generated PLexser.cs and PParser.cs.

Complete build output and error messages are below:

------ Build started: Project: AntlrExample, Configuration: Debug Any CPU ------
java -cp %CLASSPATH% org.antlr.Tool -debug -message-format vstudio P.g
ANTLR Parser Generator  Version 3.0 (May 17, 2007)  1989-2007
no such message format file
org/antlr/tool/templates/messages/formats/vstudio.stg retrying with
default ANTLR format
warning(200): P.g:14:29: Decision can match input such as &quot;'else'&quot;
using multiple alternatives: 1, 2
As a result, alternative(s) 2 were disabled for that input
C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\Csc.exe /noconfig
/nowarn:1701,1702 /errorreport:prompt /warn:4 /define:DEBUG;TRACE
/reference:..\..\..\tools\antlr-3.0\runtime\CSharp\bin\net-2.0\antlr.runtime.dll
/reference:..\..\..\tools\antlr-3.0\runtime\CSharp\bin\net-2.0\Antlr3.Runtime.dll
/reference:..\..\..\tools\antlr-3.0\runtime\CSharp\bin\net-2.0\Antlr3.Utility.dll
/reference:..\..\..\tools\antlr-3.0\runtime\CSharp\bin\net-2.0\StringTemplate.dll
/reference:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\System.Data.dll
/reference:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\System.dll
/reference:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\System.Xml.dll
/debug+ /debug:full /optimize- /out:obj\Debug\AntlrExample.exe
/target:exe PLexer.cs PParser.cs Program.cs Properties\AssemblyInfo.cs
C:\Work\AntlrExample\AntlrExample\PParser.cs(190,13): error CS0117:
'Antlr.Runtime.Debug.IDebugEventListener' does not contain a
definition for 'location'
C:\Work\AntlrExample\AntlrExample\PParser.cs(287,13): error CS0117:
'Antlr.Runtime.Debug.IDebugEventListener' does not contain a
definition for 'location'
C:\Work\AntlrExample\AntlrExample\PParser.cs(346,13): error CS0117:
'Antlr.Runtime.Debug.IDebugEventListener' does not contain a
definition for 'location'
C:\Work\AntlrExample\AntlrExample\PParser.cs(393,42): error CS0103:
The name 'nvae' does not exist in the current context
C:\Work\AntlrExample\AntlrExample\PParser.cs(485,13): error CS0117:
'Antlr.Runtime.Debug.IDebugEventListener' does not contain a
definition for 'location'
C:\Work\AntlrExample\AntlrExample\PParser.cs(544,13): error CS0117:
'Antlr.Runtime.Debug.IDebugEventListener' does not contain a
definition for 'location'

Compile complete -- 6 errors, 0 warnings
========== Build: 0 succeeded or up-to-date, 1 failed, 0 skipped ==========


Thanks
-- 
Takashi OGUMA
<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bear.mini at gmail.com</A>
-------------- next part --------------
grammar P;

options
{
    language=CSharp;
}

prog: decl* stat* ;
 
decl: type ID (',' ID)* ';' ;
    
type: 'int' | 'float' ;
        
stat: 'if' expr 'then' stat ('else' stat)?
    | ID '=' expr 
    ;   
        
expr: INT
    | 'true'
    ;   
        
ID  : 'a'..'z'+ ; 
INT : '0'..'9'+ ;
WS  : (' '|'\n')+ {$channel=HIDDEN;} ;



-------------- next part --------------
// $ANTLR 3.0 P.g 2007-05-25 09:02:46

using System;
using Antlr.Runtime;
using IList 		= System.Collections.IList;
using ArrayList 	= System.Collections.ArrayList;
using Stack 		= Antlr.Runtime.Collections.StackList;



public class PLexer : Lexer 
{
    public const int WS = 6;
    public const int T7 = 7;
    public const int T10 = 10;
    public const int T11 = 11;
    public const int INT = 5;
    public const int T12 = 12;
    public const int T13 = 13;
    public const int T8 = 8;
    public const int T14 = 14;
    public const int T9 = 9;
    public const int T15 = 15;
    public const int ID = 4;
    public const int Tokens = 16;
    public const int EOF = -1;

    public PLexer() 
    {
		InitializeCyclicDFAs();
    }
    public PLexer(ICharStream input) 
		: base(input)
	{
		InitializeCyclicDFAs();
    }
    
    override public string GrammarFileName
    {
    	get { return &quot;P.g&quot;;} 
    }

    // $ANTLR start T7 
    public void mT7() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T7;
            // P.g:7:6: ( ',' )
            // P.g:7:6: ','
            {
            	Match(','); 
            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T7

    // $ANTLR start T8 
    public void mT8() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T8;
            // P.g:8:6: ( ';' )
            // P.g:8:6: ';'
            {
            	Match(';'); 
            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T8

    // $ANTLR start T9 
    public void mT9() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T9;
            // P.g:9:6: ( 'int' )
            // P.g:9:6: 'int'
            {
            	Match(&quot;int&quot;); 

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T9

    // $ANTLR start T10 
    public void mT10() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T10;
            // P.g:10:7: ( 'float' )
            // P.g:10:7: 'float'
            {
            	Match(&quot;float&quot;); 

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T10

    // $ANTLR start T11 
    public void mT11() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T11;
            // P.g:11:7: ( 'if' )
            // P.g:11:7: 'if'
            {
            	Match(&quot;if&quot;); 

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T11

    // $ANTLR start T12 
    public void mT12() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T12;
            // P.g:12:7: ( 'then' )
            // P.g:12:7: 'then'
            {
            	Match(&quot;then&quot;); 

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T12

    // $ANTLR start T13 
    public void mT13() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T13;
            // P.g:13:7: ( 'else' )
            // P.g:13:7: 'else'
            {
            	Match(&quot;else&quot;); 

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T13

    // $ANTLR start T14 
    public void mT14() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T14;
            // P.g:14:7: ( '=' )
            // P.g:14:7: '='
            {
            	Match('='); 
            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T14

    // $ANTLR start T15 
    public void mT15() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = T15;
            // P.g:15:7: ( 'true' )
            // P.g:15:7: 'true'
            {
            	Match(&quot;true&quot;); 

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end T15

    // $ANTLR start ID 
    public void mID() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = ID;
            // P.g:22:7: ( ( 'a' .. 'z' )+ )
            // P.g:22:7: ( 'a' .. 'z' )+
            {
            	// P.g:22:7: ( 'a' .. 'z' )+
            	int cnt1 = 0;
            	do 
            	{
            	    int alt1 = 2;
            	    int LA1_0 = input.LA(1);
            	    
            	    if ( ((LA1_0 &gt;= 'a' &amp;&amp; LA1_0 &lt;= 'z')) )
            	    {
            	        alt1 = 1;
            	    }
            	    
            	
            	    switch (alt1) 
            		{
            			case 1 :
            			    // P.g:22:7: 'a' .. 'z'
            			    {
            			    	MatchRange('a','z'); 
            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt1 &gt;= 1 ) goto loop1;
            		            EarlyExitException eee =
            		                new EarlyExitException(1, input);
            		            throw eee;
            	    }
            	    cnt1++;
            	} while (true);
            	
            	loop1:
            		;	// Stops C# compiler whinging that label 'loop1' has no statements

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end ID

    // $ANTLR start INT 
    public void mINT() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = INT;
            // P.g:23:7: ( ( '0' .. '9' )+ )
            // P.g:23:7: ( '0' .. '9' )+
            {
            	// P.g:23:7: ( '0' .. '9' )+
            	int cnt2 = 0;
            	do 
            	{
            	    int alt2 = 2;
            	    int LA2_0 = input.LA(1);
            	    
            	    if ( ((LA2_0 &gt;= '0' &amp;&amp; LA2_0 &lt;= '9')) )
            	    {
            	        alt2 = 1;
            	    }
            	    
            	
            	    switch (alt2) 
            		{
            			case 1 :
            			    // P.g:23:7: '0' .. '9'
            			    {
            			    	MatchRange('0','9'); 
            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt2 &gt;= 1 ) goto loop2;
            		            EarlyExitException eee =
            		                new EarlyExitException(2, input);
            		            throw eee;
            	    }
            	    cnt2++;
            	} while (true);
            	
            	loop2:
            		;	// Stops C# compiler whinging that label 'loop2' has no statements

            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end INT

    // $ANTLR start WS 
    public void mWS() // throws RecognitionException [2]
    {
        try 
    	{
            int _type = WS;
            // P.g:24:7: ( ( ' ' | '\\n' )+ )
            // P.g:24:7: ( ' ' | '\\n' )+
            {
            	// P.g:24:7: ( ' ' | '\\n' )+
            	int cnt3 = 0;
            	do 
            	{
            	    int alt3 = 2;
            	    int LA3_0 = input.LA(1);
            	    
            	    if ( (LA3_0 == '\n' || LA3_0 == ' ') )
            	    {
            	        alt3 = 1;
            	    }
            	    
            	
            	    switch (alt3) 
            		{
            			case 1 :
            			    // P.g:
            			    {
            			    	if ( input.LA(1) == '\n' || input.LA(1) == ' ' ) 
            			    	{
            			    	    input.Consume();
            			    	
            			    	}
            			    	else 
            			    	{
            			    	    MismatchedSetException mse =
            			    	        new MismatchedSetException(null,input);
            			    	    Recover(mse);    throw mse;
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt3 &gt;= 1 ) goto loop3;
            		            EarlyExitException eee =
            		                new EarlyExitException(3, input);
            		            throw eee;
            	    }
            	    cnt3++;
            	} while (true);
            	
            	loop3:
            		;	// Stops C# compiler whinging that label 'loop3' has no statements

            	channel=HIDDEN;
            
            }
    
            this.type = _type;
        }
        finally 
    	{
        }
    }
    // $ANTLR end WS

    override public void mTokens() // throws RecognitionException 
    {
        // P.g:1:10: ( T7 | T8 | T9 | T10 | T11 | T12 | T13 | T14 | T15 | ID | INT | WS )
        int alt4 = 12;
        switch ( input.LA(1) ) 
        {
        case ',':
        	{
            alt4 = 1;
            }
            break;
        case ';':
        	{
            alt4 = 2;
            }
            break;
        case 'i':
        	{
            switch ( input.LA(2) ) 
            {
            case 'f':
            	{
                int LA4_11 = input.LA(3);
                
                if ( ((LA4_11 &gt;= 'a' &amp;&amp; LA4_11 &lt;= 'z')) )
                {
                    alt4 = 10;
                }
                else 
                {
                    alt4 = 5;}
                }
                break;
            case 'n':
            	{
                int LA4_12 = input.LA(3);
                
                if ( (LA4_12 == 't') )
                {
                    int LA4_18 = input.LA(4);
                    
                    if ( ((LA4_18 &gt;= 'a' &amp;&amp; LA4_18 &lt;= 'z')) )
                    {
                        alt4 = 10;
                    }
                    else 
                    {
                        alt4 = 3;}
                }
                else 
                {
                    alt4 = 10;}
                }
                break;
            	default:
                	alt4 = 10;
                	break;}
        
            }
            break;
        case 'f':
        	{
            int LA4_4 = input.LA(2);
            
            if ( (LA4_4 == 'l') )
            {
                int LA4_13 = input.LA(3);
                
                if ( (LA4_13 == 'o') )
                {
                    int LA4_19 = input.LA(4);
                    
                    if ( (LA4_19 == 'a') )
                    {
                        int LA4_24 = input.LA(5);
                        
                        if ( (LA4_24 == 't') )
                        {
                            int LA4_28 = input.LA(6);
                            
                            if ( ((LA4_28 &gt;= 'a' &amp;&amp; LA4_28 &lt;= 'z')) )
                            {
                                alt4 = 10;
                            }
                            else 
                            {
                                alt4 = 4;}
                        }
                        else 
                        {
                            alt4 = 10;}
                    }
                    else 
                    {
                        alt4 = 10;}
                }
                else 
                {
                    alt4 = 10;}
            }
            else 
            {
                alt4 = 10;}
            }
            break;
        case 't':
        	{
            switch ( input.LA(2) ) 
            {
            case 'h':
            	{
                int LA4_14 = input.LA(3);
                
                if ( (LA4_14 == 'e') )
                {
                    int LA4_20 = input.LA(4);
                    
                    if ( (LA4_20 == 'n') )
                    {
                        int LA4_25 = input.LA(5);
                        
                        if ( ((LA4_25 &gt;= 'a' &amp;&amp; LA4_25 &lt;= 'z')) )
                        {
                            alt4 = 10;
                        }
                        else 
                        {
                            alt4 = 6;}
                    }
                    else 
                    {
                        alt4 = 10;}
                }
                else 
                {
                    alt4 = 10;}
                }
                break;
            case 'r':
            	{
                int LA4_15 = input.LA(3);
                
                if ( (LA4_15 == 'u') )
                {
                    int LA4_21 = input.LA(4);
                    
                    if ( (LA4_21 == 'e') )
                    {
                        int LA4_26 = input.LA(5);
                        
                        if ( ((LA4_26 &gt;= 'a' &amp;&amp; LA4_26 &lt;= 'z')) )
                        {
                            alt4 = 10;
                        }
                        else 
                        {
                            alt4 = 9;}
                    }
                    else 
                    {
                        alt4 = 10;}
                }
                else 
                {
                    alt4 = 10;}
                }
                break;
            	default:
                	alt4 = 10;
                	break;}
        
            }
            break;
        case 'e':
        	{
            int LA4_6 = input.LA(2);
            
            if ( (LA4_6 == 'l') )
            {
                int LA4_16 = input.LA(3);
                
                if ( (LA4_16 == 's') )
                {
                    int LA4_22 = input.LA(4);
                    
                    if ( (LA4_22 == 'e') )
                    {
                        int LA4_27 = input.LA(5);
                        
                        if ( ((LA4_27 &gt;= 'a' &amp;&amp; LA4_27 &lt;= 'z')) )
                        {
                            alt4 = 10;
                        }
                        else 
                        {
                            alt4 = 7;}
                    }
                    else 
                    {
                        alt4 = 10;}
                }
                else 
                {
                    alt4 = 10;}
            }
            else 
            {
                alt4 = 10;}
            }
            break;
        case '=':
        	{
            alt4 = 8;
            }
            break;
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'g':
        case 'h':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        	{
            alt4 = 10;
            }
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        	{
            alt4 = 11;
            }
            break;
        case '\n':
        case ' ':
        	{
            alt4 = 12;
            }
            break;
        	default:
        	    NoViableAltException nvae_d4s0 =
        	        new NoViableAltException(&quot;1:1: Tokens : ( T7 | T8 | T9 | T10 | T11 | T12 | T13 | T14 | T15 | ID | INT | WS );&quot;, 4, 0, input);
        
        	    throw nvae_d4s0;
        }
        
        switch (alt4) 
        {
            case 1 :
                // P.g:1:10: T7
                {
                	mT7(); 
                
                }
                break;
            case 2 :
                // P.g:1:13: T8
                {
                	mT8(); 
                
                }
                break;
            case 3 :
                // P.g:1:16: T9
                {
                	mT9(); 
                
                }
                break;
            case 4 :
                // P.g:1:19: T10
                {
                	mT10(); 
                
                }
                break;
            case 5 :
                // P.g:1:23: T11
                {
                	mT11(); 
                
                }
                break;
            case 6 :
                // P.g:1:27: T12
                {
                	mT12(); 
                
                }
                break;
            case 7 :
                // P.g:1:31: T13
                {
                	mT13(); 
                
                }
                break;
            case 8 :
                // P.g:1:35: T14
                {
                	mT14(); 
                
                }
                break;
            case 9 :
                // P.g:1:39: T15
                {
                	mT15(); 
                
                }
                break;
            case 10 :
                // P.g:1:43: ID
                {
                	mID(); 
                
                }
                break;
            case 11 :
                // P.g:1:46: INT
                {
                	mINT(); 
                
                }
                break;
            case 12 :
                // P.g:1:50: WS
                {
                	mWS(); 
                
                }
                break;
        
        }
    
    }


	private void InitializeCyclicDFAs()
	{
	}

 
    
}
-------------- next part --------------
// $ANTLR 3.0 P.g 2007-05-25 09:02:46

using System;
using Antlr.Runtime;
using IList 		= System.Collections.IList;
using ArrayList 	= System.Collections.ArrayList;
using Stack 		= Antlr.Runtime.Collections.StackList;



public class PParser : Parser 
{
    public static readonly string[] tokenNames = new string[] 
	{
        &quot;&lt;invalid&gt;&quot;, 
		&quot;&lt;EOR&gt;&quot;, 
		&quot;&lt;DOWN&gt;&quot;, 
		&quot;&lt;UP&gt;&quot;, 
		&quot;ID&quot;, 
		&quot;INT&quot;, 
		&quot;WS&quot;, 
		&quot;','&quot;, 
		&quot;';'&quot;, 
		&quot;'int'&quot;, 
		&quot;'float'&quot;, 
		&quot;'if'&quot;, 
		&quot;'then'&quot;, 
		&quot;'else'&quot;, 
		&quot;'='&quot;, 
		&quot;'true'&quot;
    };

    public const int WS = 6;
    public const int INT = 5;
    public const int ID = 4;
    public const int EOF = -1;
    
    
        public PParser(ITokenStream input) 
    		: base(input)
    	{
    		InitializeCyclicDFAs();
        }
        

    override public string[] TokenNames
	{
		get { return tokenNames; }
	}

    override public string GrammarFileName
	{
		get { return &quot;P.g&quot;; }
	}


    
    // $ANTLR start prog
    // P.g:8:1: prog : ( decl )* ( stat )* ;
    public void prog() // throws RecognitionException [1]
    {   
        try 
    	{
            // P.g:8:7: ( ( decl )* ( stat )* )
            // P.g:8:7: ( decl )* ( stat )*
            {
            	// P.g:8:7: ( decl )*
            	do 
            	{
            	    int alt1 = 2;
            	    int LA1_0 = input.LA(1);
            	    
            	    if ( ((LA1_0 &gt;= 9 &amp;&amp; LA1_0 &lt;= 10)) )
            	    {
            	        alt1 = 1;
            	    }
            	    
            	
            	    switch (alt1) 
            		{
            			case 1 :
            			    // P.g:8:7: decl
            			    {
            			    	PushFollow(FOLLOW_decl_in_prog23);
            			    	decl();
            			    	followingStackPointer_--;

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop1;
            	    }
            	} while (true);
            	
            	loop1:
            		;	// Stops C# compiler whinging that label 'loop1' has no statements

            	// P.g:8:13: ( stat )*
            	do 
            	{
            	    int alt2 = 2;
            	    int LA2_0 = input.LA(1);
            	    
            	    if ( (LA2_0 == ID || LA2_0 == 11) )
            	    {
            	        alt2 = 1;
            	    }
            	    
            	
            	    switch (alt2) 
            		{
            			case 1 :
            			    // P.g:8:13: stat
            			    {
            			    	PushFollow(FOLLOW_stat_in_prog26);
            			    	stat();
            			    	followingStackPointer_--;

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop2;
            	    }
            	} while (true);
            	
            	loop2:
            		;	// Stops C# compiler whinging that label 'loop2' has no statements

            
            }
    
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
        }
        finally 
    	{
        }
        return ;
    }
    // $ANTLR end prog

    
    // $ANTLR start decl
    // P.g:10:1: decl : type ID ( ',' ID )* ';' ;
    public void decl() // throws RecognitionException [1]
    {   
        try 
    	{
            // P.g:10:7: ( type ID ( ',' ID )* ';' )
            // P.g:10:7: type ID ( ',' ID )* ';'
            {
            	PushFollow(FOLLOW_type_in_decl36);
            	type();
            	followingStackPointer_--;

            	Match(input,ID,FOLLOW_ID_in_decl38); 
            	// P.g:10:15: ( ',' ID )*
            	do 
            	{
            	    int alt3 = 2;
            	    int LA3_0 = input.LA(1);
            	    
            	    if ( (LA3_0 == 7) )
            	    {
            	        alt3 = 1;
            	    }
            	    
            	
            	    switch (alt3) 
            		{
            			case 1 :
            			    // P.g:10:16: ',' ID
            			    {
            			    	Match(input,7,FOLLOW_7_in_decl41); 
            			    	Match(input,ID,FOLLOW_ID_in_decl43); 
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop3;
            	    }
            	} while (true);
            	
            	loop3:
            		;	// Stops C# compiler whinging that label 'loop3' has no statements

            	Match(input,8,FOLLOW_8_in_decl47); 
            
            }
    
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
        }
        finally 
    	{
        }
        return ;
    }
    // $ANTLR end decl

    
    // $ANTLR start type
    // P.g:12:1: type : ( 'int' | 'float' );
    public void type() // throws RecognitionException [1]
    {   
        try 
    	{
            // P.g:12:7: ( 'int' | 'float' )
            // P.g:
            {
            	if ( (input.LA(1) &gt;= 9 &amp;&amp; input.LA(1) &lt;= 10) ) 
            	{
            	    input.Consume();
            	    errorRecovery = false;
            	}
            	else 
            	{
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_type0);    throw mse;
            	}

            
            }
    
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
        }
        finally 
    	{
        }
        return ;
    }
    // $ANTLR end type

    
    // $ANTLR start stat
    // P.g:14:1: stat : ( 'if' expr 'then' stat ( 'else' stat )? | ID '=' expr );
    public void stat() // throws RecognitionException [1]
    {   
        try 
    	{
            // P.g:14:7: ( 'if' expr 'then' stat ( 'else' stat )? | ID '=' expr )
            int alt5 = 2;
            int LA5_0 = input.LA(1);
            
            if ( (LA5_0 == 11) )
            {
                alt5 = 1;
            }
            else if ( (LA5_0 == ID) )
            {
                alt5 = 2;
            }
            else 
            {
                NoViableAltException nvae_d5s0 =
                    new NoViableAltException(&quot;14:1: stat : ( 'if' expr 'then' stat ( 'else' stat )? | ID '=' expr );&quot;, 5, 0, input);
            
                throw nvae_d5s0;
            }
            switch (alt5) 
            {
                case 1 :
                    // P.g:14:7: 'if' expr 'then' stat ( 'else' stat )?
                    {
                    	Match(input,11,FOLLOW_11_in_stat79); 
                    	PushFollow(FOLLOW_expr_in_stat81);
                    	expr();
                    	followingStackPointer_--;

                    	Match(input,12,FOLLOW_12_in_stat83); 
                    	PushFollow(FOLLOW_stat_in_stat85);
                    	stat();
                    	followingStackPointer_--;

                    	// P.g:14:29: ( 'else' stat )?
                    	int alt4 = 2;
                    	int LA4_0 = input.LA(1);
                    	
                    	if ( (LA4_0 == 13) )
                    	{
                    	    alt4 = 1;
                    	}
                    	switch (alt4) 
                    	{
                    	    case 1 :
                    	        // P.g:14:30: 'else' stat
                    	        {
                    	        	Match(input,13,FOLLOW_13_in_stat88); 
                    	        	PushFollow(FOLLOW_stat_in_stat90);
                    	        	stat();
                    	        	followingStackPointer_--;

                    	        
                    	        }
                    	        break;
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // P.g:15:7: ID '=' expr
                    {
                    	Match(input,ID,FOLLOW_ID_in_stat100); 
                    	Match(input,14,FOLLOW_14_in_stat102); 
                    	PushFollow(FOLLOW_expr_in_stat104);
                    	expr();
                    	followingStackPointer_--;

                    
                    }
                    break;
            
            }
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
        }
        finally 
    	{
        }
        return ;
    }
    // $ANTLR end stat

    
    // $ANTLR start expr
    // P.g:18:1: expr : ( INT | 'true' );
    public void expr() // throws RecognitionException [1]
    {   
        try 
    	{
            // P.g:18:7: ( INT | 'true' )
            // P.g:
            {
            	if ( input.LA(1) == INT || input.LA(1) == 15 ) 
            	{
            	    input.Consume();
            	    errorRecovery = false;
            	}
            	else 
            	{
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_expr0);    throw mse;
            	}

            
            }
    
        }
        catch (RecognitionException re) 
    	{
            ReportError(re);
            Recover(input,re);
        }
        finally 
    	{
        }
        return ;
    }
    // $ANTLR end expr


	private void InitializeCyclicDFAs()
	{
	}

 

    public static readonly BitSet FOLLOW_decl_in_prog23 = new BitSet(new ulong[]{0x0000000000000E12UL});
    public static readonly BitSet FOLLOW_stat_in_prog26 = new BitSet(new ulong[]{0x0000000000000812UL});
    public static readonly BitSet FOLLOW_type_in_decl36 = new BitSet(new ulong[]{0x0000000000000010UL});
    public static readonly BitSet FOLLOW_ID_in_decl38 = new BitSet(new ulong[]{0x0000000000000180UL});
    public static readonly BitSet FOLLOW_7_in_decl41 = new BitSet(new ulong[]{0x0000000000000010UL});
    public static readonly BitSet FOLLOW_ID_in_decl43 = new BitSet(new ulong[]{0x0000000000000180UL});
    public static readonly BitSet FOLLOW_8_in_decl47 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_type0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_11_in_stat79 = new BitSet(new ulong[]{0x0000000000008020UL});
    public static readonly BitSet FOLLOW_expr_in_stat81 = new BitSet(new ulong[]{0x0000000000001000UL});
    public static readonly BitSet FOLLOW_12_in_stat83 = new BitSet(new ulong[]{0x0000000000000810UL});
    public static readonly BitSet FOLLOW_stat_in_stat85 = new BitSet(new ulong[]{0x0000000000002002UL});
    public static readonly BitSet FOLLOW_13_in_stat88 = new BitSet(new ulong[]{0x0000000000000810UL});
    public static readonly BitSet FOLLOW_stat_in_stat90 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ID_in_stat100 = new BitSet(new ulong[]{0x0000000000004000UL});
    public static readonly BitSet FOLLOW_14_in_stat102 = new BitSet(new ulong[]{0x0000000000008020UL});
    public static readonly BitSet FOLLOW_expr_in_stat104 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_expr0 = new BitSet(new ulong[]{0x0000000000000002UL});

}
-------------- next part --------------
using System;
using System.Collections.Generic;
using System.Text;

using Antlr.Runtime;
using Antlr.Runtime.Debug;
using Antlr.Runtime.Tree;

namespace AntlrExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // create the lexer attached to stdin
            ANTLRStringStream input = new ANTLRStringStream(&quot;int i; i=4;&quot;);
            PLexer lexer = new PLexer(input);
            // create the buffer of tokens between the lexer and parser
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            // create a debug event listener that builds parse trees
            ParseTreeBuilder builder = new ParseTreeBuilder(&quot;prog&quot;);
            // create the parser attached to the token buffer
            // and tell it which debug event listener to use
            PParser parser = new PParser(tokens, builder);
            // launch the parser starting at rule prog
            parser.prog();
        }


        private static void printTree(CommonTree t, int indent)
        {
            if (t != null)
            {
                StringBuilder sb = new StringBuilder(indent);
                for (int i = 0; i &lt; indent; i++)
                {
                    sb = sb.Append(&quot;   &quot;);
                }

                for (int i = 0; i &lt; t.ChildCount; i++)
                {
                    System.Console.WriteLine(sb.ToString() + t.GetChild(i).ToString());
                    printTree((CommonTree)t.GetChild(i), indent + 1);
                }
            }
        }

    }
}
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020863.html">[antlr-interest] Mantra grammar warning.
</A></li>
	<LI>Next message: <A HREF="020860.html">[antlr-interest] Is &quot;-debug&quot; command line option broken with	language=CSharp?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20855">[ date ]</a>
              <a href="thread.html#20855">[ thread ]</a>
              <a href="subject.html#20855">[ subject ]</a>
              <a href="author.html#20855">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
