<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Re: Translators Should Use Tree Grammars
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20Translators%20Should%20Use%20Tree%20Grammars&In-Reply-To=cnr2c1%2B124e%40eGroups.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010310.html">
   <LINK REL="Next"  HREF="010326.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Re: Translators Should Use Tree Grammars</H1>
    <B>atripp54321</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20Translators%20Should%20Use%20Tree%20Grammars&In-Reply-To=cnr2c1%2B124e%40eGroups.com"
       TITLE="[antlr-interest] Re: Translators Should Use Tree Grammars">atripp at comcast.net
       </A><BR>
    <I>Mon Nov 22 13:16:12 PST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="010310.html">[antlr-interest] OOPS! Re: Translators Should Use Tree Grammars
</A></li>
        <LI>Next message: <A HREF="010326.html">[antlr-interest] Re: Translators Should Use Tree Grammars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10323">[ date ]</a>
              <a href="thread.html#10323">[ thread ]</a>
              <a href="subject.html#10323">[ subject ]</a>
              <a href="author.html#10323">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

--- In <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>, &quot;micheal_jor&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">open.zone at v...</A>&gt;
wrote:
&gt;<i> 
</I>&gt;<i> --- In <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>, &quot;atripp54321&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">atripp at c...</A>&gt;
</I>wrote:
&gt;<i> 
</I>&gt;<i> Hi Andy,
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; Section-secific comments:
</I>&gt;<i> &gt; &gt; =========================
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 1. The Complex Case: Tranforming a C AST to a Java AST
</I>&gt;<i> &gt; &gt; ======================================================
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; To be able to answer queries such as &quot;get all VAR_REF nodes that
</I>&gt;<i> &gt; refer
</I>&gt;<i> &gt; &gt; to this declaration&quot; efficiently, you would have added
</I>appropriate
&gt;<i> &gt; &gt; attributes during the symbol table construction pass(es).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Right. My problem is that the amount of information I feel I'd
</I>&gt;<i> &gt; need in the symbol table is HUGE. Some examples of info I need:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &quot;Is this variable ever used in an expression where I could change
</I>&gt;<i> &gt; it to from an int type to a boolean type?&quot;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &quot;Is this variable v ever used later in this function in either
</I>&gt;<i> &gt; 'v = x;' form or 'if (v)' form?&quot;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &quot;Is this method named 'main' and have two arguments, one of 'int'
</I>&gt;<i> &gt; type and the second of 'char *[]', 'char **', or similar type?&quot;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &quot;What other variables are assigned a value in which this variable
</I>&gt;<i> &gt; is part of the value?&quot;
</I>&gt;<i> 
</I>&gt;<i> A symbol table is a data structure (or set of data structures) that
</I>&gt;<i> stores and supports provides fast query of [some] AST node
</I>attributes.
&gt;<i> Some of those attributes may either fully answer or help in
</I>answering
&gt;<i> your queries.
</I>
I know what a symbol table is, thank you.
I've just made the point that I don't think that a symbol
table typically contains the sort of information that I
just gave four examples of.

&gt;<i> 
</I>&gt;<i> Your particular usage - a C-to-Java translator - would require no
</I>more
&gt;<i> than is typically stored in a symbol table. 
</I>
So you believe that a symbol table typically contains answers
to the kinds of questions I list above? If so, can you
give me a reference to such an implementation, or mention
of one in the literature? Maybe I just haven't kept up to
date, but I've always read that a symbol table contains
little more than variable and method declaration and
scope information.

&gt;<i> You are performing static
</I>&gt;<i> code analysis and there are established techniques and literature on
</I>&gt;<i> the subject...
</I>
Yes, and I'm saying that I've tried the established techniques
and found them severely lacking.

&gt;<i> 
</I>&gt;<i> &gt; You're probably thinking that these would not go into the symbol
</I>&gt;<i> &gt; table, I would just have to write AST-searching code for that.
</I>&gt;<i> &gt; My point is that by the time I've got this huge library of
</I>&gt;<i> &gt; AST-searching code to do these things, the symbol table is
</I>&gt;<i> &gt; superfluous.
</I>&gt;<i> 
</I>&gt;<i> You build the symbol table (or at least collect the information it
</I>&gt;<i> contains and performs the semantic checks it enables in some other
</I>&gt;<i> way) as part of the process of building an AST. If you know all your
</I>&gt;<i> input programs will be always be correct, you can skip parts of the
</I>&gt;<i> process. Unless your post-parse analysis needs the information.....
</I>
I don't think you're addressing what I said: I'm saying that
if I make my symbol table so complicated that it contains the
information that I need (e.g. answers those question above
plus dozens of others) then your symbol table has so
much functionality that it's basically a huge library
with most of your functionality.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 2a. Keeping the TreeStack and SymbolTable in sync with the AST
</I>&gt;<i> &gt; &gt; ==============================================================
</I>&gt;<i> 
</I>&gt;<i> &gt; No, we're not just talking about renaming local variables,
</I>&gt;<i> &gt; we're talking about hundreds of different transformations,
</I>&gt;<i> &gt; of which renaming local variables is just one example.
</I>&gt;<i> 
</I>&gt;<i> Fine. Provide &quot;hooks&quot; into your processing flow and plug in your
</I>&gt;<i> &quot;transformation objects&quot;. The rename point above might be one place
</I>to
&gt;<i> provide a hook for rules that deal with local variables.
</I>
OK, and my app would best be served by having each node's
action be the same: check to see if this node in the AST
matches any of my &quot;transformation rules&quot;, and do the
corresponding transformation. And of course, at that point,
I'm not really using the power of the treewalker approach.

&gt;<i> 
</I>&gt;<i> &gt; My objection is the way the tree grammar approach slices the
</I>&gt;<i> &gt; problem. You have this line above:
</I>&gt;<i> &gt;               // process global variable decl
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Well, there may be dozens of &quot;rules&quot; or &quot;transformations&quot; that
</I>&gt;<i> &gt; apply to global variables. I don't want one section of
</I>&gt;<i> &gt; code where global variable declarations are handled, with
</I>&gt;<i> &gt; bits and pieces of each of these &quot;rules&quot; embedded there.
</I>&gt;<i> 
</I>&gt;<i> This sounds like a &quot;how do I architect a system that executes a sets
</I>&gt;<i> of rules against different parts of an AST?&quot; question to me rather
</I>&gt;<i> than a tree-library vs tree-grammar approach question.
</I>
Yes, that's the question exactly. And the answer is either
&quot;use a tree-library&quot; or &quot;use a tree-grammar&quot;.
&gt;<i> 
</I>&gt;<i> You can have a look at how tools like PMD and CheckStyle are
</I>architected.

OK, I'll check those out, thanks.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 2b. Do you want methods in AST or TreeStack?
</I>&gt;<i> &gt; &gt; ============================================
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; decl.Scope.getAllBindings() or similar should give you a list
</I>of all
&gt;<i> &gt; &gt; names in the scope. This isn't a tree-grammar approach benefit.
</I>&gt;<i> &gt; ANTLR
</I>&gt;<i> &gt; &gt; does nothing to help or hinder the requirement that the symbol
</I>table
&gt;<i> &gt; &gt; code has to be written.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Since the symbol table stores extended node attributes, there
</I>isn't
&gt;<i> &gt; a
</I>&gt;<i> &gt; &gt; question of which is more &quot;natural&quot;. 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Again, my issue is that by the time you've extended the symbol
</I>&gt;<i> &gt; table to include all the information I want, it's become
</I>&gt;<i> &gt; a monster (see example questions earlier).
</I>&gt;<i> 
</I>&gt;<i> There is no need to &quot;extend&quot; the symbol table. It has information in
</I>&gt;<i> it and you decide based on your requirements what analysis functions
</I>&gt;<i> you wish to expose (and can expose efficiently). If you need more,
</I>you
&gt;<i> employ additional formalisms and techniques in static code analysis.
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; The binding attribute on the node
</I>&gt;<i> &gt; &gt; is where the actions starts:
</I>&gt;<i> &gt; &gt;   IBinding decl  = #varid.Binding;
</I>&gt;<i> &gt; &gt;   IList bindings = decl.Scope.getAllBindings();
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Objection, your honor! The defense is mixing ANTLR grammar
</I>&gt;<i> &gt; with Java code again! Sorry :) Yo just cringe cada vez
</I>&gt;<i> &gt; Veo languages mezclado together. It's very hard to read
</I>&gt;<i> &gt; if you don't know both languages.
</I>&gt;<i> 
</I>&gt;<i> Do you similarly cringe when you use ANTLR to build lexers and
</I>&gt;<i> parsers?. Is there some reason why you feel tree-parsers are any
</I>&gt;<i> different?
</I>
No, because there's no mixing of code there, it's all ANTLR.
And besides, I can (pretty much) use ANTLR without understanding
the grammar syntax - just use the .g files that came with it.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 2c. Sometimes you need multiple passes
</I>&gt;<i> &gt; &gt; ======================================
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Given all the information that the symbol table construction
</I>phase
&gt;<i> &gt; &gt; accumulates, it would be pretty easy to provide a
</I>getAllGlobalVar()
&gt;<i> &gt; &gt; method on the symbol table object itself. Combined with the
</I>&gt;<i> &gt; &gt; getAllReferringNodes() method on the nodes, what you propose is
</I>&gt;<i> &gt; &gt; trivially accomplished. And without expensive (re-)calculation.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; But what about maintenance? You need to keep it up to date.
</I>&gt;<i> &gt; I may have 20 different &quot;transformation rules&quot; that can
</I>&gt;<i> &gt; change a global variable declaration. That means the symbol
</I>&gt;<i> &gt; table has to be notified and be able to handle each of these
</I>&gt;<i> &gt; changes, or it has to be smart enough to know when its become
</I>&gt;<i> &gt; out of date and regenerate itself.
</I>&gt;<i> 
</I>&gt;<i> So you need an updatable symbol table?. Build one. Provide delete()
</I>&gt;<i> and  perhaps rename() methods where it's needed and call then as
</I>&gt;<i> appropriate during your transformations. Don't see a problem here
</I>sorry.

By the time the symbol table contains all the functionality
I need, it's no longer a &quot;symbol table&quot; (at least not like
one I've ever heard of), it's a &quot;tree library&quot;.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 4. Comparing approaches by analyzing ease of change
</I>&gt;<i> &gt; &gt; ===================================================
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; In your third change - we want three blank lines after the
</I>&quot;package&quot;
&gt;<i> &gt; &gt; line instead of two - I can't understand why there is any
</I>confusion
&gt;<i> &gt; in
</I>&gt;<i> &gt; &gt; the tree-grammar approach. If you are adding lines *after* the
</I>&gt;<i> &gt; output
</I>&gt;<i> &gt; &gt; from the package rule and, the rootID rule calls the package
</I>rule
&gt;<i> &gt; then
</I>&gt;<i> &gt; &gt; the change would be in the rootID rule. In your description, it
</I>is
&gt;<i> &gt; &gt; clear that the rootID rule prints the current two lines in any
</I>case.
&gt;<i> &gt; 
</I>&gt;<i> &gt; With the tree grammar approach, isn't the whole idea that
</I>&gt;<i> &gt; each node just prints itself?
</I>&gt;<i> 
</I>&gt;<i> Where did you get this idea from. The tree-grammar approach lets you
</I>&gt;<i> build tree-walkers by specify a grammar for the tree that is to be
</I>&gt;<i> walked and action code to execute as the tree is walked. What your
</I>&gt;<i> action code does is up to you.
</I>
Right, but the whole point of the tree grammar is to minimize
the amount of code that you have to write. What's the point
of embedding 30,000 lines of code inside a 350 line grammar,
if you could have just written 30,020 lines that do the same
thing?

&gt;<i> 
</I>&gt;<i> &gt; So in that case, the treewalker approach isn't buying you
</I>anything.
&gt;<i> 
</I>&gt;<i> Time. You don't have to write the tree parsers by hand.
</I>
Only if a top-down walk of the tree is the basis of the
code that you need. If your code is something else (like
applying a series of pattern-matching rules), then
you have to write all the code even when using a tree grammar.

&gt;<i> 
</I>&gt;<i> &gt; &gt; In your fourth change - we want to change the order of
</I>&gt;<i> &gt; printing...and
</I>&gt;<i> &gt; &gt; print the static block before the variable declarations for
</I>example
&gt;<i> &gt; -
</I>&gt;<i> &gt; &gt; you can simply employ multiple output writers. Buffer all static
</I>&gt;<i> &gt; &gt; blocks in one writer, all variable declarations in another etc.
</I>At
&gt;<i> &gt; the
</I>&gt;<i> &gt; &gt; end print contents of the various writers in any order you
</I>wish. No
&gt;<i> &gt; &gt; need to modify the AST structure.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; And isn't that quite a bit more involved than:
</I>&gt;<i> &gt;     print(getChild(ast, PACKAGE_DEF));
</I>&gt;<i> &gt;     printChildren(ast, &quot;\n&quot;,  IMPORT);
</I>&gt;<i> &gt;     out.println();
</I>&gt;<i> &gt;     out.println();
</I>&gt;<i> &gt;     print(getChild(ast, CLASS_DEF));    // only one of these...
</I>&gt;<i> &gt;     print(getChild(ast, INTERFACE_DEF));  // will print anything
</I>&gt;<i> &gt;     out.println();
</I>&gt;<i> 
</I>&gt;<i> This seven lines of code don't matter much. It's the other 1000s of
</I>&gt;<i> tree-walking lines that the tree-library approach forces you to
</I>write
&gt;<i> that matters. In the tree-grammar approach, ANTLR generates all
</I>that.

No, it doesn't generate any of that.
The only thing the tree grammar approach is giving you is that
its walking the tree for you. You still have to write all the
code that does everything else.

&gt;<i> 
</I>&gt;<i> Incidentally, the tree-grammar snippet is lucid and equally concise
</I>(4
&gt;<i> additional lines compare to the as-is print of the AST):
</I>&gt;<i> 
</I>&gt;<i> typeDefinition [PrintWriter output]
</I>&gt;<i> { 
</I>&gt;<i>   StringWriter classW  = new StringWriter();      //LINE 1
</I>&gt;<i>   StringWriter ifaceW  = new StringWriter();      //LINE 2
</I>&gt;<i> }
</I>&gt;<i>   :  ( classDeclaration[classW]
</I>&gt;<i>      | interfaceDeclaration[ifaceW]
</I>&gt;<i>      )*
</I>&gt;<i>      {
</I>&gt;<i>        // swap to your hearts contents
</I>&gt;<i>        output.write(classW.toString();          //LINE 3
</I>&gt;<i>        output.write(ifaceW.toString();          //LINE 4
</I>&gt;<i>      }
</I>&gt;<i>   ;
</I>
I'm sorry, I just don't think that's as clear.
Most of that's because I know Java much more than I know
ANTLR. But most people know Java (or C, C++, or C#) much
more than ANTLR.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 5. Limitations of TreeWalkers
</I>&gt;<i> &gt; &gt; =============================
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I don't see a tree-grammar limitation here Andy. I may be wrong
</I>but,
&gt;<i> &gt; &gt; isn't the real problem that &quot;a[3]&quot; is an array access while
</I>&quot;int[]
&gt;<i> &gt; x&quot;
</I>&gt;<i> &gt; &gt; is an array declaration?. If I am right they would have
</I>difference
&gt;<i> &gt; AST
</I>&gt;<i> &gt; &gt; representations in any case.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; No, the problem is that a C array declaration can take either
</I>form:
&gt;<i> &gt; int a[3];
</I>&gt;<i> &gt; int[3] a;
</I>&gt;<i> 
</I>&gt;<i> And they mean the same thing right?. Isn't the point of an AST to
</I>&gt;<i> remove concrete syntax irregularities like this?. Can't see why you
</I>&gt;<i> need to remember which of the variants the source had originaly
</I>since
&gt;<i> Java code generation isn't affected by it.
</I>
That's the point of ASTs in theory, but not in practice.
This cgram grammar does generate different ASTs
for these two inputs, for example.

&gt;<i> 
</I>&gt;<i> &gt; &gt; In any case, I can't provide a tree-grammar equivalent of your
</I>&gt;<i> &gt; sample
</I>&gt;<i> &gt; &gt; without knowing what the child of the ARRAY_DECLARATOR is when
</I>it
&gt;<i> &gt; &gt; isn't an EXPR. In other words without knowing a bit more about
</I>your
&gt;<i> &gt; &gt; tree's grammar.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The child of an ARRAY_DECLARATION is always an EXPR.
</I>&gt;<i> 
</I>&gt;<i> But &quot;int[] x&quot; has no expression....
</I>
Yes it does, it's just the empty expression - an EXPR with
no children.

&gt;<i> 
</I>&gt;<i> &gt; ...which highlights one of my major points: you need to understand
</I>&gt;<i> &gt; the AST structure whether you use a treewalker or not. I don't
</I>&gt;<i> &gt; even remember what the issue is here, but whatever it is, you're
</I>&gt;<i> &gt; about to go off and find an ARRAY_DECLARATION rule in an ANTLR
</I>&gt;<i> &gt; tree grammar and figure out how to stuff in some Java code.
</I>&gt;<i> &gt; I'd prefer to just be at an &quot;case ARRAY_DECLARATION:&quot; point
</I>&gt;<i> &gt; in some Java code, and just say:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; AST expr = ast.getFirstChild();
</I>&gt;<i> &gt; doSomethingWithExpr(expr);
</I>&gt;<i> 
</I>&gt;<i> My generated tree-grammar does the same ultimately. I just don't
</I>have
&gt;<i> to write all the code manually.
</I>
Which code is it that you don't have to write because of the
tree grammar? Isn't it only some simple code that walks the
tree? I mean, isn't it little more than this:
void walk(AST ast) {
   doSomeAction(ast);
   Iterator i = ast.getChildren().iterator();
   while (i.hasNext()) {
     AST child = (AST) i.next();
     walk(child);
   }
}



&gt;<i> 
</I>&gt;<i> &gt; &gt; 6. Contrasting the approaches
</I>&gt;<i> &gt; &gt; =============================
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 1. Code generation isn't magic. We all use it quite happily for
</I>&gt;<i> &gt; lexers
</I>&gt;<i> &gt; &gt; and parsers for instance. The same benefits exist for tree
</I>parsers.
&gt;<i> &gt; 
</I>&gt;<i> &gt; We use ANTLR-like tools for lexers and parsers because the
</I>&gt;<i> &gt; code they generate is straightforward and generic. Given a
</I>grammar,
&gt;<i> &gt; you know exactly what the lexer and parser code should look like.
</I>&gt;<i> 
</I>&gt;<i> So you are unfamiliar with tree parsers. Sounds like you could
</I>benefit
&gt;<i> from learning more about them.
</I>
I think I do understand tree parsers. I understand what code
they will generate. But the code they generate is not
the best basis to build a translation app on top of.

A lexer is just a lexer: the ANTLR-generated lexer does its
job, and your app can just deal with it's output (a token stream).
A Parser does it's job so that you can deal with its output
(an AST). A treewalker is not providing a clear &quot;output&quot;
like a lexer or parser, it's just providing a framework to
automatically walk a tree, for you to embed your actions within.
My main point is that any sufficiently complex
translator will not have a top-down tree walk as it's
underlying framework.

&gt;<i> 
</I>&gt;<i> &gt; However, with AST-to-AST transformation, it's not at all clear
</I>&gt;<i> &gt; what the functionality needs to be. For example, given a &quot;C source
</I>&gt;<i> &gt; AST&quot; to &quot;Java source AST&quot;, we would all come up with different
</I>&gt;<i> &gt; algorithms to do that transformation.
</I>&gt;<i> 
</I>&gt;<i> As we could about the structure of the AST we build in the parser.
</I>Or
&gt;<i> if to build an AST at all. Or the names we give to our tokens in the
</I>&gt;<i> lexer and how many there are. Or whether to use two lexers and a
</I>&gt;<i> parser or just one of each etc....
</I>
Not really. Given the problem of lexing a single C source
file, we'd all choose the same solution: one lexer (generated from
some nice list of tokens). Given the problem of parsing a
single token-stream into an AST, we'd all chose the same solution:
a parser (generated from some BNF-like input grammar).

But given a single AST that represents a C program, some
would choose a treewalker to change it to a &quot;Java AST&quot;, and
others would not.

&gt;<i> 
</I>&gt;<i> &gt; We would all end up with
</I>&gt;<i> &gt; a set of &quot;rules&quot; like &quot;Find all FUNCTION_DEF nodes with an IDENT
</I>&gt;<i> &gt; child with text 'main' and a PARAMS_DEF child that has two
</I>children,
&gt;<i> &gt; the first of which has a TYPE node with type 'int' ...
</I>&gt;<i> &gt; Does a symbol table help us with finding such a node?
</I>&gt;<i> 
</I>&gt;<i> Nodes are part of the AST. Symbol table stores node *attributes*.
</I>
So then your answer is &quot;no, a symbol table does not contain
that information&quot;. OK. And what if most of my app deals with
that type of information that's not available in a symbol
table?

&gt;<i> 
</I>&gt;<i> &gt; No. Which is easier: to extend the symbol table to include
</I>&gt;<i> &gt; that information, or write a tree-search library to find it?
</I>&gt;<i> 
</I>&gt;<i> Neither. Let ANTLR write the tree-search library for you is what
</I>I'll
&gt;<i> recommend.
</I>
Whoa...I have no idea how that would work, but sounds interesting.

&gt;<i> 
</I>&gt;<i> &gt; I think the library approach is easier, especially if we can use
</I>&gt;<i> &gt; a preexisting nice, standard tree-search-library out there.
</I>&gt;<i> 
</I>&gt;<i> As Loring pointed out, trees for different apps are likely to be
</I>very
&gt;<i> different indeed. The ANTLR or TreeDL approach of code generation
</I>are
&gt;<i> likely - are proven actually - to be very much more successful (and
</I>&gt;<i> easier to use/reuse) than your generic library approach.
</I>
Can you give me some examples of uses of ANTLR treewalkers 
to do complex translations? Someone else mentioned ASPA,
which I'm investigating now.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 2. It can be argued that the tree-grammar approach actually
</I>&gt;<i> &gt; encourages
</I>&gt;<i> &gt; &gt; your &quot;keep related code together&quot; maxim. All the code (excluding
</I>&gt;<i> &gt; &gt; library code) that applies to a phase of your transformation is
</I>kept
&gt;<i> &gt; &gt; together in one file - the grammar file.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; No, you're going to need multiple passes on the tree.
</I>&gt;<i> 
</I>&gt;<i> I wrote (note the added empahasis): 
</I>&gt;<i> 
</I>&gt;<i> &quot;All the code (excluding library code) that applies to a **phase**
</I>of
&gt;<i> your transformation is kept together in one file - the grammar
</I>file.&quot;

OK, well I'm saying that a typical &quot;translation rule&quot; is going
to contain multiple phases. And it's going to be very hard
to keep the code for each rule separate from the others when
you have multiple phases.

&gt;<i> 
</I>&gt;<i> &gt; For the &quot;main method&quot; example, I want all my code that handles
</I>&gt;<i> &gt; &quot;main method C to Java&quot; in one class. I don't want it
</I>&gt;<i> &gt; spread across one grammar that stores method and parameter info
</I>&gt;<i> &gt; in a symbol table, a second grammar that makes the change, and
</I>&gt;<i> &gt; a third grammar that makes changes to any &quot;main&quot; function calls.
</I>&gt;<i> 
</I>&gt;<i> Sure, and you can build a framework that allows you to do that on
</I>top
&gt;<i> of whatever approach you choose - TreeDL+visitors,
</I>ANTLR+tree-parsers
&gt;<i> or even ad-hoc as you are doing.
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; 3. Complex tools require training investment before you can use
</I>then
&gt;<i> &gt; &gt; effectively. Having invested in training to be able to ANTLR
</I>&gt;<i> &gt; notation
</I>&gt;<i> &gt; &gt; for specifying lexers and parsers, tree parsers are the next
</I>logical
&gt;<i> &gt; step.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; But I'm able to use the ANTLR lexer and parser without any real
</I>&gt;<i> &gt; training. I should be able to *use* ANTLR without really knowing
</I>&gt;<i> &gt; much about ANTLR grammars.
</I>&gt;<i> 
</I>&gt;<i> Did you require the same of Java?. To be able to use it without
</I>&gt;<i> knowing much about the language or it's libraries.
</I>
Yes! I use many programs that are written in Java, C, and many
other languages without ever seeing their source code.
I use the Java libraries without understanding their internals.

Are you saying it's not reasonable for me to want to be
able to deal with ASTs without having to use ANTLR syntax?
Shouldn't I be able to just swap out ANTLR and plug in
lex/yacc or some other AST-generating tool (not that I
would, of course :)?

&gt;<i> 
</I>&gt;<i> &gt; I just want ANTLR to lex and parse
</I>&gt;<i> &gt; C source and pass me the AST, and I'll take it from there.
</I>&gt;<i> 
</I>&gt;<i> Why use an AST at all?. Or indeed a generated lexer or parser?.
</I>With a
&gt;<i> file and string processing library, I can do all the stuff that the
</I>&gt;<i> lexer/parser/AST enables with ever seeing a tree node. It would be
</I>&gt;<i> messy but it would be all Java and I probably won't even have to
</I>learn
&gt;<i> Java. ;-)
</I>
Heh, I know you're joking, but that's almost exactly what I
actually spent the last two years doing!
I built the lexer with ANTLR, and I use an ANTLR-generated parser
for expression processing, but the rest is pure Java.
The approach does have drawbacks, but I'm convinced that it
was the right decision.

I've got more source-to-source translation functionality
than I've seen than any other tool, by an order of magnitude.
(Feel free to show me one that has more, of course :)

&gt;<i> 
</I>&gt;<i> &gt; &gt; 4. The comments about debugging apply equally to generated tree
</I>&gt;<i> &gt; &gt; parsers and hand-written tree walkers (they are often very
</I>similar).
&gt;<i> &gt; &gt; The tree structure is the same in any case so print the AST as
</I>you
&gt;<i> &gt; please.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I'm not proposing &quot;hand-written tree walkers&quot; so much as
</I>&gt;<i> &gt; a &quot;tree searching and manipulation library&quot;. My whole
</I>&gt;<i> &gt; point is that AST-to-AST translation is better done as a
</I>&gt;<i> &gt; rule-based pattern-matching scheme than a top-down AST-walking
</I>&gt;<i> &gt; scheme. Take a look at:
</I>&gt;<i> &gt; <A HREF="http://jazillian.com/how.html">http://jazillian.com/how.html</A>
</I>&gt;<i> &gt; And think about how you'd do all those things with a treewalker.
</I>&gt;<i> &gt; i'm certain it would be horrendous.
</I>&gt;<i> 
</I>&gt;<i> It's a lot of work but the code structure would be simple and easy
</I>to
&gt;<i> maintain.
</I>
Again, any examples of ANTLR treewalkers that 
have that much functionality?
&gt;<i> 
</I>&gt;<i> &gt; &gt; 5. ANTLR support for hetero-ASTs could be improved but nothing
</I>you
&gt;<i> &gt; &gt; have mentioned so far is beyond the support ANTLR 2.7.4's
</I>hetero-AST
&gt;<i> &gt; &gt; support. Can you give an example where this is important?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I'm not sure what you mean. The ANTLR treewalker approach
</I>basically
&gt;<i> &gt; says &quot;embed your actions at each node of the grammar&quot;. That's
</I>&gt;<i> &gt; fine for certain apps, especially compilers, interpreters,
</I>&gt;<i> &gt; and code-annotators. But I don't see how it would work for
</I>&gt;<i> &gt; a complex source-to-source translator, in which the rules
</I>&gt;<i> &gt; for transformation are complex.
</I>&gt;<i> 
</I>&gt;<i> That's how these apps are generally written nonetheless.
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; 7. Summary
</I>&gt;<i> &gt; &gt; ==========
</I>&gt;<i> 
</I>&gt;<i> &gt; The problem is that I don't
</I>&gt;<i> &gt; think the tree-grammar approach gets too complicated until
</I>&gt;<i> &gt; you've got a pretty large system. I think the first 10% of
</I>&gt;<i> &gt; my C-to-Java translator would be fine using a treewalker.
</I>&gt;<i> &gt; But soon the symbol table would seem to be completely
</I>&gt;<i> &gt; inadequate and I'd end up with all sorts of AST-searching
</I>&gt;<i> &gt; code anyway.
</I>&gt;<i> 
</I>&gt;<i> I feel I should repeat that you probably would benefit from
</I>reviewing
&gt;<i> the literature on static code analysis techniques and
</I>implementations.
&gt;<i> That's what you are doing in an ad-hoc fashion. It will hurt
</I>&gt;<i> eventually as you attempt more complex analysis. 
</I>
Sorry, I'm already &quot;done&quot; :)
I did read a lot about static code analysis techniques, and
most of it never seemed to get beyond the basics of building
symbol tables and trivial transformations like changing
a variable names or simple refactoring.

&gt;<i> IOW, some of the
</I>&gt;<i> issues you raise are really about tree-library vs tree-grammar IMHO.
</I>
That's what I'm trying for...that's what the thread's about.

Thanks,
Andy

&gt;<i> 
</I>&gt;<i> Cheers,
</I>&gt;<i> 
</I>&gt;<i> Micheal
</I>&gt;<i> ANTLR/C#
</I>




 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
    <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
    <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
    <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010310.html">[antlr-interest] OOPS! Re: Translators Should Use Tree Grammars
</A></li>
	<LI>Next message: <A HREF="010326.html">[antlr-interest] Re: Translators Should Use Tree Grammars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10323">[ date ]</a>
              <a href="thread.html#10323">[ thread ]</a>
              <a href="subject.html#10323">[ subject ]</a>
              <a href="author.html#10323">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
