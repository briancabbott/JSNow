<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Help with nondeterminism in cobol grammar
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Help%20with%20nondeterminism%20in%20cobol%20grammar&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016198.html">
   <LINK REL="Next"  HREF="016215.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Help with nondeterminism in cobol grammar</H1>
    <B>Jose Ventura</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Help%20with%20nondeterminism%20in%20cobol%20grammar&In-Reply-To="
       TITLE="[antlr-interest] Help with nondeterminism in cobol grammar">jose.ventura.roda at gmail.com
       </A><BR>
    <I>Wed May 10 04:37:00 PDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="016198.html">[antlr-interest] how to concatenate string nodes into one
	node when	create AST?
</A></li>
        <LI>Next message: <A HREF="016215.html">[antlr-interest] translating C++ to Java
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16213">[ date ]</a>
              <a href="thread.html#16213">[ thread ]</a>
              <a href="subject.html#16213">[ subject ]</a>
              <a href="author.html#16213">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Skipped content of type multipart/alternative-------------- next part --------------
/*header 
{
	package cobol;
}
	*/
class CobolLex extends Lexer;
options 
{ 
	k=1;
	charVocabulary = '\3'..'\377'; // Unicodes usuales
	caseSensitive=false;
	caseSensitiveLiterals=false;
	testLiterals=false;
	exportVocab=CobolLexVocab;

} 
tokens										// MUST be kept in sync with &quot;keywordsTable&quot; Hashtable below!!
{
	FIN_TODO;
	NUM;
    IDENT;
	LIT_HEXADECIMAL;
	LIT_PIC;
	LIT_COPY;
	FECHA;
	IGUAL;
	MAYOR_IGUAL;
	MENOR_IGUAL;
	NOT_REL;
    
    IDENTIFICATION=&quot;IDENTIFICATION&quot;;
	ID=&quot;ID&quot;;
	ENVIRONMENT=&quot;ENVIRONMENT&quot;;
	DATA=&quot;DATA&quot;;
	WORKING=&quot;WORKING-STORAGE&quot;;
	LINKAGE=&quot;LINKAGE&quot;;
	DIVISION=&quot;DIVISION&quot;;
	PROGRAM_ID=&quot;PROGRAM-ID&quot;;
	PROCEDURE=&quot;PROCEDURE&quot;;
	SECTION=&quot;SECTION&quot;;

	ACCEPT=&quot;ACCEPT&quot;;
	ADD=&quot;ADD&quot;;
	ALL=&quot;ALL&quot;;
	ALSO=&quot;ALSO&quot;;
	ALTER=&quot;ALTER&quot;;
	AND=&quot;AND&quot;;
	AT=&quot;AT&quot;;
	BLANK=&quot;BLANK&quot;;
	BY=&quot;BY&quot;;
	CALL=&quot;CALL&quot;;
	CANCEL=&quot;CANCEL&quot;;
	CICS=&quot;CICS&quot;;
	CLOSE=&quot;CLOSE&quot;;
	COMPUTE=&quot;COMPUTE&quot;;
	COMMAREA=&quot;COMMAREA&quot;;
	COMMIT=&quot;COMMIT&quot;;
	CONTINUE=&quot;CONTINUE&quot;;
	CORR=&quot;CORR&quot;;
	CORRESPONDING=&quot;CORRESPONDING&quot;;
	DELETE=&quot;DELETE&quot;;
	DELIMITED=&quot;DELIMITED&quot;;
	DISPLAY=&quot;DISPLAY&quot;;
	DIVIDE=&quot;DIVIDE&quot;;
	ELSE=&quot;ELSE&quot;;
	END=&quot;END&quot;;
	END_ADD=&quot;END-ADD&quot;;
	END_CALL=&quot;END-CALL&quot;;
	END_COMPUTE=&quot;END-COMPUTE&quot;;
	END_DIVIDE=&quot;END-DIVIDE&quot;;
	END_EVALUATE=&quot;END-EVALUATE&quot;;
	END_EXEC=&quot;END-EXEC&quot;;
	END_IF=&quot;END-IF&quot;;
	END_MULTIPLY=&quot;END-MULTIPLY&quot;;
	END_PERFORM=&quot;END-PERFORM&quot;;
	END_SEARCH=&quot;END-SEARCH&quot;;
	END_STRING=&quot;END-STRING&quot;;
	END_UNSTRING=&quot;END-UNSTRING&quot;;
	END_SUBTRACT=&quot;END-SUBTRACT&quot;;
	END_READ=&quot;END-READ&quot;;
	END_WRITE=&quot;END-WRITE&quot;;
	ENTRY=&quot;ENTRY&quot;;
	EVALUATE=&quot;EVALUATE&quot;;
	EXEC=&quot;EXEC&quot;;
	EXIT=&quot;EXIT&quot;;
	METHOD=&quot;METHOD&quot;;
	PROGRAM=&quot;PROGRAM&quot;;
	GIVING=&quot;GIVING&quot;;
	GOBACK=&quot;GOBACK&quot;;
	GO_TO=&quot;GO TO&quot;;
	IF=&quot;IF&quot;;
	IN=&quot;IN&quot;;
	INITIALIZE=&quot;INITIALIZE&quot;;
	INSPECT=&quot;INSPECT&quot;;
	INTO=&quot;INTO&quot;;
	INVOKE=&quot;INVOKE&quot;;
	LINK=&quot;LINK&quot;;
	MERGE=&quot;MERGE&quot;;
	MOVE=&quot;MOVE&quot;;
	MULTIPLY=&quot;MULTIPLY&quot;;
	OF=&quot;OF&quot;;
	OPEN=&quot;OPEN&quot;;
	OR=&quot;OR&quot;;
	OTHER=&quot;OTHER&quot;;
	PERFORM=&quot;PERFORM&quot;;
	POINTER=&quot;POINTER&quot;;
	READ=&quot;READ&quot;;
	RECEIVE=&quot;RECEIVE&quot;;
	REDEFINES=&quot;REDEFINES&quot;;
	RELEASE=&quot;RELEASE&quot;;
	REPLACING=&quot;REPLACING&quot;;
	TALLYING=&quot;TALLYING&quot;;
	RETURN=&quot;RETURN&quot;;
	REWRITE=&quot;REWRITE&quot;;
	ROLLBACK=&quot;ROLLBACK&quot;;
	SEARCH=&quot;SEARCH&quot;;
	SEND=&quot;SEND&quot;;
	SET=&quot;SET&quot;;
	SQL=&quot;SQL&quot;;
	SORT=&quot;SORT&quot;;
	SPACE=&quot;SPACE&quot;;
	SPACES=&quot;SPACES&quot;;
	START=&quot;START&quot;;
	STOP=&quot;STOP&quot;;
	STRING=&quot;STRING&quot;;
	SUBTRACT=&quot;SUBTRACT&quot;;
	SYNCPOINT=&quot;SYNCPOINT&quot;;
	TO=&quot;TO&quot;;
	THEN=&quot;THEN&quot;;
	UNSTRING=&quot;UNSTRING&quot;;
	WRITE=&quot;WRITE&quot;;
	ZERO=&quot;ZERO&quot;;
	ZEROS=&quot;ZEROS&quot;;
	ZEROES=&quot;ZEROES&quot;;
	THROUGH=&quot;THROUGH&quot;;
	THRU=&quot;THRU&quot;;
	VARYING=&quot;VARYING&quot;;
	UNTIL=&quot;UNTIL&quot;;
	USING=&quot;USING&quot;;
	WHEN=&quot;WHEN&quot;;
	WITH=&quot;WITH&quot;;
	TEST=&quot;TEST&quot;;
	BEFORE=&quot;BEFORE&quot;;
	AFTER=&quot;AFTER&quot;;
	JUSTIFIED=&quot;JUSTIFIED&quot;;
	JUST=&quot;JUST&quot;;
	OCCURS=&quot;OCCURS&quot;;
	ASCENDING=&quot;ASCENDING&quot;;
	DESCENDING=&quot;DESCENDING&quot;;
	KEY=&quot;KEY&quot;;
	INDEXED=&quot;INDEXED&quot;;
	PIC=&quot;PIC&quot;;
	PICTURE=&quot;PICTURE&quot;;
	USAGE=&quot;USAGE&quot;;
	VALUE=&quot;VALUE&quot;;
	VALUES=&quot;VALUES&quot;;
	ARE=&quot;ARE&quot;;
	RENAMES=&quot;RENAMES&quot;;
	COPY=&quot;COPY&quot;;
	// los tipos de campos BINARY..DISPLAY1 deben estar contiguos
	// ver rutina Programa.calcularLong()
	BINARY=&quot;BINARY&quot;;
	COMP=&quot;COMP&quot;;
	COMP1=&quot;COMP-1&quot;;
	COMP2=&quot;COMP-2&quot;;
	COMP3=&quot;COMP-3&quot;;
	COMP4=&quot;COMP-4&quot;;
	COMPUTATIONAL=&quot;COMPUTATIONAL&quot;;
	COMPUTATIONAL1=&quot;COMPUTATIONAL-1&quot;;
	COMPUTATIONAL2=&quot;COMPUTATIONAL-2&quot;;
	COMPUTATIONAL3=&quot;COMPUTATIONAL-3&quot;;
	COMPUTATIONAL4=&quot;COMPUTATIONAL-4&quot;;
	PACKED_DECIMAL=&quot;PACKED-DECIMAL&quot;;
	DISPLAY1=&quot;DISPLAY-1&quot;;
	//Fin de tipos.
	INDEX=&quot;INDEX&quot;;
	CHARACTERS=&quot;CHARACTERS&quot;;
	LEADING=&quot;LEADING&quot;;
	FIRST=&quot;FIRST&quot;;
	INITIAL=&quot;INITIAL&quot;;
	CONVERTING=&quot;CONVERTING&quot;;
	FOR=&quot;FOR&quot;;
	UP=&quot;UP&quot;;
	DOWN=&quot;DOWN&quot;;
	NOT=&quot;NOT&quot;;
	NULL=&quot;NULL&quot;;
	ON=&quot;ON&quot;;
	SIZE=&quot;SIZE&quot;;
	ERROR=&quot;ERROR&quot;;
	THAN=&quot;THAN&quot;;
	GREATER=&quot;GREATER&quot;;
	LESS=&quot;LESS&quot;;
	EQUAL=&quot;EQUAL&quot;;
	NUMERIC=&quot;NUMERIC&quot;;
	ALPHABETIC=&quot;ALPHABETIC&quot;;
	ALPHANUMERIC=&quot;ALPHANUMERIC&quot;;
	POSITIVE=&quot;POSITIVE&quot;;
	NEGATIVE=&quot;NEGATIVE&quot;;
	FROM=&quot;FROM&quot;;
	COUNT=&quot;COUNT&quot;;
	DELIMITIER=&quot;DELIMITER&quot;;
	INCLUDE=&quot;INCLUDE&quot;;
	NEXT=&quot;NEXT&quot;;
	SENTENCE=&quot;SENTENCE&quot;;
	ROUNDED=&quot;ROUNDED&quot;;
	WRITEQ=&quot;WRITEQ&quot;;
	READQ=&quot;READQ&quot;;
	TS=&quot;TS&quot;;
	TD=&quot;TD&quot;;
	QUEUE=&quot;QUEUE&quot;;
	NUMITEMS=&quot;NUMITEMS&quot;;
	ITEM=&quot;ITEM&quot;;
	MAIN=&quot;MAIN&quot;;
	LENGTH=&quot;LENGTH&quot;;
	RESP=&quot;RESP&quot;;
	NOHANDLE=&quot;NOHANDLE&quot;;
	ERASE=&quot;ERASE&quot;;
	DEPENDING=&quot;DEPENDING&quot;;
	TIMES=&quot;TIMES&quot;;
	DLI=&quot;DLI&quot;;
	FILE=&quot;FILE&quot;;
	FD=&quot;FD&quot;;
	SD=&quot;SD&quot;;
	EXTERNAL=&quot;EXTERNAL&quot;;
	GLOBAL=&quot;GLOBAL&quot;;
	BLOCK=&quot;BLOCK&quot;;
	CONTAINS=&quot;CONTAINS&quot;;
	RECORDS=&quot;RECORDS&quot;;
	RECORD=&quot;RECORD&quot;;
	LABEL=&quot;LABEL&quot;;
	STANDARD=&quot;STANDARD&quot;;
	OMITTED=&quot;OMITTED&quot;;
	RECORDING=&quot;RECORDING&quot;;
	MODE=&quot;MODE&quot;;
	INPUT=&quot;INPUT&quot;;
	OUTPUT=&quot;OUTPUT&quot;;
	UPON=&quot;UPON&quot;;
	NO=&quot;NO&quot;;
	ADVANCING=&quot;ADVANCING&quot;;
	DUPLICATES=&quot;DUPLICATES&quot;;
	ORDER=&quot;ORDER&quot;;
	SEQUENCE=&quot;SEQUENCE&quot;;
	COLLATING=&quot;COLLATING&quot;;
	
	

}

{ // Comienza la zona de c&#243;digo nativo

boolean ultPic=false;
boolean enExec=false;
protected Token makeToken(int type)
{
	// Usamos la implementaci&#243;n de la superclase...
	Token result = null;
	int tipo=type;

	
// while I don't have a parser for CICS and SQL DLI

	if (enExec)
	{
		if (type==END_EXEC||
			type==RETURN ||
			type==RECEIVE ||
			type==SEND   ||
			type==SYNCPOINT ||
			type==LINK ||
			type==WRITEQ ||
			type==READQ ||
			type==INCLUDE
			)
		{
			enExec=false;
		}
		else
		{
			tipo=IDENT;
		}
	}
	else
	{
		if (type==NOT)
			tipo=tipoNot();
		else
			enExec=(type==SQL||type==CICS||type==DLI);
	}

	result = super.makeToken(tipo);
	ultPic =(type==PIC||type==PICTURE);
	// ... a&#241;adimos informaci&#243;n del nombre de fichero
	result.setFilename(super.getFilename());
	// ... y devolvemos el token
	return (result);
	
}

protected int tipoNot ()
{
	int tipo = NOT;
	int marca = mark();
	int saveLong = text.length();
	
	try
	{
		while ( LA(1)==' ')
		{
			try
			{
				match(' ');
			}
			catch (MismatchedCharException m)
			{
				System.out.println (&quot;Error in space following NOT. &quot;+m.getMessage());
			}
		}
		switch (LA(1))
		{
			case '=':
			    match (&quot;=&quot;);
				tipo = NOT_REL;
				break;
			case '&gt;':
			    match (&quot;&gt;&quot;);
				tipo = NOT_REL;
				break;
			case '&lt;':
			    match (&quot;&lt;&quot;);
				tipo = NOT_REL;
				break;
			case 'g':
				tipo = NOT_REL;
				match(&quot;greater &quot;);
				break;
			case 'l':
				tipo = NOT_REL;
				match(&quot;less &quot;);
				break;
			case 'e':
				tipo = NOT_REL;
				match(&quot;equal &quot;);
				break;
		}
	}
	catch (CharStreamException c)
	{
		System.out.println (&quot;Problem with input buffer when it analize the NOT.&quot;);
	}
	catch (MismatchedCharException m)
	{
		tipo = NOT;

	}
	rewind (marca);
	text.setLength(saveLong);
	return (tipo);
}

}
COMENTARIO:
	'@' ( ~('\n'|'\r') )* 
	{$setType(Token.SKIP);}
	;

PAR_AB
	: {!ultPic }? '('
	;
PAR_CE
	: {!ultPic }? ')'
	;
CAD_COPY
	: (&quot;==&quot;) =&gt; &quot;==&quot; ( ~('=') )*	&quot;==&quot;
	{ $setType(LIT_COPY); }
	| '='
	{ $setType(IGUAL); }
	;
DOSPUNTOS
	: ':'
	;

MAS
	: {!ultPic }? 
	  '+' {$setType(MAS);}
	  (
	  		(DIGITO)+ (',' (DIGITO)+)? 
			{$setType(NUM);}
	   )?
	;
	
MENOS
	: {!ultPic }?
	  '-' {$setType(MENOS);}
	  (
	  		(DIGITO)+ ({LA(2)==DIGITO}?',' (DIGITO)+)? 
			{$setType(NUM);}
	   )?
	;
	
PUNTO
	: {!ultPic }?
	  '.' {$setType(FIN_TODO);}
	  (
	  	(DIGITO)+ {_ttype=NUM;}
	   )?
	 ;
COMA
	: {!ultPic }?
	  ',' {_ttype=COMA;} 
	  (
	  	(DIGITO)+ {_ttype=NUM;}
	   )?
	 ;
	 
POR
	: {!ultPic }? '*'
	;

DIV
	: '/'
	;

MAYOR
	: '&gt;'
		('=' {_ttype=MAYOR_IGUAL;})?
	;
MENOR: '&lt;'
		('=' {_ttype=MENOR_IGUAL;})?
	;

protected
LETRA
	: 'a'..'z'
	;

protected
DIGITO
	: '0'..'9'
	;


protected 
NL :
		(
		 (&quot;\r\n&quot;) =&gt; &quot;\r\n&quot; // MS-DOS
		 | '\r' // MACINTOSH
		 | '\n' // UNIX
		 )
		 {newline(); }
		 ;

BLANCO :
		( ' '
		| '\t'
		| NL
		) 
		{ $setType(Token.SKIP); } // La acci&#243;n del blanco: ignorar
		;

IDENT_NUM  options {testLiterals=true;}
	:{ ultPic }? ('+'|'-'|'$'|'b'|','|'e'|('0'..'9')|'x'|'s'|'v'|'z'|'*'|'('|')'|
	               {LA(2)!=' '&amp;&amp;LA(2)!='\n'&amp;&amp;LA(2)!='\r'}? '.')+  
	 {$setType (LIT_PIC);}
	|('x' '\'') =&gt; 'x' '\''( ~('\''|'\n'|'\r'|'\t') )*	'\'' 
	 {$setType (LIT_HEXADECIMAL);}
	| LETRA (LETRA|DIGITO|'-'|'_')*
	 {String s = $getText;
	  if (s.equals(&quot;IS&quot;))
	  	$setType(Token.SKIP);
	  else
	  	$setType(IDENT);
	 }
	|((DIGITO)+ (LETRA|'-'|'_')) =&gt;(DIGITO)+ (LETRA|'-'|'_') (LETRA|DIGITO|'-'|'_')*
	 {$setType (IDENT);}
	|((DIGITO)+ '/' )=&gt; (DIGITO)+ '/' (DIGITO|'/')+
	 {$setType (FECHA);}
	| (DIGITO)+  ({LA(2)!=' '&amp;&amp;LA(2)!='\n'&amp;&amp;LA(2)!='\r'}? ',' (DIGITO)+)?
	 {$setType (NUM);}
	| '_' (LETRA|DIGITO|'_')*
	 {$setType (IDENT);}
	;

CADENA :
	'\''! 
	( ~('\''|'\n'|'\r'|'\t') )*
	'\''!
	| '&quot;'! ( ~('&quot;'|'\n'|'\r'|'\t') )* '&quot;'!
	;










-------------- next part --------------
header 
{
	import java.util.*;
	import antlr.CommonToken;
}
class CobolCommand extends Parser; 
options {
	buildAST = true;
	importVocab = CobolLexVocab;
	exportVocab = CobolCommandVocab;
}
tokens {
/* tokens */
    PROGRAMA;
	SENTENCIAS;
	PARRAFO;
	PERFORM_PARRAFO;
	PERFORM_INLINE;
	CICS_GENERICO;
	SQL_GENERICO;
	CONDICION;
	LIST_EXPRESIONES;
	DECLARACION;
	CAMPO;
	MOD_TEXTO;
	INDICE;
	OPERADOR;
	EXPRESION;
	LENGTHOF;
}

sentencia_interna [String tipo]
	: sentencia  
	;
sentencia 
	:
	(options {greedy=true;}:c:comando) *  
	;
	
comando 
	: comando_if 
   	|comando_perform 
	|comando_call   
	|comando_move
	|comando_unstring
	|comando_inspect 
	|comando_add
	|comando_evaluate
	|comando_initialize
	|comando_string
	|comando_set
	|comando_search
	|comando_subtract
	|comando_multiply
	|comando_compute
	|comando_divide
	|comando_open
	|comando_close
	|comando_read
	|comando_write
	|comando_display
	|comando_sort
	|(EXIT PROGRAM) =&gt; EXIT PROGRAM!
	|EXIT!
	|CONTINUE!
	|NEXT! SENTENCE!
	|GOBACK
	;		 
		 
				  
comando_if
	: IF^ condicion parte_then (options {greedy=true;}: ELSE! parte_else)? (options {greedy=true;}: END_IF!)? 				
	;
condicion //returns [String s]
	: c:condicionOR
	{## = #( #[CONDICION, &quot;CONDICION&quot;] ,##);}
	;

listaAritmetica
	: expresionSuma 
	(COMA! expresionSuma)*
	{## = #( #[LIST_EXPRESIONES, &quot;LIST_EXPRESIONES&quot;] ,##);}
	;

condicionOR 
	: condicionAND (OR^ condicionAND)*
	;

condicionAND 
	: expresionRelacional (AND^ expresionRelacional)*
	;

expresionRelacional 
	: (expresionSuma)? (operador_relacional expresionSuma)*
	{## = #( #[EXPRESION, &quot;EXPRESION&quot;] ,##);}
	;
	
expresionSuma
	: expresionPor ( (MAS^|MENOS^) expresionPor)*
	;

expresionPor 
	: expresionUnitaria ( (POR^|DIV^) expresionUnitaria)*
	;
	
expresionUnitaria 
	: MENOS^ expresionUnitaria 
	| MAS^ expresionUnitaria 
	| expresionUnitariaNoMasMenos
	;
expresionUnitariaNoMasMenos 
	: NOT^ expresionUnitaria 
	| expresionPrimaria ((NOT)? (POSITIVE|NEGATIVE|NUMERIC|ALPHABETIC))? 
	;
	
expresionPrimaria
	: campo 
	| literal 
	| PAR_AB! condicion PAR_CE! 
	;

operador_relacional  
	: (NOT_REL )? 
	(GREATER (THAN)? (OR EQUAL (TO)?)?
	|MAYOR_IGUAL
	|MAYOR 
	|LESS (THAN)? (OR EQUAL (TO)?)?
	|MENOR_IGUAL 
	|MENOR 
	|EQUAL (TO)?
	|IGUAL
	)
	{## = #( #[OPERADOR, &quot;OPERADOR&quot;] ,##);}
	;
	
parte_then
	: (THEN!)? sentencia_interna [&quot;THEN&quot;]
	;
parte_else  
	: sentencia_interna[&quot;ELSE&quot;] 
	;
fin_if
	: END_IF!
	;
comando_perform
	{String p2 = &quot;&quot;;}
	: (PERFORM IDENT)=&gt; 
	   PERFORM i1:IDENT! 
	            ((THROUGH!|THRU!) i2:IDENT!{p2=#i2.getText();})?
				perform_opc
	{ String p = #i1.getText() + ((p2==&quot;&quot;)?&quot;&quot;:&quot;/&quot;+p2);
	  {## = #( #[PERFORM_PARRAFO, p] ,##);}
	}

	| PERFORM {## = #( #[PERFORM_INLINE, &quot;PERFORM_INLINE&quot;] ,##);}
	  perform_opc sentencia_interna [&quot;PERFORM&quot;] END_PERFORM!
	;

perform_opc
	: (test)? (perform_varying)? (perform_until)?	
	;
perform_varying
	: VARYING^ campo FROM (campo|literal) BY (campo|literal)
	;
perform_until
	: UNTIL^ condicion
	;

test!
	: (WITH)? TEST (BEFORE|AFTER)
	;

	
comando_call
	: CALL^ (campo|CADENA) (call_using)?
	;
	
call_using
	: USING^ (campo)+
	;
	

comando_move
	:  MOVE^ (CORRESPONDING!|CORR!)? (literal|campo) TO (campo (COMA!)?)+
	;

comando_unstring
	: UNSTRING^ campo (unstring_delimited)? unstring_into (unstring_with)? (unstring_tallying)?
     (END_UNSTRING)?
	;
unstring_into
	: INTO^ ( campo (delimitador)? (contador)?)+
	;
delimitador!
	:DELIMITER^ (IN!)? campo
	;
contador
	:COUNT^ (IN!)? campo
	;
unstring_delimited!
	: DELIMITED^ (BY!)? (ALL!)? (campo|literal|SIZE) (OR (ALL)? (campo|literal|SIZE))*
	;
unstring_with
	: (WITH!)? POINTER^ campo
	;
unstring_tallying
	: TALLYING^ (IN!)? campo
	;
	
comando_string
	: STRING^ (lista_string)+ string_into (unstring_with)? (END_STRING!)?
	;
string_into
	: INTO^ lista_string
	;
	
lista_string
	: (options {greedy=true;}:campo|literal)+ (DELIMITED! (BY!)? (campo!|literal!|SIZE!))?
	;

comando_inspect
	: INSPECT^ campo (parte_tallying 
	                  |parte_replacing
					  |parte_converting)+
	;
	
parte_tallying
	: TALLYING^ ( campo FOR ( (CHARACTERS (before_after)*| (ALL|LEADING) ((campo|literal) (before_after)*)+))+)+
	;
parte_replacing
	: REPLACING^ ( (CHARACTERS BY (campo|literal) (before_after)*
	    |(ALL|LEADING|FIRST) (parte_by (before_after)*)+))+
	;
parte_by
	: un_by (options {greedy=true;}:(COMA!)? un_by)*
	;
un_by:
	(campo|literal) BY (campo|literal) 
	;
parte_converting
	: CONVERTING^ (campo|literal) TO (campo|literal) (before_after)*
	;
before_after
	: (BEFORE|AFTER) (INITIAL)? (campo|literal)
	;


comando_initialize
	: INITIALIZE^ (campo)+ (initialize_replacing)?
	;
	
initialize_replacing
	:REPLACING^ (tipo_dato )+ 
	;
tipo_dato
	: (ALPHABETIC^|NUMERIC^|ALPHANUMERIC^) (DATA!)? BY (campo|literal)
	;
	
comando_evaluate
	: EVALUATE^ objeto_evaluate (ALSO objeto_evaluate)* (subcomando_when)+ (END_EVALUATE!)
	;

subcomando_when
	: WHEN^ ((condicion_when (ALSO condicion_when)*)|OTHER) (options {greedy=true;}:sentencia_interna [&quot;WHEN&quot;])?
	;
condicion_when
	: condicion (THRU condicion)?
	;
objeto_evaluate
	: (campo|literal) ((THROUGH!|THRU!) (campo|literal))?
	;

comando_set!
	: SET^ (campo)+  (TO|(UP|DOWN) BY) (campo|literal)
	;

comando_search
	: SEARCH^ campo (VARYING^ campo)? ((AT!)? END^ sentencia_interna[&quot;AT-END&quot;])?
	  (options {greedy=true;}:subcomando_when)+ (options {greedy=true;}:END_SEARCH!)?
	;

comando_add
	:  ADD^ (literal|campo) 
	   TO (campo (ROUNDED)?)+ 
	   (giving)? 
	   (size_error)? 
	   (options {greedy=true;}:END_ADD!)?
	;
	
comando_compute
	: COMPUTE^ campo (ROUNDED)? IGUAL (expresionSuma)?
	;

comando_subtract!
	: SUBTRACT^ (campo|literal) FROM (campo|literal) (ROUNDED)?  (giving)? (size_error)? (options {greedy=true;}:END_SUBTRACT!)?
	;
	
comando_multiply
	: MULTIPLY^ (campo|literal) BY (campo|literal) (ROUNDED)? (giving)? (size_error)? (options {greedy=true;}:END_MULTIPLY)?
	;
	
comando_divide
	: DIVIDE^ (campo|literal) (INTO|BY) (campo|literal) (ROUNDED)? (giving)? (size_error)? (options {greedy=true;}:END_DIVIDE)?
	;
	
size_error
	: (NOT)? (ON!)? SIZE ERROR! sentencia_interna[&quot;SIZE-ERROR&quot;]
//	: SIZE ERROR! sentencia_interna[&quot;SIZE-ERROR&quot;]
//	| NOT (ON!)? SIZE ERROR! sentencia_interna[&quot;NOT-SIZE-ERROR&quot;]
	;
giving
	: GIVING campo (ROUNDED)?
	;

comando_open
	: OPEN^ ((INPUT|OUTPUT) IDENT)+
	;
	
comando_close
	: CLOSE^ (IDENT)+
	;
	
comando_read
	: READ^ IDENT (read_into)? (read_end)? (read_no_end)? (options {greedy=true;}:END_READ!)?
	;
next_record
	: NEXT (RECORD)?
	| RECORD
	;

read_into
	: INTO^ campo
	;

read_end
	: AT! END sentencia_interna[&quot;END&quot;]
	;
read_no_end
	: NOT AT! END sentencia_interna[&quot;NOT-END&quot;]
	;

comando_write
	: WRITE^ campo FROM! IDENT (options {greedy=true;}:END_WRITE!)?
	;

comando_display
	: DISPLAY^ (campo|literal)+ (display_upon)? (display_with)?
	;
display_upon
	: UPON^ IDENT
	;
display_with
	: (WITH!)? NO ADVANCING!
	;
	
comando_sort
	: SORT IDENT (ON!)? (ASCENDING|DESCENDING) (KEY!) IDENT
	  ( (WITH!) DUPLICATES (IN!) (ORDER!)? )?
	  ( (COLLATING!)? SEQUENCE IDENT)?
	  (  (USING IDENT)
	    |(INPUT PROCEDURE! IDENT ((THRU|THROUGH) IDENT)?)
	  )
	  (  (GIVING IDENT)
	    |(OUTPUT PROCEDURE! IDENT ((THRU|THROUGH) IDENT)?)
	  )
	  ;
	
literal
	: NUM
	| CADENA
	| cero
	| SPACE
	| SPACES
	| LIT_HEXADECIMAL
	| NULL
	| LENGTH^ {##.setType(LENGTHOF);} OF! campo
	;
cero
	: ZERO
	| ZEROS
	| ZEROES
	;
	

campo 
	: in_of	( options {greedy=true;}:modif_campo)*
	;

in_of 
	: IDENT ( options {greedy=true;}:( IN!|OF!) IDENT^)*
	;
	
modif_campo  
	: (PAR_AB expresionSuma DOSPUNTOS) =&gt; PAR_AB! expresionSuma DOSPUNTOS!  
										  (expresionSuma)?PAR_CE!
	                                      {##= #( #[MOD_TEXTO,&quot;MOD_TEXTO&quot;],##)}
	| PAR_AB! listaAritmetica PAR_CE!
	 {##= #( #[INDICE,&quot;INDICE&quot;],##)}
	;
	
punto_fin!
	: FIN_TODO
	;






</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016198.html">[antlr-interest] how to concatenate string nodes into one
	node when	create AST?
</A></li>
	<LI>Next message: <A HREF="016215.html">[antlr-interest] translating C++ to Java
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16213">[ date ]</a>
              <a href="thread.html#16213">[ thread ]</a>
              <a href="subject.html#16213">[ subject ]</a>
              <a href="author.html#16213">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
