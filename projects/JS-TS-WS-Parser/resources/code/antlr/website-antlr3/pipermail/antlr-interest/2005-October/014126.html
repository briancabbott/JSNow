<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Re: antlr-interest Digest, Vol 11, Issue 48
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20antlr-interest%20Digest%2C%20Vol%2011%2C%20Issue%2048&In-Reply-To=20051027092707.5BF64DCDF9%40www.antlr.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014121.html">
   <LINK REL="Next"  HREF="014127.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Re: antlr-interest Digest, Vol 11, Issue 48</H1>
    <B>Desai Nishitkumar Ashokkumar</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Re%3A%20antlr-interest%20Digest%2C%20Vol%2011%2C%20Issue%2048&In-Reply-To=20051027092707.5BF64DCDF9%40www.antlr.org"
       TITLE="[antlr-interest] Re: antlr-interest Digest, Vol 11, Issue 48">nadesai at cse.iitb.ac.in
       </A><BR>
    <I>Thu Oct 27 03:47:13 PDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="014121.html">[antlr-interest] Changes for stream offset determination
</A></li>
        <LI>Next message: <A HREF="014127.html">[antlr-interest] C++ Comments
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14126">[ date ]</a>
              <a href="thread.html#14126">[ thread ]</a>
              <a href="subject.html#14126">[ subject ]</a>
              <a href="author.html#14126">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 27 Oct 2005 <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-request at antlr.org</A> wrote:

&gt;<i> Send antlr-interest mailing list submissions to
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i>
</I>&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-request at antlr.org</A>
</I>&gt;<i>
</I>&gt;<i> You can reach the person managing the list at
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-owner at antlr.org</A>
</I>&gt;<i>
</I>&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;<i> than &quot;Re: Contents of antlr-interest digest...&quot;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Today's Topics:
</I>&gt;<i>
</I>&gt;<i>   1. RE: ASTPair handling in C# runtime for 2.7.6 (Luis Leal)
</I>&gt;<i>   2. Re: Checking for expression end in Javascript parser (Tech)
</I>&gt;<i>   3. Re: Re: Checking for expression end in Javascript	parser (Tech)
</I>&gt;<i>   4. Re: ASTPair handling in C# runtime for 2.7.6 (Martin Probst)
</I>&gt;<i>   5. RE: ASTPair handling in C# runtime for 2.7.6 (Micheal J)
</I>&gt;<i>   6. RE: ASTPair handling in C# runtime for 2.7.6 (Micheal J)
</I>&gt;<i>   7. Changes for stream offset determination (Jim Crafton)
</I>&gt;<i>   8. Re: Re: thank you sir (Sebastian Kaliszewski)
</I>&gt;<i>   9. Re: Re: thank you sir (Paul Johnson)
</I>&gt;<i>  10. Re: Help to make an iteration (somehing go wrong	with
</I>&gt;<i>      previous) (Bryan Ewbank)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 1
</I>&gt;<i> Date: Wed, 26 Oct 2005 22:18:06 +0200
</I>&gt;<i> From: &quot;Luis Leal&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">luisl at scarab.co.za</A>&gt;
</I>&gt;<i> Subject: RE: [antlr-interest] ASTPair handling in C# runtime for 2.7.6
</I>&gt;<i> To: &quot;Micheal J&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">open.zone at virgin.net</A>&gt;,	&quot;''antlr-interest' Interest'&quot;
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">MPEMLILMNEOKCPPBGEMKAEJFCIAA.luisl at scarab.co.za</A>&gt;
</I>&gt;<i> Content-Type: text/plain;	charset=&quot;us-ascii&quot;
</I>&gt;<i>
</I>&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> I vote for option 3 as it will have the least impact on client code and will
</I>&gt;<i> probably be reasonably efficient given the generational garbage collector. I
</I>&gt;<i> think it's probably better to spend effort on the run-time design for Antlr
</I>&gt;<i> v3 - which I'm very keen to help with BTW. Has work started on it? Please
</I>&gt;<i> let me know how I can help.
</I>&gt;<i>
</I>&gt;<i> There is also a bug in the _saveIndex optimization which causes compile
</I>&gt;<i> errors in generated lexers. I'd be happy to contribute a patch if this
</I>&gt;<i> hasn't already been fixed.
</I>&gt;<i>
</I>&gt;<i> Regards
</I>&gt;<i>
</I>&gt;<i> Luis
</I>&gt;<i>
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Micheal J [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">open.zone at virgin.net</A>]
</I>&gt;<i> Sent: 26 October 2005 08:28 PM
</I>&gt;<i> To: ''antlr-interest' Interest'
</I>&gt;<i> Subject: [antlr-interest] ASTPair handling in C# runtime for 2.7.6
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> For background info, pls see this thread:
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://www.antlr.org/pipermail/antlr-interest/2005-April/011838.html">http://www.antlr.org/pipermail/antlr-interest/2005-April/011838.html</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The options currently being considered are (in order of attractiveness):
</I>&gt;<i>
</I>&gt;<i> 1. Rewrite ASTPair as a struct.
</I>&gt;<i>   Pros: no heap allocations, no GC impact/churn
</I>&gt;<i>   Cons: breaking changes to ASTFactory methods (and client code):
</I>&gt;<i>         - makeASTRoot() and
</I>&gt;<i>         - addASTChild()
</I>&gt;<i>
</I>&gt;<i> 2. Provide a per-instance object pool
</I>&gt;<i>   Pros: fixes multi-threading issue, reduces ASTPair allocations
</I>&gt;<i>   Cons: future GCs may be more efficient, GC impact
</I>&gt;<i>
</I>&gt;<i> 3. Return to the pre-2.7.5 scheme and allow the GC to clean up.
</I>&gt;<i>   Pros: fixes multi-threading issue, leverages GC improvements
</I>&gt;<i>   Cons: more ASTPair allocations, GC impact
</I>&gt;<i>
</I>&gt;<i> Any opinions?.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Micheal
</I>&gt;<i> ANTLR/C#
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 2
</I>&gt;<i> Date: Wed, 26 Oct 2005 21:29:43 +0100
</I>&gt;<i> From: Tech &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">tech at swingkid.fsnet.co.uk</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Checking for expression end in
</I>&gt;<i> 	Javascript parser
</I>&gt;<i> To: shmuel siegel &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at shmuelhome.mine.nu</A>&gt;
</I>&gt;<i> Cc: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">435FE737.8090007 at swingkid.fsnet.co.uk</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
</I>&gt;<i>
</I>&gt;<i> Absolutely, poor wording on my part. I guess I should have said
</I>&gt;<i> 'Javascript statements end at either a semi colon, or the earliest new
</I>&gt;<i> line that makes a valid statement.'
</I>&gt;<i>
</I>&gt;<i> Given this, should
</I>&gt;<i>
</I>&gt;<i>    a=3
</I>&gt;<i>
</I>&gt;<i> count as a complete statement on it's own line? My parser won't treat is
</I>&gt;<i> as such because the expressions are nested, so I hope not!
</I>&gt;<i>
</I>&gt;<i> Mark
</I>&gt;<i>
</I>&gt;<i> shmuel siegel wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Tech wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> One aspect that is different is that Javascript expressions end
</I>&gt;&gt;&gt;<i> either at a semi colon, or at the earliest new line that makes a
</I>&gt;&gt;&gt;<i> valid expression.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As far as I know, this is not a valid definition for javascript
</I>&gt;&gt;<i> statements. It is true for control statements like &quot;return&quot; or &quot;break&quot;
</I>&gt;&gt;<i> but not for arithmetic statements.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Consider,
</I>&gt;&gt;<i>     &lt;script&gt;
</I>&gt;&gt;<i>         a=3
</I>&gt;&gt;<i>         +4
</I>&gt;&gt;<i>         alert(a);
</I>&gt;&gt;<i>     &lt;/script&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is legal and will result in an alert with the value 7. In general,
</I>&gt;&gt;<i> a new line only marks the end of a statement if the next token cannot
</I>&gt;&gt;<i> be part of the previous pattern.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 3
</I>&gt;<i> Date: Wed, 26 Oct 2005 21:38:00 +0100
</I>&gt;<i> From: Tech &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">tech at swingkid.fsnet.co.uk</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Re: Checking for expression end in
</I>&gt;<i> 	Javascript	parser
</I>&gt;<i> To: Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt;
</I>&gt;<i> Cc: ANTLR Interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">435FE928.20406 at swingkid.fsnet.co.uk</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
</I>&gt;<i>
</I>&gt;<i> Hi Terence,
</I>&gt;<i>
</I>&gt;<i> I wanted to say 'if the next character is on the same line it has to be
</I>&gt;<i> a semi colon, otherwise the semi colon is optional.' I'm not sure if I
</I>&gt;<i> need the 'semi colon is optional' bit, because we could always treat it
</I>&gt;<i> as a separate (empty) statement, but am I right in thinking I have to
</I>&gt;<i> put something as an alternative for the semantic predicate to make sense?
</I>&gt;<i>
</I>&gt;<i> Mark
</I>&gt;<i>
</I>&gt;<i> Terence Parr wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Oct 26, 2005, at 1:33 AM, Tech wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I have overriden consume() in my parser to store the line number of
</I>&gt;&gt;&gt;<i> the last token consumed:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>    int currentLine = 0;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>    public override void consume()
</I>&gt;&gt;&gt;<i>        {
</I>&gt;&gt;&gt;<i>            currentLine = LA(1);
</I>&gt;&gt;&gt;<i>            base.consume();
</I>&gt;&gt;&gt;<i>        }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I have then defined semi:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>    semi
</I>&gt;&gt;&gt;<i>        :    {currentLine == LT(1).getLine()}? SEMI
</I>&gt;&gt;&gt;<i>        |    (SEMI)?
</I>&gt;&gt;&gt;<i>        ;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> This seems to work, but gives me lots of disambiguation warnings.
</I>&gt;&gt;&gt;<i> What do you think?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hi Mark,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> remove the (...)? around the SEMI as semi is optional...probably not
</I>&gt;&gt;<i> waht you want.
</I>&gt;&gt;<i> Ter
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 4
</I>&gt;<i> Date: Wed, 26 Oct 2005 23:54:48 +0200
</I>&gt;<i> From: Martin Probst &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">mail at martin-probst.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] ASTPair handling in C# runtime for 2.7.6
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">1130363688.9728.3.camel at localhost.localdomain</A>&gt;
</I>&gt;<i> Content-Type: text/plain
</I>&gt;<i>
</I>&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;&gt;<i> For background info, pls see this thread:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> <A HREF="http://www.antlr.org/pipermail/antlr-interest/2005-April/011838.html">http://www.antlr.org/pipermail/antlr-interest/2005-April/011838.html</A>
</I>&gt;<i>
</I>&gt;<i> Has anyone actually tested how big the performance impact is? This is of
</I>&gt;<i> course application dependant, but in my experience doing such
</I>&gt;<i> optimisations without a good benchmark is not a good idea, especially in
</I>&gt;<i> managed code (in my case: Java code, but probably applies to .NET, too).
</I>&gt;<i>
</I>&gt;<i> Martin
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 5
</I>&gt;<i> Date: Thu, 27 Oct 2005 00:05:30 +0100
</I>&gt;<i> From: &quot;Micheal J&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">open.zone at virgin.net</A>&gt;
</I>&gt;<i> Subject: RE: [antlr-interest] ASTPair handling in C# runtime for 2.7.6
</I>&gt;<i> To: &quot;''antlr-interest' Interest'&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;000401c5da81$c3f225b0$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">6902a8c0 at hercules</A>&gt;
</I>&gt;<i> Content-Type: text/plain;	charset=&quot;us-ascii&quot;
</I>&gt;<i>
</I>&gt;&gt;<i> Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I vote for option 3 as it will have the least impact on
</I>&gt;&gt;<i> client code and will probably be reasonably efficient given
</I>&gt;&gt;<i> the generational garbage collector.
</I>&gt;<i>
</I>&gt;<i> Noted. I describe the reasons for moving away from option 3 in 2.7.5 in
</I>&gt;<i> another message in this thread.
</I>&gt;<i>
</I>&gt;&gt;<i> I think it's probably
</I>&gt;&gt;<i> better to spend effort on the run-time design for Antlr v3 -
</I>&gt;&gt;<i> which I'm very keen to help with BTW. Has work started on it?
</I>&gt;&gt;<i> Please let me know how I can help.
</I>&gt;<i>
</I>&gt;<i> ;-)
</I>&gt;<i>
</I>&gt;<i> Will do.
</I>&gt;<i>
</I>&gt;&gt;<i> There is also a bug in the _saveIndex optimization which
</I>&gt;&gt;<i> causes compile errors in generated lexers. I'd be happy to
</I>&gt;&gt;<i> contribute a patch if this hasn't already been fixed.
</I>&gt;<i>
</I>&gt;<i> Details of the bug?.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Micheal
</I>&gt;<i> ANTLR/C#
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 6
</I>&gt;<i> Date: Thu, 27 Oct 2005 00:05:30 +0100
</I>&gt;<i> From: &quot;Micheal J&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">open.zone at virgin.net</A>&gt;
</I>&gt;<i> Subject: RE: [antlr-interest] ASTPair handling in C# runtime for 2.7.6
</I>&gt;<i> To: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;000501c5da81$c4b2b690$<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">6902a8c0 at hercules</A>&gt;
</I>&gt;<i> Content-Type: text/plain;	charset=&quot;us-ascii&quot;
</I>&gt;<i>
</I>&gt;&gt;<i> Has anyone actually tested how big the performance impact is?
</I>&gt;&gt;<i> This is of course application dependant, but in my experience
</I>&gt;&gt;<i> doing such optimisations without a good benchmark is not a
</I>&gt;&gt;<i> good idea, especially in managed code (in my case: Java code,
</I>&gt;&gt;<i> but probably applies to .NET, too).
</I>&gt;<i>
</I>&gt;<i> Yes. I did with a couple of in-production grammars with input files
</I>&gt;<i> typically over 3MB in size. Hundreds of thousands of the damned things were
</I>&gt;<i> alloc'ed even though the longest only call-chain was only a few thousands.
</I>&gt;<i> With larger files, that alloc'ed resource and the resulting GC churn was an
</I>&gt;<i> issue. That is what led to the original change to use an object pool in
</I>&gt;<i> 2.7.5.
</I>&gt;<i>
</I>&gt;<i> Jim Crozman did as well. He reports about this in the thread.
</I>&gt;<i>
</I>&gt;<i> Option 1 seems to have it all IMO.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Micheal
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 7
</I>&gt;<i> Date: Wed, 26 Oct 2005 19:53:12 -0400
</I>&gt;<i> From: Jim Crafton &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jim.crafton at gmail.com</A>&gt;
</I>&gt;<i> Subject: [antlr-interest] Changes for stream offset determination
</I>&gt;<i> To: ANTLR Interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">e88138500510261653w6b016f6oc687d5bf3f89f37c at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1
</I>&gt;<i>
</I>&gt;<i> Here are the changes I made to allow a custom AST node to determine
</I>&gt;<i> the current offset of the lexer.
</I>&gt;<i>
</I>&gt;<i> In CharScanner.hpp, class antlr::CharScanner
</I>&gt;<i>
</I>&gt;<i> protected:
</I>&gt;<i> unsigned int offset_;
</I>&gt;<i>
</I>&gt;<i> public:
</I>&gt;<i>  unsigned int offset() const {
</I>&gt;<i>    return offset_;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 	virtual void consume()
</I>&gt;<i> 	{
</I>&gt;<i> 		if (inputState-&gt;guessing == 0)
</I>&gt;<i> 		{
</I>&gt;<i> 			int c = LA(1);
</I>&gt;<i> 			if (caseSensitive)
</I>&gt;<i> 			{
</I>&gt;<i> 				append(c);
</I>&gt;<i> 			}
</I>&gt;<i> 			else
</I>&gt;<i> 			{
</I>&gt;<i> 				// use input.LA(), not LA(), to get original case
</I>&gt;<i> 				// CharScanner.LA() would toLower it.
</I>&gt;<i> 				append(inputState-&gt;getInput().LA(1));
</I>&gt;<i> 			}
</I>&gt;<i> //*************************************************************
</I>&gt;<i> 			offset_ ++;
</I>&gt;<i> //*************************************************************
</I>&gt;<i>
</I>&gt;<i> 			// RK: in a sense I don't like this automatic handling.
</I>&gt;<i> 			if (c == '\t')
</I>&gt;<i> 				tab();
</I>&gt;<i> 			else
</I>&gt;<i> 				inputState-&gt;column++;
</I>&gt;<i> 		}
</I>&gt;<i> 		inputState-&gt;getInput().consume();
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> I increment the offset_ member in the consume() method.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In CharScanner.cpp
</I>&gt;<i>
</I>&gt;<i> CharScanner::CharScanner(InputBuffer&amp; cb, bool case_sensitive )
</I>&gt;<i> 	: saveConsumedInput(true) //, caseSensitiveLiterals(true)
</I>&gt;<i> 	, offset_(0) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-------I added initializer for offset to 0
</I>&gt;<i> 	, caseSensitive(case_sensitive)
</I>&gt;<i> 	, literals(CharScannerLiteralsLess(this))
</I>&gt;<i> 	, inputState(new LexerInputState(cb))
</I>&gt;<i> 	, commitToPath(false)
</I>&gt;<i> 	, tabsize(8)
</I>&gt;<i> 	, traceDepth(0)
</I>&gt;<i> {
</I>&gt;<i> 	setTokenObjectFactory(&amp;CommonToken::factory);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> CharScanner::CharScanner(InputBuffer* cb, bool case_sensitive )
</I>&gt;<i> 	: saveConsumedInput(true) //, caseSensitiveLiterals(true)
</I>&gt;<i> 	, offset_(0) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-------I added initializer for offset to 0
</I>&gt;<i> 	, caseSensitive(case_sensitive)
</I>&gt;<i> 	, literals(CharScannerLiteralsLess(this))
</I>&gt;<i> 	, inputState(new LexerInputState(cb))
</I>&gt;<i> 	, commitToPath(false)
</I>&gt;<i> 	, tabsize(8)
</I>&gt;<i> 	, traceDepth(0)
</I>&gt;<i> {
</I>&gt;<i> 	setTokenObjectFactory(&amp;CommonToken::factory);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> CharScanner::CharScanner( const LexerSharedInputState&amp; state, bool
</I>&gt;<i> case_sensitive )
</I>&gt;<i> 	: saveConsumedInput(true) //, caseSensitiveLiterals(true)
</I>&gt;<i> 	, offset_(0) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-------I added initializer for offset to 0
</I>&gt;<i> 	, caseSensitive(case_sensitive)
</I>&gt;<i> 	, literals(CharScannerLiteralsLess(this))
</I>&gt;<i> 	, inputState(state)
</I>&gt;<i> 	, commitToPath(false)
</I>&gt;<i> 	, tabsize(8)
</I>&gt;<i> 	, traceDepth(0)
</I>&gt;<i> {
</I>&gt;<i> 	setTokenObjectFactory(&amp;CommonToken::factory);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In Token.hpp, class antlr::Token
</I>&gt;<i>
</I>&gt;<i> public:
</I>&gt;<i> virtual void setOffset( unsigned int offset ){
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> virtual unsigned int getOffset() const{
</I>&gt;<i>   return 0;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In CommonToken.hpp class antlr::CommonToken
</I>&gt;<i>
</I>&gt;<i> protected:
</I>&gt;<i> unsigned int offset_;
</I>&gt;<i>
</I>&gt;<i> public:
</I>&gt;<i> virtual void setOffset( unsigned int offset ) {
</I>&gt;<i> 	offset_ = offset;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> virtual unsigned int getOffset() const {
</I>&gt;<i> 	return offset_;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In CommonToken.cpp
</I>&gt;<i>
</I>&gt;<i> CommonToken::CommonToken() : Token(), line(1), col(1), offset_(0), text(&quot;&quot;)
</I>&gt;<i> {}
</I>&gt;<i>
</I>&gt;<i> CommonToken::CommonToken(int t, const ANTLR_USE_NAMESPACE(std)string&amp; txt)
</I>&gt;<i> : Token(t)
</I>&gt;<i> , line(1)
</I>&gt;<i> , col(1)
</I>&gt;<i> ,offset_(0)
</I>&gt;<i> , text(txt)
</I>&gt;<i> {}
</I>&gt;<i>
</I>&gt;<i> CommonToken::CommonToken(const ANTLR_USE_NAMESPACE(std)string&amp; s)
</I>&gt;<i> : Token()
</I>&gt;<i> , line(1)
</I>&gt;<i> , col(1)
</I>&gt;<i> , offset_(0)
</I>&gt;<i> , text(s)
</I>&gt;<i> {}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Note that the offset_ member is initialized to 0.
</I>&gt;<i>
</I>&gt;<i> Then in my custom AST class I do something like this:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class CppASTNode : public CommonAST {
</I>&gt;<i> public:
</I>&gt;<i>
</I>&gt;<i> 	CppASTNode(): line_(0), column_(0), offset_(0) {}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 	CppASTNode( antlr::RefToken t ): line_(0), column_(0), offset_(0) {
</I>&gt;<i> 		CommonAST::setType(t-&gt;getType() );
</I>&gt;<i> 		CommonAST::setText(t-&gt;getText() );
</I>&gt;<i>
</I>&gt;<i> 		line_ = t-&gt;getLine();
</I>&gt;<i> 		column_ = t-&gt;getColumn();
</I>&gt;<i> 		offset_ = t-&gt;getOffset() - t-&gt;getText().size();
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	void initialize(int t, const std::string&amp; txt) {
</I>&gt;<i> 		CommonAST::setType(t);
</I>&gt;<i> 		CommonAST::setText(txt);
</I>&gt;<i>
</I>&gt;<i> 		line_ = 0; // to be noticed !
</I>&gt;<i> 		column_ = 0;
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i> 	void initialize( RefCppASTNode t ) {
</I>&gt;<i>        CommonAST::setType(t-&gt;getType() );
</I>&gt;<i> 		CommonAST::setText(t-&gt;getText() );
</I>&gt;<i>
</I>&gt;<i> 		line_ = t-&gt;line_;
</I>&gt;<i> 		column_ = t-&gt;column_;
</I>&gt;<i>
</I>&gt;<i> 		offset_ = t-&gt;offset_;
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i> 	void initialize( RefAST t ) {
</I>&gt;<i>        CommonAST::initialize(t);
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i> 	void initialize( antlr::RefToken t )  {
</I>&gt;<i>        CommonAST::initialize(t);
</I>&gt;<i>
</I>&gt;<i> 		line_ = t-&gt;getLine();
</I>&gt;<i> 		column_ = t-&gt;getColumn();
</I>&gt;<i> 		offset_ = t-&gt;getOffset() - t-&gt;getText().size();
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i> 	void setText(const std::string&amp; txt) {
</I>&gt;<i> 		CommonAST::setText(txt);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	void setType(int type) {
</I>&gt;<i> 		CommonAST::setType(type);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	static antlr::RefAST factory( void ) {
</I>&gt;<i> 		antlr::RefAST ret =
</I>&gt;<i> 			static_cast&lt;antlr::RefAST&gt;(RefCppASTNode(new CppASTNode()));
</I>&gt;<i>
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	int getLineNumber() const {
</I>&gt;<i> 		return line_;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	int getColumnNumber() const {
</I>&gt;<i> 		return column_;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	unsigned int getOffset() const {
</I>&gt;<i> 		return offset_;
</I>&gt;<i> 	}
</I>&gt;<i> protected:
</I>&gt;<i> 	int line_;
</I>&gt;<i> 	int column_;
</I>&gt;<i> 	unsigned int offset_;
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers, and hope this proves useful to others.
</I>&gt;<i>
</I>&gt;<i> Jim
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 8
</I>&gt;<i> Date: Thu, 27 Oct 2005 09:32:57 +0200
</I>&gt;<i> From: Sebastian Kaliszewski &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">Sebastian.Kaliszewski at softax.com.pl</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Re: thank you sir
</I>&gt;<i> To: ANTLR Interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">436082A9.4050208 at softax.com.pl</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
</I>&gt;<i>
</I>&gt;<i> Terence Parr wrote:
</I>&gt;&gt;<i> C++ is C so I'm not sure you have a problem with anything except the  io
</I>&gt;&gt;<i> libraries and such; still the Clib should still work with C++ right?
</I>&gt;<i>
</I>&gt;<i> Well, this is not true. There are many C constructs which are illegal in
</I>&gt;<i> C++, and some constructs have different meaning (i.e. my_type my_fun() vs
</I>&gt;<i> my_type my_fun(void)).
</I>&gt;<i>
</I>&gt;<i> rgds
</I>&gt;<i> Sebastian Kaliszewski
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 9
</I>&gt;<i> Date: Thu, 27 Oct 2005 10:20:10 +0100
</I>&gt;<i> From: Paul Johnson &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">gt54-antlr at cyconix.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Re: thank you sir
</I>&gt;<i> To: ANTLR Interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">43609BCA.1090407 at cyconix.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1; format=flowed
</I>&gt;<i>
</I>&gt;<i> Sebastian Kaliszewski wrote:
</I>&gt;&gt;<i> Terence Parr wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> C++ is C so I'm not sure you have a problem with anything except the
</I>&gt;&gt;&gt;<i> io libraries and such; still the Clib should still work with C++ right?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Well, this is not true. There are many C constructs which are illegal in
</I>&gt;&gt;<i> C++, and some constructs have different meaning (i.e. my_type my_fun()
</I>&gt;&gt;<i> vs my_type my_fun(void)).
</I>&gt;<i>
</I>&gt;<i> As Stroustrup says in Appx B of his book, &quot;with minor exceptions, C++ is
</I>&gt;<i> a superset of [C89] C... Well-written C programs tend to be C++ programs
</I>&gt;<i> as well&quot;. Sure, you can write bad C that won't compile as C++, but you
</I>&gt;<i> can't fix bad C programs automatically, which appears to be what the OP
</I>&gt;<i> wanted.
</I>&gt;<i>
</I>&gt;<i> Anyway, it's not at all obvious what the OP wanted to do. g++ is just a
</I>&gt;<i> driver for GCC: it assumes that the default language is C++, and that
</I>&gt;<i> you need to link against the C++ libraries. It has no problem compiling
</I>&gt;<i> C programs, even bad ones, and certainly ones which aren't valid C++.
</I>
  g++ has problem in compiling many c programs. As I previously said in c 
typecasting is not needed explicitly where as in c++ it is needed. 
there are many other types of statments for which g++ gives error but gcc 
compiles without any error. Btw, whats the OP ?

  thanks for ur reply.
&gt;<i>
</I>&gt;<i> Paul
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 10
</I>&gt;<i> Date: Thu, 27 Oct 2005 05:26:58 -0400
</I>&gt;<i> From: Bryan Ewbank &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">ewbank at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Help to make an iteration (somehing go
</I>&gt;<i> 	wrong	with previous)
</I>&gt;<i> To: ANTLR Interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">dd3a065f0510270226x3def51dco3c305831222298de at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=ISO-8859-1
</I>&gt;<i>
</I>&gt;<i> Let me try again with more explanation...
</I>&gt;<i>
</I>&gt;<i> [01] eval:
</I>&gt;<i> [02]  ... ... ... | while_stmt | ... ... ...
</I>&gt;<i> [03] ;
</I>&gt;<i> [04]
</I>&gt;<i> [05] while_stmt
</I>&gt;<i> [06] :
</I>&gt;<i> [07] 	#( WHILE e:expr s:stmt )
</I>&gt;<i> [08] 	{
</I>&gt;<i> [09] 		while (eval(#e) == true)
</I>&gt;<i> [10] 		{
</I>&gt;<i> [11] 			eval(#s);
</I>&gt;<i> [12] 		}
</I>&gt;<i> [13] 	}
</I>&gt;<i> [14] ;
</I>&gt;<i>
</I>&gt;<i> Line [07] matches the assumed tree for a while node.  When this matches, the
</I>&gt;<i> action (lines [08-13]) is executed.  The while-statement at [09] is executed in
</I>&gt;<i> the native language, which means that the &quot;eval(#s)&quot; at [11] will be executed
</I>&gt;<i> each time that the condition in the while at [09] evaluates to &quot;true&quot;
</I>&gt;<i>
</I>&gt;<i> Note that [07] could probably be rewritten as follows, because it's likely
</I>&gt;<i> wasteful to traverse those trees to recognize them:
</I>&gt;<i>
</I>&gt;<i> 	[07] 	#( WHILE e:. s:. )
</I>&gt;<i>
</I>&gt;<i> So, yes, stmt is another tree. ANTLR allows you to walk (and capture) the expr
</I>&gt;<i> and stmt trees once; after that, you must walk (and evaluate) each tree
</I>&gt;<i> multiple times.
</I>&gt;<i>
</I>&gt;<i> Hope this is a bit more clear in what I was saying,
</I>&gt;<i>
</I>&gt;<i> - Bryan
</I>&gt;<i>
</I>&gt;<i> On 10/26/05, <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">gil_loureiro at iol.pt</A> &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">gil_loureiro at iol.pt</A>&gt; wrote:
</I>&gt;&gt;<i> But the problem is stmt is another tree ... how can I walk this tree
</I>&gt;&gt;<i> (with eval(#s)) to run the contained set of statements multiple times?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> antlr-interest mailing list
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> End of antlr-interest Digest, Vol 11, Issue 48
</I>&gt;<i> **********************************************
</I>&gt;<i>
</I>
-- 
Nishit Desai
M.Tech II year 
Computer Science &amp; Engg.
IIT Bombay
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014121.html">[antlr-interest] Changes for stream offset determination
</A></li>
	<LI>Next message: <A HREF="014127.html">[antlr-interest] C++ Comments
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14126">[ date ]</a>
              <a href="thread.html#14126">[ thread ]</a>
              <a href="subject.html#14126">[ subject ]</a>
              <a href="author.html#14126">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
