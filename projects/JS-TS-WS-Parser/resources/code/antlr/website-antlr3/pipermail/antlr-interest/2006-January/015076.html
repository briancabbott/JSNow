<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] New article on StringTemplates and Treewalkers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20New%20article%20on%20StringTemplates%20and%20Treewalkers&In-Reply-To=43C557BB.9080706%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015074.html">
   <LINK REL="Next"  HREF="015087.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] New article on StringTemplates and Treewalkers</H1>
    <B>Gregg Reynolds</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20New%20article%20on%20StringTemplates%20and%20Treewalkers&In-Reply-To=43C557BB.9080706%40jazillian.com"
       TITLE="[antlr-interest] New article on StringTemplates and Treewalkers">dev at arabink.com
       </A><BR>
    <I>Wed Jan 11 13:52:17 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="015074.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
        <LI>Next message: <A HREF="015087.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15076">[ date ]</a>
              <a href="thread.html#15076">[ thread ]</a>
              <a href="subject.html#15076">[ subject ]</a>
              <a href="author.html#15076">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Andy Tripp wrote:
&gt;<i> 
</I>
&gt;&gt;<i>
</I>&gt;&gt;<i> Isn't this a false dichotomy?  The same considerations apply to both 
</I>&gt;&gt;<i> situations.  If antlr can do many-to-one (source grammar to a variety 
</I>&gt;&gt;<i> of target languages) 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> You mean &quot;one-to-many&quot;, here, not &quot;many-to-one&quot;, don't you? ANTLR itself 
</I>&gt;<i> has just one input language, and &quot;many&quot; output languages (C++, Java, C#).
</I>
Oops.

&gt;<i> 
</I>&gt;&gt;<i> that is only because somebody took the trouble to write the target 
</I>&gt;&gt;<i> generation code.  It's not one-to-many, but many one-to-ones.  This is 
</I>&gt;&gt;<i> exactly what happens with a many-to-one mapping (variety of source 
</I>&gt;&gt;<i> languages to one target language): for each source language somebody 
</I>&gt;&gt;<i> has to take the trouble to write the transformation code, and you 
</I>&gt;&gt;<i> again end up with many one-to-ones.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> No, I don't think that ANTLR is many one-to-ones at all. There is only 
</I>&gt;<i> one input language, there is a lot of code to derive the output, and then
</I>&gt;<i> there are minor variations on the output to make it fit either C++, 
</I>&gt;<i> Java, or C# syntax.
</I>
Ok, syntactically, maybe the backend code is mixed up.  But 
conceptually?  After all, what is the difference between many-one and 
many one-one, rilly?

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So if it is a problem for Antlr, it is the same problem for Jazillion 
</I>&gt;&gt;<i> or any other code xformer, regardless of implementation technique.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I do agree that (and I'm not sure if this is your point or not) ANTLR 
</I>&gt;<i> and Jazillian seem like they should both be designed the same way.
</I>
Not at all, I'm only trying abstract in order to find the gist nut of 
the problem.  After all, if you went to the trouble of trying antlr and 
finding it lacking, there's something there, there.
&gt;&gt;<i>
</I>&gt;&gt;<i> Actually I think &quot;MVC&quot; is probably not the best idiom for discussion 
</I>&gt;&gt;<i> parsing and transformation, coming as it does from the world of 
</I>&gt;&gt;<i> graphical representation of data.  (Personally I don't find it useful 
</I>&gt;&gt;<i> to think of the result of a translation as a &quot;view&quot; of the source; 
</I>&gt;&gt;<i> e.g. calling the parser code generated by Antlr a &quot;view&quot; of the source 
</I>&gt;&gt;<i> grammar doesn't work for me.  
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Me neither, I hope I didn't say that.
</I>
Sorry, that actually belongs on a different note to Mr. Parr regarding 
his (excellent) paper on separating MVC.  I like the content, just 
interested in other (possibly &quot;better&quot;) ways of expressing it.

&gt;<i> 
</I>&gt;&gt;<i> Nobody considers the machine code emitted by a compiler to be a &quot;view&quot; 
</I>&gt;&gt;<i> of the source code.)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Ah, but they do. I do, and  that's exactly what Terence is saying in the 
</I>&gt;<i> StringTemplate article...that the target Java, python, and bytecode
</I>&gt;<i> are simple three slightly different &quot;views&quot; of the output. I agree with 
</I>&gt;<i> that.
</I>&gt;<i> 
</I>
Well, you're a special case so we get to remove you from the sample.  ;)

But the article was about a straightforward source to source 
transformation - not machine code generation (Java byte code is not 
machine code).  I wonder if you and/or Mr. Parr really think of compiled 
code - machine code - as a &quot;view&quot; of the source.  Ordinarily I mean - of 
course one can talk about it that way for special purposes.

&gt;&gt;<i>
</I>&gt;&gt;<i> The real question is not separation of m v and c, but of the 
</I>&gt;&gt;<i> *genericity* (adaptability, flexibility, whatever) of the &quot;service&quot;: 
</I>&gt;&gt;<i> given a parser generator, is its backend architecture general enough 
</I>&gt;&gt;<i> to make it easy to write specialized emitters?  Given a language 
</I>&gt;&gt;<i> transformer (e.g. Jazillion), is its frontend architecture general 
</I>&gt;&gt;<i> enough to make it easy to specialize it for a variety of input languages?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> In my case, I haven't cared too much (yet) that the frontend by able to 
</I>&gt;<i> handle multiple input languages (or that the backend be able
</I>&gt;<i> to output multiple languages for that matter). Just a single C-to-Java 
</I>&gt;<i> translator is hard enough, and I've been happy to spend 3 years full time
</I>&gt;<i> thinking about all the ways to do that really well, rather than 
</I>&gt;<i> expanding my scope. Having said that, I'm now working on C++ to Java, 
</I>&gt;<i> though :)
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> More specifically:  how hard would it be to write an ML or Haskell 
</I>&gt;&gt;<i> emitter for Antlr (something I'd like to see)?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Good question, and my related question is &quot;will StringTemplate make that 
</I>&gt;<i> any easier?&quot;.
</I>
For the actual text generation, yes (I think); but that has nothing to 
do with target v. source driven transformation strategies.

&gt;&gt;<i>
</I>&gt;&gt;<i> How hard would it be to write an ML or Haskell front-end for 
</I>&gt;&gt;<i> Jazillion?  (I mean relative to a C frontend, not relative to a 
</I>&gt;&gt;<i> backend to Antlr, which would no doubt be easier.)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Answer: very hard: the translation rules are all C-specific. To put it 
</I>&gt;<i> bluntly, the Jazillian &quot;front-end&quot; is not in any way separated from the 
</I>&gt;<i> &quot;engine&quot;
</I>&gt;<i> and &quot;backend&quot;. I believe it's impossible to design such a 
</I>&gt;<i> any-language-to-any-language translation engine, despite the fact that
</I>&gt;<i> Semantic Designs claims to have such a product.
</I>&gt;<i> 
</I>I guess Lisp or some similar lambda calculus thingee would be best for 
the urlanguage.  Wouldn't that be a fun project?  No doubt somebody 
somewhere has tried.
&gt;&gt;<i>
</I>&gt;&gt;<i> (Note GCC is a good example of genericity both on the front and back 
</I>&gt;&gt;<i> ends.)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Right, I'm familiar with the gcc 4.0 architecture. IIRC it only supports 
</I>&gt;<i> C/C++ with gcc-specific extensions and Java as input,
</I>&gt;<i> and executable and Java bytecode as output. Good luck on getting it to 
</I>&gt;<i> input or output ML, Haskell, or Lisp :)
</I>
I looked into that a bit once.  I don't remember the details, but there 
are languages for which GCC just ain't the right tool.

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A general observation:  you contrast the Antlr (AST) approach to 
</I>&gt;&gt;<i> &quot;pattern-matching&quot; in a few places (e.g. &quot;is what you've got using 
</I>&gt;&gt;<i> StringTemplates and AST walking better than what you'd have with some 
</I>&gt;&gt;<i> (unspecified here) pattern-matching approach?&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But parsing *is* pattern matching, no?  So it isn't clear (to me) what 
</I>&gt;&gt;<i> exact contrast you're trying to establish.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I'm not refering to ANTLR parsing here, but ANTLR treewalking. But yes, 
</I>&gt;<i> we could consider treewalking to be &quot;pattern-matching on
</I>&gt;<i> two-dimensional trees&quot;, while I'm saying I prefer &quot;pattern-matching on 
</I>&gt;<i> one-dimensional token streams&quot;. Simply because it's trivial to
</I>&gt;<i> form mental pictures of token streams. When we read &quot;int[] i;&quot;, our 
</I>&gt;<i> brain has already tokenized it into a sequence of 5 tokens:
</I>&gt;<i> int [ ] i ;
</I>&gt;<i> But given that same chunk of code, our brains to NOT easily form an AST 
</I>&gt;<i> structure:
</I>&gt;<i> VAR_DEC
</I>&gt;<i>     TYPE &quot;int&quot;
</I>&gt;<i>     ARRAY_DEC  &quot;[]&quot;
</I>&gt;<i>     NAME &quot;i&quot;
</I>
Yep.  Although I daresay it depends on which language one is most 
comfortable with.  In lisp dialects it's pretty straightforward to thing 
in terms of something more treelike.  Then again, given the mainstream 
resistance to all those parentheses...

&gt;<i> 
</I>&gt;<i> Avoiding mental pictures of AST trees altogether is just a HUGE 
</I>&gt;<i> productivity boost, at least for me.
</I>&gt;<i> I'd say I'm at least twice as productive in writing rules (both simple 
</I>&gt;<i> text-replacement ones and
</I>&gt;<i> complex ones written in Java code), and probably more like 5-10x more 
</I>&gt;<i> productive
</I>&gt;<i> by largely ignoring AST structures.
</I>
That's interesting.  Can't argue with experience.  I suggest we cadge a 
few million bucks out of the DOD to do a study.

-gregg

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015074.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
	<LI>Next message: <A HREF="015087.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15076">[ date ]</a>
              <a href="thread.html#15076">[ thread ]</a>
              <a href="subject.html#15076">[ subject ]</a>
              <a href="author.html#15076">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
