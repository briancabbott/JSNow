<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Tree-Parser Grammer Question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Tree-Parser%20Grammer%20Question&In-Reply-To=170826586F3BD511910D0200C110AAA8032B4EBF%40memail03.bco-home.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002278.html">
   <LINK REL="Next"  HREF="002277.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Tree-Parser Grammer Question</H1>
    <B>Sriram Durbha</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Tree-Parser%20Grammer%20Question&In-Reply-To=170826586F3BD511910D0200C110AAA8032B4EBF%40memail03.bco-home.com"
       TITLE="[antlr-interest] Tree-Parser Grammer Question">cintyram at yahoo.com
       </A><BR>
    <I>Tue Nov 12 13:30:11 PST 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="002278.html">[antlr-interest] Tree-Parser Grammer Question
</A></li>
        <LI>Next message: <A HREF="002277.html">[antlr-interest] Tree-Parser Grammer Question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2280">[ date ]</a>
              <a href="thread.html#2280">[ thread ]</a>
              <a href="subject.html#2280">[ subject ]</a>
              <a href="author.html#2280">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>hi monty,
 in one of the applicaitons that i am writing [a translator] ,
part of the translation can be syntax directed; [ that is ..  target
code canbe generated directly from the parse action ;]

how ever important ones need ast;

now i am in a difficult position;
1.] the source language does not have a special delimiter ;
2. most of the constructs are optional ;
now i am not able to parse the if else construct;
but would like to know if there are any precautions i have to take
specially so that i can build a good and suitable tree ..

3.
 also i am trying to represent the translation strategy in a neutral
form , so that i can apply representations in that form to different
sets of sources and targets; Has any work been done in this area?

cheers
ram




--- <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">mzukowski at yci.com</A> wrote:
&gt;<i> Typically a root is chosen for its structure, not its content.  For
</I>&gt;<i> instance
</I>&gt;<i> a simplistic variable declaration in C would look like #(NDeclarator
</I>&gt;<i> type ID
</I>&gt;<i> (expr)?);  The NDeclarator is an imaginary type, which you might
</I>&gt;<i> consider
</I>&gt;<i> using.  Again I ask why is it important to have the name be the root?
</I>&gt;<i> Typically symbols are stored in a symbol table so you can look them
</I>&gt;<i> up by
</I>&gt;<i> scope and and name and that will point you to the right tree.  
</I>&gt;<i> 
</I>&gt;<i> What do you envision doing with the tree that makes it important to
</I>&gt;<i> have the
</I>&gt;<i> name first?
</I>&gt;<i> 
</I>&gt;<i> Note that your structure for the tree with IDENT as an optional root
</I>&gt;<i> muddles
</I>&gt;<i> things up.  You don't know from the start which of the tree
</I>&gt;<i> alternatives you
</I>&gt;<i> are looking at.  This will slow down your tree traversal as well. 
</I>&gt;<i> Some
</I>&gt;<i> people argue that tree grammars should avoid optional closures
</I>&gt;<i> totally.
</I>&gt;<i> Take for instance a for loop.  In C any of the three expressions are
</I>&gt;<i> optional, but for my tree I don't want to decide based on content, so
</I>&gt;<i> I
</I>&gt;<i> added an imaginary NEmptyExpression alternative to my expr rule.  So
</I>&gt;<i> now a
</I>&gt;<i> missing expr in a for loop is forced in as an NEmptyExpression. 
</I>&gt;<i> Imagine how
</I>&gt;<i> to handle the tree grammar if I left those three exprs optional. 
</I>&gt;<i> It's not
</I>&gt;<i> pretty.  My simple tree grammar for &quot;for&quot; is this:
</I>&gt;<i> 
</I>&gt;<i>                #( &quot;for&quot;
</I>&gt;<i>                 expr expr expr
</I>&gt;<i>                 statement
</I>&gt;<i>                 )
</I>&gt;<i> 
</I>&gt;<i> OK, let's get ready for round two!
</I>&gt;<i> 
</I>&gt;<i> Monty
</I>&gt;<i> 
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Ney, Richard [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">richard.ney at aspect.com</A>]
</I>&gt;<i> Sent: Tuesday, November 12, 2002 8:51 AM
</I>&gt;<i> To: '<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>'
</I>&gt;<i> Subject: RE: [antlr-interest] Tree-Parser Grammer Question
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The rational for this was to have the final output name of each
</I>&gt;<i> column in
</I>&gt;<i> the select statement to always be the root. Now based on SQL92 that
</I>&gt;<i> can be
</I>&gt;<i> the column name, an alias, or the group expression. Now I was
</I>&gt;<i> starting to
</I>&gt;<i> look at making the initial parser always add the alias in to the
</I>&gt;<i> tree.
</I>&gt;<i> Anyone have an example of a conditional rule in the parser that can
</I>&gt;<i> add
</I>&gt;<i> stuff into the tree conditionally?
</I>&gt;<i> 
</I>&gt;<i> -Richard
</I>&gt;<i> 
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">mzukowski at yci.com</A> [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">mzukowski at yci.com</A>] 
</I>&gt;<i> Sent: Tuesday, November 12, 2002 8:26 AM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>
</I>&gt;<i> Subject: RE: [antlr-interest] Tree-Parser Grammer Question
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It is kind of weird to have optional matches like (IDENT^)? promoted
</I>&gt;<i> to the
</I>&gt;<i> root.  What is your rationale for this?  Your tree rule would look
</I>&gt;<i> like
</I>&gt;<i> 
</I>&gt;<i> selectColumn: #(IDENT groupExpression)
</I>&gt;<i> 			| groupExpression
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> Monty
</I>&gt;<i> 
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Ney, Richard [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">richard.ney at aspect.com</A>]
</I>&gt;<i> Sent: Monday, November 11, 2002 11:26 PM
</I>&gt;<i> To: '<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>'
</I>&gt;<i> Subject: [antlr-interest] Tree-Parser Grammer Question
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I have battled this issue for two days now so I'm at a loss to how to
</I>&gt;<i> solve
</I>&gt;<i> this problem. I created a initial parser for a basic SQL Select. One
</I>&gt;<i> of my
</I>&gt;<i> key rules in the initial parser looks like this: groupExpression 
</I>&gt;<i>         : (&quot;avg&quot;^|&quot;max&quot;^|&quot;min&quot;^|&quot;sum&quot;^) OPEN_PAREN!
</I>&gt;<i> (additiveExpression |
</I>&gt;<i> ((&quot;all&quot; | &quot;distinct&quot;) field_name)) CLOSE_PAREN! (IDENT^)
</I>&gt;<i>         | (&quot;count&quot;^ OPEN_PAREN! ((&quot;all&quot; | &quot;distinct&quot;)? field_name |
</I>&gt;<i> STAR)
</I>&gt;<i> CLOSE_PAREN! (IDENT^)?) 
</I>&gt;<i>         | additiveExpression (IDENT^)? 
</I>&gt;<i>         ; 
</I>&gt;<i> The result of this rule is that it builds the tree with the final
</I>&gt;<i> name of
</I>&gt;<i> the column always being to top-most root. I.E. Select test, count(*),
</I>&gt;<i> count(*) test from foo; 
</I>&gt;<i> Results in a tree that looks like 
</I>&gt;<i> select 
</I>&gt;<i>         test 
</I>&gt;<i>         count 
</I>&gt;<i>                 * 
</I>&gt;<i>         test 
</I>&gt;<i>                 count 
</I>&gt;<i>                         * 
</I>&gt;<i> from 
</I>&gt;<i>         foo 
</I>&gt;<i> Now in my tree parser I have a two rules that look like this: 
</I>&gt;<i> selectColumn 
</I>&gt;<i>         : fieldName (groupExpression)? 
</I>&gt;<i>         ; 
</I>&gt;<i>         
</I>&gt;<i> groupExpression 
</I>&gt;<i>         : #(&quot;avg&quot; mathExpression) 
</I>&gt;<i>         { 
</I>&gt;<i>         } 
</I>&gt;<i>         | #(&quot;sum&quot; mathExpression) 
</I>&gt;<i>         { 
</I>&gt;<i>         } 
</I>&gt;<i>         | #(&quot;count&quot; (&quot;all&quot; | &quot;distinct&quot;)? (fieldName| STAR)) 
</I>&gt;<i>         { 
</I>&gt;<i>         } 
</I>&gt;<i>         | #(&quot;max&quot; mathExpression) 
</I>&gt;<i>         { 
</I>&gt;<i>         } 
</I>&gt;<i>         | #(&quot;min&quot; mathExpression) 
</I>&gt;<i>         { 
</I>&gt;<i>         } 
</I>&gt;<i>         ; 
</I>&gt;<i> These rules handle the 1st and 3rd cases in the select statement but
</I>&gt;<i> not the
</I>&gt;<i> 2nd where the count(*) doesn't have an alias. Does anyone have an
</I>&gt;<i> idea how
</I>&gt;<i> to write something like selectColumn 
</I>&gt;<i>         : (fieldName)? (groupExpression)? 
</I>&gt;<i>         ; 
</I>&gt;<i> that is a little less ambiguous? 
</I>&gt;<i> -Richard 
</I>&gt;<i>
</I>----------------------------------------------------------------------------
&gt;<i> ------------------------ 
</I>&gt;<i> Richard Ney     Aspect Communications 
</I>&gt;<i> Principal Software Engineer 
</I>&gt;<i> <A HREF="http://www.aspect.com">http://www.aspect.com</A>                           Main:  408.325.2200 
</I>&gt;<i> mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">richard.ney at aspect.com</A>                   SJ Office:
</I>&gt;<i> 408.325.2464 
</I>&gt;<i>         Home Office: 916.797.9602 
</I>&gt;<i>
</I>----------------------------------------------------------------------------
&gt;<i> ------------------------ 
</I>&gt;<i> The Three Laws of Infernal Dynamics:
</I>&gt;<i> 1. An object in motion will always be headed in the wrong direction.
</I>&gt;<i> 2. An
</I>&gt;<i> object at rest will always be in the wrong place. 3. The energy
</I>&gt;<i> required to
</I>&gt;<i> change either of these states will always be more than you wish to
</I>&gt;<i> expend,
</I>&gt;<i> but never so much as to make the task appear prospectively
</I>&gt;<i> impossible.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Your use of Yahoo! Groups is subject to the Yahoo! Terms of Service. 
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i> 
</I>&gt;<i> Your use of Yahoo! Groups is subject to
</I>&gt;<i> <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i> 
</I>&gt;<i> Your use of Yahoo! Groups is subject to
</I>&gt;<i> <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i> 
</I>&gt;<i> Your use of Yahoo! Groups is subject to
</I>&gt;<i> <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>

__________________________________________________
Do you Yahoo!?
U2 on LAUNCH - Exclusive greatest hits videos
<A HREF="http://launch.yahoo.com/u2">http://launch.yahoo.com/u2</A>

 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002278.html">[antlr-interest] Tree-Parser Grammer Question
</A></li>
	<LI>Next message: <A HREF="002277.html">[antlr-interest] Tree-Parser Grammer Question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2280">[ date ]</a>
              <a href="thread.html#2280">[ thread ]</a>
              <a href="subject.html#2280">[ subject ]</a>
              <a href="author.html#2280">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
