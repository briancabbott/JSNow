<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] New article on StringTemplates and Treewalkers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20New%20article%20on%20StringTemplates%20and%20Treewalkers&In-Reply-To=43C3EB3F.8010503%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015026.html">
   <LINK REL="Next"  HREF="015070.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] New article on StringTemplates and Treewalkers</H1>
    <B>Gregg Reynolds</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20New%20article%20on%20StringTemplates%20and%20Treewalkers&In-Reply-To=43C3EB3F.8010503%40jazillian.com"
       TITLE="[antlr-interest] New article on StringTemplates and Treewalkers">dev at arabink.com
       </A><BR>
    <I>Wed Jan 11 09:34:18 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="015026.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
        <LI>Next message: <A HREF="015070.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15065">[ date ]</a>
              <a href="thread.html#15065">[ thread ]</a>
              <a href="subject.html#15065">[ subject ]</a>
              <a href="author.html#15065">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Andy Tripp wrote:
&gt;<i> In a fit of reverse-writer's-block last night, I wrote down
</I>&gt;<i> some thoughts on AST treewalking and StringTemplate, titled
</I>&gt;<i> &quot;Why I don't Use StringTemplate for Language translation&quot;
</I>&gt;<i> 
</I>&gt;<i> The article is here: <A HREF="http://www.jazillian.com/stringTemplate.html">http://www.jazillian.com/stringTemplate.html</A>
</I>&gt;<i> 
</I>
Hi Andy,

A few holes to poke in your article.  Which I mean in the nicest 
possible way!

 From your paper:  &quot;But the main rationale for separating the &quot;view&quot; 
from the &quot;controller&quot; and &quot;model&quot; is so that we can have multiple 
&quot;views&quot;, and that we can easily change the &quot;view&quot; without having to 
touch the &quot;model&quot; or the &quot;controller. Certain applications may have 
multiple &quot;views&quot; (ANTLR, for example, which takes a single input in 
ANTLR-language, but generates Java code for Java programmers, C code for 
C programmers, etc). But for other applications, such as a 
&quot;Any-dialect-of-C to Java&quot; or &quot;C or C++ to Java&quot;, the mapping is 
many-to-one, not one-to-many.&quot;

Isn't this a false dichotomy?  The same considerations apply to both 
situations.  If antlr can do many-to-one (source grammar to a variety of 
target languages) that is only because somebody took the trouble to 
write the target generation code.  It's not one-to-many, but many 
one-to-ones.  This is exactly what happens with a many-to-one mapping 
(variety of source languages to one target language): for each source 
language somebody has to take the trouble to write the transformation 
code, and you again end up with many one-to-ones.

So if it is a problem for Antlr, it is the same problem for Jazillion or 
any other code xformer, regardless of implementation technique.

Actually I think &quot;MVC&quot; is probably not the best idiom for discussion 
parsing and transformation, coming as it does from the world of 
graphical representation of data.  (Personally I don't find it useful to 
think of the result of a translation as a &quot;view&quot; of the source; e.g. 
calling the parser code generated by Antlr a &quot;view&quot; of the source 
grammar doesn't work for me.  Nobody considers the machine code emitted 
by a compiler to be a &quot;view&quot; of the source code.)

The real question is not separation of m v and c, but of the 
*genericity* (adaptability, flexibility, whatever) of the &quot;service&quot;: 
given a parser generator, is its backend architecture general enough to 
make it easy to write specialized emitters?  Given a language 
transformer (e.g. Jazillion), is its frontend architecture general 
enough to make it easy to specialize it for a variety of input languages?

More specifically:  how hard would it be to write an ML or Haskell 
emitter for Antlr (something I'd like to see)?

How hard would it be to write an ML or Haskell front-end for Jazillion? 
  (I mean relative to a C frontend, not relative to a backend to Antlr, 
which would no doubt be easier.)

(Note GCC is a good example of genericity both on the front and back ends.)

A general observation:  you contrast the Antlr (AST) approach to 
&quot;pattern-matching&quot; in a few places (e.g. &quot;is what you've got using 
StringTemplates and AST walking better than what you'd have with some 
(unspecified here) pattern-matching approach?&quot;

But parsing *is* pattern matching, no?  So it isn't clear (to me) what 
exact contrast you're trying to establish.

One of the examples you give to illustrate the difficulty of AST-walking:

	2.  At any &quot;printf function&quot; node, loop through the format string and 
arguments, and do lots of processing to replace them with Java using the 
&quot;+&quot; operator.

My understanding is that you would just write a production for the 
grammar of the args of the printf function, which you could take 
directly from the C grammar, augmented by info from the printf 
definition in the library.  The &quot;lots of processing&quot; must occur 
regardless of implementation strategy, but in Antlr the grammar 
recognition part (looping through the format string and args) is clear 
and simple(?).

Correct me if I'm wrong, but I get the impression you're thinking about 
writing by hand a bunch of the AST parsing logic that Antlr generates 
automatically for tree grammars, rather the way you might need to 
proceed if you were using a less sophisticated parser generator 
(lex/yacc, etc.)  In that case, yes, it would definitely be a pain 
because you might need to do it all by hand.  But if I understand Antlr 
correctly, it saves you the trouble by supporting tree grammar.  So the 
interesting contrast is not necessarily between your approach and 
Antlr's, but between Antlr v. other parser generators.

All for now.  I'm not sure I agree with your paper, but it has certainly 
provoked thought.

-gregg
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015026.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
	<LI>Next message: <A HREF="015070.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15065">[ date ]</a>
              <a href="thread.html#15065">[ thread ]</a>
              <a href="subject.html#15065">[ subject ]</a>
              <a href="author.html#15065">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
