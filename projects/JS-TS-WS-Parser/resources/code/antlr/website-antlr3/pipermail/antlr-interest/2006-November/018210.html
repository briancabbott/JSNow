<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=002801c6fe07%24fc712ee0%24c704a8c0%40hercules">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018201.html">
   <LINK REL="Next"  HREF="018217.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=002801c6fe07%24fc712ee0%24c704a8c0%40hercules"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Wed Nov  1 20:10:28 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018201.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018217.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18210">[ date ]</a>
              <a href="thread.html#18210">[ thread ]</a>
              <a href="subject.html#18210">[ subject ]</a>
              <a href="author.html#18210">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Micheal J wrote:

&gt;<i>Hi Andy,
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>I don't think I'm changing my position. I still disagree with that 
</I>&gt;&gt;<i>quote. I think almost all the great tools
</I>&gt;&gt;<i>are the ones that the majority of programmers to &quot;get&quot;. In 
</I>&gt;&gt;<i>fact, that's 
</I>&gt;&gt;<i>part of what makes them great.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I don't think &quot;popular&quot; and &quot;great&quot; (when applied to tools) are synonyms.
</I>&gt;<i>  
</I>&gt;<i>
</I>I don't either, that's why I said &quot;in part&quot;.

&gt;<i>Some &quot;great&quot; tools are accessible to the majority. Others are not.
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>Being a great tool for the job doesn't guarantee popularity. 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Popularity 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>is ultimately a measure of the tool's accessibility to average 
</I>&gt;&gt;&gt;<i>programmers (they are the majority). Great tools are often 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>beyond the 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>ability of the average programmer. Certainly to build. And 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>often to use 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>too.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>I disagree. I view Java as being &quot;great&quot; and C++ not being 
</I>&gt;&gt;<i>&quot;great&quot;.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>If productivity (not power) is the priority, Java/C# is likely to be a
</I>&gt;<i>better tool than C++ for those problems to which Java is applicable.
</I>&gt;<i>
</I>&gt;<i>Otherwise C++ (or some other tool) is better.
</I>&gt;<i>  
</I>&gt;<i>
</I>And Java is *always* the priority. The only way you'd ever fall back to 
C++ is if there really
wasn't enough power in Java. And I've only heard of one or two cases of 
that.

&gt;&gt;<i>and I think the 
</I>&gt;&gt;<i>vast majority 
</I>&gt;&gt;<i>of programmers who know both
</I>&gt;&gt;<i>agree with me.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I make no such claim (I have no idea what the vast majority of competent
</I>&gt;<i>Java/C++ programmers think).
</I>&gt;<i>  
</I>&gt;<i>
</I>Then you should get out more. Talk to 10 co-workers about Java vs. C++, 
or go to a conference.
I'd say that less than 5% of those who've actually used both Java and 
C++ prefer C++.
That's from my experience of talking to perhaps a few hundred developers 
about it.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Probably the main benefit is that it's easy to use for 
</I>&gt;&gt;<i>&quot;average programmers&quot;. That's also why
</I>&gt;&gt;<i>ANTLR is better than the competition - because it's easier to use.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Not to my mind. Coco/R, JavaCC, SLK are equally easy to use (if one takes
</I>&gt;<i>the time to learn them).
</I>&gt;<i>
</I>&gt;<i>ANTLR's &quot;popularity&quot; is due to a lot if things including: Ter's predicated
</I>&gt;<i>LL(k)/LL(*) technology, 
</I>&gt;<i>
</I>LL(*) is brand new to V3, so that has nothing to do with it. And some of 
the others are LL(k), so
I don't think that's it, either. I'm using Javacc now, and it's driving 
me nuts, just as lex/yacc
and similar tools did.

&gt;<i>[somewhat] comprehensible code generation for
</I>&gt;<i>multiple target languages, grammar as documentation for all phases of
</I>&gt;<i>translation, it's PD or BSD license, funky codegen in V3 etc
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Yes, a few people want to add stuff back, but most do not. It's just 
</I>&gt;&gt;<i>that the few are very vocal.
</I>&gt;&gt;<i>The vast majority don't want MI, operator overloading, or built-in 
</I>&gt;&gt;<i>AspectOrientedDesign.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>The &quot;vast majority&quot; don't understand the value/utility of MI, mixins, or the
</I>&gt;<i>&quot;why?&quot; of AOD  etc.
</I>&gt;<i>  
</I>&gt;<i>
</I>That's a circular argument. If someone &quot;understands the value&quot; of MI, 
etc. then of course they want it.
It's that &quot;vast majority&quot; who know what they are and don't want them 
that matters.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>And that's why Java is popular and
</I>&gt;&gt;&gt;&gt;<i>Smalltalk and 
</I>&gt;&gt;&gt;&gt;<i>LISP are not.
</I>&gt;&gt;&gt;&gt;<i>It's also why people prefer Java over C++.
</I>&gt;&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>It is a easier tool to use. Less powerful. But easier.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Right - so I hope there's nothing wrong with me pushing to make ANTLR 
</I>&gt;&gt;<i>(or some successor)
</I>&gt;&gt;<i>easier to use. A compiler is easier to use than compiling by 
</I>&gt;&gt;<i>hand, but 
</I>&gt;&gt;<i>also less powerful.
</I>&gt;&gt;<i>I'm ok with that.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>In the context of this thread, &quot;compiling by hand&quot; is not a tool.
</I>&gt;<i>  
</I>&gt;<i>
</I>The point is that just because one approach (whether tool or not) is 
less powerful doesn't
mean that it's worse.

&gt;<i>How would you change in ANTLR to make it easier?
</I>&gt;<i>  
</I>&gt;<i>
</I>Short answer: hide all the details from me. Make it so that I have no 
idea that
there is code being generated to do lexing and parsing. Let me just give 
it a C grammar
and a Java grammar, and then dive in and start writing translation logic 
without any
generated code or even ASTs in sight. How to do that is left as an 
exercise for the reader.

&gt;<i>
</I>&gt;&gt;<i>That's like having to know the details about the 
</I>&gt;&gt;<i>bytecode that
</I>&gt;&gt;<i>javac creates. I don't have to read the manual for that stuff...I'd 
</I>&gt;&gt;<i>rather have the tool not
</I>&gt;&gt;<i>force me to know those details.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Quite often just getting &quot;something that works&quot; is all that is required.
</I>&gt;<i>Getting the best output from a compiler requires knowing more about what
</I>&gt;<i>goes on under the hood.
</I>&gt;<i>  
</I>&gt;<i>
</I>Yea, I know. You can do a better job at garbage collection than java's 
gc. You can write
better byte code than javac because you've studied javac and bytecode.

The Java JIT guys say the first rule of performance optimization is to 
STOP doing whatever
it is you're doing that you think is producing better bytecode. And what 
did Terence find
out about performance when he tried generating his own bytecode?

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>For your examples of [general purpose language] compiler and ANTLR 
</I>&gt;&gt;&gt;<i>[grammar language compiler], the domain expertise isn't 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>primarily about 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>the internals of the tool. It's about the syntax, semantics 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>and idioms 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>of the language recognized by the tool. Knowledge of the tool's 
</I>&gt;&gt;&gt;<i>internals can elevate those who have it above the &quot;average&quot; user who 
</I>&gt;&gt;&gt;<i>doesn't.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>But required knowledge of the tool's internals limits the &quot;average&quot; 
</I>&gt;&gt;<i>user's productivity.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>A user is already limited if he/she don't understand how a tool works.
</I>&gt;<i>Whether or not that matters depends on what they are trying to accomplish.
</I>&gt;<i>  
</I>&gt;<i>
</I>Yes, we lower 99% of the programming community are writing sub-par code 
because we don't
understand how our compilers work. ;)

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>Java's swan song is productivity (for those problems to 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>which to it can 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>be applied). Not power as in flexibility, expressivity or 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>performance.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>I use Java/C# for the productivity benefits. If performance, 
</I>&gt;&gt;&gt;<i>flexibility or expressivity was *more* important in a particular 
</I>&gt;&gt;&gt;<i>project, there are better tools than Java/C# (e.g. C++, Occaml).
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Right, so you're just like the rest of us. You've chosen to 
</I>&gt;&gt;<i>limit your 
</I>&gt;&gt;<i>own &quot;power&quot; by using Java rather
</I>&gt;&gt;<i>than, say, assembly. So I'm sticking with my claim that
</I>&gt;&gt;<i>&quot;I think a tool can be great while being simple enough for most 
</I>&gt;&gt;<i>programmers (e.g. Java).&quot;
</I>&gt;&gt;<i>and not buying your &quot;Not without limiting it's power&quot; reply.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>It isn't &quot;my&quot; reply. The fact is:
</I>&gt;<i>- Java/C# is less powerful than assembler, C or C++ (you need them to build
</I>&gt;<i>java/c# in the first place).
</I>&gt;<i>  
</I>&gt;<i>
</I>If that's your definition of &quot;power&quot;, I don't see how it relates to 
anything. I need an engine to build
a car. That, to me, doesn't mean the engine is &quot;more powerful&quot; than the 
car. I'd say if anything
the car is &quot;more powerful&quot; (or maybe just &quot;more useful&quot;) than the 
engine, as it lets you get the
job done faster.

&gt;<i>- For some problems, Java/C# is more productive than assembler, C or C++.
</I>&gt;<i>  
</I>&gt;<i>
</I>I'd say &quot;for almost all problems&quot; but OK.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>Incidentally, your DSL is just a small part of your 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>particular language 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>recognition toolkit.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>It is??? How do you know that?
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Relying on what I've learned about similar systems.
</I>&gt;<i>If it isn't I'd like to hear more about it.
</I>&gt;<i>  
</I>&gt;<i>
</I>It depends on how you measure, but I wouldnt' say my DSL is a &quot;small part&quot;.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>He isn't using ANTLR directly (i.e. creating/maintaining ANTLR 
</I>&gt;&gt;&gt;<i>grammars) so, no surprise if he hasn't had to learn to use ANTLR.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Ah, but he is using ANTLR directly: he spends all day working 
</I>&gt;&gt;<i>with the 
</I>&gt;&gt;<i>Token streams produced by ANTLR,
</I>&gt;&gt;<i>without having ever seen an ANTLR grammar. That's possible when using 
</I>&gt;&gt;<i>ANTLR as a lexer,
</I>&gt;&gt;<i>but that wouldn't be possible using its parser.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I disagree. He is working with code generated by ANTLR. He isn't using
</I>&gt;<i>ANTLR.
</I>&gt;<i>  
</I>&gt;<i>
</I>Ah, come on. When someone is using a lexer built using ANTLR, you won't 
consider that to be
&quot;using ANTLR?&quot; As in &quot;He's using ANTLR without ever seeing the input 
grammar&quot;. That's
like saying I'm not &quot;using javac&quot;, I'm just using the bytecode that it 
generates.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>He _is_ using a DSL you created to encode source-to-source 
</I>&gt;&gt;&gt;<i>transformations. You just expressed the opinion that he has 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>aquired the 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>domain expertise required to use your DSL.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Yes, so if you believe me when I say that my DSL is orders of 
</I>&gt;&gt;<i>magnitude 
</I>&gt;&gt;<i>easier to use than
</I>&gt;&gt;<i>to use ANTLR to build and walk ASTs, then you must see my point: He's 
</I>&gt;&gt;<i>much more productive.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>But he is also limited to what your DSL allows - cf. &quot;not without limiting
</I>&gt;<i>it's power&quot;. 
</I>&gt;<i>
</I>&gt;<i>If he used ANTLR directly (like you did). He can do more. Your DSL (like
</I>&gt;<i>Java/C#) favours productivity over power/flexibility.
</I>&gt;<i>  
</I>&gt;<i>
</I>The whole point of building the DSL is because I think if he (or I) used 
ANTLR directly, we'd actually
&quot;do less&quot;, not &quot;do more&quot;. We'd get less accomplished because we'd be 
struggling with AST
shapes in our heads. The DSL lets us tackle the same problem at a higher 
level of abstraction.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>So I'm building my DSL (and other code) on top of 
</I>&gt;&gt;<i>ANTLR/lexer. I think 
</I>&gt;&gt;<i>there's an opportunity
</I>&gt;&gt;<i>for Terence to build a better and different tool in place of the 
</I>&gt;&gt;<i>ANTLR/parser - one that doesn't
</I>&gt;&gt;<i>require users to know formal language theory or picture ASTs in their 
</I>&gt;&gt;<i>heads.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Personally, I can't see how that is possible.
</I>&gt;<i>  
</I>&gt;<i>
</I>I'm a bit fuzzy on the details, too :)

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>Not by the design of the compiler. But by how well tested it 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>is. And by 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>how well documented Java (and javacc) is.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>No, I do think it's by the design of the compiler - by the design of 
</I>&gt;&gt;<i>compilers in general.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>ANTLR *is* a compiler.
</I>&gt;<i>  
</I>&gt;<i>
</I>Right, and as such, I believe it can do what &quot;traditional&quot; compilers do: 
hide all the underlying
stuff from the users.

&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Compiler designers take it as a given that users need only know the 
</I>&gt;&gt;<i>syntax/semantics of the input
</I>&gt;&gt;<i>language. If Ter took it as a given that ANTLR4 users need 
</I>&gt;&gt;<i>only know the 
</I>&gt;&gt;<i>syntax/semantics
</I>&gt;&gt;<i>of the input language, he'd end up with a very different tool.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>When using ANTLR, that is all one needs to know. 
</I>&gt;<i>
</I>No. To use ANTLR, you not only need to know the input language (say, C) 
syntax&amp;symantics, you
also need to know:
* The ANTLR syntax&amp;symantics
* How to hook in actions: where do they make sense? What language are 
they in?
* You often need to know details about the code that's generated to 
resolve ambiguities
* You need to know how the grammar maps to an AST structure. It's not 
enough to have a mental
   picture of the input grammar, you need to be able to form a mental 
picture of the AST each time
   you see a chunk of code.

&gt;<i>By knowing even more, it is
</I>&gt;<i>possible to do even more than the &quot;average&quot; ANTLR user.
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>Now with ANTLR V3, not only can you look at the output code 
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>it if you 
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>wish but, for the price of a little more knowledge (i.e. domain 
</I>&gt;&gt;&gt;<i>expertise), you can change it!.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>I can change the bytecode generated by javac, too. If javac let me do 
</I>&gt;&gt;<i>that, it would be an indication
</I>&gt;&gt;<i>to the javac designer that his design is less-than-great.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Or that &quot;the [above average] programmer knows best&quot; to paraphrase the C/C++
</I>&gt;<i>motto.
</I>&gt;<i>
</I>&gt;<i>A compiler designer can't determine the best code to generate for every
</I>&gt;<i>possible situation in advance. 
</I>&gt;<i>
</I>He doesn't need to always generate the best code. It's good enough that 
he just generally do
better than humans do.

&gt;<i>This feature makes the tool more useful - for
</I>&gt;<i>those who care to acquire the knowledge required to use it effectively. It
</I>&gt;<i>empowers knowledgeable users to tailor the output for any given situation.
</I>&gt;<i>  
</I>&gt;<i>
</I>And yet, there is no equivalent in Java - no bytecode tweaking. And no 
one seems to mind.
And there is an equivalent in C/C++ - embedded asm code. That was 
popular 20 years ago,
but today's programmers realize that the assembler is probably better at 
producing good code,
and they don't need every last 1% of performance anyway.

So, I guess we're way off topic :( But thanks for the conversation!
Andy

&gt;<i>
</I>&gt;<i>Micheal
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018201.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018217.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18210">[ date ]</a>
              <a href="thread.html#18210">[ thread ]</a>
              <a href="subject.html#18210">[ subject ]</a>
              <a href="author.html#18210">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
