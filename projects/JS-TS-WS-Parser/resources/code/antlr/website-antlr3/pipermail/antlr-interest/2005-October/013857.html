<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] C++ beginner questions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20C%2B%2B%20beginner%20questions&In-Reply-To=200510031708.j93H8p309646%40shell2.webquarry.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013851.html">
   <LINK REL="Next"  HREF="013860.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] C++ beginner questions</H1>
    <B>Akhilesh Mritunjai</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20C%2B%2B%20beginner%20questions&In-Reply-To=200510031708.j93H8p309646%40shell2.webquarry.com"
       TITLE="[antlr-interest] C++ beginner questions">virtualaspirin at yahoo.com
       </A><BR>
    <I>Mon Oct  3 13:54:37 PDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="013851.html">[antlr-interest] C++ beginner questions
</A></li>
        <LI>Next message: <A HREF="013860.html">[antlr-interest] C++ beginner questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13857">[ date ]</a>
              <a href="thread.html#13857">[ thread ]</a>
              <a href="subject.html#13857">[ subject ]</a>
              <a href="author.html#13857">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Ivan

--- Ian Kaplan &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">iank at bearcave.com</A>&gt; wrote:
&gt;<i>   If the customer's perception of a compiler is that
</I>&gt;<i> it is slow, they
</I>&gt;<i>   may not buy it.  So the speed of a &quot;run once&quot;
</I>
Yes, rather they *will not* buy it if the slow
compiler means that their developers sit around
twiddling fingers for a long time.

But to come at that, lets defines 'slow'. If the
compilation time is insignifant compared to other
overheads, then its not an issue. OTOH, in spaces like
databases, you'll end up seeing SQL interpreter taking
a significant part total time if end users are not
careful enough (eg. not using prepared statements).

A lot of that comes through proper compiler design.
eg. one of the prime reasons why Java, and to some
extent MS C++ and C# compilers, are taking lead
because they allow incremental compilation. Thus a
frontend can give an illusion of code-run-debug-code
cycle with compiler being invisible. Eclipse's java
compiler is written in Java (so is Sun's) and its
beauty is that it gets out of the way. Thus the
perception of time 'wasted' is reduced... a win-win
situation.

&gt;<i>   Your argument seems also revolve around &quot;I can
</I>&gt;<i> find a bunch of Java
</I>&gt;<i>   programmers, but C++ programmers are harder to
</I>&gt;<i> find&quot;.  I'm
</I>
Nope. My argument is that 'good' programmers are hard
to find, and when I actually get them, why should I
waste their time on petty issues like, for example,
finding memory leaks. About the languages, my
perception is that good programmers can be good in any
language they code in. They are not tied to a specific
language. Smart people are not afraid of learning new
things and they learn damn fast.

&gt;<i>   processors.  For example, although parsing a query
</I>&gt;<i> language is relatively straight forward, optimizing 
</I>&gt;<i> it can be non-trivial. The sort of people that can
</I>do 
&gt;<i> this are not easy to find either.
</I>
*grin* so why waste their time on obvious and petty
things ? I'm working on a well known DSL too! And I'd
rather have my team work on solving complex and fun
problems rather than doing menial tasks.

&gt;<i>   I have found that because of the huge Java class
</I>&gt;<i> libraries available, some Java programmers I've 
</I>&gt;<i> worked with do not understand algorithms and data
</I>&gt;<i> structures as well as they should.
</I>
Oh, you forgot STL. Its far... far... richer than
Java's algorithm collection. Again, why blame the
tools ? Should I complain that because eclipse handles
compilation transparently, my team may not know all
compiler options... no I shouldn't! That's not in
their KRA and if and when they'd require it, they're
smart enough to learn in &amp; out of it in hours.

&gt;<i>  For example,
</I>&gt;<i>   I've seen some gross misuse of the Java HashMap. 
</I>
Oh please. Don't tell me you haven't seen any of
pointers, hash_map&lt;char*, SomeType&gt;, etc etc.

I've seen people using a hammer on screws. Should we
start blaming the hammer ? Or should we be straight
and call the 'human' holding it a prime evidence
against Darwin's law of evolution and survival for the
fittest ?

&gt;<i> <A HREF="http://www.bearcave.com/misl/misl_other/economics.">http://www.bearcave.com/misl/misl_other/economics.</A>
</I>&gt;<i> html. We can correspond via email.
</I>
Interesting link. Reading it.

&gt;<i>   If you're developing a software product there will
</I>&gt;<i> be, you hope, a few developers and many users.  So 
</I>&gt;<i> the extra effort that goes into development to 
</I>&gt;<i> produce a better product is something that is
</I>&gt;<i>   amortized over your user base.
</I>
Oh sure. But also factor in things like support.
Coders are fallible. So, what if the product crashes
and burns ? Can you ask them a log file and ship the
patch by monday ? Can you code upgrades fast enough to
keep pace with time and competition 50x your company's
size ?

Also, in a complex project, by the time product ships
(12-18 months), the harware is about 2x faster
overall. So in my opinion going for a 20% increase in
performance at the cost of above points is wrong
unless speed is the make-or-break situation.


&gt;<i>   powerful.  Because of the interpretive overhead of
</I>&gt;<i> Java (and as others have pointed out, the JVM
</I>startup 
&gt;<i> cost) you need to think carefully when choosing to 
</I>&gt;<i> use Java in some performance intensive applications.
</I> 

Well, Java at least has come a long way since 1.1
days.  And for some reasons I think writing a compiler
in Java makes sense. The prime reason is the 'input'.

Input to compilers is not white-noise. It is
structured and generated by either humans or machines
- both exhibiting clear patterns in whatever they
generate. The only difference is that it is situation,
person and machine dependant that what pattern will be
there.

Static compilers (C/C++) do static optimizations. Can
they make optimizations with regard to these patterns
? Nope! JVM (hotspot VM) now has a run-time profiler
that provides feedback to JIT. It can at run time find
critical portions and optimize them through a number
of ways implemented right now and in time to come. So
the speed of execution on any non-trivial amount of
input will increase over time... something that static
compilers will never be able to do.

(That is exactly how java version of my compiler beat
the C++ version. The input was 8MB script generated
code. The JVM figured it out and optimized the
particular code path while C++ one just kept fighting
branch mispredictions and RefCount'ed GC overheads).

- Akhilesh



		
__________________________________ 
Yahoo! Mail - PC Magazine Editors' Choice 2005 
<A HREF="http://mail.yahoo.com">http://mail.yahoo.com</A>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013851.html">[antlr-interest] C++ beginner questions
</A></li>
	<LI>Next message: <A HREF="013860.html">[antlr-interest] C++ beginner questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13857">[ date ]</a>
              <a href="thread.html#13857">[ thread ]</a>
              <a href="subject.html#13857">[ subject ]</a>
              <a href="author.html#13857">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
