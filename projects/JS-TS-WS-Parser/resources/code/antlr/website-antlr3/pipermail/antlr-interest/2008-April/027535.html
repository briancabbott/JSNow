<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] advocacy of C++ support in ANTLR 3.x
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20advocacy%20of%20C%2B%2B%20support%20in%20ANTLR%203.x&In-Reply-To=%3Cb4443b867f63b447abb65e98083cbb14%40temporal-wave.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027527.html">
   <LINK REL="Next"  HREF="027560.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] advocacy of C++ support in ANTLR 3.x</H1>
    <B>Jim Idle</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20advocacy%20of%20C%2B%2B%20support%20in%20ANTLR%203.x&In-Reply-To=%3Cb4443b867f63b447abb65e98083cbb14%40temporal-wave.com%3E"
       TITLE="[antlr-interest] advocacy of C++ support in ANTLR 3.x">jimi at temporal-wave.com
       </A><BR>
    <I>Tue Apr  1 09:53:39 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027527.html">[antlr-interest] advocacy of C++ support in ANTLR 3.x
</A></li>
        <LI>Next message: <A HREF="027560.html">[antlr-interest] advocacy of C++ support in ANTLR 3.x
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27535">[ date ]</a>
              <a href="thread.html#27535">[ thread ]</a>
              <a href="subject.html#27535">[ subject ]</a>
              <a href="author.html#27535">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please read the comments in the source for common tree adaptor and base tree adaptor before attempting this, as well as <A HREF="http://www.antlr.org/api/C/index.html.">http://www.antlr.org/api/C/index.html.</A> 

 

In the C version , all adaptors and so on should return a pointer to pANTLR_BASE_TREE, which should be contained within your own tree nodes (which can contain anything so long as they have an ANTLR_BASE_TREE interface. That interface contains a pointer to the higher level structure, such as COMMON_TREE, which in turn can point to an even higher level tree. But, you need to implement an adaptor, which will handle the tree for you and which the generated code will use. The adaptor needs to provide the methods in the BASE_TREE_ADAPTOR. You can probably create a COMMON adaptor, then install pointers to your own methods for those that won't work as is. To be honest though, I don't know of anyone that is doing this, so you may be pioneering here, though the standard implementation uses the same mechanisms, so it must 'work' ;-)

 

It would seem that in your case you will want both an adaptor and a tree implementation. You might find it just as easy to implement the standard tree, then use a tree grammar to construct your own tree, though you shoudl not HAVE to do this.

 

Jim

 

From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] On Behalf Of Tomas Potrusil
Sent: Tuesday, April 01, 2008 3:58 AM
To: ANTLR
Subject: Re: [antlr-interest] advocacy of C++ support in ANTLR 3.x

 

I was wrong. I do not need to &quot;override&quot; a tree, but a tree adaptor! Investigating the mailing-list and the source code I've found that the generated parser uses just the adapter and not the tree directly. But then there is something strange in the current C runtime:

 

In Java runtime the tree adaptor interface works with &quot;Object&quot; objects only. Of course it must abstract access to real tree nodes - it is an adaptor; not just an object factory.  Terence Parr in a documentation says: &quot;Rather than have a separate factory and adaptor, I've merged them.&quot;

 

The C runtime simulates its Java version, but it doesn't work with void* (&quot;Object&quot; in C) but directly with ANTLR3_BASE_TREE. It is not an adaptor anymore, it is just an object factory. Methods like

ANTLR3_TREE_ADAPTOR::addChild(...adaptor, pANTLR3_BASE_TREE t, pANTLR3_BASE_TREE child)

are useless, because everyone can call t-&gt;addChild(child) directly.

 

This prevents me to use our existing AST C++ classes within ANTLR without &quot;subclassing&quot; them from ANTLR3_COMMON_TREE, doesn't it...

 

Tom

 

From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A>] On Behalf Of Jim Idle
Sent: Monday, March 31, 2008 1:39 AM
To: ANTLR
Subject: Re: [antlr-interest] advocacy of C++ support in ANTLR 3.x

 

You will probably find it best to override pANTLR3_COMMON_TREE by encapsulating this within your own structure, as per the docs. This, as all the structures are, is a set of pointers to functions and you need only override the ones that you have to, just as in Java. Runtime type checking 'can' be an overhead, so i am not sure you would want to do that anyway, but I will contemplate your suggestion of course as it has some merit.

 

Jim

 

From: Tomas Potrusil [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">potrto at centrum.cz</A>] 
Sent: Friday, March 28, 2008 5:43 AM
To: Jim Idle
Cc: ANTLR
Subject: RE: [antlr-interest] advocacy of C++ support in ANTLR 3.x

 

Oh yes, I know. I've already made a prototype implementation of a part of the grammar based on the idea I presented bellow (atom returns [OurNode* result] etc.). It is working but it is a little bit clumsy and I cannot use the resulting AST for a tree parsing - of course, I'm creating my own AST.

 

I've been thinking about the new tree adapter (I was talking about bellow) and probably you are true,  few C++ wrappers could do the work. But there is one inconvenience - there is not an &quot;abstract&quot; tree yet. The most abstract tree is ANTLR3_BASE_TREE_struct which contains children vector and other attributes. The ANTLR3_TREE_struct with only pointers to functions (something like a Java interface) would suit my needs better. Our existing AST nodes solve the storage already... Could you do it, please?

 

Another problem is safety. When somebody call ANTLR3_BASE_TREE_struct::addChild(pANTLR3_BASE_TREE tree) for example, I must trust him that the tree argument is really the tree he is calling. I cannot write dynamic_cast&lt;MyTreeWrapper&gt;(tree-&gt;super). This cannot be solved in the current C-based system.

 

Tom

 

From: Jim Idle

 

ANTLR 3.1 C target can now incorporate C++ code directly into the grammar and so can easily call your existing C++ code. All you do is compile the C output file as C++ (or rename it to .cpp perhaps). 

Can you try using that and let me know if you think that there is anything that you could do if the runtime was C++ that you can't do right now? I don't really think that there will be.

You need to get the latest 3.1 snapshot from the downloads page and use the ANTLR Tool hjar in there. Then build the ANTLR 3.1 C runtime from the tar.gz in the dist director under the runtime/C directory in the snapshot. 3 or 4 people have successfully integrated their C++ code with the C target now and I think you will have similar success :-)

Jim

 

-----

Hallo,

 

I'm new to the list. I'm trying to use ANTLR for generating a SQL parser because our current parser doesn't support Unicode input - it was generated by Lex/Yacc. We use C++ and we have our own complex AST that is used by a SQL engine already... So my idea is to write a tree adapter that would create our existing AST nodes (they would just inherit ANTLR tree interface).

 

And here comes a problem that ANTLR 3.x doesn't contain support for &quot;pure&quot; C++ implementation. I've just found Jim Idle's &quot;promise&quot;:

 

&gt;<i> Later I may well produce a complete C++ implementation from scratch,
</I>
&gt;<i> however, at this point I am not sure that it buys you anything. Please
</I>
&gt;<i> let me know if there are things you cannot do with the system as it
</I>
&gt;<i> stands (other than access the tokens and so on using C++ objects, which
</I>
&gt;<i> will be done later). 
</I>
 

I know that the problem could be solved with the current system somehow, but it would be probably very ugly. So yes, complete C++ implementation will buy us something! Or we can use ANTLR 2.x...

 

Right now we will probably try to build the AST by hand:

 

atom returns [OurNode* result]

@init { $result = NULL; }

:<i>              NUMBER
</I>
                {

                               std::string str((char*)$NUMBER.text-&gt;chars, $NUMBER.text-&gt;len);

                               $result = new OurNumberNode(str);

                };

 

Or do you have some other ideas?

 

Thanks

 

Tom

 



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20080401/52424eef/attachment-0001.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20080401/52424eef/attachment-0001.html</A> 
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027527.html">[antlr-interest] advocacy of C++ support in ANTLR 3.x
</A></li>
	<LI>Next message: <A HREF="027560.html">[antlr-interest] advocacy of C++ support in ANTLR 3.x
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27535">[ date ]</a>
              <a href="thread.html#27535">[ thread ]</a>
              <a href="subject.html#27535">[ subject ]</a>
              <a href="author.html#27535">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
