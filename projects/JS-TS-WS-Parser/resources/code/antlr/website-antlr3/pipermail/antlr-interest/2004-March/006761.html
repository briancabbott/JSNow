<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] stuff I don't like about ANTLR 2.x
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20stuff%20I%20don%27t%20like%20about%20ANTLR%202.x&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006750.html">
   <LINK REL="Next"  HREF="006772.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] stuff I don't like about ANTLR 2.x</H1>
    <B>matthew ford</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20stuff%20I%20don%27t%20like%20about%20ANTLR%202.x&In-Reply-To="
       TITLE="[antlr-interest] stuff I don't like about ANTLR 2.x">Matthew.Ford at forward.com.au
       </A><BR>
    <I>Sun Mar  7 11:56:15 PST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006750.html">[antlr-interest] stuff I don't like about ANTLR 2.x
</A></li>
        <LI>Next message: <A HREF="006772.html">[antlr-interest] Re: stuff I don't like about ANTLR 2.x
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6761">[ date ]</a>
              <a href="thread.html#6761">[ thread ]</a>
              <a href="subject.html#6761">[ subject ]</a>
              <a href="author.html#6761">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The main thing that gets me about Antlr is the tree construction
manipulation.  It is too easy to get loops in your trees.
Here is my suggestions  for a revised syntax for tree construction. As you
can see they as been around for a while now.
all the best
matthew


Draft specification for Antlr Tree Generation
By Matthew Ford
Revision 1  25th Sept 2001

Section 1:Control of automatic tree generation in the Parser
By default the Parser will automatically generate AST trees.  This
generation can be
disabled globally by setting buildAST=false.

When buildAST=false ALL code related to AST tree building is removed and the
only ways to build your own tree are :-
i) to update a global tree or
ii) use Antlr's return syntax to pass your own tree back.
(Note: in this mode you should not need to link or load any AST code unless
you
reference it yourself from action, etc)

With buildAST = true (that is the default) you can selectively disable tree
generation
by using the ! syntax.  This can be used on either a rule or token basis.
Example of a rule based use of ! to disable tree generation

addition!
    :   INT PLUS i:INT
;

In this case no tree generation code is generated for this rule.  If you
want to create a
tree by hand for this rule you need to return it as shown below
addition returns [AST return_tree]!
   :   INT PLUS i:INT  { .. code to generate return_tree }
;


So I suggest this be relaxed a little to say that
No tree generation code is output except that labels in the rule are
initialized with the
appropiate minimal tree.
For example
&gt;<i> drop_table_statement!
</I>&gt;<i> : &quot;drop&quot; &quot;table&quot; t3:table_name t4:drop_behavior
</I>;
results in #t3 containing tree resulting from the rule table_name
and
statement!
:<i> INT PLUS i:INT
</I>;
would set up a tree for label i consisting of a single root node containing
the INT
token
This allows the user to control what tree code is added to their code if the
tree
generation is turned off for a rule. If there are not labels then no code.


To suppress a single token use ! after the token.  It will not be added to
the tree, eg.
statement
:<i>  lhsVar EQUALS rhs SEMI!  // SEMI is not added to the tree.
</I>;

Note as far as the rule statement is concerned
statement
:<i>   lhsVar EQUALS addition!  // suppress addition of tree returned from
</I>addition
;
addition:
    :   INT PLUS i:INT
;

Is the same as
statement
:<i>   lhsVar EQUALS addition
</I>;
addition!   // suppress generation tree
    :   INT PLUS i:INT
;

But in the second case no rule in the parser can get a tree from the
addition rule.

and
statement
 :  lhsVar EQUALS addition!
;
addition!
    :   INT PLUS i:INT
;

is redundant but legal.

You would probably actually use something like
statement
{AST addTree;}
:<i>   lhsVar EQUALS^ addTree=addition!
</I>   { ## =   build tree here using ## and addTree }
;

addition returns [AST returnTree]
    :   INT PLUS^ i:INT
{ returnTree = ##}  // pick up the autogenerated tree
;

Note: It makes no sense in this system to allow ! to be applied to
alternative of rules
that is :-
statement
{AST addTree;}
:<i>   lhsVar EQUALS^ addTree=addition!
</I>    { ## =   build tree here using ## and addTree }
|<i>!  printstatement
</I>;

is now illegal

In all other cases (that is when buildAST is true and ! is not used) the
return tree is
always generated and assigned to the global AST_return to be picked up by
the parent
rule.  This AST_return can be modified/overwritten using the syntax
discussed below.

Section 2: Syntax for manual modification of trees in the Parser
Note this is for modification of trees that have been automatically created.
If you set
buildAST=false or use ! on a rule, you are on your own as no tree code is
generated
for you.

Tree nodes are created using
#[TOKEN_TYPE] or #[TOKEN_TYPE,&quot;text&quot;]

Trees are created using
#(root, c1, ..., cn)
where
 root must be a node
 c1,to cn are the 1st to nth children which may be either nodes or
other trees.

Elements of the current rule can be addressed using the following
## is a short cut for AST_return, the current result tree.
#id is a short cut for the current tree rooted at the location originally
occupied by the
node labelled by id
@id is a short cut for the root node of the tree rooted at the location
originally
occupied by the node labelled by id
When these occur on the rhs of = they are replaced by clones of their
respective nodes
or trees. This prevents deadly loops.  As an optimisation ## =
#(#[token],##) could be
done without cloning ##.
When these occur on the lhs of = they refer to that location in the tree.
This allows
subtree replacements.

eg
statement
:<i>   lhsVar e:EQUALS^ a:addition
</I>  {
      #a = #(@a,#[INT,&quot;5&quot;],#[INT,&quot;6&quot;]);
     // the children of the addition subtree in the result (##) have been
replace with 5,6
    // a: now refers to the new subtree, the original subtree is has been
replaced by it.
    @a = #[MINUS]
    // the root of the new subtree a is now MINUS
   ## = #(#[STATEMENT],##);
   // add a node to the top of the result tree.  a: and e: still point to
the same subtrees.
  ## = #[DIV];
  // where do a: and e: point now?  They still point to there subtrees which
are not
released until the rule returns.
 // so the following is valid
  ## = #(@#,#a,#[INT,&quot;3&quot;],#a);
   // @# is the root node of ##  which is now just #[DIV]
   // note it is valid to use #a twice as it is cloned.
}
;


----- Original Message ----- 
From: &quot;Terence Parr&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt;
To: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>&gt;
Sent: Sunday, March 07, 2004 7:05 AM
Subject: [antlr-interest] stuff I don't like about ANTLR 2.x


&gt;<i> Folks,
</I>&gt;<i>
</I>&gt;<i> In preparation for the ANTLR 3.0 whitepaper, I need to start writing
</I>&gt;<i> down everything that annoys me about ANTLR 2.0.  I have started another
</I>&gt;<i> &quot;blog&quot; document:
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://www.antlr.org/blog/antlr3/antlr2.bashing.tml">http://www.antlr.org/blog/antlr3/antlr2.bashing.tml</A>
</I>&gt;<i>
</I>&gt;<i> Feel free to send in your pet peeves to me or to this list.  I will try
</I>&gt;<i> to add to this file.
</I>&gt;<i>
</I>&gt;<i> I can hear John Mitchell now: &quot;predicate hoisting!&quot; ;)
</I>&gt;<i>
</I>&gt;<i> Terence
</I>&gt;<i> --
</I>&gt;<i> Professor Comp. Sci., University of San Francisco
</I>&gt;<i> Creator, ANTLR Parser Generator, <A HREF="http://www.antlr.org">http://www.antlr.org</A>
</I>&gt;<i> Cofounder, <A HREF="http://www.jguru.com">http://www.jguru.com</A>
</I>&gt;<i> Cofounder, <A HREF="http://www.knowspam.net">http://www.knowspam.net</A> enjoy email again!
</I>&gt;<i> Cofounder, <A HREF="http://www.peerscope.com">http://www.peerscope.com</A> pure link sharing
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yahoo! Groups Links
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>

 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
     <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
     <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
     <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 
-------------- next part --------------
Draft specification for Antlr Tree Generation
By Matthew Ford 
Revision 1  25th Sept 2001

Section 1:Control of automatic tree generation in the Parser
By default the Parser will automatically generate AST trees.  This generation can be 
disabled globally by setting buildAST=false.  

When buildAST=false ALL code related to AST tree building is removed and the 
only ways to build your own tree are :-
i) to update a global tree or 
ii) use Antlr's return syntax to pass your own tree back.
(Note: in this mode you should not need to link or load any AST code unless you 
reference it yourself from action, etc)

With buildAST = true (that is the default) you can selectively disable tree generation 
by using the ! syntax.  This can be used on either a rule or token basis.
Example of a rule based use of ! to disable tree generation

addition!
    :   INT PLUS i:INT
;

In this case no tree generation code is generated for this rule.  If you want to create a 
tree by hand for this rule you need to return it as shown below
addition returns [AST return_tree]!
   :   INT PLUS i:INT  { .. code to generate return_tree }
;


So I suggest this be relaxed a little to say that 
No tree generation code is output except that labels in the rule are initialized with the 
appropiate minimal tree. 
For example 
&gt;<i> drop_table_statement!
</I>&gt;<i> : &quot;drop&quot; &quot;table&quot; t3:table_name t4:drop_behavior 
</I>;
results in #t3 containing tree resulting from the rule table_name 
and 
statement! 
:<i> INT PLUS i:INT 
</I>; 
would set up a tree for label i consisting of a single root node containing the INT 
token 
This allows the user to control what tree code is added to their code if the tree 
generation is turned off for a rule. If there are not labels then no code. 


To suppress a single token use ! after the token.  It will not be added to the tree, eg.
statement
:<i>  lhsVar EQUALS rhs SEMI!  // SEMI is not added to the tree.
</I>;

Note as far as the rule statement is concerned 
statement
:<i>   lhsVar EQUALS addition!  // suppress addition of tree returned from addition
</I>;
addition:
    :   INT PLUS i:INT
;

Is the same as 
statement
:<i>   lhsVar EQUALS addition
</I>;
addition!   // suppress generation tree
    :   INT PLUS i:INT
;

But in the second case no rule in the parser can get a tree from the addition rule.

and  
statement
 :  lhsVar EQUALS addition!
;
addition!
    :   INT PLUS i:INT
;

is redundant but legal.

You would probably actually use something like
statement
{AST addTree;}
:<i>   lhsVar EQUALS^ addTree=addition!
</I>   { ## =   build tree here using ## and addTree }
;

addition returns [AST returnTree]
    :   INT PLUS^ i:INT
{ returnTree = ##}  // pick up the autogenerated tree
;

Note: It makes no sense in this system to allow ! to be applied to alternative of rules 
that is :-
statement
{AST addTree;}
:<i>   lhsVar EQUALS^ addTree=addition!
</I>	   { ## =   build tree here using ## and addTree }
|<i>!  printstatement
</I>;

is now illegal

In all other cases (that is when buildAST is true and ! is not used) the return tree is 
always generated and assigned to the global AST_return to be picked up by the parent 
rule.  This AST_return can be modified/overwritten using the syntax discussed below.

Section 2: Syntax for manual modification of trees in the Parser
Note this is for modification of trees that have been automatically created.  If you set 
buildAST=false or use ! on a rule, you are on your own as no tree code is generated 
for you.

Tree nodes are created using
#[TOKEN_TYPE] or #[TOKEN_TYPE,&quot;text&quot;] 

Trees are created using 
#(root, c1, ..., cn)
where
 root must be a node
 c1,to cn are the 1st to nth children which may be either nodes or 
other trees.

Elements of the current rule can be addressed using the following
## is a short cut for AST_return, the current result tree.
#id is a short cut for the current tree rooted at the location originally occupied by the 
node labelled by id
@id is a short cut for the root node of the tree rooted at the location originally 
occupied by the node labelled by id
When these occur on the rhs of = they are replaced by clones of their respective nodes 
or trees. This prevents deadly loops.  As an optimisation ## = #(#[token],##) could be 
done without cloning ##.
When these occur on the lhs of = they refer to that location in the tree. This allows 
subtree replacements.

eg
statement
:<i>   lhsVar e:EQUALS^ a:addition
</I>  { 
      #a = #(@a,#[INT,&quot;5&quot;],#[INT,&quot;6&quot;]);   
     // the children of the addition subtree in the result (##) have been replace with 5,6
    // a: now refers to the new subtree, the original subtree is has been replaced by it.
    @a = #[MINUS]
    // the root of the new subtree a is now MINUS
   ## = #(#[STATEMENT],##);
   // add a node to the top of the result tree.  a: and e: still point to the same subtrees.
  ## = #[DIV];
  // where do a: and e: point now?  They still point to there subtrees which are not 
released until the rule returns.
 // so the following is valid
  ## = #(@#,#a,#[INT,&quot;3&quot;],#a);
   // @# is the root node of ##  which is now just #[DIV]
   // note it is valid to use #a twice as it is cloned.
}
;

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006750.html">[antlr-interest] stuff I don't like about ANTLR 2.x
</A></li>
	<LI>Next message: <A HREF="006772.html">[antlr-interest] Re: stuff I don't like about ANTLR 2.x
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6761">[ date ]</a>
              <a href="thread.html#6761">[ thread ]</a>
              <a href="subject.html#6761">[ subject ]</a>
              <a href="author.html#6761">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
