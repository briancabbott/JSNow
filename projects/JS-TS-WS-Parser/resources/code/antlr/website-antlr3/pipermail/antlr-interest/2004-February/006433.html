<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] FEATURE REQUEST: std::stream -- remove
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20FEATURE%20REQUEST%3A%20std%3A%3Astream%20--%20remove&In-Reply-To=BC54EAFC.2F22B%25sunshine%40public.kherson.ua">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006429.html">
   <LINK REL="Next"  HREF="006435.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] FEATURE REQUEST: std::stream -- remove</H1>
    <B>Arnar Birgisson</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20FEATURE%20REQUEST%3A%20std%3A%3Astream%20--%20remove&In-Reply-To=BC54EAFC.2F22B%25sunshine%40public.kherson.ua"
       TITLE="[antlr-interest] FEATURE REQUEST: std::stream -- remove">arnarb at oddi.is
       </A><BR>
    <I>Mon Feb 16 02:03:26 PST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006429.html">[antlr-interest] FEATURE REQUEST: std::stream -- remove
</A></li>
        <LI>Next message: <A HREF="006435.html">[antlr-interest] FEATURE REQUEST: std::stream -- remove
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6433">[ date ]</a>
              <a href="thread.html#6433">[ thread ]</a>
              <a href="subject.html#6433">[ subject ]</a>
              <a href="author.html#6433">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello all,

Sun, 15. Feb 2004 kl. 09:23:08 +0200 skrifa&#173;i Ruslan Zasukhin:
&gt;<i> So I dream, that ANTLR C++ runtime sources of Lexer / Parser
</I>&gt;<i> depend NOT on std::streams, but on some C++ interface class of stream
</I>&gt;<i> 
</I>&gt;<i>     I_Istream
</I>&gt;<i>     I_OStream
</I>
I beg to differ. I see the std::stream definition as an interface declaration, since there are many implementations of it. Therefore, I see no reason why ANTLR should implement another interface layer to encapsulate the std::stream interface.

The std::stream library was designed (IMHO successfully) to be easy to extend and tack on top of various input/output systems. Having such a standard greatly simplifies development in my case, instead of each library or project you use having it's own interface declarations. That only means that in your own project, you need wrappers to make all those stream interfaces work together, which is kind of ironic if most of them use the same stream implementation behind those interfaces.

I say ANTLR should stick to std::stream, whereas that is already such an interface as you describe, and a standard one too. Chances are that users already have std::stream wrappers for their custom streams (at least that has been my case).

&gt;<i> And ANTLR distribution have include implementation of these interfaces for
</I>&gt;<i> STD::stream.
</I>&gt;<i> 
</I>&gt;<i> 1) STD::streams will be encapsulated into this .cpp file only
</I>&gt;<i> 
</I>&gt;<i> 2) we will get ability to use other implementations of streams if we need.
</I>&gt;<i> 
</I>&gt;<i> For example, in our Valentina DBMS we have own such stream interfaces,
</I>&gt;<i> And we have a lots of implementations of them
</I>&gt;<i>     Stream on STD file
</I>&gt;<i>     Stream on our own file class
</I>&gt;<i>     Stream on socket
</I>&gt;<i>     Stream on Cached Files.
</I>&gt;<i> 
</I>&gt;<i> As you know DBMS have caching, and we can use files via our own caching.
</I>&gt;<i> But because ANTLR depend on std::stream we cannot use caching files with it.
</I>&gt;<i> This put down performance.
</I>
Writing std::stream implementations is easy, usually only a matter of extending std::streambuf. -- In your case, writing a std::stream wrapper over your interfaces is also an option, and could benefit you in more librarires than just ANTLR.

&gt;<i> I believe using of interfaces is flexible and good OO design feature.
</I>
This is a very good point, and I totally agree. However, in my opinion, std::stream is just an interface declaration (and a good one), not an implementation. For that we have SGI, Microsoft, etc.

Arnar


 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
     <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
     <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
     <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006429.html">[antlr-interest] FEATURE REQUEST: std::stream -- remove
</A></li>
	<LI>Next message: <A HREF="006435.html">[antlr-interest] FEATURE REQUEST: std::stream -- remove
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6433">[ date ]</a>
              <a href="thread.html#6433">[ thread ]</a>
              <a href="subject.html#6433">[ subject ]</a>
              <a href="author.html#6433">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
