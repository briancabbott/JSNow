<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=452D3180.2070907%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017895.html">
   <LINK REL="Next"  HREF="017908.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Loring Craymer</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=452D3180.2070907%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">lgcraymer at yahoo.com
       </A><BR>
    <I>Wed Oct 11 18:00:10 PDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="017895.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="017908.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17906">[ date ]</a>
              <a href="thread.html#17906">[ thread ]</a>
              <a href="subject.html#17906">[ subject ]</a>
              <a href="author.html#17906">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

--- Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
&gt;<i> As for tree structures, the AST shapes are pretty
</I>&gt;<i> arbitrary. Monty's C 
</I>&gt;<i> grammar and the two java.g grammars build
</I>&gt;<i> similar trees, but there are differences where the
</I>&gt;<i> only reason for the 
</I>&gt;<i> difference is &quot;just because it was designed that
</I>&gt;<i> way&quot;.
</I>&gt;<i> With a one dimensional token stream, we don't have
</I>&gt;<i> that problem. There's 
</I>&gt;<i> one less level obstraction between what's
</I>&gt;<i> on the screen and the mental picture in my head. To
</I>&gt;<i> this day, I'm not 
</I>&gt;<i> sure off the top of my head what the AST
</I>&gt;<i> is for, say, &quot;public static void main(String[] args)
</I>&gt;<i> {&quot;. I have trouble 
</I>&gt;<i> keeping the C AST, the Java AST, and the mapping
</I>&gt;<i> between the two in my head all at once. And this is
</I>&gt;<i> the most trivial case!
</I>
There are simpler cases, but this is a pretty fair
example of the conceptual problem.  Visualizing the
tree is usually a distraction; you are a lot closer to
thinking effectively with your &quot;stream of tokens&quot;
model.  The point of the tree structure is to simplify
the recognition problem:  &quot;down&quot; and &quot;right&quot; can be
used to capture distinctions.  ANTLR always does an
inorder traversal of the tree, which translates to a
token sequence.  Ter actually formalized this in the
ANTLR 3 TreeNodeStream:  &quot;DOWN&quot; and &quot;UP&quot; are generated
tokens.

&gt;<i> And yet, as a sequence of tokens, there's no mental
</I>&gt;<i> work at all. What I 
</I>&gt;<i> &quot;see&quot; is the same as my mental image.
</I>&gt;<i> (And what I &quot;see&quot; is a sequence of tokens, not a
</I>&gt;<i> sequence of chars).
</I>&gt;<i> 
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If I were working on a natural language problem,
</I>&gt;<i> would I use trees?  
</I>&gt;<i> &gt; Sure!  Trees are a very convenient way of
</I>&gt;<i> capturing semantics into 
</I>&gt;<i> &gt; syntactic form.  Would I generate output with a
</I>&gt;<i> visitor?  For 
</I>&gt;<i> &gt; Esperanto or one of the Romance languages,
</I>&gt;<i> possibly (for these 
</I>&gt;<i> &gt; languages, simple syntactic principles apply); for
</I>&gt;<i> English, that is 
</I>&gt;<i> &gt; unlikely--too much &quot;peephole&quot; substitution is
</I>&gt;<i> necessary to handle 
</I>&gt;<i> &gt; special cases.  Instead, I would most likely
</I>&gt;<i> process the input into a 
</I>&gt;<i> &gt; canonical tree with a regular structure
</I>&gt;<i> (converting input to tree form 
</I>&gt;<i> &gt; is about transforming the special cases) and do
</I>&gt;<i> some form of 
</I>&gt;<i> &gt; rule-based substitution for all of the nasty
</I>&gt;<i> colloquialisms and other 
</I>&gt;<i> &gt; special cases.  (In compiler parlance, that is
</I>&gt;<i> called &quot;peephole 
</I>&gt;<i> &gt; optimization&quot;, often an essential for generating
</I>&gt;<i> good code.)
</I>&gt;<i> 
</I>&gt;<i> And yet, from what my admitedly feeble research
</I>&gt;<i> found is that NLP 
</I>&gt;<i> systems generally don't use a tree.
</I>&gt;<i> If they do, it's not at the heart of the system -
</I>&gt;<i> they are not &quot;tree 
</I>&gt;<i> processors&quot;.
</I>
NLP (neuro-linguistic processing) is done by wetware. 
Natural language processing, however, is almost always
done with trees masked by &quot;Attribute Grammars&quot;.  [That
is post-parsing; GLR and &quot;Corner Parsing&quot; algorithms
are usually used for recognition, and Europe seems to
be the hotbed for published research in the area.]



&gt;<i> I always thought a &quot;compiler&quot; was just a translator
</I>&gt;<i> that happened to 
</I>&gt;<i> have an output that's at a lower level than the
</I>&gt;<i> input - typically
</I>&gt;<i> machine code, or byte code. But then, I guess I'm
</I>&gt;<i> just remembering an 
</I>&gt;<i> undergrad compiler class from 20 years ago, and the
</I>&gt;<i> dragon book, so I guess I'm no expert.
</I>
I was careful to specify &quot;compiler technology&quot; as
distinguished from production compilers.  Research
compilers often do some very strange (and wonderful)
things.  Also, &quot;lower level&quot; is a subjective
judgement.

&gt;<i> 
</I>&gt;<i> &gt; Nothing that you have described doing is out of
</I>&gt;<i> place in a 
</I>&gt;<i> &gt; conventional compiler environment.  You might find
</I>&gt;<i> it interesting to 
</I>&gt;<i> &gt; take a look at GNU RTL, used to generate the
</I>&gt;<i> peephole optimizer for 
</I>&gt;<i> &gt; the gcc toolset.
</I>&gt;<i> 
</I>&gt;<i> Huh??? That makes no sense to me. I've described
</I>&gt;<i> lots of things that are 
</I>&gt;<i> completely out of place in
</I>&gt;<i> a conventional compiler. A conventional compiler
</I>&gt;<i> doesn't translate 
</I>&gt;<i> library calls, like &quot;printf&quot; to
</I>&gt;<i> &quot;System.out.println&quot;.
</I>&gt;<i> I do stuff like &quot;strcpy(v1, v2) --&gt; v1 = v2&quot;,
</I>&gt;<i> replacing a C strcpy() 
</I>&gt;<i> call with a Java assignment.
</I>&gt;<i> No conventional compiler does anything like that,
</I>&gt;<i> because technically, 
</I>&gt;<i> it's wrong!
</I>
Check out memcpy for gcc targeting an x86 for an
example of a compiler-translated library call.  As for
the assignment, I see nothing wrong; you have added
the restrictions that all strings are read-only.  That
would cause errors if naively translated statements
like &quot;v1[5] = ' ';&quot;, but I assume that you do the
right thing.

&gt;<i> I rename files, methods, and variables based on
</I>&gt;<i> user-specified mappings. 
</I>&gt;<i> Compilers don't do that.
</I>&gt;<i> I could go on.
</I>
Most of the translations are not user-specified, true.
 But any C/C++ compiler renames methods and variables
according to user specifications (macros), and
supports file renaming for output.  

&gt;<i> 
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As to your &quot;unconventional&quot; approach:  I hate to
</I>&gt;<i> say this, but 
</I>&gt;<i> &gt; everything that you have described doing is well
</I>&gt;<i> documented in the 
</I>&gt;<i> &gt; literature.
</I>&gt;<i> 
</I>&gt;<i> Maybe you could point me to something specific.
</I>&gt;<i> Today I'm adding smarts 
</I>&gt;<i> to my GotoRemoverRule that generates code that
</I>&gt;<i> is not faster or more compact than what it was
</I>&gt;<i> producing before, but it 
</I>&gt;<i> looks better to the human eye. I doubt that
</I>&gt;<i> there's any literature on that.
</I>
That sort of thing is usually isolated to &quot;see what I
can do&quot; claims in papers.  Compiler-generated
assembler files are usually quite readable (well, for
assembly language) and that dates back to the days
when it was necessary to claim that &quot;FORTRAN-generated
assembler is as good as (or nearly as good as)
programmer-generated code&quot;.

&gt;<i> 
</I>&gt;<i> &gt; I have noticed that &quot;healthy disrespect for
</I>&gt;<i> conventional approaches&quot; 
</I>&gt;<i> &gt; usually translates to &quot;I never check to see if I
</I>&gt;<i> am reinventing the 
</I>&gt;<i> &gt; wheel or not&quot;.  One of the great resources on the
</I>&gt;<i> web is Citeseer:  
</I>&gt;<i> &gt; &lt;<A HREF="http://citeseer.ist.psu.edu/">http://citeseer.ist.psu.edu/</A>&gt;.  It has some of
</I>&gt;<i> the good early papers 
</I>&gt;<i> &gt; on pattern matching and transformation systems.
</I>&gt;<i> 
</I>&gt;<i> I've looked at many, many papers on those. Can you
</I>&gt;<i> point me to anything 
</I>&gt;<i> specific that you
</I>&gt;<i> think I'm missing?
</I>
No, sorry, you'll have to do your own research.  I
never have enough time to do as much as I would like
for myself!

&gt;<i> 
</I>&gt;<i> I've also noticed that the person who feels like
</I>&gt;<i> they're &quot;breaking new 
</I>&gt;<i> ground&quot; just hasn't done his homework. That's why
</I>&gt;<i> I spend so much time typing here - worried that I
</I>&gt;<i> might be doing that. 
</I>&gt;<i> So I'm not just being defensive,
</I>&gt;<i> 
</I>
This is a user group, not a theory group, so it is not
the ideal forum for this sort of sanity check
(although it is certainly better than none).  I do
have to think that dragging Monty out of  the woodwork
for this discussion was a significant achievement! I
only jumped in after I thought that sanity had
prevailed to make the point that &quot;it's really not the
methodology that's at issue, it's the level of tool
support&quot;.

--Loring
=== message truncated ===


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
<A HREF="http://mail.yahoo.com">http://mail.yahoo.com</A> 
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017895.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="017908.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17906">[ date ]</a>
              <a href="thread.html#17906">[ thread ]</a>
              <a href="subject.html#17906">[ subject ]</a>
              <a href="author.html#17906">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
