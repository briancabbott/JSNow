<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Aggressive vs. Lazy Buffering in ANTLR
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Aggressive%20vs.%20Lazy%20Buffering%20in%20ANTLR&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018883.html">
   <LINK REL="Next"  HREF="018885.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Aggressive vs. Lazy Buffering in ANTLR</H1>
    <B>Foolish Ewe</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Aggressive%20vs.%20Lazy%20Buffering%20in%20ANTLR&In-Reply-To="
       TITLE="[antlr-interest] Aggressive vs. Lazy Buffering in ANTLR">foolishewe at hotmail.com
       </A><BR>
    <I>Tue Dec 19 07:59:47 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018883.html">[antlr-interest] Error report in tree walker after semantic	predicate
</A></li>
        <LI>Next message: <A HREF="018885.html">[antlr-interest] Aggressive vs. Lazy Buffering in ANTLR
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18884">[ date ]</a>
              <a href="thread.html#18884">[ thread ]</a>
              <a href="subject.html#18884">[ subject ]</a>
              <a href="author.html#18884">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi All:

Thanks for the help (especiallly Ter), in a previous e-mail, I suggested 
that aggressive buffering in
in ANTLRInputStream made ANTLR problematic for parsing interactive input, 
since the
ANTRLInputStream constructor blocks on reading all input until EOF into a 
buffer.

However, I tried making a simple input method that uses Lazy buffering (i.e. 
reads characters
on demand extending the buffer).  This lazy input stream no longer blocks on 
the constructor,
however, now I've noticed that the CommonTokenStream constructor appears to 
block.
It appears to be blocking in fillBuffer, but I don't see an explicit call in 
the constructor.
The impact of this is that it negates the interactive support that the lazy 
buffering of my
home-grown input stream class, so I'd like to fix it.

Is there a lazy buffering (buffer as input becomes available/on demand) 
variant of TokenStream
support or have I made some error?

This interactive sort of support might allow ANTLR to be used for a wider 
class of application,
e.g. for parsing piped input (log messages delivered through pipes),
nteractive scripting languages, etc. and may widen the appeal of ANTLR.

Regards:

Bill M.

_________________________________________________________________
Visit MSN Holiday Challenge for your chance to win up to $50,000 in Holiday 
cash from MSN today! 
<A HREF="http://www.msnholidaychallenge.com/index.aspx?ocid=tagline&amp;locale=en-us">http://www.msnholidaychallenge.com/index.aspx?ocid=tagline&amp;locale=en-us</A>

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018883.html">[antlr-interest] Error report in tree walker after semantic	predicate
</A></li>
	<LI>Next message: <A HREF="018885.html">[antlr-interest] Aggressive vs. Lazy Buffering in ANTLR
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18884">[ date ]</a>
              <a href="thread.html#18884">[ thread ]</a>
              <a href="subject.html#18884">[ subject ]</a>
              <a href="author.html#18884">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
