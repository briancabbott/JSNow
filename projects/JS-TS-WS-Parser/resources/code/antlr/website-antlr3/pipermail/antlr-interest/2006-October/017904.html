<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=53D973C8-5EFB-4933-9361-DCE9B9521279%40classdump.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017903.html">
   <LINK REL="Next"  HREF="017905.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=53D973C8-5EFB-4933-9361-DCE9B9521279%40classdump.org"
       TITLE="[antlr-interest] philosophy about translation">antlr at jazillian.com
       </A><BR>
    <I>Wed Oct 11 16:12:11 PDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="017903.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="017905.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17904">[ date ]</a>
              <a href="thread.html#17904">[ thread ]</a>
              <a href="subject.html#17904">[ subject ]</a>
              <a href="author.html#17904">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Andy Tripp wrote:

&gt;<i> Kay Roepke wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 11. Oct 2006, at 22:33 Uhr, Andy Tripp wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Kay Roepke wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> On 11. Oct 2006, at 20:29 Uhr, Andy Tripp wrote:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Don't you have to know the types of the variables used in the  
</I>&gt;&gt;&gt;&gt;<i> source  and destination language? Can you actually do without
</I>&gt;&gt;&gt;&gt;<i> a type system and/or symbol table?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Sure, if you can just call a library function that searches a token  
</I>&gt;&gt;&gt;<i> stream to figure out a variable's type, then you don't
</I>&gt;&gt;&gt;<i> need to keep a separate table.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ok, then it simply boils down to you not being concerned with 
</I>&gt;&gt;<i> redoing  that every time you'd need to know a variable's type, right?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Right. It's just that my getVariableType() method searches a token 
</I>&gt;<i> stream rather than a symbol table, that's all.
</I>&gt;<i>
</I>&gt;&gt;<i> You could of course do the same thing in a tree, traversing it every  
</I>&gt;&gt;<i> time you find a reference to a variable. I think this is bothering 
</I>&gt;&gt;<i> me  the most, I find it hard to grasp why you would like to do the  
</I>&gt;&gt;<i> searching over and over, instead of simply recording the fact that  
</I>&gt;&gt;<i> `foo' was declared as `int' and then use that information further  
</I>&gt;&gt;<i> down the line. 
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As I've said before, the reason is that I'd end up making lots of 
</I>&gt;<i> calls to keep the symbol table up to date. By &quot;lots of calls&quot;
</I>&gt;<i> I mean, writing lines of code. Assuming that it's just as easy to 
</I>&gt;<i> write code (and call it) that looks at the token stream as to look
</I>&gt;<i> at a symbol table, the only reason for a symbol table would be 
</I>&gt;<i> performance, which I'm not concerned about.
</I>&gt;<i>
</I>&gt;&gt;<i> But I agree that from a functionality point of view it  doesn't 
</I>&gt;&gt;<i> matter how you end up knowing the type of something as long  as you 
</I>&gt;&gt;<i> can discover it.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I find it hard to picture doing  the right thing without trees,  
</I>&gt;&gt;&gt;&gt;<i> but then again I might
</I>&gt;&gt;&gt;&gt;<i> be missing a lot.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> As I said, you've got maybe 100,000 lines of code that does all  
</I>&gt;&gt;&gt;<i> kinds of stuff to be able to translate sentences like
</I>&gt;&gt;&gt;<i> &quot;Woods Eyes Masters&quot;. It knows that &quot;Woods&quot; is a person, it knows  
</I>&gt;&gt;&gt;<i> that &quot;Masters&quot; is an upcoming golf tournament.
</I>&gt;&gt;&gt;<i> I knows that this &quot;Woods&quot; person might actually be &quot;eyeing&quot; this  
</I>&gt;&gt;&gt;<i> particular tournament. It knows this is a sports page
</I>&gt;&gt;&gt;<i> headline. It would be able to handle &quot;Andy Masters Woods&quot;, too  
</I>&gt;&gt;&gt;<i> (assuming it knows that I'm working on
</I>&gt;&gt;&gt;<i> my driving skills).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> By the time you've got all that code working, the fact that you're  
</I>&gt;&gt;&gt;<i> using a tree structure is just a very minor footnote.
</I>&gt;&gt;&gt;<i> Your translation above is horribly wrong, and the AST didn't help  
</I>&gt;&gt;&gt;<i> you make it right one bit.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> heh heh. I never said that I actually know any Spanish ;) But I 
</I>&gt;&gt;<i> could  argue along the same lines: With a flat stream approach, you'd 
</I>&gt;&gt;<i> still  build up a hierarchical data structure of some sort to 
</I>&gt;&gt;<i> discover the  structure of sentences. You would have to able to 
</I>&gt;&gt;<i> distinguish various  grammatical structures (of which I simply don't 
</I>&gt;&gt;<i> know the proper  english terms, unfortunately. I'd need to look them 
</I>&gt;&gt;<i> up, which I'm too  lazy right now...), in order to retain the logical 
</I>&gt;&gt;<i> structure of a  sentence. You might not start from an AST, but you 
</I>&gt;&gt;<i> still would  implicitely build one.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yea, maybe. But it's one thing to use a tree-like data structure as 
</I>&gt;<i> one of many data structures during processing.
</I>&gt;<i> It's quite another to architect the whole thing as a &quot;tree-walking 
</I>&gt;<i> approach&quot;.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> When I see a &quot;rule&quot; like
</I>&gt;&gt;&gt;&gt;<i>     v1 = v1 + v2 =&gt; v1 += v2
</I>&gt;&gt;&gt;&gt;<i> I cannot help but seeing a tree.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> That's because it's too trivial of an example, and I think that's  
</I>&gt;&gt;&gt;<i> the trap that people keep falling into.
</I>&gt;&gt;&gt;<i> Try:
</I>&gt;&gt;&gt;<i> ADD A B TO C D GIVING E.
</I>&gt;&gt;&gt;<i> NAME PIX 9(5)V99 VALUE ALL SPACES.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> or
</I>&gt;&gt;&gt;<i> main(int argc, char *argv[]);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The first ones is hard for you picture as a tree because it's COBOL  
</I>&gt;&gt;&gt;<i> and you don't even know right off
</I>&gt;&gt;&gt;<i> what they MEAN. As for the C example, I have trouble remembering  
</I>&gt;&gt;&gt;<i> what the tree is for &quot;*argv[]&quot;,
</I>&gt;&gt;&gt;<i> and I'm frustrated that I'll have to deal with &quot;char *argv[]&quot;,  
</I>&gt;&gt;&gt;<i> &quot;char **argv&quot;, &quot;char argv[][]&quot;, etc. individually.
</I>&gt;&gt;&gt;<i> I'd rather just once map them all to a single form by doing stuff  
</I>&gt;&gt;&gt;<i> like:
</I>&gt;&gt;&gt;<i> char **v --&gt; char *v[]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> True enough, things can get complicated real quick. But isn't the  
</I>&gt;&gt;<i> value of an AST that you can formulate &quot;rules&quot; on the basis of the  
</I>&gt;&gt;<i> _abstract_ structure of the input? How would you model something 
</I>&gt;&gt;<i> like  this with your rule based system? E.g.:
</I>&gt;&gt;<i> char **v vs. int **v vs. id *someObject (id being the generic  
</I>&gt;&gt;<i> _pointer_ to an object in Objective-C) ?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In my pattern matching system, I have simple &quot;placeholders&quot;. I'd say:
</I>&gt;<i> v1 **v2 --&gt; v1 v2[][];
</I>&gt;<i> The &quot;v1&quot; and &quot;v2&quot; will match only simple single-ID tokens (like &quot;int&quot;) 
</I>&gt;<i> and things that look like variable references
</I>&gt;<i> (like foo[3].bar). I also have an &quot;x&quot; placeholder that matches &quot;zero 
</I>&gt;<i> or more characters&quot; and handles
</I>&gt;<i> nesting of braces like this:
</I>&gt;<i>
</I>&gt;<i> if (true) {x2} --&gt; x2
</I>&gt;<i>
</I>&gt;&gt;<i> Would you need one rule for each supported type instead of one rule  
</I>&gt;&gt;<i> for all non-pointer types and one exception for pointer types?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If things get non-trivial, I can mix this pattern language with code. 
</I>&gt;<i> For example, to verify that
</I>&gt;<i> the &quot;v1&quot; in v1 **v2 --&gt; v1 v2[][];&quot; really is a type, I could say 
</I>&gt;<i> something like:
</I>&gt;<i>
</I>&gt;<i> class StarChecker extends PatternRule {
</I>&gt;<i>    StarChecker() {
</I>&gt;<i>         super(&quot;v1 ** v2&quot;, &quot;v1 v2[][]&quot;);
</I>&gt;<i>   }
</I>&gt;<i>   boolean match(Source source) {
</I>&gt;<i>        if (super.match(source)) {
</I>&gt;<i>            String v1 = results.get(&quot;v1&quot;);    // get the text that &quot;v1&quot; 
</I>&gt;<i> placeholder matched
</I>&gt;<i>            if (source.isType(v1)) {           // verify that it's 
</I>&gt;<i> really a type (e.g. using symbol table)
</I>&gt;<i>                return true;
</I>&gt;<i>            }
</I>&gt;<i>         }
</I>&gt;<i>         return false;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> In the end, it's just another way to  specify a transformation, is  
</I>&gt;&gt;&gt;&gt;<i> it not? I mean, what is the
</I>&gt;&gt;&gt;&gt;<i> fundamental difference? Tokens that are close to each other in a   
</I>&gt;&gt;&gt;&gt;<i> token stream most often end up close to each other in a tree for
</I>&gt;&gt;&gt;&gt;<i> some metric, aren't they? Ok, they might end up in different  
</I>&gt;&gt;&gt;&gt;<i> branches  from a common interior node, but for really nasty stuff  
</I>&gt;&gt;&gt;&gt;<i> like
</I>&gt;&gt;&gt;&gt;<i> variable decl vs. usage you have symbol tables. I feel like I'm   
</I>&gt;&gt;&gt;&gt;<i> missing some important information here.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think one thing that maybe you're missing is the scope of the  
</I>&gt;&gt;&gt;<i> problem that I'm dealing with.
</I>&gt;&gt;&gt;<i> You refer to &quot;variable decl vs. usage&quot; as &quot;really nasty stuff&quot;.  
</I>&gt;&gt;&gt;<i> Using token streams, I find a declaration
</I>&gt;&gt;&gt;<i> by looking backwards for pattern &quot;&lt;type&gt; v;&quot; or &quot;&lt;type&gt; v =&quot;. If I  
</I>&gt;&gt;&gt;<i> don't find that pattern, I search other files
</I>&gt;&gt;&gt;<i> for that pattern. That's pretty trivial code to search for that  
</I>&gt;&gt;&gt;<i> pattern, starting at a given token. That's not the
</I>&gt;&gt;&gt;<i> &quot;nasty stuff&quot;, that's the trivial stuff!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sorry, I wasn't clear. Simply recording the type of a variable is  
</I>&gt;&gt;<i> trivial. I was referring to the proximity of those nodes in the tree,
</I>&gt;&gt;<i> which could make it &quot;nasty&quot; in terms of traversal needed to find the  
</I>&gt;&gt;<i> declaration when you see a usage.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Seems pretty trivial to find the variable declaration either way.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The nasty stuff is things like looking at a variable that's an  
</I>&gt;&gt;&gt;<i> &quot;int&quot; or &quot;long&quot;
</I>&gt;&gt;&gt;<i> type, looking at every reference to see if it will be possible to  
</I>&gt;&gt;&gt;<i> change the variable type to &quot;boolean&quot;, and then
</I>&gt;&gt;&gt;<i> doing so. Or looking at a pointer declaration and all its usages to  
</I>&gt;&gt;&gt;<i> see what the Java equivalent really is:
</I>&gt;&gt;&gt;<i> is it used solely as an array index? (if so, we'll replace the  
</I>&gt;&gt;&gt;<i> pointer by an &quot;int&quot;, change the thing it points to
</I>&gt;&gt;&gt;<i> into an array, and change the syntax of every reference) Or is it a  
</I>&gt;&gt;&gt;<i> real pointer type, such
</I>&gt;&gt;&gt;<i> as in a LinkedList? Or is it just a pointer
</I>&gt;&gt;&gt;<i> so that we can pass an address to a function and have the function  
</I>&gt;&gt;&gt;<i> change the value? This kind of analysis
</I>&gt;&gt;&gt;<i> needs lots of heuristics and lots of work. So I sometimes feel like  
</I>&gt;&gt;&gt;<i> I'm just getting started when everyone else
</I>&gt;&gt;&gt;<i> has already given up.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think most people here would get to &quot;memset()&quot; and simply say  
</I>&gt;&gt;&gt;<i> &quot;sorry, there's no
</I>&gt;&gt;&gt;<i> Java equivalent&quot;, whereas I would then get going listing out the  
</I>&gt;&gt;&gt;<i> common cases: is memset being
</I>&gt;&gt;&gt;<i> used to initialize a variable which will automatically be  
</I>&gt;&gt;&gt;<i> guaranteed to be initialized in Java? Or do I need to
</I>&gt;&gt;&gt;<i> generate some initialization code? Can it just be replaced by a  
</I>&gt;&gt;&gt;<i> single &quot;new&quot; call? And so on.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think this where it gets interesting, too. Actually the lack of  
</I>&gt;&gt;<i> tools that produce natural code in the target language is probably  
</I>&gt;&gt;<i> the most important reason why many people wouldn't even consider  
</I>&gt;&gt;<i> using a language translator for any sizable codebase, which has to 
</I>&gt;&gt;<i> be  maintained thereafter.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Right. I'm trying to change the dynamics on that and get people to 
</I>&gt;<i> believe that it can be done.
</I>&gt;<i> I believe my product does it, but it's still a tough sell. About 1/3 
</I>&gt;<i> of the people who come up to our booth
</I>&gt;<i> at tradeshows are &quot;skeptics&quot;. They come up, take a quick look, and 
</I>&gt;<i> then ask &quot;how do you handle unions?&quot; or
</I>&gt;<i> &quot;...memset?&quot; or &quot;multiple inheritence.&quot; By the time I've started 
</I>&gt;<i> explaining about how memset is almost always
</I>&gt;<i> used to initialize a struct to zero, and we check for that sort of 
</I>&gt;<i> thing, they walk away. It's how we programmers
</I>&gt;<i> naturally are: we sure want our compilers to work 100%, and it seems 
</I>&gt;<i> like a translator should, too. So since
</I>&gt;<i> it's impossible, in theory, we go back and do it by hand (or don't do 
</I>&gt;<i> it). It never occurs to us that someone could simply
</I>&gt;<i> automate the stuff that everyone's doing by hand and save everyone 90% 
</I>&gt;<i> of the time and effort.
</I>&gt;<i>
</I>&gt;<i> The traveling salesman problem is NP-complete, and yet we have no 
</I>&gt;<i> problem using algorithms that are less than
</I>&gt;<i> perfect do the best they can because they're so much better than 
</I>&gt;<i> humans. It's a shame we can't seem to take
</I>&gt;<i> the same approach with rewriting code to a new language.
</I>&gt;<i>
</I>&gt;&gt;<i> Myself included. I have never considered even to look for a Java to  
</I>&gt;&gt;<i> Objective-C translator to port StringTemplate, for instance. Not 
</I>&gt;&gt;<i> that  I'd think there is anything like that, but still.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Thanks for the input. I think your response to translating &quot;Woods  
</I>&gt;&gt;&gt;<i> Eyes Masters&quot; illustrates my point perfectly.
</I>&gt;&gt;&gt;<i> That is, for real NLP, treewalking solves nothing. It's simply one  
</I>&gt;&gt;&gt;<i> way to start approaching the problem,
</I>&gt;&gt;&gt;<i> and by the time you tackle all the hard issues, treewalking is just  
</I>&gt;&gt;&gt;<i> a tiny piece of the work, and it's not clear (to me)
</I>&gt;&gt;&gt;<i> that it's even adding anything. To me, saying &quot;high-level language  
</I>&gt;&gt;&gt;<i> translation is mostly a matter of walking an AST&quot;
</I>&gt;&gt;&gt;<i> is like saying &quot;Getting from NYC to LA is mostly a matter of  
</I>&gt;&gt;&gt;<i> getting on a plane&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not an expert in linguistics, far from it, so I can't really say  
</I>&gt;&gt;<i> anything for NLP. 
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yea, me neither. I was pretty shocked at how different the NLP 
</I>&gt;<i> approaches are from &quot;compiler&quot; approaches.
</I>&gt;<i> Seemed like zero overlap. I'm still pretty shocked at how bad NLP 
</I>&gt;<i> seems to be, but I guess I have just
</I>&gt;<i> one data point: babelfish.
</I>&gt;<i>
</I>&gt;&gt;<i> But for artificial languages I think it helps  solving real problems. 
</I>&gt;&gt;<i> I don't think it is an accident that trees are  in use for these 
</I>&gt;&gt;<i> things for such a long time (scale: comp.sci.).  Surely, it is a 
</I>&gt;&gt;<i> silver bullet, as you have demonstrated. If it was  the only way to 
</I>&gt;&gt;<i> get things done, you couldn't have built what you  have built.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yea, that may be true. But if
</I>&gt;&gt;&gt;<i> you're going to program a robot to get from NYC to LA, getting on  
</I>&gt;&gt;&gt;<i> the plane will be just one tiny piece. To the
</I>&gt;&gt;&gt;<i> point where it doesn't really matter whether the robot takes a  
</I>&gt;&gt;&gt;<i> plane or a car.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> :D
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> cheers,
</I>&gt;&gt;<i> -k
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017903.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="017905.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17904">[ date ]</a>
              <a href="thread.html#17904">[ thread ]</a>
              <a href="subject.html#17904">[ subject ]</a>
              <a href="author.html#17904">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
