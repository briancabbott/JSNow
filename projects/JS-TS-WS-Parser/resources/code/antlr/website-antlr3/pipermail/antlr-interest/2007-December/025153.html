<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] NQOT: Grammar meta-programming
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20NQOT%3A%20Grammar%20meta-programming&In-Reply-To=%3Cb8ceeef70712081854j31d91e26i77635a8ec347109b%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025136.html">
   <LINK REL="Next"  HREF="025141.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] NQOT: Grammar meta-programming</H1>
    <B>Steve Bennett</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20NQOT%3A%20Grammar%20meta-programming&In-Reply-To=%3Cb8ceeef70712081854j31d91e26i77635a8ec347109b%40mail.gmail.com%3E"
       TITLE="[antlr-interest] NQOT: Grammar meta-programming">stevagewp at gmail.com
       </A><BR>
    <I>Sat Dec  8 18:54:08 PST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="025136.html">[antlr-interest] NQOT: Grammar meta-programming
</A></li>
        <LI>Next message: <A HREF="025141.html">[antlr-interest] NQOT: Grammar meta-programming
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25153">[ date ]</a>
              <a href="thread.html#25153">[ thread ]</a>
              <a href="subject.html#25153">[ subject ]</a>
              <a href="author.html#25153">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/8/07, Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
&gt;<i>  It does seem like you could get 90% of the way in parsing languages like C,
</I>&gt;<i> C++, Java, and C#
</I>&gt;<i>  with some generic scheme. But in practice,  it turns out to  be  less than
</I>&gt;<i> 10%. That's because
</I>&gt;<i>  a *basic* parser, which covers most of the language, seems like it's 90% of
</I>&gt;<i> the effort, but it's
</I>&gt;<i>  really only 10%. So let's say your *basic* parser covers expressions, flow
</I>&gt;<i> control, and function declarations.
</I>&gt;<i>  Great! Now start on function pointers, templates/generics, operator
</I>&gt;<i> overloading,
</I>&gt;<i>  preprocessor directives, typedef, etc. What's the saying? &quot;In software, the
</I>&gt;<i> first 90% takes 90% of the time,
</I>&gt;<i>  and the last 10% takes the OTHER 90% of the time&quot; :)
</I>
Yep, that wouldn't surprise me. However, if the goal is to be able to
handle esoteric languages (particularly where the syntax could be
tweaked) most of these really horrible aspects probably won't be
present. Well, that's my understanding of esoteric languages - odd
syntax, odd semantics, but generally straightforward to parse.

&gt;<i>  Then try it on real-world programs, and you'll be amazed at
</I>&gt;<i>  what strange syntax is actually considered valid (especially in C++). Your
</I>&gt;<i> parser fails, you
</I>
C++ is not a language anyone in their right mind would want to try and
parse. Ever. I should have ruled it out.

&gt;<i>  And that's not even mentioning column-based formatting (FORTRAN, COBOL),
</I>&gt;<i>  and constructs within the program that can change how the program should be
</I>&gt;<i> parsed (COBOL).
</I>
Those would probably be outside the immedate grouping of languages to
be dealt with.


&gt;<i>  Beyond just successful parsing, there's the issue of creating a reasonable
</I>&gt;<i> AST.
</I>&gt;<i>  As a simple example, the return type of a C/C++ function is optional, but
</I>&gt;<i> you might want
</I>&gt;<i>  the AST to have a return type. So you want to stuff an &quot;int&quot; node in the
</I>&gt;<i> AST during parsing.
</I>&gt;<i>  Or you might want to building symbol tables during parsing.
</I>
That doesn't strike me as patricularly remarkable semantics.

&gt;<i>
</I>&gt;<i>  So for any real-world app, you could copy-and-paste some common parts of a
</I>&gt;<i> grammar
</I>&gt;<i>  (such as grabbing the expression-part of a C grammar for use in your Java
</I>&gt;<i> grammar), or
</I>&gt;<i>  you could come up with some fancy generic mechanism. Either way, that work
</I>&gt;<i> is going to
</I>&gt;<i>  be a tiny amount of the total work (say 0.01%) anyway.
</I>
I think it'll be more than that...perhaps I'm really thinking in terms
of a rapid prototyping tool, rather than a genuine solution for
building industrial strength parsers.

&gt;<i>  One way to approach this is to compare the C and Java ANTLR grammars.
</I>&gt;<i> You'll see that
</I>&gt;<i>  these apparently similar languages don't have all that much in common in
</I>&gt;<i> their grammars.
</I>
Interesting.
&gt;<i>  On the other hand...one approach I've thought about would be to use
</I>&gt;<i> programming-by-example.
</I>&gt;<i>  You feed your magic tool sets of examples: &quot;Here is a program, and here is
</I>&gt;<i> the AST that
</I>&gt;<i>  it should produce&quot;. If you can make your set of examples exhaustive (i.e.
</I>&gt;<i> cover all language
</I>&gt;<i>  constructs), that seems like it might work.
</I>
Yeah. Or even, &quot;Translate the following pseudo code into your
language.&quot; Then the metaparser will know the meaning of your code
without you having to explicitly write the AST.

Steve
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025136.html">[antlr-interest] NQOT: Grammar meta-programming
</A></li>
	<LI>Next message: <A HREF="025141.html">[antlr-interest] NQOT: Grammar meta-programming
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25153">[ date ]</a>
              <a href="thread.html#25153">[ thread ]</a>
              <a href="subject.html#25153">[ subject ]</a>
              <a href="author.html#25153">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
