<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] postmortem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3C47D94198.6040107%40jazillian.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027173.html">
   <LINK REL="Next"  HREF="027193.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] postmortem</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3C47D94198.6040107%40jazillian.com%3E"
       TITLE="[antlr-interest] postmortem">antlr at jazillian.com
       </A><BR>
    <I>Thu Mar 13 08:00:40 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027173.html">[antlr-interest] postmortem
</A></li>
        <LI>Next message: <A HREF="027193.html">[antlr-interest] postmortem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27185">[ date ]</a>
              <a href="thread.html#27185">[ thread ]</a>
              <a href="subject.html#27185">[ subject ]</a>
              <a href="author.html#27185">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thomas Brandon wrote:
&gt;<i> On Thu, Mar 13, 2008 at 7:58 AM, Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt; wrote:
</I>&gt;<i>   
</I>&gt;&gt;<i>  Jim Idle wrote:
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i> I think you miss the point. We can't 'know' that they did or didn't want a
</I>&gt;&gt;&gt;<i> flat tree. Who is this someone that you are designating tasks like this to?
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Well, we can't &quot;know' anything about what anyone wants, in general. The best
</I>&gt;&gt;<i>  we can do is make a best guess. And I think the best guess is that most
</I>&gt;&gt;<i> ANTLR users want a non-flat AST.
</I>&gt;&gt;<i>     
</I>&gt;<i> Yes, most ANTLR users want a non-flat tree. But most (if not all) of
</I>&gt;<i> these users do not want a parse tree. 
</I>Agreed. But keep in mind that for many applications, simply walking the 
AST by hand is enough.
&gt;<i> The parse trees generated by
</I>&gt;<i> ANTLR are not just like ASTs and cannot be used as such. Parse trees
</I>&gt;<i> consist of standard AST nodes for all the actual language nodes and
</I>&gt;<i> special parse tree nodes (of type ParseTree extending CommonTree) for
</I>&gt;<i> the rule references. These parse tree nodes have a token type of 0.
</I>&gt;<i> Thus you cannot use a tree parser against a parse tree and manually
</I>&gt;<i> walking the tree would be complicated. Parse trees (as generated by
</I>&gt;<i> ANTLR) are more of a debugging aid than a type of AST that
</I>&gt;<i> automatically adds structure.
</I>&gt;<i>   
</I>...I think that in many cases processing the parse tree would be very 
simple:

if (!(ast instanceof ParseTree)) {
   doSomethingWith(ast);
} else {
   // ignore ParseTree nodes
}

&gt;<i> Perhaps you could add an output=CST (Concrete Syntax Tree, aka parse
</I>&gt;<i> tree) option. But how would this work?
</I>&gt;<i> Given a rule like:
</I>&gt;<i> myop: modifier MYOP contents;
</I>&gt;<i> what should our proposed CST constructor generate? What token types
</I>&gt;<i> should rule references automatically generate? You could generate a
</I>&gt;<i> token type named after the rule but producing ^(MYOP attributes MYOP
</I>&gt;<i> contents) where the first MYOP is our auto-generated one mapping to no
</I>&gt;<i> part of the input and the second is an actual token seems bizarre and
</I>&gt;<i> likely to cause troubles. Maybe we could do ^(RULE_MYOP modifier MYOP
</I>&gt;<i> contents) but do any of the users who don't want flat ASTs want that?
</I>&gt;<i>   
</I>No. Instead, how about saying &quot;if there is exactly one terminal (i.e. 
lexer token or literal) in the rule,
put a ^ after that:

(attributes MYOP^ contents)
&gt;<i> And do they also want:
</I>&gt;<i> modifier: PUBLIC | PROTECTED;
</I>&gt;<i> to generate ^(RULE_MODIFIER PUBLIC)?
</I>&gt;<i>   
</I>Given that definition of modifiers, I'd want:

modifier: PUBLIC^ | PROTECTED^;

More realistically, they'll also have:
modifiers: modifier*;

...where I'd additionally want:
modifiers: ^(RULE_MODIFIERS modifier*)


&gt;<i> I'd imagine what they really want is not a CST but the AST ^(MYOP
</I>&gt;<i> modifier content). With modifier having no dummy parent and contents
</I>&gt;<i> having one.
</I>&gt;<i>   
</I>Right. So maybe these heuristics work:
* put a ^ after every literal.
* if we see more than one literal in a sequence (e.g. MYOP WHATEVER 
attributes contents), only the first one gets a ^
* a rule gets wrapped with ^(RULE_XXX ...) iff any of its alternatives 
is a non-literal

In that way, we get what we want:
modifier: PUBLIC^ | PROTECTED^;
myop: modifier MYOP^ contents;


&gt;<i> OK, so we don't want output=CST we want to auto-generate ASTs. But
</I>&gt;<i> how? Given the above case we might think we could have a rule that if
</I>&gt;<i> there's one token reference and other rule references we make the
</I>&gt;<i> token the root. That's easy but what if we've got:
</I>&gt;<i> method: keywords ID args catch;
</I>&gt;<i> we probably don't want ^(ID keywords args catch) as that's very hard
</I>&gt;<i> for our tree walker to distinguish from:
</I>&gt;<i> field: keywords ID init;
</I>&gt;<i> which makes ^(ID keywords init).
</I>&gt;<i>   
</I>Right, that's a problem. I guess I'd suggest making an AST node for 
*every* rule:
modifier: ^(RULE_MODIFIER (PUBLIC^ | PROTECTED^));
myop: ^(RULE_MYOP (modifier MYOP^ contents));

...but I guess maybe that puts us where we started - generating a full 
parse tree.
But even without solving this problem - go ahead and leave the tree as 
being hard to walk -
we're still ahead. The goal here is not to generate a &quot;good&quot; AST, but 
rather just produce something
that's better than nothing (i.e. a flat tree). So the newbie gets this 
tree, sees that it's hard to
distinguish the various cases where he's got an ID node, and starts 
reading up on how to build
an AST. He's better off here than the alternative: a blank stare at a 
flat ast.
&gt;<i> And what do we do with:
</I>&gt;<i> method: keywords ID LPAREN args RPAREN CATCH catch;
</I>&gt;<i> Here I'd probably want the AST ^(METHOD_CALL ID keywords args catch)
</I>&gt;<i> but how can a tool know that.
</I>&gt;<i>   
</I>Here again, I think the &quot;every rule gets its own AST&quot; rule covers it. 
Yes, I suppose that
makes it a parse tree.
&gt;<i> OK, so we want to have some default rules and some syntax to disable
</I>&gt;<i> automatic generation. 
</I>Just use what's already there: if there are zero ^ characters, return a 
parse tree.
&gt;<i> But how often is this auto generation actually
</I>&gt;<i> going to be used? I think you're very often going to want to disable
</I>&gt;<i> any such automatic generation. OK, so any use of AST rebuild operators
</I>&gt;<i> disables the automatic generation. 
</I>Right.
&gt;<i> But what about your &quot;modifiers:
</I>&gt;<i> PUBLIC | PROTECTED;&quot; rule? Adding &quot;options { autoAST=false; }&quot; to all
</I>&gt;<i> such rules is going to be pretty annoying
</I>No. No need for per-rule options, or even any new global options.
&gt;<i>  and &quot;modifiers!: PUBLIC |
</I>&gt;<i> PROTECTED;&quot; isn't going to be very understandable for new users.
</I>&gt;<i>   
</I>Right, no need for that either.
&gt;<i> I think if you spend a bit of time actually thinking about how you'd
</I>&gt;<i> manage to implement what you want you'll see it really doesn't work.
</I>&gt;<i>   
</I>Thanks for writing this up. Let me know if you think the replies I gave 
would work.
As I said, if they work, but only make things somewhat better, but not a 
completely usable AST, that's
still a win IMO. If they don't work, then how about simply say &quot;if there 
are no ^'s, I'll just use
the existing code to get a parse tree and return that&quot;?

Andy
&gt;<i> Tom.
</I>&gt;<i>
</I>&gt;<i>   
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20080313/f8474cd9/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20080313/f8474cd9/attachment.html</A> 
</PRE>


























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027173.html">[antlr-interest] postmortem
</A></li>
	<LI>Next message: <A HREF="027193.html">[antlr-interest] postmortem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27185">[ date ]</a>
              <a href="thread.html#27185">[ thread ]</a>
              <a href="subject.html#27185">[ subject ]</a>
              <a href="author.html#27185">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
