<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Exception while trying to generate Java	classes for lexer
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Exception%20while%20trying%20to%20generate%20Java%0A%09classes%20for%20lexer&In-Reply-To=%3CCDE26092-1C0C-4C3E-8AE0-6F15D124976F%40cs.usfca.edu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029037.html">
   <LINK REL="Next"  HREF="029041.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Exception while trying to generate Java	classes for lexer</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Exception%20while%20trying%20to%20generate%20Java%0A%09classes%20for%20lexer&In-Reply-To=%3CCDE26092-1C0C-4C3E-8AE0-6F15D124976F%40cs.usfca.edu%3E"
       TITLE="[antlr-interest] Exception while trying to generate Java	classes for lexer">parrt at cs.usfca.edu
       </A><BR>
    <I>Mon Jul  7 15:20:18 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="029037.html">[antlr-interest] [stringtemplate-interest] howto set separator	in parallel list iteration
</A></li>
        <LI>Next message: <A HREF="029041.html">[antlr-interest] read from socket
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29038">[ date ]</a>
              <a href="thread.html#29038">[ thread ]</a>
              <a href="subject.html#29038">[ subject ]</a>
              <a href="author.html#29038">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Fixed.
Thanks.
Ter
On Jun 27, 2008, at 5:50 PM, Sumanto Biswas wrote:

&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> I have a parser-lexer combination. I used to have it together, but
</I>&gt;<i> separated them so that I could have better control over options and
</I>&gt;<i> also for better readability.
</I>&gt;<i>
</I>&gt;<i> When the lexer was part of parser, it generated fine. However, I took
</I>&gt;<i> the lexer out of the parser, and tried to generate them separately,
</I>&gt;<i> the parser just generated the parser.java file. When I tried to
</I>&gt;<i> generate from lexer, I got the exception stack trace pasted below.
</I>&gt;<i>
</I>&gt;<i> The lexer is pasted below the stack trace and also attached.
</I>&gt;<i>
</I>&gt;<i> Thanks in advance,
</I>&gt;<i> Sumanto
</I>&gt;<i>
</I>&gt;<i> ================================================================
</I>&gt;<i> ANTLR Parser Generator  Version 3.1b1 (May 20, 2008)  1989-2008
</I>&gt;<i> error(100): soslLexerRules.g:0:0: syntax error: buildnfa: &lt;AST&gt;:0:0:
</I>&gt;<i> unexpected AST node: synpred133_soslLexerRules
</I>&gt;<i> error(100): soslLexerRules.g:0:0: syntax error: buildnfa:
</I>&gt;<i> &lt;AST&gt;:184:10: expecting EOA, found '..'
</I>&gt;<i> error(100): soslLexerRules.g:0:0: syntax error: buildnfa: &lt;AST&gt;:
</I>&gt;<i> expecting EOA, found '&lt;empty tree&gt;'
</I>&gt;<i> error(10):  internal error: soslLexerRules.g :  
</I>&gt;<i> java.lang.NullPointerException
</I>&gt;<i> org.antlr.tool.NFAFactory.build_Astar(NFAFactory.java:570)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.ebnf(TreeToNFAConverter.java:1937)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.element(TreeToNFAConverter.java: 
</I>&gt;<i> 1261)
</I>&gt;<i> org 
</I>&gt;<i> .antlr.tool.TreeToNFAConverter.alternative(TreeToNFAConverter.java: 
</I>&gt;<i> 1008)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.block(TreeToNFAConverter.java:803)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.ebnf(TreeToNFAConverter.java:1989)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.element(TreeToNFAConverter.java: 
</I>&gt;<i> 1261)
</I>&gt;<i> org 
</I>&gt;<i> .antlr.tool.TreeToNFAConverter.alternative(TreeToNFAConverter.java: 
</I>&gt;<i> 1008)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.block(TreeToNFAConverter.java:803)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.rule(TreeToNFAConverter.java:586)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.rules(TreeToNFAConverter.java:412)
</I>&gt;<i> org 
</I>&gt;<i> .antlr.tool.TreeToNFAConverter.grammarSpec(TreeToNFAConverter.java: 
</I>&gt;<i> 366)
</I>&gt;<i> org.antlr.tool.TreeToNFAConverter.grammar(TreeToNFAConverter.java:159)
</I>&gt;<i> org.antlr.tool.Grammar.buildNFA(Grammar.java:858)
</I>&gt;<i> org.antlr.tool.CompositeGrammar.createNFAs(CompositeGrammar.java:362)
</I>&gt;<i> org.antlr.Tool.process(Tool.java:284)
</I>&gt;<i> org.antlr.Tool.main(Tool.java:71)
</I>&gt;<i> ================================================================
</I>&gt;<i>
</I>&gt;<i> ================================================================
</I>&gt;<i> lexer grammar soslLexerRules;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i> 	backtrack=true;
</I>&gt;<i> 	memoize=true;
</I>&gt;<i> 	filter=true;
</I>&gt;<i> 	// k=2;
</I>&gt;<i> 	// charVocabulary='\u0000'..'\uFFFE';  // support full unicode
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @header {
</I>&gt;<i> import java.util.HashMap;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @members {
</I>&gt;<i>    private boolean _scanningQuery = false;
</I>&gt;<i>
</I>&gt;<i>    public boolean isScanningQuery() {
</I>&gt;<i>        return _scanningQuery;
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i>    public void setScanningQuery(boolean scanningQuery) {
</I>&gt;<i>        _scanningQuery = scanningQuery;
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> EQUAL 			: '=' ;
</I>&gt;<i> NOT_EQUAL 		: '!=' ;
</I>&gt;<i> LESS_THAN 		: '&lt;' ;
</I>&gt;<i> LESS_THAN_OR_EQUAL 	: '&lt;=' ;
</I>&gt;<i> GREATER_THAN 		: '&gt;' ;
</I>&gt;<i> GREATER_THAN_OR_EQUAL 	: '&gt;=' ;
</I>&gt;<i> LPAREN 			: '(' ;
</I>&gt;<i> RPAREN 			: ')' ;
</I>&gt;<i> COLON   		: ':' ;
</I>&gt;<i> COMMA 			: ',' ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> LITERAL : { isScanningQuery() }? '&quot;'
</I>&gt;<i>    (SEARCH_CHAR
</I>&gt;<i>        | ' '
</I>&gt;<i>        | '\t'
</I>&gt;<i>        | '\n'
</I>&gt;<i>        | '\r')*
</I>&gt;<i>     '&quot;'
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> SEARCH_TERM : { isScanningQuery() }? SEARCH_CHAR2 ( SEARCH_CHAR )*
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> LCURLY  : '{' { setScanningQuery(true); }
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> RCURLY  : '}' { setScanningQuery(false); }
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> // ----------------------------------------------------
</I>&gt;<i> // Following are parser tokens
</I>&gt;<i> // ----------------------------------------------------
</I>&gt;<i> FIND 		: 	{ !isScanningQuery() }? ('f'|'F') ('i'|'I') ('n'|'N')  
</I>&gt;<i> ('d'|'D') ;
</I>&gt;<i> LIMIT 		 : 	{ !isScanningQuery() }? ('l'|'L') ('i'|'I') ('m'|'M')
</I>&gt;<i> ('i'|'I') ('t'|'T') ;
</I>&gt;<i> IN 		 : 	{ !isScanningQuery() }? ('i'|'I') ('n'|'N') ;
</I>&gt;<i> CONVERTCURRENCY	 :	{ !isScanningQuery() }? 'convertCurrency' ;
</I>&gt;<i> AMOUNT 		 : 	{ !isScanningQuery() }? 'Amount' ;
</I>&gt;<i> TOLABEL 	 : 	{ !isScanningQuery() }? 'toLabel' ;
</I>&gt;<i> ALL		 :	{ !isScanningQuery() }? 'ALL' ;
</I>&gt;<i> FIELDS		 :	{ !isScanningQuery() }? 'FIELDS' ;
</I>&gt;<i> NAME		 :	{ !isScanningQuery() }? 'NAME' ;
</I>&gt;<i> EMAIL		 :	{ !isScanningQuery() }? 'EMAIL' ;
</I>&gt;<i> PHONE		 :	{ !isScanningQuery() }? 'PHONE' ;
</I>&gt;<i> RETURNING	 : 	{ !isScanningQuery() }? ('r'|'R') ('e'|'E') ('t'|'T')
</I>&gt;<i> ('u'|'U') ('r'|'R') ('n'|'N') ('i'|'I') ('n'|'N') ('g'|'G') ;
</I>&gt;<i> ORDER		 :	{ !isScanningQuery() }? ('o'|'O') ('r'|'R') ('d'|'D')
</I>&gt;<i> ('e'|'E') ('r'|'R') ;
</I>&gt;<i> BY		 :	{ !isScanningQuery() }? ('b'|'B') ('y'|'Y') ;
</I>&gt;<i> ASC		 :	{ !isScanningQuery() }? 'ASC' ;
</I>&gt;<i> DESC		 :	{ !isScanningQuery() }? 'DESC' ;
</I>&gt;<i> NULLS		 :	{ !isScanningQuery() }? 'NULLS' ;
</I>&gt;<i> FIRST		 :	{ !isScanningQuery() }? ('f'|'F') ('i'|'I') ('r'|'R')
</I>&gt;<i> ('s'|'S') ('t'|'T') ;
</I>&gt;<i> LAST		 :	{ !isScanningQuery() }? ('l'|'L') ('a'|'A') ('s'|'S')  
</I>&gt;<i> ('t'|'T') ;
</I>&gt;<i> WITH		 :	{ !isScanningQuery() }? ('w'|'W') ('i'|'I') ('t'|'T')  
</I>&gt;<i> ('h'|'H') ;
</I>&gt;<i> DIVISION	 :	{ !isScanningQuery() }? ('d'|'D') ('i'|'I') ('v'|'V')
</I>&gt;<i> ('i'|'I') ('s'|'S') ('i'|'I') ('o'|'O') ('n'|'N') ;
</I>&gt;<i> AND_SCAN	 :	{ isScanningQuery() }?  ('a'|'A') ('n'|'N') ('d'|'D') ;
</I>&gt;<i> OR_SCAN 	 :	{ isScanningQuery() }?  ('o'|'O') ('r'|'R') ;
</I>&gt;<i> NOT_SCAN	 :	{ isScanningQuery() }?  ('n'|'N') ('o'|'O') ('t'|'T') ;
</I>&gt;<i> AND		 :	{ !isScanningQuery() }? ('a'|'A') ('n'|'N') ('d'|'D') ;
</I>&gt;<i> OR 		 :	{ !isScanningQuery() }? ('o'|'O') ('r'|'R') ;
</I>&gt;<i> NOT		 :	{ !isScanningQuery() }? ('n'|'N') ('o'|'O') ('t'|'T') ;
</I>&gt;<i> WHERE		 :	{ !isScanningQuery() }? ('w'|'W') ('h'|'H') ('e'|'E')
</I>&gt;<i> ('r'|'R') ('e'|'E') ;
</I>&gt;<i> LIKE		 :	{ !isScanningQuery() }? ('l'|'L') ('i'|'I') ('k'|'K')  
</I>&gt;<i> ('e'|'E') ;
</I>&gt;<i> NULL		 :	{ !isScanningQuery() }? ('n'|'N') ('u'|'U') ('l'|'L')  
</I>&gt;<i> ('l'|'L') ;
</I>&gt;<i> TRUE		 :	{ !isScanningQuery() }? ('t'|'T') ('r'|'R') ('u'|'U')  
</I>&gt;<i> ('e'|'E') ;
</I>&gt;<i> FALSE		 :	{ !isScanningQuery() }? ('f'|'F') ('a'|'A') ('l'|'L')
</I>&gt;<i> ('s'|'S') ('e'|'E') ;
</I>&gt;<i> INCLUDES	 :	{ !isScanningQuery() }? ('i'|'I') ('n'|'N') ('c'|'C')
</I>&gt;<i> ('l'|'L') ('u'|'U') ('d'|'D') ('e'|'E') ('s'|'S') ;
</I>&gt;<i> EXCLUDES	 :	{ !isScanningQuery() }? ('e'|'E') ('x'|'X') ('c'|'C')
</I>&gt;<i> ('l'|'L') ('u'|'U') ('d'|'D') ('e'|'E') ('s'|'S') ;
</I>&gt;<i> YESTERDAY	 :	{ !isScanningQuery() }? 'YESTERDAY' ;
</I>&gt;<i> TODAY 		 :	{ !isScanningQuery() }? 'TODAY' ;
</I>&gt;<i> TOMORROW 	 :	{ !isScanningQuery() }? 'TOMORROW' ;
</I>&gt;<i> LAST_WEEK 	 :	{ !isScanningQuery() }? 'LAST_WEEK' ;
</I>&gt;<i> THIS_WEEK 	 :	{ !isScanningQuery() }? 'THIS_WEEK' ;
</I>&gt;<i> NEXT_WEEK 	 :	{ !isScanningQuery() }? 'NEXT_WEEK' ;
</I>&gt;<i> LAST_MONTH 	 :	{ !isScanningQuery() }? 'LAST_MONTH' ;
</I>&gt;<i> THIS_MONTH 	 :	{ !isScanningQuery() }? 'THIS_MONTH' ;
</I>&gt;<i> NEXT_MONTH 	 :	{ !isScanningQuery() }? 'NEXT_MONTH' ;
</I>&gt;<i> LAST_90_DAYS 	 :	{ !isScanningQuery() }? 'LAST_90_DAYS' ;
</I>&gt;<i> NEXT_90_DAYS 	 :	{ !isScanningQuery() }? 'NEXT_90_DAYS' ;
</I>&gt;<i> LAST_N_DAYS 	 :	{ !isScanningQuery() }? 'LAST_N_DAYS' ;
</I>&gt;<i> NEXT_N_DAYS 	 :	{ !isScanningQuery() }? 'NEXT_N_DAYS' ;
</I>&gt;<i> THIS_QUARTER 	 :	{ !isScanningQuery() }? 'THIS_QUARTER' ;
</I>&gt;<i> LAST_QUARTER 	 :	{ !isScanningQuery() }? 'LAST_QUARTER' ;
</I>&gt;<i> NEXT_QUARTER 	 :	{ !isScanningQuery() }? 'NEXT_QUARTER' ;
</I>&gt;<i> THIS_YEAR 	 :	{ !isScanningQuery() }? 'THIS_YEAR' ;
</I>&gt;<i> LAST_YEAR 	 :	{ !isScanningQuery() }? 'LAST_YEAR' ;
</I>&gt;<i> NEXT_YEAR 	 :	{ !isScanningQuery() }? 'NEXT_YEAR' ;
</I>&gt;<i> NEXT_N_YEARS 	 :	{ !isScanningQuery() }? 'NEXT_N_YEARS' ;
</I>&gt;<i> LAST_N_YEARS 	 :	{ !isScanningQuery() }? 'LAST_N_YEARS' ;
</I>&gt;<i> THIS_FISCAL_QUARTER 	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'THIS_FISCAL_QUARTER' ;
</I>&gt;<i> LAST_FISCAL_QUARTER 	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'LAST_FISCAL_QUARTER' ;
</I>&gt;<i> NEXT_FISCAL_QUARTER 	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'NEXT_FISCAL_QUARTER' ;
</I>&gt;<i> NEXT_N_QUARTERS 	 :	{ !isScanningQuery() }? 'NEXT_N_QUARTERS' ;
</I>&gt;<i> LAST_N_QUARTERS 	 :	{ !isScanningQuery() }? 'LAST_N_QUARTERS' ;
</I>&gt;<i> THIS_FISCAL_YEAR 	 :	{ !isScanningQuery() }? 'THIS_FISCAL_YEAR' ;
</I>&gt;<i> LAST_FISCAL_YEAR 	 :	{ !isScanningQuery() }? 'LAST_FISCAL_YEAR' ;
</I>&gt;<i> NEXT_FISCAL_YEAR 	 :	{ !isScanningQuery() }? 'NEXT_FISCAL_YEAR' ;
</I>&gt;<i> NEXT_N_FISCAL_YEARS 	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'NEXT_N_FISCAL_YEARS' ;
</I>&gt;<i> LAST_N_FISCAL_YEARS 	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'LAST_N_FISCAL_YEARS' ;
</I>&gt;<i> NEXT_N_FISCAL_QUARTERS	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'NEXT_N_FISCAL_QUARTERS' ;
</I>&gt;<i> LAST_N_FISCAL_QUARTERS 	 :	{ !isScanningQuery() }?  
</I>&gt;<i> 'LAST_N_FISCAL_QUARTERS' ;
</I>&gt;<i> // ----------------------------------------------------
</I>&gt;<i> // ----------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> WS	 :	(' '
</I>&gt;<i> 	|	'\t'
</I>&gt;<i> 	|	'\n'
</I>&gt;<i> 	|	'\r')
</I>&gt;<i> 		{ skip();   }
</I>&gt;<i> 	;
</I>&gt;<i> 	
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ID     : { !isScanningQuery() }? ( LETTER (LETTER | '_' | DIGIT)*);
</I>&gt;<i>
</I>&gt;<i> PARAM  : { isScanningQuery() }? '$' LETTER (LETTER | '_' | DIGIT)*;
</I>&gt;<i>
</I>&gt;<i> NUMBER  : { !isScanningQuery() }? DIGIT+ ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> QUOTE_DATA  : '\'' ( SEARCH_CHAR )+ '\'' ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> DATETIME : DATE ('t'|'T') HOUR ':' MINUTE ':' SECOND (('z'|'Z') |
</I>&gt;<i> (('+' |'-') HOUR ':' MINUTE))
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> DATE : ( DIGIT DIGIT DIGIT DIGIT ) '-' ( '0' '1'..'9' | '1' ('0' | '1'
</I>&gt;<i> | '2') ) '-'  ( '0' '1'..'9' | '1'..'2' DIGIT | '3' ('0' | '1') )
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> HOUR : '0'..'1' DIGIT | '2' '0'..'3'
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> MINUTE : '0'..'5' DIGIT
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> SECOND : '0'..'5' DIGIT | '60'
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> POSINTEGER  : DIGIT+
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> DIGIT : '0'..'9'
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> LETTER : 'a'..'z' | 'A'..'Z'
</I>&gt;<i>    ;
</I>&gt;<i> 	
</I>&gt;<i> // same as SEARCH_CHAR, but won't match a $
</I>&gt;<i> fragment
</I>&gt;<i> SEARCH_CHAR2 :
</I>&gt;<i>    ( '\\&amp;'
</I>&gt;<i>    | '\\|'
</I>&gt;<i>    | '\\!'
</I>&gt;<i>    | '\\{'
</I>&gt;<i>    | '\\}'
</I>&gt;<i>    | '\\['
</I>&gt;<i>    | '\\]'
</I>&gt;<i>    | '\\('
</I>&gt;<i>    | '\\)'
</I>&gt;<i>    | '\\^'
</I>&gt;<i>    | '\\~'
</I>&gt;<i>    | '\\:'
</I>&gt;<i>    | '\\\\'
</I>&gt;<i>    | '\\\''
</I>&gt;<i>    | '\\\&quot;' //  asd
</I>&gt;<i>    | '\\+'
</I>&gt;<i>    | '\\-'
</I>&gt;<i>    | '\\?'
</I>&gt;<i>    | '\\*'
</I>&gt;<i>    |
</I>&gt;<i>   ~( ' '              // don't allow white space
</I>&gt;<i>    | '\t'             // don't allow white space
</I>&gt;<i>    | '\n'             // don't allow white space
</I>&gt;<i>    | '\r'             // don't allow white space
</I>&gt;<i>    | '&amp;'              // reserved char per spec
</I>&gt;<i>    | '|'              // reserved char per spec
</I>&gt;<i>    | '!'              // reserved char per spec
</I>&gt;<i>    | '{'              // reserved char per spec
</I>&gt;<i>    | '}'              // reserved char per spec
</I>&gt;<i>    | '['              // reserved char per spec
</I>&gt;<i>    | ']'              // reserved char per spec
</I>&gt;<i>    | '('              // reserved char per spec (from 10.0)
</I>&gt;<i>    | ')'              // reserved char per spec (from 10.0)
</I>&gt;<i>    | '?'              // reserved char per spec (from 10.0)
</I>&gt;<i>    | '^'              // reserved char per spec
</I>&gt;<i>    | '~'              // reserved char per spec
</I>&gt;<i>    | ':'              // reserved char per spec
</I>&gt;<i>    | '\\'             // reserved char per spec
</I>&gt;<i>    | '\''             // reserved char per spec
</I>&gt;<i>    | '\&quot;'             // not reserved, but treating as reserved for
</I>&gt;<i> better parsing behavior.
</I>&gt;<i>    | '+'              // reserved char per spec
</I>&gt;<i>    | '-'              // reserved char per spec
</I>&gt;<i>    | '$'              // reserved for params
</I>&gt;<i>    ) )
</I>&gt;<i>    ;
</I>&gt;<i>
</I>&gt;<i> // FIND_VAL : 'f' 'i' 'n' 'd'
</I>&gt;<i> //    ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> fragment
</I>&gt;<i> SEARCH_CHAR :
</I>&gt;<i>    ( '\\&amp;'
</I>&gt;<i>    | '\\|'
</I>&gt;<i>    | '\\!'
</I>&gt;<i>    | '\\{'
</I>&gt;<i>    | '\\}'
</I>&gt;<i>    | '\\['
</I>&gt;<i>    | '\\]'
</I>&gt;<i>    | '\\('
</I>&gt;<i>    | '\\)'
</I>&gt;<i>    | '\\^'
</I>&gt;<i>    | '\\~'
</I>&gt;<i>    | '\\:'
</I>&gt;<i>    | '\\\\'
</I>&gt;<i>    | '\\\''
</I>&gt;<i>    | '\\\&quot;'
</I>&gt;<i>    | '\\+'
</I>&gt;<i>    | '\\-'
</I>&gt;<i>    | '\\?'
</I>&gt;<i> // --    | '\\*'
</I>&gt;<i>    |
</I>&gt;<i>   ~( ' '              // don't allow white space
</I>&gt;<i>    | '\t'             // don't allow white space
</I>&gt;<i>    | '\n'             // don't allow white space
</I>&gt;<i>    | '\r'             // don't allow white space
</I>&gt;<i>    | '&amp;'              // reserved char per spec
</I>&gt;<i>    | '|'              // reserved char per spec
</I>&gt;<i>    | '!'              // reserved char per spec
</I>&gt;<i>    | '{'              // reserved char per spec
</I>&gt;<i>    | '}'              // reserved char per spec
</I>&gt;<i>    | '['              // reserved char per spec
</I>&gt;<i>    | ']'              // reserved char per spec
</I>&gt;<i>    | '('              // reserved char per spec (from 10.0)
</I>&gt;<i>    | ')'              // reserved char per spec (from 10.0)
</I>&gt;<i>    | '?'              // reserved char per spec (from 10.0)
</I>&gt;<i>    | '^'              // reserved char per spec
</I>&gt;<i>    | '~'              // reserved char per spec
</I>&gt;<i>    | ':'              // reserved char per spec
</I>&gt;<i>    | '\\'             // reserved char per spec
</I>&gt;<i>    | '\''             // reserved char per spec
</I>&gt;<i>    | '\&quot;'             // not reserved, but treating as reserved for
</I>&gt;<i> better parsing behavior.
</I>&gt;<i>    | '+'              // reserved char per spec
</I>&gt;<i>    | '-'              // reserved char per spec
</I>&gt;<i>    ) )
</I>&gt;<i>    ;
</I>&gt;<i> ================================================================
</I>&gt;<i> &lt;soslLexerRules.g&gt;
</I>
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029037.html">[antlr-interest] [stringtemplate-interest] howto set separator	in parallel list iteration
</A></li>
	<LI>Next message: <A HREF="029041.html">[antlr-interest] read from socket
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29038">[ date ]</a>
              <a href="thread.html#29038">[ thread ]</a>
              <a href="subject.html#29038">[ subject ]</a>
              <a href="author.html#29038">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
