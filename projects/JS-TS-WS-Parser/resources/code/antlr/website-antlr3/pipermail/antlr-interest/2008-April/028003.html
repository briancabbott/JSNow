<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Why don't parsers support character ranges?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Why%20don%27t%20parsers%20support%20character%20ranges%3F&In-Reply-To=%3C200804231755.34175.rschulz%40sonic.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028002.html">
   <LINK REL="Next"  HREF="028004.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Why don't parsers support character ranges?</H1>
    <B>Randall R Schulz</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Why%20don%27t%20parsers%20support%20character%20ranges%3F&In-Reply-To=%3C200804231755.34175.rschulz%40sonic.net%3E"
       TITLE="[antlr-interest] Why don't parsers support character ranges?">rschulz at sonic.net
       </A><BR>
    <I>Wed Apr 23 17:55:34 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="028002.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
        <LI>Next message: <A HREF="028004.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28003">[ date ]</a>
              <a href="thread.html#28003">[ thread ]</a>
              <a href="subject.html#28003">[ subject ]</a>
              <a href="author.html#28003">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wednesday 23 April 2008 17:01, Peter Nann wrote:
&gt;<i> Hmmm, I was hoping for more than the 'efficiency' argument...
</I>&gt;<i> I am wondering if that argument is about 10 years past its use-by
</I>&gt;<i> date...
</I>&gt;<i> We are not in the days of single-digit-Megahertz and RAM measured in
</I>&gt;<i> k anymore... when lexx and yacc were written...
</I>
Well, ANTLR goes well beyond lex and yacc. However, if you believe that 
lexer / parser stratification is no longer justified, you could set out 
to prove that thesis by writing a unified lexer / parser generator 
tool. (That does everything current tools do!) Many good current parser 
generators are open source (including ANTLR, of course), so you can 
exploit the techniques they use and that you like and replace or 
improve the ones you don't.

Personally, I'm not sure stratifying the lexical and syntactic analysis 
is a bad thing. I've certainly never found it to be a problem, and I've 
written my share of parsers, using lex &amp; yacc (or flex and bison, I 
guess), JavaCC, ANTLR 2.x and 3.x. The only thing I don't care for is 
the use of alphabetic case to distinguish lexical from syntactical 
rules.


&gt;<i> It would depend on the scale of parsing you need to do of course, but
</I>&gt;<i> for small-scale parsing I would question whether CPU and RAM matters
</I>&gt;<i> any more on that task...
</I>
You know, there's a reason we don't call them &quot;little languages&quot; any 
more. They are never little and they never were little! And while it's 
legitimate to make a considered choice about trading off, say, 
developer time and execution time, it's not really OK to do something 
slowly when you don't get something in turn for it.


&gt;<i> I will have to take your word about 'combinatorial explosion' for
</I>&gt;<i> some problems, but I thought simple RDP's could pretty much break
</I>&gt;<i> down to one branch (as in: switch statement) per character (or token
</I>&gt;<i> if you tokenize it), which doesn't seem excessive, or combinatorial.
</I>
You may still want to produce a DFA, and that can in general yield and 
exponential increase in the number of states. Not stratifying the 
lexical and syntactic layers will exacerbate that problem (I think).

And I don't have any idea about the consequences of unifying lexical 
analysis with syntax analysis in the face of arbitrary or variable 
look-ahead or backtracking.

Lastly, I still think lexical states (as they exist in JavaCC, e.g.) 
would be a good thing. It seems that would be harder to do when the 
lexer is not separated from the parser.


&gt;<i>  - But, yes, that was just my CS101 project!
</I>
Interesting. If you got that stuff in CS101, you must have gotten one 
hell of a CS education.


&gt;<i> ...
</I>&gt;<i>
</I>&gt;<i> Sorry to be a sour-puss, but I was quite excited about ANTLR at first
</I>&gt;<i> look, but then got disappointed very quickly, so I'm a bit like a
</I>&gt;<i> child who just broke his favourite toy...  ;-)
</I>
Show the ANTLR principals wrong by besting them at their own game. If 
you drop the sour-puss act, they'll probably wish you well, even help 
you, and certainly congratulate you if you succeed.


Randall Schulz
</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028002.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
	<LI>Next message: <A HREF="028004.html">[antlr-interest] Why don't parsers support character ranges?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28003">[ date ]</a>
              <a href="thread.html#28003">[ thread ]</a>
              <a href="subject.html#28003">[ subject ]</a>
              <a href="author.html#28003">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
