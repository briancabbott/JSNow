<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> Fwd: [antlr-interest] Relational operator in COBOL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Fwd%3A%20%5Bantlr-interest%5D%20Relational%20operator%20in%20COBOL&In-Reply-To=e39abda10603060050r457d59d1w%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015589.html">
   <LINK REL="Next"  HREF="015590.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Fwd: [antlr-interest] Relational operator in COBOL</H1>
    <B>Jose Ventura</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Fwd%3A%20%5Bantlr-interest%5D%20Relational%20operator%20in%20COBOL&In-Reply-To=e39abda10603060050r457d59d1w%40mail.gmail.com"
       TITLE="Fwd: [antlr-interest] Relational operator in COBOL">jose.ventura.roda at gmail.com
       </A><BR>
    <I>Wed Mar  8 07:13:13 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="015589.html">[antlr-interest] Relational operator in COBOL
</A></li>
        <LI>Next message: <A HREF="015590.html">[antlr-interest] Re: Reloading from previous parse?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15616">[ date ]</a>
              <a href="thread.html#15616">[ thread ]</a>
              <a href="subject.html#15616">[ subject ]</a>
              <a href="author.html#15616">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Skipped content of type multipart/alternative-------------- next part --------------
A non-text attachment was scrubbed...
Name: mcon.java
Type: application/octet-stream
Size: 1268 bytes
Desc: not available
Url : <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20060308/e385920e/mcon-0001.obj">http://www.antlr.org/pipermail/antlr-interest/attachments/20060308/e385920e/mcon-0001.obj</A>
-------------- next part --------------
@condition 1
ident1 &gt; 1 .

@condition 2
ident1 = 1 or (ident2 GREATER 2). 

@condition 3
ident1 &gt; 0 and ident1 &lt; 50 .

@condition 4
ident1 NOT = 0 .

@condition 5, is like condition 3 
ident1 &gt; 0 and &lt; 50.

@condition 6
ident1 (1, hola, 3+5)(1:5) = &quot;Test l&quot;.


















-------------- next part --------------
/*header 
{
	package cobol;
}
	*/
class CobolLex extends Lexer;
options 
{ 
	k=1;
	charVocabulary = '\3'..'\377'; // Unicodes usuales
	caseSensitive=false;
	caseSensitiveLiterals=false;
	testLiterals=false;
	exportVocab=CobolLexVocab;

} 
tokens										// MUST be kept in sync with &quot;keywordsTable&quot; Hashtable below!!
{
	FIN_TODO;
	NUM;
    IDENT;
	LIT_HEXADECIMAL;
	LIT_PIC;
	LIT_COPY;
	FECHA;
	IGUAL;
	MAYOR_IGUAL;
	MENOR_IGUAL;
	NOT_REL;
    
    IDENTIFICATION=&quot;IDENTIFICATION&quot;;
	ID=&quot;ID&quot;;
	ENVIRONMENT=&quot;ENVIRONMENT&quot;;
	DATA=&quot;DATA&quot;;
	WORKING=&quot;WORKING-STORAGE&quot;;
	LINKAGE=&quot;LINKAGE&quot;;
	DIVISION=&quot;DIVISION&quot;;
	PROGRAM_ID=&quot;PROGRAM-ID&quot;;
	PROCEDURE=&quot;PROCEDURE&quot;;
	SECTION=&quot;SECTION&quot;;

	ACCEPT=&quot;ACCEPT&quot;;
	ADD=&quot;ADD&quot;;
	ALL=&quot;ALL&quot;;
	ALSO=&quot;ALSO&quot;;
	ALTER=&quot;ALTER&quot;;
	AND=&quot;AND&quot;;
	AT=&quot;AT&quot;;
	BLANK=&quot;BLANK&quot;;
	BY=&quot;BY&quot;;
	CALL=&quot;CALL&quot;;
	CANCEL=&quot;CANCEL&quot;;
	CICS=&quot;CICS&quot;;
	CLOSE=&quot;CLOSE&quot;;
	COMPUTE=&quot;COMPUTE&quot;;
	COMMAREA=&quot;COMMAREA&quot;;
	COMMIT=&quot;COMMIT&quot;;
	CONTINUE=&quot;CONTINUE&quot;;
	CORR=&quot;CORR&quot;;
	CORRESPONDING=&quot;CORRESPONDING&quot;;
	DELETE=&quot;DELETE&quot;;
	DELIMITED=&quot;DELIMITED&quot;;
	DISPLAY=&quot;DISPLAY&quot;;
	DIVIDE=&quot;DIVIDE&quot;;
	ELSE=&quot;ELSE&quot;;
	END=&quot;END&quot;;
	END_ADD=&quot;END-ADD&quot;;
	END_CALL=&quot;END-CALL&quot;;
	END_COMPUTE=&quot;END-COMPUTE&quot;;
	END_DIVIDE=&quot;END-DIVIDE&quot;;
	END_EVALUATE=&quot;END-EVALUATE&quot;;
	END_EXEC=&quot;END-EXEC&quot;;
	END_IF=&quot;END-IF&quot;;
	END_MULTIPLY=&quot;END-MULTIPLY&quot;;
	END_PERFORM=&quot;END-PERFORM&quot;;
	END_SEARCH=&quot;END-SEARCH&quot;;
	END_STRING=&quot;END-STRING&quot;;
	END_UNSTRING=&quot;END-UNSTRING&quot;;
	END_SUBTRACT=&quot;END-SUBTRACT&quot;;
	ENTRY=&quot;ENTRY&quot;;
	EVALUATE=&quot;EVALUATE&quot;;
	EXEC=&quot;EXEC&quot;;
	EXIT=&quot;EXIT&quot;;
	METHOD=&quot;METHOD&quot;;
	PROGRAM=&quot;PROGRAM&quot;;
	GOBACK=&quot;GOBACK&quot;;
	GO_TO=&quot;GO TO&quot;;
	IF=&quot;IF&quot;;
	IN=&quot;IN&quot;;
	INITIALIZE=&quot;INITIALIZE&quot;;
	INSPECT=&quot;INSPECT&quot;;
	INTO=&quot;INTO&quot;;
	INVOKE=&quot;INVOKE&quot;;
	LINK=&quot;LINK&quot;;
	MERGE=&quot;MERGE&quot;;
	MOVE=&quot;MOVE&quot;;
	MULTIPLY=&quot;MULTIPLY&quot;;
	OF=&quot;OF&quot;;
	OPEN=&quot;OPEN&quot;;
	OR=&quot;OR&quot;;
	OTHER=&quot;OTHER&quot;;
	PERFORM=&quot;PERFORM&quot;;
	POINTER=&quot;POINTER&quot;;
	READ=&quot;READ&quot;;
	RECEIVE=&quot;RECEIVE&quot;;
	REDEFINES=&quot;REDEFINES&quot;;
	RELEASE=&quot;RELEASE&quot;;
	REPLACING=&quot;REPLACING&quot;;
	TALLYING=&quot;TALLYING&quot;;
	RETURN=&quot;RETURN&quot;;
	REWRITE=&quot;REWRITE&quot;;
	ROLLBACK=&quot;ROLLBACK&quot;;
	SEARCH=&quot;SEARCH&quot;;
	SEND=&quot;SEND&quot;;
	SET=&quot;SET&quot;;
	SQL=&quot;SQL&quot;;
	SORT=&quot;SORT&quot;;
	SPACE=&quot;SPACE&quot;;
	SPACES=&quot;SPACES&quot;;
	START=&quot;START&quot;;
	STOP=&quot;STOP&quot;;
	STRING=&quot;STRING&quot;;
	SUBTRACT=&quot;SUBTRACT&quot;;
	SYNCPOINT=&quot;SYNCPOINT&quot;;
	TO=&quot;TO&quot;;
	THEN=&quot;THEN&quot;;
	UNSTRING=&quot;UNSTRING&quot;;
	WRITE=&quot;WRITE&quot;;
	ZERO=&quot;ZERO&quot;;
	ZEROS=&quot;ZEROS&quot;;
	ZEROES=&quot;ZEROES&quot;;
	THROUGH=&quot;THROUGH&quot;;
	THRU=&quot;THRU&quot;;
	VARYING=&quot;VARYING&quot;;
	UNTIL=&quot;UNTIL&quot;;
	USING=&quot;USING&quot;;
	WHEN=&quot;WHEN&quot;;
	WITH=&quot;WITH&quot;;
	TEST=&quot;TEST&quot;;
	BEFORE=&quot;BEFORE&quot;;
	AFTER=&quot;AFTER&quot;;
	JUSTIFIED=&quot;JUSTIFIED&quot;;
	JUST=&quot;JUST&quot;;
	OCCURS=&quot;OCCURS&quot;;
	ASCENDING=&quot;ASCENDING&quot;;
	DESCENDING=&quot;DESCENDING&quot;;
	KEY=&quot;KEY&quot;;
	IS=&quot;IS&quot;;
	INDEXED=&quot;INDEXED&quot;;
	PIC=&quot;PIC&quot;;
	PICTURE=&quot;PICTURE&quot;;
	USAGE=&quot;USAGE&quot;;
	VALUE=&quot;VALUE&quot;;
	VALUES=&quot;VALUES&quot;;
	ARE=&quot;ARE&quot;;
	RENAMES=&quot;RENAMES&quot;;
	COPY=&quot;COPY&quot;;
	BINARY=&quot;BINARY&quot;;
	COMP=&quot;COMP&quot;;
	COMP1=&quot;COMP-1&quot;;
	COMP2=&quot;COMP-2&quot;;
	COMP3=&quot;COMP-3&quot;;
	COMP4=&quot;COMP-4&quot;;
	COMPUTATIONAL=&quot;COMPUTATIONAL&quot;;
	COMPUTATIONAL1=&quot;COMPUTATIONAL-1&quot;;
	COMPUTATIONAL2=&quot;COMPUTATIONAL-2&quot;;
	COMPUTATIONAL3=&quot;COMPUTATIONAL-3&quot;;
	COMPUTATIONAL4=&quot;COMPUTATIONAL-4&quot;;
	DISPLAY1=&quot;DISPLAY-1&quot;;
	INDEX=&quot;INDEX&quot;;
	PACKED_DECIMAL=&quot;PACKED-DECIMAL&quot;;
	CHARACTERS=&quot;CHARACTERS&quot;;
	LEADING=&quot;LEADING&quot;;
	FIRST=&quot;FIRST&quot;;
	INITIAL=&quot;INITIAL&quot;;
	CONVERTING=&quot;CONVERTING&quot;;
	FOR=&quot;FOR&quot;;
	UP=&quot;UP&quot;;
	DOWN=&quot;DOWN&quot;;
	NOT=&quot;NOT&quot;;
	NULL=&quot;NULL&quot;;
	ON=&quot;ON&quot;;
	SIZE=&quot;SIZE&quot;;
	ERROR=&quot;ERROR&quot;;
	THAN=&quot;THAN&quot;;
	GREATER=&quot;GREATER&quot;;
	LESS=&quot;LESS&quot;;
	EQUAL=&quot;EQUAL&quot;;
	NUMERIC=&quot;NUMERIC&quot;;
	ALPHABETIC=&quot;ALPHABETIC&quot;;
	POSITIVE=&quot;POSITIVE&quot;;
	NEGATIVE=&quot;NEGATIVE&quot;;
	FROM=&quot;FROM&quot;;
	

}

{ // Comienza la zona de c&#243;digo nativo

boolean ultPic=false;
boolean enExec=false;
protected Token makeToken(int type)
{
	// Usamos la implementaci&#243;n de la superclase...
	Token result = null;

	
// while I don't have a parser for CICS and SQL.

	if (enExec)
	{
		if (type==END_EXEC||
			type==RETURN ||
			type==RECEIVE ||
			type==SEND   ||
			type==SYNCPOINT ||
			type==LINK
			)
		{
			enExec=false;
			result = super.makeToken(type);
		}
		else
		{
			result = super.makeToken(IDENT);
		}
	}
	else
	{
		if (type==NOT)
		{
			if (esOperadorRelacional())
			{
				type=NOT_REL;
				System.out.println (&quot;Se cambia a NOT&quot;);
			}
		}
		result = super.makeToken(type);
	}

	enExec=(type==SQL||type==CICS);
	ultPic =(type==PIC||type==PICTURE);
	
	
		
	// ... a&#241;adimos informaci&#243;n del nombre de fichero
	result.setFilename(super.getFilename());
	// ... y devolvemos el token
	return (result);
	
}

protected boolean esOperadorRelacional ()
{
	boolean operadorRelacional = false;
	int marca = mark();
	try
	{
		while ( LA(1)==' ')
		{
			try
			{
				match(' ');
			}
			catch (MismatchedCharException m)
			{
				System.out.println (&quot;Error en el match del NOT. &quot;+m.getMessage());
			}
		}
		switch (LA(1))
		{
			case '=':
				operadorRelacional = true;
				break;
			case '&gt;':
				operadorRelacional = true;
				break;
			case '&lt;':
				operadorRelacional = true;
				break;
			case 'g':
				operadorRelacional = true;
				try
				{
					match(&quot;greater&quot;);
				}
				catch (MismatchedCharException m)
				{
					operadorRelacional = false;
				}
				break;
			case 'l':
				operadorRelacional = true;
				try
				{
					match(&quot;less&quot;);
				}
				catch (MismatchedCharException m)
				{
					operadorRelacional = false;
				}
				break;
			case 'e':
				operadorRelacional = true;
				try
				{
					match(&quot;equal&quot;);
				}
				catch (MismatchedCharException m)
				{
					operadorRelacional = false;
				}
				break;
		}
	}
	catch (CharStreamException c)
	{
		System.out.println (&quot;problemas al leer despues del NOT&quot;);
	}
	rewind (marca);
	return (operadorRelacional);

}

}
COMENTARIO:
	'@' ( ~('\n'|'\r') )* 
	{$setType(Token.SKIP);}
	;

PAR_AB
	: {!ultPic }? '('
	;
PAR_CE
	: {!ultPic }? ')'
	;
CAD_COPY
	: (&quot;==&quot;) =&gt; &quot;==&quot; ( ~('=') )*	&quot;==&quot;
	{ $setType(LIT_COPY); }
	| '='
	{ $setType(IGUAL); }
	;
DOSPUNTOS
	: ':'
	;

MAS
	: {!ultPic }? 
	  '+' {_ttype = MAS;}
	  (
	  		(DIGITO)+ (',' (DIGITO)+)? 
			{_ttype = NUM;}
	   )?
	;
	
MENOS
	: {!ultPic }?
	  '-' {_ttype = MENOS;}
	  (
	  		(DIGITO)+ (',' (DIGITO)+)? 
			{_ttype = NUM;}
	   )?
	;
	
PUNTO
	: {!ultPic }?
	  '.' {_ttype = FIN_TODO;}
	  (
	  	(DIGITO)+ {_ttype=NUM;}
	   )?
	 ;
COMA
	: {!ultPic }?
	  ',' {_ttype=COMA;} 
	  (
	  	(DIGITO)+ {_ttype=NUM;}
	   )?
	 ;
	 
POR
	: {!ultPic }? '*'
	;

DIVIDE
	: '/'
	;

MAYOR
	: '&gt;'
		('=' {_ttype=MAYOR_IGUAL;})?
	;
MENOR: '&lt;'
		('=' {_ttype=MENOR_IGUAL;})?
	;

protected
LETRA
	: 'a'..'z'
	;

protected
DIGITO
	: '0'..'9'
	;


protected 
NL :
		(
		 (&quot;\r\n&quot;) =&gt; &quot;\r\n&quot; // MS-DOS
		 | '\r' // MACINTOSH
		 | '\n' // UNIX
		 )
		 {newline(); }
		 ;

BLANCO :
		( ' '
		| '\t'
		| NL
		) 
		{ $setType(Token.SKIP); } // La acci&#243;n del blanco: ignorar
		;

IDENT_NUM  options {testLiterals=true;}
	:{ ultPic }? ('+'|'-'|'$'|'b'|','|'e'|('0'..'9')|'x'|'s'|'v'|'z'|'*'|'('|')'|
	               {LA(2)!=' '&amp;&amp;LA(2)!='\n'&amp;&amp;LA(2)!='\r'}? '.')+  
	 {$setType (LIT_PIC);}
	|('x' '\'') =&gt; 'x' '\''( ~('\''|'\n'|'\r'|'\t') )*	'\'' 
	 {$setType (LIT_HEXADECIMAL);}
	| LETRA (LETRA|DIGITO|'-'|'_')*
	 {$setType (IDENT);}
	|((DIGITO)+ (LETRA|'-'|'_')) =&gt;(DIGITO)+ (LETRA|'-'|'_') (LETRA|DIGITO|'-'|'_')*
	 {$setType (IDENT);}
	|((DIGITO)+ '/' )=&gt; (DIGITO)+ '/' (DIGITO|'/')+
	 {$setType (FECHA);}
	| (DIGITO)+  ({LA(2)!=' '&amp;&amp;LA(2)!='\n'&amp;&amp;LA(2)!='\r'}? ',' (DIGITO)+)?
	 {$setType (NUM);}
	| '_' (LETRA|DIGITO|'_')*
	 {$setType (IDENT);}
	;

CADENA :
	'\''! 
	( ~('\''|'\n'|'\r'|'\t') )*
	'\''!
	| '&quot;'! ( ~('&quot;'|'\n'|'\r'|'\t') )* '&quot;'!
	;


















-------------- next part --------------
class condition extends Parser; // Se extiende Parser, y no Lexer
options {
	buildAST = true;
	importVocab = CobolLexVocab;
}

tokens
{
	CONDICION;
	FIELD;
	LIST;
	MOD_TEXTO;
	INDICE;
}

setCondition
	: (condition FIN_TODO!)*
	{#setCondition = #( #[SET, &quot;SET&quot;] ,setCondition);}
	;


condition
	: conditionOR
	{#condition = #( #[CONDICION, &quot;CONDICION&quot;] ,#condition);}
	;
	
conditionOR
	: conditionAND (OR^ conditionAND)*
	;

conditionAND
	: expresionRelacional (AND^ expresionRelacional)*
	;
expresionRelacional
	: (expresionSuma)? (operador_relacional expresionSuma)*
	;
	

	
expresionSuma
	: expresionPor ( (MAS^|MENOS^) expresionPor)*
	;

expresionPor
	: expresionUnitaria ( (POR^|DIVIDE^) expresionUnitaria)*
	;
	
expresionUnitaria
	: MENOS^ expresionUnitaria
	| MAS^ expresionUnitaria
	| expresionUnitariaNoMasMenos
	;
expresionUnitariaNoMasMenos
	: (IS)? NOT^ expresionUnitaria
	| expresionPrimaria
	;
	
expresionPrimaria
	: identifier
	| literal
	| POSITIVE
	| NEGATIVE
	| NUMERIC
	| ALPHABETIC
	| PAR_AB! condition PAR_CE!
	;

operador_relacional
	:(NOT_REL)? 
	(GREATER (THAN)? (OR EQUAL (TO)?)?
	|MAYOR_IGUAL
	|MAYOR
	|LESS (THAN)? (OR EQUAL (TO)?)?
	|MENOR_IGUAL
	|MENOR
	|EQUAL (TO)?
	|IGUAL
	)
	;

	literal
	: NUM
	| CADENA
	| cero
	| SPACE
	| SPACES
	| LIT_HEXADECIMAL
	| NULL
	;
cero
	: ZERO
	| ZEROS
	| ZEROES
	;
	

identifier
	{String texto=&quot;&quot;;String i=&quot;&quot;;}
	: i=in_of {texto=i;}
	 (modif_campo)*
	{
		## = #( #[FIELD,texto] ,##);
	}
	;

in_of returns [String t]
	{t=&quot;&quot;;}
	: i1:IDENT {t+=#i1.getText();}
	  ( ( in1:IN {t+=&quot; &quot;+#in1.getText();}
	      |of1:OF {t+=&quot; &quot;+#of1.getText();}
		 )
		 i2:IDENT {t+=&quot; &quot;+#i2.getText();}
	  )*
	;
	
modif_campo 
	: (PAR_AB expresionSuma DOSPUNTOS) =&gt; PAR_AB! expresionSuma DOSPUNTOS (expresionSuma)? PAR_CE!
	{#modif_campo= #( #[MOD_TEXTO,&quot;MOD_TEXTO&quot;],#modif_campo);}
	| PAR_AB! conditionList  PAR_CE!
	{#modif_campo= #( #[INDICE,&quot;INDICE&quot;],#modif_campo);}
	;


conditionList
	: condition (COMA condition)*
	{#conditionList = #( #[LIST, &quot;LIST&quot;] ,conditionList);}
	;
















</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015589.html">[antlr-interest] Relational operator in COBOL
</A></li>
	<LI>Next message: <A HREF="015590.html">[antlr-interest] Re: Reloading from previous parse?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15616">[ date ]</a>
              <a href="thread.html#15616">[ thread ]</a>
              <a href="subject.html#15616">[ subject ]</a>
              <a href="author.html#15616">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
