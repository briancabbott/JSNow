<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Profiler 2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Profiler%202&In-Reply-To=005301c5f735%243ff9a5a0%246b02a8c0%40hercules">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014617.html">
   <LINK REL="Next"  HREF="014633.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Profiler 2</H1>
    <B>Martin Probst</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Profiler%202&In-Reply-To=005301c5f735%243ff9a5a0%246b02a8c0%40hercules"
       TITLE="[antlr-interest] Profiler 2">mail at martin-probst.com
       </A><BR>
    <I>Fri Dec  2 06:14:52 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="014617.html">[antlr-interest] Profiler 2
</A></li>
        <LI>Next message: <A HREF="014633.html">[antlr-interest] Profiler 2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14625">[ date ]</a>
              <a href="thread.html#14625">[ thread ]</a>
              <a href="subject.html#14625">[ subject ]</a>
              <a href="author.html#14625">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> 10x?. That's a little way out there. ANTLR C++ parsers aren't that slow
</I>&gt;<i> iirc. Esp. once they are compiled in release mode with optimizations turned
</I>&gt;<i> on. One just needs to remember to use a [f]lex scanner as the sample
</I>&gt;<i> demonstrates.
</I>&gt;<i>
</I>&gt;<i> I wonder what factors came into play on your project.
</I>
Well, a keyword free language which made the (ANTLR-generated) lexer
very complex, a programmer that tried to avoid to much hassle by working
around some more complexity in the lexer with ()=&gt; blocks, etc. So no
flex there.

On the other hand, the LALR guy actually wrote his own LALR(1) parser
generation tool for the job. Don't ask me why. Needless to say that my
parser was working, tested &amp; finished in about 1 month and his wasn't
really done after 6 (and of course much more error prone).

My point was not that 10x is really a representative number, but a
naive/quick implementation using only ANTLR (no flex) can be
significantly slower than a LALR parser, without making really stupid
errors on the ANTLR part.

I'm pretty sure that with a hand-coded/flex Lexer and some more
optimisations this would have gone down significantly, and there would
have been plenty of time for that in the 5 month productivity
difference ;-)

Martin

</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014617.html">[antlr-interest] Profiler 2
</A></li>
	<LI>Next message: <A HREF="014633.html">[antlr-interest] Profiler 2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14625">[ date ]</a>
              <a href="thread.html#14625">[ thread ]</a>
              <a href="subject.html#14625">[ subject ]</a>
              <a href="author.html#14625">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
