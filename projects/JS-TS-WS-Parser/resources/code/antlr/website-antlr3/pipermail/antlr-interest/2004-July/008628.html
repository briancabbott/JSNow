<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Can't create AST Node?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Can%27t%20create%20AST%20Node%3F&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008639.html">
   <LINK REL="Next"  HREF="008633.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Can't create AST Node?</H1>
    <B>Tiller, Michael (M.M.)</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Can%27t%20create%20AST%20Node%3F&In-Reply-To="
       TITLE="[antlr-interest] Can't create AST Node?">mtiller at ford.com
       </A><BR>
    <I>Thu Jul  8 13:23:58 PDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008639.html">[antlr-interest] Can't create AST Node?
</A></li>
        <LI>Next message: <A HREF="008633.html">[antlr-interest] Can't create AST Node?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8628">[ date ]</a>
              <a href="thread.html#8628">[ thread ]</a>
              <a href="subject.html#8628">[ subject ]</a>
              <a href="author.html#8628">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Well, when I'm done I'm going to try and convince the powers that be
here to allow me to release the code to try and promote the use of the
language by vendors, suppliers, etc.  We'll see if that flies.

I doubt I'm going to have anything very interesting to show (from a Java
perspective) because this is an extremely low priority to my management
so I suspect it will very quickly be on the very back burner (before I
get something useful).

With regards to ANTLR 'fest, I'm happy to share my experiences and ideas
(even if I don't have any actual code worth/able to share).  I don't
doubt the value of tree parsers in many circumstances and, to be honest,
I don't know if there is really a barrier to enjoying the best of both
worlds.  I'm just at the point where I'm tired of wrestling the het-AST
support.  With time, ANTLR may very well support the best of both
worlds.

I think there may be some interesting possibilities for using
introspection on the Java side to deal with tree walking.  For example,
do you really need first child, next sibling, etc when you can get a
complete inventory of fields?!?  I mean why not make a tree walker that
works with native objects rather than having to create special AST
nodes?  Couldn't you just use java.reflect + instanceof (I'm no Java
expert and I'm not sure how &quot;portable&quot; it would be).  That way you could
both walk existing Java classes and potentially create new ones as you
went.  The idea is AST=java.Object, children=java.reflect.Fields and you
just use/create native Java objects.  No special base classes (for
example).  Perhaps the overhead would be too much?!?  Just a thought.

One last comment, I suspect that it might be useful to provide automatic
&quot;visitor generation&quot; for people where visitors seem more attractive (ala
SableCC?).

--
Mike

&gt;<i> -----Original Message-----
</I>&gt;<i> From: Monty Zukowski [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">monty at codetransform.com</A>]
</I>&gt;<i> Sent: Thursday, July 08, 2004 4:03 PM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>
</I>&gt;<i> Cc: Monty Zukowski
</I>&gt;<i> Subject: Re: [antlr-interest] Can't create AST Node?
</I>&gt;<i> 
</I>&gt;<i> Yeah, it's all coming back to me now.  I remember reading the paper
</I>&gt;<i> before, I think.  I'm glad to hear you are now targeting Java, just
</I>&gt;<i> because that's easier for me to understand.  At some point I'd really
</I>&gt;<i> like to see the code to this.  This would make an excellent project to
</I>&gt;<i> analyze in preparation for the ANTLR 'fest, which seems to be coming
</I>in
&gt;<i> October according to the latest rumors.  It's a wacky language, rather
</I>&gt;<i> dense, declarative instead of interpreted, and you're doing source
</I>code
&gt;<i> analysis, which is cool.  From your description you need random
</I>access,
&gt;<i> some graph processing type of functionality, as well as typical tree
</I>&gt;<i> walker stuff.
</I>&gt;<i> 
</I>&gt;<i> Any chance I could have a deeper look?  I'd be happy to sign an NDA if
</I>&gt;<i> necessary.  You can contact me privately if you like through my
</I>&gt;<i> website.
</I>&gt;<i> 
</I>&gt;<i> Monty
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ANTLR &amp; Java Consultant -- <A HREF="http://www.codetransform.com">http://www.codetransform.com</A>
</I>&gt;<i> ANSI C/GCC transformation toolkit --
</I>&gt;<i> <A HREF="http://www.codetransform.com/gcc.html">http://www.codetransform.com/gcc.html</A>
</I>&gt;<i> Embrace the Decay -- <A HREF="http://www.codetransform.com/EmbraceDecay.html">http://www.codetransform.com/EmbraceDecay.html</A>
</I>&gt;<i> 
</I>&gt;<i> On Jul 8, 2004, at 12:34 PM, Tiller, Michael ((M.M.)) wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; -----Original Message-----
</I>&gt;<i> &gt;&gt; From: Monty Zukowski [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">monty at codetransform.com</A>]
</I>&gt;<i> &gt;&gt; Subject: Re: [antlr-interest] Can't create AST Node?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; On Jul 8, 2004, at 10:52 AM, Tiller, Michael ((M.M.)) wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Still not sure what you are trying to do :)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Well, as I've said many times, I'm no expert in compiler
</I>development.
&gt;<i> &gt; The language I'm working with is Modelica (<A HREF="http://www.modelica.org,">http://www.modelica.org,</A>
</I>&gt;<i> &gt; which includes the language specification, i.e. grammar +
</I>semantics).
&gt;<i> &gt;
</I>&gt;<i> &gt; I'm trying to do some very specific things but protecting for others
</I>as
&gt;<i> &gt; well.  The main goal of my work is in code metrics.  So I'm
</I>interested
&gt;<i> &gt; in analyzing source code.  But Modelica is more of a declarative
</I>&gt;<i> &gt; language rather than an imperative or procedural language.  This is
</I>&gt;<i> &gt; important because Modelica involves an &quot;instantiation&quot; process (you
</I>&gt;<i> &gt; might also call it an elaboration process) which is the tricky part
</I>&gt;<i> &gt; (from my perspective).  There are a couple of papers on the Modelica
</I>&gt;<i> &gt; site from the most recent conference that discuss language tools
</I>&gt;<i> &gt; (including a paper I wrote about what I'm doing).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; Yeah, but that can get cumbersome at the object level with
</I>recursion
&gt;<i> &gt;&gt; and alternatives.  It depends a great deal on the complexity of the
</I>&gt;<i> &gt;&gt; language.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sure and I'm completely willing to accept that I'm just being stupid
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt; not recognizing the value of the tree parsers.  It's a bit of a
</I>&gt;<i> &gt; learning
</I>&gt;<i> &gt; experience.  What I can say is that I have implemented a big chunk
</I>of
&gt;<i> &gt; what I wanted and I never used a tree parser and I still don't see
</I>how
&gt;<i> &gt; it would help.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt;&gt; Think about it this way.  Imagine trying to program in Java or C++
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt;&gt;&gt; not ever using the &quot;.&quot; (as in computer.drives[1].head.position)
</I>and
&gt;<i> &gt;&gt;&gt; instead having to interrogate every object using only
</I>&gt;<i> &gt; &quot;getFirstChild()&quot;
</I>&gt;<i> &gt;&gt;&gt; and &quot;getNextSibling()&quot; and having only type and text information.
</I>&gt;<i> &gt;&gt;&gt; Imagine trying to express what I just typed? (i.e.
</I>&gt;<i> &gt;&gt;&gt; computer.drives[1].head.position) You get something like:
</I>&gt;<i> &gt;&gt;&gt; ...
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; Yikes!  Isn't &quot;computer.drives[1].position.head&quot; much simpler and
</I>&gt;<i> &gt;&gt;&gt; statically checkable?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; Sure it is.  Tree grammars are appropriate for walking but not
</I>&gt;<i> &gt;&gt; searching.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; And perhaps that is at the heart of this.  The elaboration process
</I>&gt;<i> &gt; involves working with one type definition and then constantly
</I>expanding
&gt;<i> &gt; the branches of it.  There really isn't much &quot;searching&quot;.  There is
</I>&gt;<i> &gt; some
</I>&gt;<i> &gt; work in determining the scope for different statements and stuff but
</I>&gt;<i> &gt; that is pretty simple (compared to the elaboration semantics).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; When you translate you typically walk the whole tree.
</I>&gt;<i> &gt;&gt; Sometimes you index the tree with a symbol table.  But rarely do
</I>you
&gt;<i> &gt;&gt; say 'give me the first term of the third expression in the for
</I>loop.'
&gt;<i> &gt;
</I>&gt;<i> &gt; In my current implementation, I find myself always wanting to grab a
</I>&gt;<i> &gt; specific subtree and having to search for it (analogous to what I
</I>&gt;<i> &gt; describe above).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Furthermore, I suspect part of the applicability of tree walking
</I>&gt;<i> &gt; involves what order you do things in.  At any given level in my tree
</I>I
&gt;<i> &gt; start at that level, do several passes only at that level (and doing
</I>&gt;<i> &gt; different things) and then I recursively follow that procedure for
</I>each
&gt;<i> &gt; child.  It seems like this juxtaposes the order that is more natural
</I>&gt;<i> &gt; for
</I>&gt;<i> &gt; tree walkers which would be to do one task (e.g. scope resolution)
</I>for
&gt;<i> &gt; the whole tree and then do another task for the whole tree.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; You can read the instantiation process in the Modelica specification
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt; if you see a natural way to map it into a tree parser, let me know.
</I>&gt;<i> &gt; Keep in mind that the scoping rules in Modelica are a little
</I>difficult
&gt;<i> &gt; from a compiler writer point of view (lots of non-fully qualified
</I>type
&gt;<i> &gt; names to deal with).  Scoping also involves traversal of both the
</I>type
&gt;<i> &gt; hierarchy and the &quot;instance hierarchy&quot; (the elaborated tree).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; Monty
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; Mike
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Yahoo! Groups Links
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>


 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
    <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
    <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
    <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008639.html">[antlr-interest] Can't create AST Node?
</A></li>
	<LI>Next message: <A HREF="008633.html">[antlr-interest] Can't create AST Node?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8628">[ date ]</a>
              <a href="thread.html#8628">[ thread ]</a>
              <a href="subject.html#8628">[ subject ]</a>
              <a href="author.html#8628">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
