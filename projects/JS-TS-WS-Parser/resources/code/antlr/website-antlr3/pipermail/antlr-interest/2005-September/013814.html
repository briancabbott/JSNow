<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] C++ beginner questions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20C%2B%2B%20beginner%20questions&In-Reply-To=20050929194619.GB1216%40mail">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013807.html">
   <LINK REL="Next"  HREF="013824.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] C++ beginner questions</H1>
    <B>Bryan Ewbank</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20C%2B%2B%20beginner%20questions&In-Reply-To=20050929194619.GB1216%40mail"
       TITLE="[antlr-interest] C++ beginner questions">ewbank at gmail.com
       </A><BR>
    <I>Thu Sep 29 16:39:45 PDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="013807.html">[antlr-interest] C++ beginner questions
</A></li>
        <LI>Next message: <A HREF="013824.html">[antlr-interest] C++ beginner questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13814">[ date ]</a>
              <a href="thread.html#13814">[ thread ]</a>
              <a href="subject.html#13814">[ subject ]</a>
              <a href="author.html#13814">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi David,

There is a small but thriving C++ contingent here :-)

On 9/29/05, David Maxwell &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">david at crlf.net</A>&gt; wrote:
&gt;<i> 1) Is there a list of Java -&gt; C++ equivalent methods?
</I>
There was none I could find, but in general if you replace &quot;.&quot; with
&quot;-&gt;&quot; for function calls you are dead on.  Likewise, replace &quot;.&quot; with
&quot;::&quot; for data members is a pretty good guess.  For your example, I
seem to remember that $setType(Token::SKIP) works okay -- but I use a
lex-based scanner, as in one of the C++ examples (seach for
example/c++/*.l for guidance :-)

&gt;<i> Almost all of the tutorials target Java, and it's often not clear to me
</I>&gt;<i> how to get the same effect in C++.
</I>
This has been an issue for me to; I'm sure there are some workarounds
that I've done in C++ that could be done more elegantly, but it
works...

&gt;<i> 2) Are there any examples targetting C++ that do NOT use the AST
</I>&gt;<i> funcionality?
</I>
Not as far as I know.  You might reconsider using a tree to split
&quot;parse&quot; from &quot;operate&quot;; I've found it a very powerful model even when
replacing a yacc product.

&gt;<i> For example, I can't find even a single instance of using a token's
</I>&gt;<i> text, in a C++ example. Reading the generated C++ doesn't make it any
</I>&gt;<i> clearer either.
</I>&gt;<i>
</I>&gt;<i> I've labelled tokens in the _Paser_ and used -&gt;getText() there, but in
</I>&gt;<i> the _Lexer_ it doesn't work for me. The label ends up becoming a goto
</I>&gt;<i> target label, and not an object with a getText() method. Even with gdb
</I>&gt;<i> on the generated program, I can't find any variable that holds the
</I>&gt;<i> token's text.
</I>
I think you can use &quot;#tokenname&quot; in the lexer, but I have to again
shrug here, as I use lex.

&gt;<i> 4) Is there any equivalent to the Lex/Yacc documentation 'How to resolve
</I>&gt;<i> shift/reduce conflicts' - for how to address lexical nondeterminisms in
</I>&gt;<i> antlr?
</I>&gt;<i>
</I>&gt;<i> For example, I've noticed that rule order in the Lexer DOES matter, but
</I>&gt;<i> I can't find any documentation about how to order rules to get the
</I>&gt;<i> desired results. I've just been following 'most specific first', but
</I>&gt;<i> I'd appreciate a more precise answer.
</I>
Focusing on the &quot;yacc&quot; side of this, I have been very generous with
&quot;greedy=true&quot; in my grammar; it's not always needed - in fact, I seem
to remember it's the default behavior(?) - but it always clears up
what's going on.

The key thing to resolve conflicts is to eliminate duplicate left
prefixes from your rules.  You can't simple take a yacc grammar and
throw it at ANTLR (LALR -&gt; LL; ugh).  Common left-prefixes will cause
you grief, especially coming from yacc.  I seem to recall being unable
to see that type of problem for several days/weeks.  I've been a happy
antlr user now for about a year, and I would prefer not to go back
(but my boss has other ideas :-).

&gt;<i> I'll probably have more questions as I do more, but that's enough for
</I>&gt;<i> now ;-)
</I>
This is the place; welcome to our little corner of the web!
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013807.html">[antlr-interest] C++ beginner questions
</A></li>
	<LI>Next message: <A HREF="013824.html">[antlr-interest] C++ beginner questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13814">[ date ]</a>
              <a href="thread.html#13814">[ thread ]</a>
              <a href="subject.html#13814">[ subject ]</a>
              <a href="author.html#13814">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
