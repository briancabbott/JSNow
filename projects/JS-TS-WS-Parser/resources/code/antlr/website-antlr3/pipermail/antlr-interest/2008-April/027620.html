<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] XML QName Character Validation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20XML%20QName%20Character%20Validation&In-Reply-To=%3C315C9076-9A30-40FC-82A9-4DC92D5A0FAA%40martin-probst.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027615.html">
   <LINK REL="Next"  HREF="027627.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] XML QName Character Validation</H1>
    <B>Martin Probst</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20XML%20QName%20Character%20Validation&In-Reply-To=%3C315C9076-9A30-40FC-82A9-4DC92D5A0FAA%40martin-probst.com%3E"
       TITLE="[antlr-interest] XML QName Character Validation">mail at martin-probst.com
       </A><BR>
    <I>Fri Apr  4 02:24:54 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027615.html">[antlr-interest]  How to suppress tokens with rewrite rules
</A></li>
        <LI>Next message: <A HREF="027627.html">[antlr-interest] XML QName Character Validation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27620">[ date ]</a>
              <a href="thread.html#27620">[ thread ]</a>
              <a href="subject.html#27620">[ subject ]</a>
              <a href="author.html#27620">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi all,

I'm making really nice progress with my XQuery grammar, thanks to the  
help of Jim Idle and Ter's awesome LL(*) algorithm.

I'm facing a single last problem: in XQuery, QNames play an important  
role. QNames and keywords overlap, so it's a keyword-free grammar. The  
rules on what makes a legal QName from the XML spec are quite complex  
in their selection of Unicode characters, see here: <A HREF="http://www.w3.org/TR/REC-xml/#NT-Letter">http://www.w3.org/TR/REC-xml/#NT-Letter</A>

If I naively translate that to ANTLR fragment rules, ANTLR fails to  
analyze those rules:
warning(205): XQuery.g:1:8: ANTLR could not analyze this decision in  
rule Tokens; often this is because of recursive rule references  
visible from the left edge of alternatives.  ANTLR will re-analyze the  
decision with a fixed lookahead of k=1.  Consider using &quot;options  
{k=1;}&quot; for that decision and possibly adding a syntactic predicate.
error(10):  internal error:  
org.antlr.tool.Grammar.createLookaheadDFA(Grammar.java:1152): could  
not even do k=1 for decision 24; reason: timed out (&gt;1000ms)

No blame here, those rules are probably better handled in a different  
way. The question is: which different way? I tried taking those rules  
out into a Java file called CharHelper, and having these rules:

... lots of tokens, snip ...
UNION	:	'union';
UNORDERED
		:	'unordered';
... snip ...
QName	:	NCName (':' NCName)?;
fragment NCName	:	NCNameStartChar NCNameChar*;
fragment NCNameStartChar
		:	Letter | '_';
fragment NCNameStartChar
		:	Letter | '_';
fragment NCNameChar
		:	Letter | XMLDigit | '.' | '-' | '_' | CombiningChar | Extender;
fragment Letter
		:	{ CharHelper.isLetter(LA(1) }? =&gt;  .;
fragment BaseChar
		:	{ CharHelper.isBaseChar(LA(1) }? =&gt;  .;
fragment Ideographic	
		:	{ CharHelper.isIdeographic(LA(1)) }? =&gt;  .;
fragment XMLDigit
		:	{ CharHelper.isXMLDigit(LA(1)) }? =&gt;  .;
fragment CombiningChar
		:	{ CharHelper.isCombiningChar(LA(1)) }? =&gt;  .;
fragment Extender
		:	{ CharHelper.isExtender(LA(1)) }? =&gt;  .;

But this makes ANTLR complain about ambiguities:
warning(209): XQuery.g:319:1: Multiple token rules can match input  
such as &quot;'u'&quot;: UNION, UNORDERED, QName, Wildcard
As a result, tokens(s) UNORDERED,QName,Wildcard were disabled for that  
input

So apparently the lexical analysis is now behaving quite differently.  
Before all this, I just specified NCName to be ('a'..'z' | 'A'..'Z')+  
and it worked like a charm. I somehow fail to see how (effectivly)  
changing that to '\u0000'..'\uFFFE' with a gating predicate changes  
this to be ambiguous.

Any ideas?

BTW: I've implemented a nice technique of lexer switching based on  
parser context. XQuery is a language who's lexical structure changes  
quite radically between normal expressions and the embedded XML  
literals.

This is somewhat similar to the example at <A HREF="http://www.antlr.org/wiki/display/ANTLR3/Island+Grammars+Under+Parser+Control">http://www.antlr.org/wiki/display/ANTLR3/Island+Grammars+Under+Parser+Control</A> 
. However I don't need to switch the full parser, as my grammatical  
rules for the whole language fit into one grammar - I just needed to  
change the way tokens are generated by the lexer. I'm going to write  
up my technique as an addendum to that page once it's done.

I'd also like to make my grammar freely available on antlr.org once  
it's done, if there is interest. Do I just send it to Ter, or how does  
that work?

Thanks,
Martin
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027615.html">[antlr-interest]  How to suppress tokens with rewrite rules
</A></li>
	<LI>Next message: <A HREF="027627.html">[antlr-interest] XML QName Character Validation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27620">[ date ]</a>
              <a href="thread.html#27620">[ thread ]</a>
              <a href="subject.html#27620">[ subject ]</a>
              <a href="author.html#27620">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
