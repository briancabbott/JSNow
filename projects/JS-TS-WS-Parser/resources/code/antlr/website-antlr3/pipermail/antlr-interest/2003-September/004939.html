<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Error when my C++ project since updating antlr
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Error%20when%20my%20C%2B%2B%20project%20since%20updating%20antlr&In-Reply-To=20030911151357.K27584%40cs.utwente.nl">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004938.html">
   <LINK REL="Next"  HREF="004940.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Error when my C++ project since updating antlr</H1>
    <B>Anthony Breneli&#232;re</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Error%20when%20my%20C%2B%2B%20project%20since%20updating%20antlr&In-Reply-To=20030911151357.K27584%40cs.utwente.nl"
       TITLE="[antlr-interest] Error when my C++ project since updating antlr">abreneliere at telys.com
       </A><BR>
    <I>Thu Sep 11 06:53:40 PDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="004938.html">[antlr-interest] Re: inversion problems: unreachable statemen
	ts &amp; lex failures
</A></li>
        <LI>Next message: <A HREF="004940.html">[antlr-interest] updated ANTLR tutorial added to getting started doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4939">[ date ]</a>
              <a href="thread.html#4939">[ thread ]</a>
              <a href="subject.html#4939">[ subject ]</a>
              <a href="author.html#4939">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ok,

I just downloaded the file
<A HREF="http://wwwhome.cs.utwente.nl/~klaren/antlr/antlr-20030911.tar.gz">http://wwwhome.cs.utwente.nl/~klaren/antlr/antlr-20030911.tar.gz</A>

I re-generated all the grammar files, i compiled the project.
..but the problem is still there:

CIAOParser.hpp(330) : error C2555: 'CIAOParser::getAST': overriding 
virtual function return type differs and is not covariant from 
'antlr::Parser::getAST'
        antlr\antlr\Parser.hpp(103) : see declaration of 
'antlr::Parser::getAST'

The problem in not the 2.7.2 01/03 version, it dos just appear when i 
upgrade to the new version.

I send to you my iCAIOGrammar.g file, and the 'Main' function that call 
the parser.

Cordially,
Anthony

Ric Klaren wrote:

&gt;<i>Hi,
</I>&gt;<i>
</I>&gt;<i>On Fri, Sep 05, 2003 at 08:02:38PM +0200, Anthony Breneli?re wrote:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>error C2555: 'CIAOParser::getAST': overriding virtual function return 
</I>&gt;&gt;<i>type differs and is not covariant from 'antlr::Parser::getAST'
</I>&gt;&gt;<i>        antlr\antlr\Parser.hpp(103) : see declaration of 
</I>&gt;&gt;<i>'antlr::Parser::getAST'
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>i didnt have that error before, and methods getAST are the same in the 
</I>&gt;&gt;<i>last version
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I've set &quot;CommonAST&quot; as the AST node of the grammar.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>What's behind this error message ?
</I>&gt;&gt;<i>Anyone has an idea about how to solve this problem ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>New snapshot is up, I think it should fix this. 
</I>&gt;<i>
</I>&gt;<i>Note: RPM's are not updated yet (they are the previous snapshot version).
</I>&gt;<i>
</I>&gt;<i>Cheers,
</I>&gt;<i>
</I>&gt;<i>Ric
</I>&gt;<i>  
</I>&gt;<i>
</I>
 

Your use of Yahoo! Groups is subject to <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A> 

-------------- next part --------------
//*********************************************************************************
//                          THE CIAO GRAMMAR FILE
//                        author : Anthony Breneli&#232;re
//
// Description : this files is composed of two parts,
//
//    1. The grammar, the grammar validates the syntax of the
// file, the grammar part gets tokens from the lexer and products a tree node for
// the tree walker
//
//    2. The Lexer, the lexer reads caracters from the input stream and creates a 
// a stream of tokens, that are sent to the parser (to the functions of the grammar).
//

// These lines are added to the lexer/parser header files
//
header {
	#include &quot;antlr.extended/ASTFactoryExt.hpp&quot;
	#include &quot;antlr.extended/ASTPNode.hpp&quot;
	#include &quot;world/WWorld.hpp&quot;
	#include &quot;debugger/CIAODebugReport.hpp&quot;
	
	using namespace std;
	using namespace ciao;
	using namespace world;
	using namespace antlr;
}

// These lines are added to the lexer/parser cpp files
//
header &quot;post_include_cpp&quot; {

	#include &lt;iostream&gt;
	#include &quot;world/WPropertiesTypes.hpp&quot;

	void CIAOParser::reportError(const RecognitionException&amp; ex)
	{
		CObjectList * objs;
		CObjectList * objs2;
		CObject * _templ;
		CObject * _text;
		int nLine = 0, nTLine = 0;
		char buffer[30];
		
		_templ = new CObject();
		_templ-&gt;aP(p_CATEGORY, &quot;CIAOText&quot;);
		
		objs = new CObjectList();
		world-&gt;findObjectsWProp( objs, world-&gt;content, _templ );
		// objs.sort( &quot;BufferLine&quot; );
		for ( CObjectList::iterator ir = objs-&gt;begin();
			ir != objs-&gt;end();
			ir++ )
		{
			nTLine = atoi( (*ir)-&gt;getValue(p_BUFFERLINE).c_str() );
			if ( nTLine &lt;= ex.getLine() &amp;&amp; nTLine &gt; nLine ) nLine = nTLine;
		}
		_templ-&gt;clear();
		_templ-&gt;aP( p_BUFFERLINE, itoa( nLine, buffer, 10) );
		objs2 = new CObjectList();
		world-&gt;findObjectsWProp( objs2, objs, _templ );
		
		if (objs2-&gt;size() == 1)
		{
			
			_text = objs2-&gt;front();
		    
			cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;fichier &quot; &lt;&lt; _text-&gt;getValue( p_FILENAME )
				&lt;&lt; &quot; page &quot; &lt;&lt; _text-&gt;getValue( p_PAGENUMBER )
				&lt;&lt; &quot; ligne &quot; &lt;&lt; _text-&gt;getValue( p_LINENUMBER )
				&lt;&lt; endl &lt;&lt; &quot;------------------------------&quot;
				&lt;&lt; endl &lt;&lt; &quot;ID : &quot; &lt;&lt; _text-&gt;getValue(p_IDENTIFIER)
				&lt;&lt; endl &lt;&lt; _text-&gt;getValue(p_CONTENT)
				&lt;&lt; endl &lt;&lt; &quot;------------------------------&quot;
				&lt;&lt; endl &lt;&lt; &quot;Erreur : &quot; &lt;&lt; ex.toString() &lt;&lt; endl;
		} 
		else
			cout &lt;&lt; endl &lt;&lt; &quot;Unknown error : the corresponding Text has not been found&quot;
				&lt;&lt; &quot; by the debugger&quot; &lt;&lt; endl;
			
		delete objs;
		delete objs2;
		delete _templ;
	}
	
}

options {
	language=&quot;Cpp&quot;;
}

//***************************************************
//                 THE CIAO PARSER
//
class CIAOParser extends Parser;

options {
	k = 3;		// k tokens are used to determine the choice between the different
				// alternatives of a rule
	buildAST = true;
	importVocab = CIAOLex;
	exportVocab = CIAOPar;
	ASTLabelType = &quot;RefPNode&quot;;
	defaultErrorHandler = true;
}

tokens {	// those tokens are declared because they are used as root nodes
			// for the tree node creation

	// used by the grammar and the walkers:
	
	R_DAT=&quot;[data types]&quot;;		// [data types]
	R_ENS=&quot;[entity stat]&quot;;		// [entity stat]
	R_ENI=&quot;[id]&quot;;				// [id]
	R_ATS=&quot;[attributes]&quot;;		// [attributes]
	R_MES=&quot;[methods]&quot;;			// [methods]
	R_INH=&quot;[inherits]&quot;;			// [inherits]
	R_ASS=&quot;[association]&quot;;		// [association]
	R_CAR=&quot;[cardinality]&quot;;		// [cardinality]
	R_ACS=&quot;[action]&quot;;			// [action]
	R_USS=&quot;[use]&quot;;				// [use]
	R_FUS=&quot;[function]&quot;;			// [function]
	R_FRS=&quot;[free]&quot;;				// [free]
	R_INV=&quot;[invariant]&quot;;		// [invariant]
	R_COS=&quot;[condition]&quot;;		// [condition]
	R_DAL=&quot;[decl aliases]&quot;;		// [decl aliases]
	R_ALI=&quot;[aliases]&quot;;			// [aliases]
	R_IHM=&quot;[ihm]&quot;;				// [ihm]
	R_ATL=&quot;[attributeList]&quot;;	// [attributeList]
	R_ENT=&quot;[entity]&quot;;			// [entity]
	R_ENC=&quot;[entityComponent]&quot;;	// [entityComponent]
	R_SET=&quot;[set]&quot;;				// [set]
	R_SEC=&quot;[setComponent]&quot;;		// [setComponent]
	R_CLA=&quot;[clause]&quot;;			// [clause]
	R_CAT=&quot;[clause attribute]&quot;;	// [clause attribute]
	R_ATT=&quot;[attribute]&quot;;		// [attribute]
	R_STA=&quot;[statement]&quot;;		// [statement]
	R_PRP=&quot;[properties]&quot;;		// [properties]
	R_IDE=&quot;[identifier]&quot;;		// [identifier]
	R_MOP=&quot;[mod properties]&quot;;	// [mod properties]
	R_MVE=&quot;[mod version]&quot;;		// [mod version]
	R_MNA=&quot;[mod name]&quot;;			// [mod name]
	R_MDA=&quot;[mod date]&quot;;			// [mod date]
	R_SST=&quot;[state]&quot;;			// [state]
	R_REQ=&quot;[requirement]&quot;;		// [requirement]
	R_EQU=&quot;[equivalence]&quot;;      // [equivalence]
	R_PRO=&quot;[protection]&quot;;		// [protection]
	R_SIL=&quot;[protectors]&quot;;		// [protectors]
	R_FNC=&quot;[function_call]&quot;;    // [function_call]
}

{
private:
	CWorld * world;
	CDebugReport * debugR;
	string sCurrentStat;
	
public:
	ASTFactoryExt * astFactoryExt;

	CIAOParser(TokenStream&amp; lexer, CWorld * _world )
	: LLkParser(lexer,3), world( _world )
	{
		debugR = new CDebugReport( &amp;cerr );
	}
	
	~CIAOParser() 
	{
		delete debugR;
	}
	
	void reportError(const RecognitionException&amp; ex);
}

// Root rule for the grammar:

ciaoDocument 
	:	( DELIMITER! statementA DELIMITER! )*
;
exception
catch [ RecognitionException &amp; ex ]
{
		reportError( ex );
		consume();
		consumeUntil(_tokenSet_0);
}

statementA!
	{ sCurrentStat = &quot;&quot;; }
	:	( b:staStateA )? a:statId c:statement
	{ #statementA = #( #[R_STA, &quot;[statement]&quot;], #a, #b, #c ); }
;

statement
	:	{ sCurrentStat == &quot;EXIG&quot; }? requirement
	|	{ sCurrentStat == &quot;FREE&quot; }? statFree
	|	{ sCurrentStat == &quot;ENTITY&quot; }? statEntity
	|	{ sCurrentStat == &quot;ACTION&quot; }? action
	|	{ sCurrentStat == &quot;ASSOCIATION&quot; }? statAssociation
	|	{ sCurrentStat == &quot;CONDITION&quot; }? statCondition
	|	{ sCurrentStat == &quot;USE&quot; }? use
	|	{ sCurrentStat == &quot;AFFECTATION&quot; }? statAssignment
	|	{ sCurrentStat == &quot;DATATYPES&quot; }? statDataTypes
	|	{ sCurrentStat == &quot;IHM&quot; }? ihm
	|	{ sCurrentStat == &quot;FUNCTION&quot; }? function
	|	{ sCurrentStat == &quot;DOC_PROPERTIES&quot; }? moduleProperties
	|	{ sCurrentStat == &quot;INVARIANT&quot; }? invariant
	|	{ sCurrentStat == &quot;PROTECTION&quot; }? protection
	|	REQU! equivalence
;

staStateA!
	:	a:staState
	{ #staStateA = #( #[R_SST, &quot;[state]&quot;], #a ); }
;

staState
	:	&quot;NEW&quot; 
	|	&quot;CANCELED&quot;
	|	&quot;CHANGED&quot;
	|	&quot;VALID&quot;
	|	staStateSymbol
;

staStateSymbol
	:	PLUS
	|	MINUS
	|	LNOT
	|	CROSS
;
	
statId!
	:	a:ID_EXIG
		{ sCurrentStat = &quot;EXIG&quot;; 
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #a );
		}
	|	b:ID_FREE
		{ sCurrentStat = &quot;FREE&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #b );
		}
	|	c:ID_ENTITY
		{ sCurrentStat = &quot;ENTITY&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #c );
		}
	|	d:ID_ACTION
		{ sCurrentStat = &quot;ACTION&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #d );
		}
	|	e:ID_ASSOCIATION 
		{ sCurrentStat = &quot;ASSOCIATION&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #e );
		}
	|	f:ID_CONDITION
		{ sCurrentStat = &quot;CONDITION&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #f );
		}
	|	g:ID_USE
		{ sCurrentStat = &quot;USE&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #g );
		}
	|	h:ID_AFFECTATION 
		{ sCurrentStat = &quot;AFFECTATION&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #h );
		}
	|	i:ID_DATATYPES
		{ sCurrentStat = &quot;DATATYPES&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #i );
		}
	|	j:ID_IHM
		{ sCurrentStat = &quot;IHM&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #j );
		}
	|	k:ID_FUNCTION
		{ sCurrentStat = &quot;FUNCTION&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #k );
		}
	|	l:ID_DOC_PROPERTIES
		{ sCurrentStat = &quot;DOC_PROPERTIES&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #l );
		}
	|	m:ID_INVARIANT
		{ sCurrentStat = &quot;INVARIANT&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #m );
		}
	|	n:ID_PROTECTION
		{ sCurrentStat = &quot;PROTECTION&quot;;
		  #statId = #( #[R_IDE, &quot;[identifier]&quot;], #n );
		}
;

// protection rules {

	protection!
		:   COLON a:statIdProtectorList BSR b:ID_INVARIANT
		{
		#protection = 
			#( #[R_PRO, &quot;[protection]&quot;],
			#( #[R_SIL, &quot;[protectors]&quot;], #a ), #b );
		}
	;

	statIdProtectorList
		:	statIdProtector (COMMA! statIdProtector)*
	;

	statIdProtector
		: ( ID_FREE | ID_EXIG | ID_CONDITION | ID_INVARIANT )
	;

// }

equivalence
	:	a:statId
	{ #equivalence = #( #[R_EQU, &quot;[equivalence]&quot;], #a ); }
;

// protection rules {

	moduleProperties!
		:	a:modulePropertyList
		{ #moduleProperties = #( #[R_MOP, &quot;[mod properties]&quot;], #a ); }
	;

	modulePropertyList
		:	( moduleProperty )*
	;

	moduleProperty!
		:	&quot;NAME&quot; EQUAL a:STRING
		{ #moduleProperty = #( #[R_MNA, &quot;[module name]&quot;], #a ); }
		|	&quot;VERSION&quot; EQUAL b:STRING
		{ #moduleProperty = #( #[R_MVE, &quot;[module version]&quot;], #b ); }
		|	&quot;DATE&quot; EQUAL c:STRING
		{ #moduleProperty = #( #[R_MDA, &quot;[module date]&quot;], #c ); }
	;
	
// }

// END Root

// I - Declaration of entities

statDataTypes!
	:	a:statDataTypeList
		{ #statDataTypes = #( #[R_DAT, &quot;[data types]&quot;], #a ); }
;

statDataTypeList
	:	(CODE_ID (DOT CODE_ID)*)+
;

statEntity!
	:	CODE_ID (a:inheritance)? (b:attMetList)?
		{
			#statEntity = #( #[R_ENS, &quot;[entity stat]&quot;], 
				( #[R_ENI, &quot;[id]&quot;], #CODE_ID ), #a, #b );
		}
;

attMetList
	:	( attMet )+
;

attMet!
	:	&quot;ATTRIBUTES&quot;! a:statAttributeList
		{
			#attMet = #( #[R_ATS, &quot;[attributes]&quot;], #a );
		}
	|	&quot;METHODS&quot;! b:statMethodList
		{
			#attMet = #( #[R_MES, &quot;[methods]&quot;], #b );
		}
;

inheritance!
	:	&quot;INHERITS&quot; a:identifierList
		{
			#inheritance = #( #[R_INH, &quot;[inherits]&quot;], #a );
		}
;

statAttributeList
	:	( statAttribute )+
;

statMethodList
	:	( statMethod )+
;

statAttribute!
	:	a:CODE_ID b:CODE_ID (DOT CODE_ID)*
		{
			#statAttribute = #( #a, #b );
		}
;

statMethod
	:	a:CODE_ID b:CODE_ID
		{
			#statMethod = #( #a, #b );
		}
;

// END I

// II - Declaration of associations

statAssociation
	:	association 
;

association!
	:	a:entity b:STRING c:cardinality d:entityOrSet	//! use of 'entity', 'entityOrSet' !
	{
		#association = #( #[R_ASS, &quot;[association]&quot;], #a, #b, #c, #d );
	}
;

cardinality!
	:	a:INTEGER COMMA b:INTEGER 
	{	#cardinality = #( #[R_CAR, &quot;[cardinality]&quot;], #a, #b );	}
	
	|	c:INTEGER COMMA d:&quot;n&quot; 
	{	#cardinality = #( #[R_CAR, &quot;[cardinality]&quot;], #c, #d );	}

	|	e:&quot;n&quot; COMMA f:INTEGER
	{	#cardinality = #( #[R_CAR, &quot;[cardinality]&quot;], #e, #f );	}
;

// END II

// III - Declaration of actions

action!
	:	a:actionCommand b:entSetAttList //! use of 'entSetAttList' !
	{
		#action = #( #[R_ACS, &quot;[action]&quot;], #a, #b );
	}
;

actionCommand
	:	&quot;CREATE&quot;
	|	&quot;READ&quot;
	|	&quot;UPDATE&quot; 
	|	&quot;DELETE&quot; 
	|	&quot;FIND&quot; 
	|	&quot;PRINT&quot; 
	|	&quot;LIST&quot; 
;

// actionState
// 	:	&quot;POSSIBLE&quot;! 
// 	|	&quot;NOT&quot;! &quot;POSSIBLE&quot;! 
// 	|	&quot;POSSIBLE&quot;! &quot;ONLY&quot;! &quot;WHEN&quot;! conditionalExpression  //! use of 'conditionalExpression' !
// ;

// END of III 

// IV - Declaration of assignments
statAssignment
	:	ifAssignment
	|	assignmentExpression
;

ifAssignment
	:	&quot;IF&quot;! conditionalExpression	//! use of 'conditionalExpression' !
		&quot;THEN&quot;! assignmentExpression	//! use of 'conditionalExpression' !
		(&quot;ELSE&quot;! assignmentExpression)?	//! use of 'assignmentExpression' !
;
// END of IV 

// V - Declaration of uses
use
	:	a:entSetAttList	// use of 'entSetAttList'
	{
		#use = #( #[R_USS, &quot;[use]&quot;], #a );
	}
;

// END of V 

// VI - Declaration of functions 
function!
	:	STRING functionOperator a:conditionalExpression		// use of 'conditionalExpression'
	{	#function = #( #[R_FUS, &quot;[function]&quot;], #a ); }
	
	|	STRING functionActionCommand b:assignmentExpression	// use of 'assignmentExpression'
	{	#function = #( #[R_FUS, &quot;[function]&quot;], #b );	}
;

functionActionCommand
	:	&quot;PRE&quot; 
	|	&quot;POST&quot;
;

functionOperator
	:	&quot;POSSIBLE&quot; &quot;ONLY&quot; &quot;WHEN&quot;
;

// END of VI

// VII - Declaration of types

// END of VII

// VIII - Declaration of free constraints

statFree! // FREE &quot;This is a free constraint !&quot;
	:	a:INFORMAL_TEXT ( optionalError )?
		{ #statFree = #( #[R_FRS, &quot;[free]&quot;], #a); }
;

// END of VIII

// VIII - Declaration of requirements

requirement! // EXIG &quot;This is an exigeance !&quot;
	:	a:INFORMAL_TEXT ( optionalError )?
		{ #requirement = #( #[R_REQ, &quot;[requirement]&quot;], #a); }
;

// END of VIII

// VI - Declaration of condition

invariant
	:	( association )=&gt; a:association ( optionalError )? // use of '(II) association'
	{	#invariant = #( #[R_INV, &quot;[invariant]&quot;], #a );	}
	
	|	( b:statAliasList )? c:conditionalExpression ( optionalError )? // use of 'conditionalExpression'
	{	#invariant = #( #[R_INV, &quot;[invariant]&quot;], #b, #c );	}
;

statCondition
	:	statConditionA
;

statConditionA!
	:	( association )=&gt; a:association ( optionalError )? // use of '(II) association'
	{	#statConditionA = #( #[R_COS, &quot;[condition]&quot;], #a );	}
	
	|	( b:statAliasList )? c:conditionalExpression ( optionalError )? // use of 'conditionalExpression'
	{	#statConditionA = #( #[R_COS, &quot;[condition]&quot;], #b, #c );	}
;

statAliasList
	:	(statAlias)+
;

statAlias!
	:	a:identifierList &quot;AS&quot; (&quot;DISTINCT&quot;)? b:component
			// --TODO: restrict 'entity', there should be only one entity
	{	#statAlias = #( #[R_DAL, &quot;[decl_aliases]&quot;], #b, ( #[R_ALI, &quot;[aliases]&quot;], #a ) ); }
;

// END of VI

// VII - Declaration of ihm 

ihm!
	:	(target)+
	|	a:conditionalExpression ( optionalError )?
	{	#ihm = #( #[R_IHM, &quot;[ihm]&quot;], #a ); }
;

target!
	:	&quot;LINK&quot; STRING &quot;TARGET&quot; STRING 
;

// END of VII

// VIII - Error handling syntax 

optionalError!
	:	&quot;OTHERWISE&quot; &quot;ERROR&quot; INTEGER 
	|	&quot;OTHERWISE&quot; &quot;ERROR&quot; STRING 
;

// END of VIII

// IX - Entities &amp; Attributes

attributeSetList	// ::customer(.firstname, .lastname)
	:	set simpleAttRowInp 
;

attributeEntList	// customer(.firstname, .lastname)
	:	entity simpleAttRowInp 
;

attributeList!	// customer(.firstname, .lastname)
	:	( setPredicate )=&gt; c:set d:simpleAttRowInp
		{ #attributeList = #( #[R_ATL, &quot;[attributeList]&quot;], #c, #d ); }
		
	|	a:entity b:simpleAttRowInp 
		{ #attributeList = #( #[R_ATL, &quot;[attributeList]&quot;], #a, #b ); }
;

simpleAttRowInp	// (.firstname, .lastname)
	:	LPAREN! simpleAttRow RPAREN!
;

simpleAttRow	// .firstname, .lastname
	:	simpleAttribute (COMMA! simpleAttribute)*
;

attributeRow	// ::customer(.firstname, .lastname), supplier.name
	:	
	(	( attribute )=&gt; attribute
	|	( attributeList )=&gt; attributeList	)
	( COMMA! (
			( attribute )=&gt; attribute
		|	( attributeList )=&gt; attributeList
	) )*
;

entityOrSet
	:	( setPredicate )=&gt; set
	|	entity
;

entity! // (supplier WHERE name=&quot;Telys&quot;):client
	:	a:entityComponentList
		{ #entity = #( #[R_ENT, &quot;[entity]&quot;], #a ); }
;

entityComponentList
	:	firstEntityComponent ( entityComponent )*
	|	( entityComponent )+
;

firstEntityComponent! // (supplier WHERE name=&quot;Telys&quot;)
	:	a:component
		{ #firstEntityComponent = #( #[R_ENC, &quot;[entityComponent]&quot;], #a ); }
;

entityComponent! // ( :(supplier WHERE name=&quot;Telys&quot;) )
	:	COLON a:component
		{ #entityComponent = #( #[R_ENC, &quot;[entityComponent]&quot;], #a ); }
;

component
	:	LPAREN! CODE_ID clause RPAREN!
	|	CODE_ID
;

set! // ( supplier WHERE name=&quot;Telys&quot; ):client
	:	a:setComponentList
		{ #set = #( #[R_SET, &quot;[set]&quot;], #a ); }
;

setComponentList
	:	( firstEntityComponent )? ( setComponent | entityComponent )+
;

setPredicate
	:	( firstEntityComponent )? ( entityComponent )* setComponent 
;

setComponent! // (supplier WHERE name=&quot;Telys&quot;)
	:	DB_COLON a:component
		{ #setComponent = #( #[R_SEC, &quot;[setComponent]&quot;], #a ); }
;

clause!
	:	a:&quot;WHERE&quot; b:conditionalExpression
	{	#clause	= #( #[R_CLA, &quot;[clause]&quot;], #a, #b ); }
;

entityRow	// (supplier WHERE name=&quot;Telys&quot;):client, service
	:	entity (COMMA! entity)*
;

entSetAttList	// (supplier WHERE name=&quot;Telys&quot;):client, service
	:	entSetAtt ( COMMA! entSetAtt )*
;

entSetAtt
	:
	(	( attributeList )=&gt; attributeList
	|	( attribute )=&gt; attribute
	|	( setPredicate )=&gt; set
	|	entity
	)
;

attributeEnt	// (supplier WHERE name=&quot;Telys&quot;):client.address
	:	entity simpleAttribute 
;

attributeSet	// (supplier WHERE name=&quot;Telys&quot;)::client.address
	:	set simpleAttribute 
;

attribute!	// ::supplier:client.address
	:	( setPredicate )=&gt; c:set d:simpleAttribute
		{ #attribute = #( #[R_ATT, &quot;[attribute]&quot;], #c, #d ); }
	|	( entity )=&gt; a:entity b:simpleAttribute
		{ #attribute = #( #[R_ATT, &quot;[attribute]&quot;], #a, #b ); }
	|	e:simpleAttribute 
		{ #attribute = #( #[R_CAT, &quot;[clause attribute]&quot;], #e ); }
;

simpleAttribute	// .name
	:	DOT! CODE_ID 
;

setOperation
	:	( set &quot;INTERSECT&quot; )=&gt; a:set &quot;INTERSECT&quot;! b:set
	|	( set &quot;UNION&quot; )=&gt; set &quot;UNION&quot;! set 
	|	( set &quot;MINUS&quot; )=&gt; set &quot;MINUS&quot;! set 
;

// END of IX

// X - Expressions

expression
	:	assignmentExpression
;

assignmentExpression
	:	conditionalExpression
		ASSIGN! conditionalExpression
;

conditionalExpression
	:	inferenceExpression
;

inferenceExpression
	:	logicalOrExpression ( (LIN! | RIN! | REQU!) logicalOrExpression)*
;

logicalOrExpression
	:	logicalAndExpression (&quot;OR&quot;! logicalAndExpression)*
;

logicalAndExpression
	:	equalityExpressionOrBoolean
	(&quot;AND&quot;! equalityExpressionOrBoolean)*
;

equalityExpressionOrBoolean
	:	(attribute expBoolAttClause)=&gt; attribute expBoolAttClause 
	|	(attributeRow expBoolAttListClause)=&gt; attributeRow expBoolAttListClause 
	|	(equalityExpression setBooleanOperator)=&gt;
			value setBooleanOperator (attributeSet | valueListInb | interval)
	|	(interval)=&gt; interval setBooleanOperator interval 
	|	(set setBooleanOperator)=&gt; set setBooleanOperator set 
	|	(attributeEntList setBooleanOperator)=&gt; attributeEntList setBooleanOperator attributeSetList 
	|	( &quot;TRUE&quot;! | &quot;VRAI&quot;! )
	|	( &quot;FALSE&quot;! | &quot;FAUX&quot;! )
	
	|	equalityExpression
;
	
equalityExpression
	:	relationalExpression ((NOT_EQUAL! | EQUAL!) relationalExpression)*
;

relationalExpression
	:	additiveExpression
		( ( LT_! | GT! | LE! | GE! ) additiveExpression )*
;

additiveExpression
	:	multiplicativeExpression ((PLUS! | MINUS! ) multiplicativeExpression)*
;

multiplicativeExpression
	:	unaryExpression ((STAR! | DIV! | MOD! ) unaryExpression)*
;

unaryExpression
	:	MINUS! unaryExpression
	|	PLUS!  unaryExpression
	|	unaryExpressionNotPlusMinus
;

unaryExpressionNotPlusMinus
	:	BNOT! unaryExpression
	|	LNOT! unaryExpression
	|	primaryExpression
;

primaryExpression
    :   ( value )=&gt; value
	|	LPAREN! conditionalExpression RPAREN!
;

// END of X

// X - Expressions

setBooleanOperator!
	:	&quot;IN&quot; 
	|	&quot;NOT&quot; &quot;IN&quot;
;

expBoolAttClause!
	:	&quot;IS&quot; &quot;MAX&quot;
	|	&quot;IS&quot; &quot;MIN&quot; 
	|	&quot;IS&quot; &quot;NULL&quot; 
	|	&quot;IS&quot; &quot;NOT&quot; &quot;NULL&quot; 
	|	&quot;IS&quot; &quot;NUMERIC&quot;
	|	&quot;IS&quot; &quot;DATE&quot; 
	|	&quot;IS&quot; &quot;PASSWORD&quot; 
	|	&quot;IS&quot; &quot;TRUE&quot; 
	|	&quot;IS&quot; &quot;FALSE&quot; 
	|	&quot;EXIST&quot; 
	|	&quot;EXIST&quot; cardinality 
;

expBoolAttListClause!
	:	&quot;UNIQUE&quot;
;

numberFunction!
	:	a:numberFunctionA { #numberFunction = #( #[R_FNC, &quot;[function_call]&quot;], #a ); }
	|	b:numberFunctionB { #numberFunction = #b; }
	
;

numberFunctionB
	:	&quot;DATE&quot;! LPAREN! ( value )? RPAREN!
	|	&quot;SECOND&quot;! LPAREN! ( value )? RPAREN!
	|	&quot;MINUTE&quot;! LPAREN! ( value )? RPAREN!
	|	&quot;HOUR&quot;! LPAREN! ( value )? RPAREN!
	|	&quot;DAY&quot;! LPAREN! ( value )? RPAREN!
	|	&quot;MONTH&quot;! LPAREN! ( value )? RPAREN!
	|	&quot;YEAR&quot;! LPAREN! ( value )? RPAREN!
;

numberFunctionA
	:	&quot;SUM&quot; LPAREN! ( attributeSet )? RPAREN!
	|	&quot;AVERAGE&quot; LPAREN! ( attributeSet )? RPAREN!
	|	&quot;COUNT&quot; LPAREN! set RPAREN!
	|	&quot;MAX&quot; LPAREN! attribute RPAREN!
	|	&quot;MIN&quot; LPAREN! attribute RPAREN!
;

number!
	:	INTEGER
	|	FLOAT
;

interval
	:	LBRACK! value COMMA! value RBRACK!
;

valueListInb
	:	LCURLY! value (COMMA! value )* RCURLY! 
;

value // i replaced 'attribute' by 'simpleAttribute'
	:	numberFunction
	|	attribute
	|	number!
	|	STRING!
;

identifierListWOCA
	:	( CODE_ID )+
;

identifierList
	:	CODE_ID ( COMMA! CODE_ID )*
;
-------------- next part --------------
//*********************************************************************************
//                          THE CIAO LEXER FILE
//                        author : Anthony Breneli&#232;re
//
//    The Lexer, the lexer reads caracters from the input stream and creates a 
// a stream of tokens, that are sent to the parser (to the functions of the grammar).
//

// These lines are added to the lexer header files
//
header {
	#include &lt;iostream&gt;
	
	#include &quot;antlr.extended/ASTFactoryExt.hpp&quot;
	#include &quot;antlr.extended/ASTPNode.hpp&quot;
	#include &quot;world/WPropertiesTypes.hpp&quot;
	#include &quot;world/WWorld.hpp&quot;
	#include &quot;debugger/CIAODebugReport.hpp&quot;

	using namespace std;
	using namespace ciao;
	using namespace world;
	using namespace antlr;
}

// These lines are added to the lexer/parser cpp files
//
header &quot;post_include_cpp&quot; {

	void CIAOLexer::reportError(const RecognitionException&amp; ex)
	{
		CObjectList * objs;
		CObjectList * objs2;
		CObject * _templ;
		CObject * _text;
		int nLine = 0, nTLine = 0;
		char buffer[30];
		
		_templ = new CObject();
		_templ-&gt;aP(p_CATEGORY, &quot;CIAOText&quot;);
		
		objs = new CObjectList();
		world-&gt;findObjectsWProp( objs, world-&gt;content, _templ );
		// objs.sort( &quot;BufferLine&quot; );
		for ( CObjectList::iterator ir = objs-&gt;begin();
			ir != objs-&gt;end();
			ir++ )
		{
			nTLine = atoi( (*ir)-&gt;getValue(p_BUFFERLINE).c_str() );
			if ( nTLine &lt;= ex.getLine() &amp;&amp; nTLine &gt; nLine ) nLine = nTLine;
		}
		_templ-&gt;clear();
		_templ-&gt;aP( p_BUFFERLINE, itoa( nLine, buffer, 10) );
		objs2 = new CObjectList();
		world-&gt;findObjectsWProp( objs2, objs, _templ );
		
		if ( objs2-&gt;size() == 1 )
		{
			
			_text = objs2-&gt;front();
		    
			cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;fichier &quot; &lt;&lt; _text-&gt;getValue( p_FILENAME )
				&lt;&lt; &quot; page &quot; &lt;&lt; _text-&gt;getValue( p_PAGENUMBER )
				&lt;&lt; &quot; ligne &quot; &lt;&lt; _text-&gt;getValue( p_LINENUMBER )
				&lt;&lt; endl &lt;&lt; &quot;------------------------------&quot;
				&lt;&lt; endl &lt;&lt; &quot;ID : &quot; &lt;&lt; _text-&gt;getValue(p_IDENTIFIER)
				&lt;&lt; endl &lt;&lt; _text-&gt;getValue(p_CONTENT)
				&lt;&lt; endl &lt;&lt; &quot;------------------------------&quot;
				&lt;&lt; endl &lt;&lt; &quot;Erreur : &quot; &lt;&lt; ex.toString() &lt;&lt; endl;
		} 
		else
			cout &lt;&lt; endl &lt;&lt; &quot;Unknown error : the corresponding Text has not been found&quot;
				&lt;&lt; &quot; by the debugger&quot; &lt;&lt; endl;
			
		delete objs;
		delete objs2;
		delete _templ;
	}
	
}

options {
	language=&quot;Cpp&quot;;
}

//***************************************************
//                 THE CIAO LEXER
//
{
#include &lt;string&gt;
#include &quot;antlr/SemanticException.hpp&quot;
}
class CIAOLexer extends Lexer;

options {
	// testLiterals=false;
	exportVocab = CIAOLex;
	importVocab = CIAOLitterals;
	k=4;
	// charVocabulary='\u0003'..'\u00FF';
	charVocabulary='\3'..'\377';
	testLiterals=false;
	defaultErrorHandler = true;
	
	// without inlining some bitset tests, couldn't do unicode;
	// I need to make ANTLR generate smaller bitsets; see
	// bottom of JavaLexer.java
	// codeGenBitsetTestThreshold=20;
}

tokens {
	ID_ENTITY;
	ID_AFFECTATION;
	ID_ASSOCIATION;
	ID_DATATYPES;
	ID_IHM;
	ID_DOC_PROPERTIES;
	ID_EXIG;
	ID_FREE;
	ID_ACTION;
	ID_CONDITION;
	ID_USE;
	ID_FUNCTION;
	ID_INVARIANT;
	ID_PROTECTION;
}

{
private:
	CWorld * world;
	CDebugReport * debugR;
	
	bool bOutOfCIAOContext;
	bool bInformalLanguageContext;
	bool bWaitForStatementNature;
	bool bStatIsIdentified;
	
public:
	CIAOLexer(ANTLR_USE_NAMESPACE(std)istream&amp; in, CWorld * _world )
		: CharScanner(new CharBuffer(in),true), world( _world ), 
		bOutOfCIAOContext( true ), bInformalLanguageContext( false ),
		bWaitForStatementNature( false ), bStatIsIdentified( false )
	{
		initLiterals();
		debugR = new CDebugReport( &amp;cerr );
	}
	
	~CIAOLexer()
	{
		delete debugR;
	}
	
	void reportError( const RecognitionException&amp; ex );
	
}

// CIAO DELIMITER
DELIMITER
	:	'\244' 
	{ 
		if ( bOutOfCIAOContext ) 
			bOutOfCIAOContext = false;
		else
			bOutOfCIAOContext = true;
			bInformalLanguageContext = false;
			bStatIsIdentified = false;
	}
;

IGNORE_TEXT
	:	{ bOutOfCIAOContext }? ( options { generateAmbigWarnings=false; } : ENDOFLINE | ~( '\244' ) )+
	{ 
		$setType(Token::SKIP);
	}
;

INFORMAL_TEXT
	:	{ bInformalLanguageContext }? (  options { generateAmbigWarnings=false; } : ENDOFLINE | ~( '\244' ) )+ 
;

// Operators
//
QUESTION		:	'?'		;
LPAREN			:	'('		;
RPAREN			:	')'		;
LBRACK			:	'['		;
RBRACK			:	']'		;
LCURLY			:	'{'		;
RCURLY			:	'}'		;
COLON			:	':'		;
DB_COLON		:	&quot;::&quot;	;
COMMA			:	','		;
DOT				:	'.'		;
ASSIGN			:	&quot;:=&quot;	;
EQUAL			:	&quot;=&quot;		;
LNOT			:	'!'		;
BNOT			:	'~'		;
NOT_EQUAL		:	&quot;&lt;&gt;&quot;	;
DIV				:	'/'		;
DIV_ASSIGN		:	&quot;/=&quot;	;
PLUS			:	'+'		;
PLUS_ASSIGN		:	&quot;+=&quot;	;
INC				:	&quot;++&quot;	;
MINUS			:	'-'		;
MINUS_ASSIGN	:	&quot;-=&quot;	;
DEC				:	&quot;--&quot;	;
STAR			:	'*'		;
STAR_ASSIGN		:	&quot;*=&quot;	;
MOD				:	'%'		;
MOD_ASSIGN		:	&quot;%=&quot;	;
SR				:	&quot;&gt;&gt;&quot;	;
SR_ASSIGN		:	&quot;&gt;&gt;=&quot;	;
BSR				:	&quot;&gt;&gt;&gt;&quot;	;
BSR_ASSIGN		:	&quot;&gt;&gt;&gt;=&quot;	;
GE				:	&quot;&gt;=&quot;	;
GT				:	&quot;&gt;&quot;		;
SL				:	&quot;&lt;&lt;&quot;	;
SL_ASSIGN		:	&quot;&lt;&lt;=&quot;	;
LE				:	&quot;&lt;=&quot;	;
LT_				:	'&lt;'		;
BXOR			:	'^'		;
BXOR_ASSIGN		:	&quot;^=&quot;	;
BOR				:	'|'		;
BOR_ASSIGN		:	&quot;|=&quot;	;
LOR				:	&quot;||&quot;	;
BAND			:	'&amp;'		;
BAND_ASSIGN		:	&quot;&amp;=&quot;	;
LAND			:	&quot;&amp;&amp;&quot;	;
SEMI			:	';'		;
LIN				:	&quot;==&gt;&quot;	;
RIN				:	&quot;&lt;==&quot;	;
AT				:	'@'		;
// UNDERSCORE		:	'_'		;
AP				:	'`'		;
RAP				:	('\221' | '\222'); // '
CROSS			:	('\327');
REQU			:	&quot;&lt;==&gt;&quot;	;

// Whitespace and new lines characters are ignored
// only in CIAO Formal context language
WS
	:	( ' ' | '\t' | '\f' | ENDOFLINE )+
	{	$setType(Token::SKIP); }
;

STRING
	:	'&quot;' ( options { generateAmbigWarnings = false; } : ENDOFLINE | ~('&quot;' | '\244'))* '&quot;'
	|	'\'' ( options { generateAmbigWarnings = false; } : ENDOFLINE | ~('\'' | '\244'))* '\''
;

FLOAT_OR_INTEGER
	:	( FLOAT ) =&gt; FLOAT { $setType(FLOAT); }
	|	( INTEGER ) =&gt; INTEGER { $setType(INTEGER); }
;

IDENTIFIER
	options { testLiterals=true; }
	:	( 
		( CODE_WDOT '/' &quot;ENTITY&quot; )=&gt;
		 CODE_WDOT '/' &quot;ENTITY&quot; { $setType( ID_ENTITY ); }
	|	( CODE_WDOT '/' &quot;AFFECTATION&quot; )=&gt;
		CODE_WDOT '/' &quot;AFFECTATION&quot; { $setType( ID_AFFECTATION ); }
	|	( CODE_WDOT '/' &quot;ASSOCIATION&quot; )=&gt;
		CODE_WDOT '/' &quot;ASSOCIATION&quot; { $setType( ID_ASSOCIATION ); }
	|	( CODE_WDOT '/' &quot;DATATYPES&quot; )=&gt;
		CODE_WDOT '/' &quot;DATATYPES&quot; { $setType( ID_DATATYPES ); }
	|	( CODE_WDOT '/' &quot;IHM&quot; )=&gt;
		CODE_WDOT '/' &quot;IHM&quot; { $setType( ID_IHM ); }
	|	( CODE_WDOT '/' &quot;DOC_PROPERTIES&quot; )=&gt;
		CODE_WDOT '/' &quot;DOC_PROPERTIES&quot; { $setType( ID_DOC_PROPERTIES ); }
	|	( CODE_WDOT '/' 'E' )=&gt;
		CODE_WDOT '/' 'E' { $setType( ID_EXIG ); if ( ! bStatIsIdentified ) bInformalLanguageContext = true; }
	|	( CODE_WDOT '/' 'F' )=&gt;
		CODE_WDOT '/' 'F' { $setType( ID_FREE ); if ( ! bStatIsIdentified ) bInformalLanguageContext = true; }
	|	( CODE_WDOT '/' 'A' )=&gt;
		CODE_WDOT '/' 'A' { $setType( ID_ACTION ); }
	|	( CODE_WDOT '/' 'R' )=&gt;
		CODE_WDOT '/' 'R' { $setType( ID_CONDITION ); }
	|	( CODE_WDOT '/' 'U' )=&gt;
		CODE_WDOT '/' 'U' { $setType( ID_USE ); }
	|	( CODE_WDOT '/' 'F' )=&gt;
		CODE_WDOT '/' 'F' { $setType( ID_FUNCTION ); }
	|	( CODE_WDOT '/' 'I' )=&gt;
		CODE_WDOT '/' 'I' { $setType( ID_INVARIANT ); }
	|	( CODE_WDOT '/' 'P' )=&gt;
		CODE_WDOT '/' 'P' { $setType( ID_PROTECTION ); }
	|	( CODE_ID ) =&gt; CODE_ID { $setType(CODE_ID); }
		) 
	{
		bStatIsIdentified = true;
	}
;

UNKNOWN_CHAR
	:	( ( '\241'..'\243' ) | ('\245'..'\326') | ('\330'..'\377') )
;

protected
CODE_ID
	:	LETTER (LETTER | NUMBER)*
;

protected
CODE_WDOT
	:	LETTER (LETTER | NUMBER | '.')* 
;

protected
FLOAT
	:	(NUMBER)+ '.' (NUMBER)+
;

protected
INTEGER
	:	(NUMBER)+
;

protected
NUMBER
	: ('0'..'9')
;

protected
LETTER
	: ('a'..'z'|'A'..'Z' |'_')
;

protected
ENDOFLINE
	:	( options { generateAmbigWarnings=false; } : &quot;\r\n&quot; | '\r' | '\n' ) { newline(); }
;
-------------- next part --------------
//***************************************************************
// File		: CIAOMain.cpp
// Projet	: iCIAO
// Auteur	: Anthony Breneli&#232;re
// Version	: 1.0

// include the antlr-generated files
// CIAO grammar
#include &lt;antlr.generated/CIAOLexer.hpp&gt;
#include &lt;antlr.generated/CIAOParser.hpp&gt;
#include &lt;antlr.generated/CIAOWalker.hpp&gt;
#include &lt;antlr.generated/CIAOAdvWalker.hpp&gt;

// CIAO debugger
#include &lt;debugger/CIAODebugLexer.hpp&gt;
#include &lt;debugger/CIAODebugParser.hpp&gt;

// CIAO commandline
#include &quot;CmdLine/cmdLineLexer.hpp&quot;
#include &quot;CmdLine/cmdLineParser.hpp&quot;

// include the needed antlr source files
#include &lt;antlr/BaseAST.hpp&gt;
#include &lt;antlr/TokenBuffer.hpp&gt;
#include &lt;antlr/CharStreamException.hpp&gt;
#include &lt;antlr/TokenStreamIOException.hpp&gt;
#include &lt;antlr/TokenStreamRecognitionException.hpp&gt;
#include &lt;antlr/TokenStreamRetryException.hpp&gt;
#include &lt;antlr/RecognitionException.hpp&gt;
#include &quot;antlr.extended/ASTFactoryExt.hpp&quot;

// include the models used to store datas
#include &quot;ciao.elements/CIAOWorkTable.hpp&quot;
#include &quot;ciao.elements/CIAOProject.hpp&quot;
#include &quot;world/WWorld.hpp&quot;

#include &quot;CIAOMain.hpp&quot;
#include &quot;CIAOReport.hpp&quot;
#include &quot;debugger/CIAODebugReport.hpp&quot;
#include &lt;conio.h&gt;

#ifdef _WINDOWS
#include &quot;win32/_Win_Start.hpp&quot;
#endif

	
	#include &quot;managed.code/ConverterDoc.hpp&quot;
#ifdef USE_MANAGED_EXTENSIONS
	#define NONET
	#include &quot;managed.code/ConverterXmi.hpp&quot;
#endif

using namespace std;
using namespace world;
using namespace Win32System;

namespace ciao
{

CMainApp::CMainApp()
{
	// # change the version number here ! #
	sVersion = &quot;v0.920 build 034&quot;;
}

CMainApp::~CMainApp()
{
	char buf;

	if ( this-&gt;Options.DestinationFile == &quot;&quot; )
	{
		cout &lt;&lt; endl &lt;&lt; &quot;Press a key to exit...&quot; &lt;&lt; endl;
		buf = getch();
	}
}

int CMainApp::Main(string &amp;sCmdLine)
{
	ifstream fileIn, fileIn_;
	string sCIAOfn;
	strstream clinebuf;

	//
	// I - parse the command line and assign the application properties
	//
	try
	{
		clinebuf &lt;&lt; sCmdLine;
	
		cmdLineLexer lexer( clinebuf );
		cmdLineParser parser( lexer );

		// read the program parameters and sets the corresponding application attributes
		parser.parameter_list( this-&gt;Options );

	}
	catch(ANTLR_USE_NAMESPACE(antlr)ANTLRException &amp; e)
	{
		DisplayHelp();
		return -1;
	}

	/*if(this-&gt;Options.iniFile == &quot;&quot;)
	{
		this-&gt;Options.iniFile = _getCurrentDir();
		this-&gt;Options.iniFile.append(&quot;\\iCIAO.ini&quot;);
	}*/

	//
	// Read the INI File
	//
	/*if(this-&gt;Options.iniFile != &quot;&quot;)
	{

		string source = _getINIValue(	this-&gt;Options.iniFile,
										&quot;Parameters&quot;,
										&quot;Source&quot;);

		if(source == &quot;1&quot;)
		{
			this-&gt;Options.source = true;
		}
		else
		{
			this-&gt;Options.source = false;
		}

	}*/

	// redirect the results to a file if an output file is specified
	if ( this-&gt;Options.DestinationFile != &quot;&quot; )
		if ( -1 == RedirectCout2File( cout, true, this-&gt;Options.DestinationFile ) ) return -1;

	// redirect the errors to a file if an output file is specified
	Win32System::_getCurrentDir( Options.DebugFile );
	Options.DebugFile += &quot;\\debug.log&quot;;
	if ( -1 == RedirectCout2File( cerr, true, Options.DebugFile ) ) return -1;

	//
	// II - display and checking the chosen attributes to standard output stream
	//
	{
		// check the source filed existance, and replace the 
		string sFNtoCheck;
		bool allFilesFound = true;

		for ( vector&lt;string&gt;::iterator ir = Options.SourceFiles.begin();
			ir != this-&gt;Options.SourceFiles.end();
			ir++ )
		{
			_searchPath( sFNtoCheck, *ir );
			if ( sFNtoCheck == &quot;&quot; ) 
			{
				cerr &lt;&lt; endl &lt;&lt; &quot;The file &quot; &lt;&lt; *ir &lt;&lt; &quot; has not been found.&quot;;
				allFilesFound = false;
			}
			else
				*ir = sFNtoCheck;
		}
		if ( ! allFilesFound ) return (-1);

		cerr &lt;&lt; &quot;-=================( Command Parameters )=================-&quot; &lt;&lt; endl;
		cerr &lt;&lt; endl;

		for ( vector&lt;string&gt;::iterator ir = Options.SourceFiles.begin();
			ir != this-&gt;Options.SourceFiles.end();
			ir++ )
		{
			cerr &lt;&lt; &quot;* Source file : &quot; + *ir &lt;&lt; endl;
		}
			cerr &lt;&lt; &quot;* Destination file : &quot; + this-&gt;Options.DestinationFile &lt;&lt; endl;
			cerr &lt;&lt; &quot;* &quot; &lt;&lt; endl;
	}

	if ( this-&gt;Options.SourceFiles.size() == 0 ) 
	{
		DisplayHelp();
		return -1;
	}

	if ( this-&gt;Options.displayHelp )
	{
		DisplayHelp();
		return 0;
	}

		#ifdef _WINDOWS
	//
	// III - generate the text documents from XMI or Word documents
	//
	ConvertDocuments();
		#endif

	//
	// IV - concatenates source file to consolidate all ciao text files into one
	//      the result text file is sCIAOfn
	//
	ConcatenateSourceFiles( sCIAOfn );

	fileIn.open( sCIAOfn.c_str() );
	fileIn_.open( sCIAOfn.c_str() );

	// The antlr extended factory is used to create a tree of CIAO elements
	// that are exploited, it is used in the parser, and created here :
	ANTLR_USE_NAMESPACE(antlr)ASTFactoryExt ast_factory( &quot;PNode&quot;, antlr::PNode::factory );

	// The world for storing all the datas is created there :
	CWorld * world = new CWorld();

	// The ciao data object that check document consistency is created here:
	CProject * project = new CProject();
	CWorkTable * workTable = new CWorkTable( project );

	if ( fileIn.fail() || fileIn_.fail() )
	{
		cerr &lt;&lt; endl &lt;&lt; &quot;The file '&quot; &lt;&lt; sCIAOfn &lt;&lt; &quot;' could not be opened.&quot; &lt;&lt; endl;
		return -1;
	}

	else
	{
		// the main text document to analyse has been successfully opened

	//
	// V - pre-parsing the document,
	//			for debugging purpose

	CIAODebugLexer debuglexer( fileIn, false );
	CIAODebugParser debugparser( debuglexer, world );

	try
	{
 		debugparser.document();
	}
	catch(ANTLR_USE_NAMESPACE(antlr)ANTLRException&amp; e)
	{
		cerr &lt;&lt; &quot;Debugger Exception: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}

	fileIn.close();
	fileIn.open( sCIAOfn.c_str() );

	//
	// VI - parsing the document,
	//			the parser's ciaoDocument function is called, and the file is read

	CIAOLexer lexer( fileIn_, world );
	CIAOParser parser( lexer, world  );

	try
	{
		parser.initializeASTFactory( ast_factory );
		parser.setASTFactory( &amp;ast_factory );
		parser.ciaoDocument();
	}
	catch(ANTLR_USE_NAMESPACE(antlr)CharStreamException&amp; e)
	{
		cerr &lt;&lt; &quot;CIAOMain: CharStreamException: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}
	catch(ANTLR_USE_NAMESPACE(antlr)RecognitionException&amp; e)
	{
		cerr &lt;&lt; &quot;CIAOMain: RecognitionException: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}
	catch(ANTLR_USE_NAMESPACE(antlr)TokenStreamIOException&amp; e)
	{
		cerr &lt;&lt; &quot;CIAOMain: TokenStreamIOException: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}
	catch(ANTLR_USE_NAMESPACE(antlr)TokenStreamRecognitionException&amp; e)
	{
		cerr &lt;&lt; &quot;CIAOMain: TokenStreamRecognitionException: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}
	catch(ANTLR_USE_NAMESPACE(antlr)TokenStreamRetryException&amp; e)
	{
		cerr &lt;&lt; &quot;CIAOMain: TokenStreamRetryException: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}
	catch(ANTLR_USE_NAMESPACE(antlr)TokenStreamException&amp; e)
	{
		cerr &lt;&lt; &quot;CIAOMain: TokenStreamException: &quot; &lt;&lt; e.toString() &lt;&lt; endl;
		return -1;
	}

	//
	// VIb - display the resulting tree 
	//			

	if ( this-&gt;Options.displayTree )
		cout &lt;&lt; GetTreeString ( static_cast&lt;antlr::RefAST&gt;( parser.getAST() ), 0 ) &lt;&lt; endl;

	if ( this-&gt;Options.checkSyntaxOnly ) {
		cout &lt;&lt; &quot;Syntax is OK&quot;;
		return 0;
	}
			
	//
	// VII - walking the parser's resulting tree,
	//			the consistency's functions are called
			
		CIAOWalker walker ( workTable );
		CIAOAdvWalker advWalker ( world );
		
		// walker.initializeASTFactory(ast_factory);
		// walker.setASTFactory(&amp;ast_factory);
		
		// walk tree
		walker.ciaoTreeDocument( static_cast&lt;antlr::RefAST&gt; (parser.getAST()) );
		// walk advanced tree : pass 1
		advWalker.ciaoTreeDocument( static_cast&lt;antlr::RefAST&gt; (parser.getAST()), 1 );

		// creating the world-&gt;statementList and world-&gt;ciaoTextList lists
		world-&gt;statementList = new CObjectList();
		CObject * oTemplate = new CObject();
		oTemplate-&gt;aP( p_CATEGORY, &quot;Statement&quot; );
		world-&gt;findObjectsWProp( world-&gt;statementList, world-&gt;content, oTemplate);
		delete oTemplate;
				
		world-&gt;ciaoTextList = new CObjectList();
		oTemplate = new CObject();
		oTemplate-&gt;aP( p_CATEGORY, &quot;CIAOText&quot; );
		world-&gt;findObjectsWProp( world-&gt;ciaoTextList, world-&gt;content, oTemplate);
		delete oTemplate;

		// walk advanced tree : pass 2
		advWalker.ciaoTreeDocument( static_cast&lt;antlr::RefAST&gt; (parser.getAST()), 2 );	
		
		fileIn.close();
		fileIn_.close();
	}

	//
	// VIIb - display the world's content 
	//	

	// create the report objects to configure it according to the options
	CDebugReport * debugR = new CDebugReport( &amp;cerr );

	if ( this-&gt;Options.displayTree )
		debugR-&gt;displayObjectList( world-&gt;content );

	delete debugR;

	// delete the source file if it's a temp file
	if ( ! Options.doNotDeleteTempFiles ) 
	{
		bool bFileFound = false;
		vector&lt;string&gt;::iterator ir = this-&gt;Options.SourceFiles.begin();
		while ( ir != this-&gt;Options.SourceFiles.end() )
		{
			if ( sCIAOfn == *ir ) bFileFound = true;
			ir++;
		}
		if ( ! bFileFound )
		{
			if ( ! _deleteFile( sCIAOfn ) )
				{ cerr &lt;&lt; &quot;Warning, the file &quot; &lt;&lt; sCIAOfn &lt;&lt; &quot; could not be deleted&quot;; }
		}
	}

	//
	// VIII - here are performed the post-reading consistency checks on the project
	//
	workTable-&gt;performDataAnalysis();

	//
	// IX - display the results,
	//				to a file, a graphic interface or the console
	DisplayResults( world, workTable );

	delete world;
	delete project;
	delete workTable;

	// reinitialize the standard output stream, that has been kept as static value
	//
	if ( this-&gt;Options.DestinationFile != &quot;&quot; ) RedirectCout2File( cout, false, &quot;&quot; );

	return (0);
}


int CMainApp::RedirectCout2File( ostream &amp; _ostr, bool _toFile, const string &amp; _sFileN )
{
	static streambuf * ostr_sbuf; // remember the cout buffer to reinitialize
	static ofstream * FOutput;

	if ( _toFile ) // redirect to file or reinitialize
	{
		FOutput = new ofstream;

		(*FOutput).open( _sFileN.c_str(), ios_base::out);

		if ( ! (*FOutput).fail() )
		{
			ostr_sbuf = _ostr.rdbuf();
			_ostr.rdbuf( (*FOutput).rdbuf() );
		}
		else
		{
			// exit !
			cout &lt;&lt; &quot;The specified file &quot; &lt;&lt; _sFileN
				&lt;&lt; &quot; could not be opened for writing.&quot;;
			// delete FOutput;
			return -1;
		}
	}
	else
	{
		if ( this-&gt;Options.DestinationFile != &quot;&quot; )
		{
			_ostr.rdbuf( ostr_sbuf );
			(*FOutput).close();
		}
	}
	return 0;
}


void CMainApp::ConcatenateSourceFiles(string &amp; sCIAOfn)
{
	ifstream fileIn;
	ofstream fileOut;
	char * fbuffer;
	long size;

	if ( this-&gt;Options.SourceCIAOFiles.size() &gt; 1 )
	{
		// concatenate source files into one unique file
		{

			sCIAOfn = &quot;___temp.ciao&quot;;

			fileOut.open( sCIAOfn.c_str(), ofstream::binary | ofstream::trunc );

			if ( ! (fileIn.fail()) )
			{
				for ( vector&lt;string&gt;::iterator ir = Options.SourceCIAOFiles.begin();
					ir != this-&gt;Options.SourceCIAOFiles.end();
					ir++ )
				{
					if ( ! (fileIn.fail()) )
					{
						fileIn.open( (*ir).c_str(), ifstream::binary);

						// get size of file
						fileIn.seekg(0, ifstream::end);
						size = fileIn.tellg();
						fileIn.seekg(0);

						// allocate memory for file content
						fbuffer = new char [size];

						// read content of infile
						fileIn.read (fbuffer, size);

						// write to outfile
						fileOut.write (fbuffer, size);

						// release dynamically-allocated memory
						delete[] fbuffer;

						fileIn.close();
						fileIn.clear();

						// delete the source file if it's a temp file
						if ( ! Options.doNotDeleteTempFiles ) 
						{
							bool bFileFound = false;
							vector&lt;string&gt;::iterator ir2 = this-&gt;Options.SourceFiles.begin();
							while ( ir2 != this-&gt;Options.SourceFiles.end() )
							{
								if ( *ir == *ir2 ) bFileFound = true;
								ir2++;
							}
							if ( ! bFileFound )
							{
								if ( ! _deleteFile( *ir ) )
									{ cerr &lt;&lt; &quot;Warning, the file &quot; &lt;&lt; *ir &lt;&lt; &quot; could not be deleted&quot;; }
							}
						}
					}
					else
					{
						cout &lt;&lt; &quot;The source file '&quot; + (*ir) + &quot;' could not be opened.&quot; &lt;&lt; endl;
						return;
					}
				}
			}
			else
			{
				cout &lt;&lt; &quot;The destination file '&quot; + sCIAOfn + &quot;' could not be opened.&quot; &lt;&lt; endl;
			}

			fileOut.close();
		}
	}
	else
	{
		sCIAOfn = this-&gt;Options.SourceCIAOFiles[0];
	}

}


void CMainApp::DisplayHelp(void)
{
	cout &lt;&lt; endl &lt;&lt; &quot;----------------------------------------------------------------------&quot;
		 &lt;&lt; endl &lt;&lt; &quot;iCIAO.exe &quot;;
	if ( Options.dispVersion ) cout &lt;&lt; sVersion;
	cout &lt;&lt;         &quot;    :   CIAO (c) Telys&quot;
	     &lt;&lt; endl &lt;&lt; &quot;----------------------------------------------------------------------&quot; &lt;&lt; endl
		 &lt;&lt; endl &lt;&lt; &quot;To use iCIAO you have to type the following command :&quot; &lt;&lt; endl
		 &lt;&lt; endl &lt;&lt; &quot;     Simple usage : iCIAO.exe (source 1)..(source n) /ouput:(destination) [options]&quot; &lt;&lt; endl
		 &lt;&lt; endl &lt;&lt; &quot;           source : the path of one or more sources files,&quot;
		 &lt;&lt; endl &lt;&lt; &quot;                    may be \&quot;\\specifications\\survey application.ciao\&quot;&quot;
		 &lt;&lt; endl &lt;&lt; &quot;      destination : the path of a destination file,&quot;
		 &lt;&lt; endl &lt;&lt; &quot;                    may be \&quot;\\temp\\spec results.txt\&quot;&quot; &lt;&lt; endl
		 &lt;&lt; endl &lt;&lt; &quot;            /help : display that help message&quot;
		 &lt;&lt; endl &lt;&lt; &quot;            /tree : display the resulting AST data tree&quot; &lt;&lt; endl
	     &lt;&lt; endl &lt;&lt; &quot; /checksyntaxonly : just check the syntax, do not check the document consistency&quot; &lt;&lt; endl;
}


string CMainApp::GetTreeString(antlr::RefAST T, int level)
{
	string ts=&quot;&quot;;
	int i;

	if ( T == NULL ) return ts;

	if ( T-&gt;getFirstChild() )
	{
		ts += &quot;\n&quot;;
		for ( i=1; i&lt;=level; i++ ) ts += &quot;. &quot;;
		ts += T-&gt;toString();
		ts += GetTreeString( T-&gt;getFirstChild(), level + 1 );
	}
	else
	{
		ts += &quot;\n&quot;;
		for ( i=1; i&lt;=level; i++ ) ts += &quot;. &quot;;
		ts += T-&gt;toString();
	}


	if ( T-&gt;getNextSibling() )
		ts += GetTreeString( T-&gt;getNextSibling(), level );

	return ts;
}


void CMainApp::DisplayResults( CWorld * _world, CWorkTable * _workTable )
{
	string sCounterFile;

	CReportCreator * Report = new CReportCreator();

	Report-&gt;setLanguage ( this-&gt;Options.language );
	Report-&gt;setLinesOn ( false );
	Report-&gt;setDetailsOn ( true );
	Report-&gt;setWorld( _world );
	Report-&gt;setWorkTable( _workTable );

	if (this-&gt;Options.language == &quot;french&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;          -= Rapport d'analyse iCIAO =-&quot; &lt;&lt; endl;
	if (this-&gt;Options.language == &quot;english&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;          -= Analysis CIAO report =-&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;________________________________________________________________________________&quot; &lt;&lt; endl &lt;&lt; endl;

	if (this-&gt;Options.language == &quot;french&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;Document(s) source(s) : &quot; &lt;&lt; endl;
	if (this-&gt;Options.language == &quot;english&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;Source(s) document(s) : &quot; &lt;&lt; endl;

	for ( vector&lt;string&gt;::iterator ir = Options.SourceFiles.begin();
		ir != this-&gt;Options.SourceFiles.end();
		ir++ )
	{
		cout &lt;&lt; &quot; - &quot; + *ir &lt;&lt; endl;
	}

	if (this-&gt;Options.language == &quot;french&quot;)
		cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;      [ [ Coh&#233;rence des r&#232;gles ] ]&quot; &lt;&lt; endl &lt;&lt; endl;
	if (this-&gt;Options.language == &quot;english&quot;)
		cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;      [ [ Rules's consistency ] ]&quot; &lt;&lt; endl &lt;&lt; endl;

	cout &lt;&lt; &quot;Anomalies de niveau 1 : &quot;;

	Report-&gt;displayNoErrorNotification();
	Report-&gt;displayEntitiesToUser( (elementState) (tused | tnotdeclared) );
	Report-&gt;displayEntitiesToUser( (elementState) (tdeclared | tnotused) );
	Report-&gt;displayAttributesToUser( (elementState) (tused | tnotdeclared) );
	Report-&gt;displayAttributesToUser( (elementState) (tdeclared | tnotused) );
	Report-&gt;displayAssociationsToUser( (elementState) (tused | tnotdeclared) );
	Report-&gt;displayAssociationsToUser( (elementState) (tdeclared | tnotused) );
	Report-&gt;displayEntitiesWithoutAttribute();
	Report-&gt;displayAssociationsWithoutCardinality();
	// Report-&gt;displayEntitiesWMissingAction();
	Report-&gt;displayEntitiesWMissingActionDetailed();

	cout &lt;&lt; &quot;Anomalies de niveau 2 : &quot;;

	Report-&gt;displayInvariantIncoherence();

	if (this-&gt;Options.DestinationFile != &quot;&quot;)
	{
		cout &lt;&lt; &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;
			 &lt;&lt; &quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;;
	}

	cout &lt;&lt; &quot;_____________________________________________________&quot; &lt;&lt; endl &lt;&lt; endl;

	if (this-&gt;Options.language == &quot;french&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;      [ [ Informations sur les entit&#233;s/associations ] ]&quot; &lt;&lt; endl &lt;&lt; endl;
	if (this-&gt;Options.language == &quot;english&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;      [ [ Entity/Associations informations ] ]&quot; &lt;&lt; endl &lt;&lt; endl;

	Report-&gt;displayEntitiesToUser( tused );
	Report-&gt;displayEntitiesToUser( tdeclared );
	Report-&gt;displayAttributesToUser( tused );
	Report-&gt;displayAttributesToUser( tdeclared );
	Report-&gt;displayAssociationsToUser( tused );
	Report-&gt;displayAssociationsToUser( tdeclared );
	
	if (this-&gt;Options.language == &quot;french&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;      [ [ Compteurs ] ]&quot; &lt;&lt; endl &lt;&lt; endl;
	if (this-&gt;Options.language == &quot;english&quot;)
		cout &lt;&lt; endl &lt;&lt; &quot;      [ [ Counters ] ]&quot; &lt;&lt; endl &lt;&lt; endl;

	Report-&gt;displayCounters();

	if ( this-&gt;Options.DestinationFile != &quot;&quot; )
	{
		int sSlashPos = Options.DestinationFile.rfind('\\');

		if ( sSlashPos != -1 ) 
			sCounterFile = Options.DestinationFile.substr( 0, sSlashPos + 1 );

		sCounterFile = sCounterFile + ( (Options.language == &quot;english&quot;) ? &quot;counter.txt&quot; : &quot;&quot; );
		sCounterFile = sCounterFile	+ ( (Options.language == &quot;french&quot;) ? &quot;compteur.txt&quot; : &quot;&quot; );

		RedirectCout2File( cout, true, sCounterFile );

	}
	
	Report-&gt;displayStatementStatusCounters();
	
	delete Report;
}

	#ifdef _WINDOWS


void CMainApp::ConvertDocuments()
{
	string sExt; // used to store the extension of source files for anslysis
	string sCIAOfn; // used to store the name of the generated text ciao file
	string sDOCInitfn; // used to store the name of the .doc/.xmi file as entered by the user
	string sDOCfn; // used to store the name of the .doc/.xmi file with the full path 

	for ( vector&lt;string&gt;::iterator ir = Options.SourceFiles.begin();
		ir != this-&gt;Options.SourceFiles.end();
		ir++ )
	{
		sDOCInitfn = *ir;
		if ( sDOCInitfn.length() &gt;= 4 ) sExt.assign(sDOCInitfn.substr(sDOCInitfn.length() - 4, 4));

		sDOCfn = _getAbsolutePathName( sDOCfn, sDOCInitfn );
		sCIAOfn.assign(sDOCfn, 0, sDOCfn.length() - 3);
		sCIAOfn.append(&quot;ciao&quot;, 4);

		if ( ( sExt == &quot;.doc&quot; )	|| ( sExt == &quot;.rtf&quot; ) )
		{
			// strings sCIAOfn et sDOCfn are defined

			if ( ( sExt == &quot;.doc&quot; )
				|| ( sExt == &quot;.rtf&quot; ) )
			{
				CConverterDoc * convDoc = new CConverterDoc();
				convDoc-&gt;ConvertFromDOC( sCIAOfn.c_str(), sDOCfn.c_str(), this-&gt;Options.debugDocLines );
			}
		}

#ifdef USE_MANAGED_EXTENSIONS

		// that functionality is only available using managed extensions
		else
			if ( ( sExt == &quot;.xmi&quot; )	|| ( sExt == &quot;.xml&quot; ) )
			{
				if ( ( sExt == &quot;.xmi&quot; )
					|| ( sExt == &quot;.xml&quot; ) )
				{
					CConverterXmi * convXmi = new CConverterXmi();
					convXmi-&gt;ConvertFromXMI( sCIAOfn.c_str(), sDOCfn.c_str() );
				}
			}

#endif // USE_MANAGED_EXTENSIONS

			else sCIAOfn = sDOCInitfn;
		
		// add the converted (or not) source file to the CIAO source file list
		Options.SourceCIAOFiles.push_back( sCIAOfn );
	}
}

} // end of namespace ciao

	#endif // _WINDOWS
-------------- next part --------------
//***************************************************************
// File		: CIAOMain.hpp
// Project	: iCIAO
// Author	: Anthony Breneliere
// Version	: 1.0

#ifndef _CIAOMain_hpp_
#define _CIAOMain_hpp_

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;strstream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;antlr/ASTRefCount.hpp&gt;

#include &quot;CIAOConfig.hpp&quot;
#include &quot;world/WWorld.hpp&quot;
#include &quot;ciao.elements/CIAOWorkTable.hpp&quot;

namespace ciao {

// options of the source file
class CAppOptions
{
	public:

		CAppOptions()
		{
			displayHelp = false;
			displayTree = false;
			checkSyntaxOnly = false;
			language = &quot;french&quot;;
			dispVersion = false;
			debugDocLines = false;
			doNotDeleteTempFiles = false;
			source = false;
			iniFile = &quot;&quot;;
		}

		// List of source files to analyze
		std::vector&lt;std::string&gt; SourceFiles;

		// List of CIAO source files to analyze
		std::vector&lt;std::string&gt; SourceCIAOFiles;

		// the name of the destination file
		std::string DestinationFile;

		// this is the name of the debug file
		std::string DebugFile;

		// language to use with the program
		std::string language;

		// user asked to display the help message if true
		bool displayHelp;

		// display also the tree resulting from the parsing
		bool displayTree;

		// just check the syntax
		bool checkSyntaxOnly;

		// just check the syntax
		bool dispVersion;
	
		// option to detch the lines &amp; pages from the original document
		bool debugDocLines;

		// option used to preserve intermediary files when the analys id done
		// from an xml file or a word document
		bool doNotDeleteTempFiles;

		// option used to display the source file of a ciao error
		bool source;

		// the INI file name
		std::string iniFile;
};

class CMainApp
{

	std::string sVersion;

public: 

	CAppOptions Options;

	CMainApp();

	~CMainApp();

	/*
	 * the platform generic main function, called by the program run-time or another
	 * main's function (specific to the platform)
	 */
	int Main (std::string &amp;sCmdLine);

	/*
	 * display the parser's resulting tree
	 */
	std::string GetTreeString(antlr::RefAST T, int level);

	/*
	 * Display the resulting data after the ciao document's consistency
	 * has been performed
	 */
	void DisplayResults( world::CWorld * _world, CWorkTable * _workTable );

	/*
	 * Display the command-line help
	 */
	void DisplayHelp(void);

	/*
	 * Windows Specific function.
	 * Converts all XMI and Word documents to ciao text files
	 */
	void ConvertDocuments();

	/*
	 * read the source files names from the app's options, concatenate all these files
	 * into one, which name is sent has parameter
	 */
	void ConcatenateSourceFiles(std::string &amp; sCIAOfn);

	/*
	 * Redirect the standard ouput to a file
	 *	- use a static variable to store the cout's buffer
	 */
		// int RedirectCout2File( bool toFile, const string &amp; _sFileN );
	int RedirectCout2File( ostream &amp; _ostr, bool _toFile, const string &amp; _sFileN );
};

} // end of ciao namespace

#endif
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004938.html">[antlr-interest] Re: inversion problems: unreachable statemen
	ts &amp; lex failures
</A></li>
	<LI>Next message: <A HREF="004940.html">[antlr-interest] updated ANTLR tutorial added to getting started doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4939">[ date ]</a>
              <a href="thread.html#4939">[ thread ]</a>
              <a href="subject.html#4939">[ subject ]</a>
              <a href="author.html#4939">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
