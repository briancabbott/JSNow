<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Fwd: Semantic predicate losing token/char	position on error
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Fwd%3A%20Semantic%20predicate%20losing%20token/char%0A%09position%20on%20error&In-Reply-To=%3CAANLkTimE9kRJo0YAkJO4M3Z8qj1iIUbcUFiMPp8xvotk%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="038949.html">
   <LINK REL="Next"  HREF="038954.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Fwd: Semantic predicate losing token/char	position on error</H1>
    <B>Karim Chichakly</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Fwd%3A%20Semantic%20predicate%20losing%20token/char%0A%09position%20on%20error&In-Reply-To=%3CAANLkTimE9kRJo0YAkJO4M3Z8qj1iIUbcUFiMPp8xvotk%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Fwd: Semantic predicate losing token/char	position on error">karimc17 at gmail.com
       </A><BR>
    <I>Tue Jun  8 08:40:47 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="038949.html">[antlr-interest] Fwd: Semantic predicate losing token/char	position on error
</A></li>
        <LI>Next message: <A HREF="038954.html">[antlr-interest] Fwd: Semantic predicate losing token/char	position on error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38953">[ date ]</a>
              <a href="thread.html#38953">[ thread ]</a>
              <a href="subject.html#38953">[ subject ]</a>
              <a href="author.html#38953">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Jim,

The semantic predicate was a red herring.  First of all, no viable alt
exception is reliably giving me a token, which makes sense to me.

Secondly, changing the grammar is what leads to my problem and I think I
know why, though I don't know how to get around it.  If my grammar appears
as follows:

var        :    var_id
        |    var_id LEFT_PAREN args RIGHT_PAREN        -&gt; ^(CALL var_id
args)
        ;

and I enter &quot;a ab&quot;, the token I get from no viable alt exception is, in
fact, &quot;ab&quot;, as I expect.  If I rewrite the grammar as follows:

var        :    var_id
        (    LEFT_PAREN args RIGHT_PAREN        -&gt; ^(CALL var_id args)
        |    -&gt; var_id
        )
        ;

and I enter &quot;a ab&quot;, the token I get from no viable alt exception is &quot;&quot;.
Indeed, token-&gt;start == token-&gt;stop == parser-&gt;input_start.  It is not as
surprising to me that token-&gt;start == token-&gt;stop as that they equal
parser-&gt;input_start.  In thinking about this, it seems the parser get the
next token, &quot;ab&quot;, which successfully matches var_id.  It then has to get
another token (consuming &quot;ab&quot;) to distinguish between the cases presented
before it.  We are at the end of input, so, of course, the next token it
gets is &quot;&quot;, but I would have expected there to be a difference between
token-&gt;start and parser-&gt;input_start of 4.

Tracing through the generated code, I see a different picture.  I thought
the problem was that it consumed the token.  The problem is really that it
never consumed any tokens at all.  That is why token-&gt;start ==
parser-&gt;input_start.  My full definition of var_id is:

var_id        :    ID
        |    ID (DOT ID)+    -&gt; ^(DOT ID+)
        |    DOT^ ID
        ;

The code generated for this switches on LA(1) to test for ID or DOT.  Within
case ID, it then switches on LA(2) to decide between the first two
alternatives.  Here it fails because LA(2) is also ID and it throws a no
viable alt exception.  Unfortunately, since it made this decision based on
LA(1) and LA(2), the actual token that caused the problem has not been
identified; instead everything still points to the start of the input.  Is
there any way to recover this information?

By the way, for the [first] grammar that properly returns the erroneous
token, cdfa18.predict is called instead, which does consume tokens.  The
first grammar, however, is unable to disambiguate the cases I have to parse
(&quot;X&quot; as a 0-argument function call vs. &quot;X&quot; as a variable).

Thanks again,

Karim


---------- Forwarded message ----------
From: Karim Chichakly &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">karimc17 at gmail.com</A>&gt;
Date: Mon, Jun 7, 2010 at 2:46 PM
Subject: Re: [antlr-interest] Fwd: Semantic predicate losing token/char
position on error
To: &quot;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A> interest&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;


Hi Jim,

Thank you!  I did not realize you could write a rule like that in ANTLR.

Re: No viable alt exception:  I can see that the parser has no idea about
what kind of token it is, but didn't the lexer pull a token off?  [If not,
what is the parser trying to match?]  Where is that token?  I am guessing
that this will be moot after I change the grammar as you suggest since I was
getting that token (with the same error) before I put the leading predicate
in.

Thanks,

Karim


---------- Forwarded message ----------
From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
 Date: Mon, Jun 7, 2010 at 2:12 PM
Subject: Re: [antlr-interest] Fwd: Semantic predicate losing token/char
position on error
To: &quot;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A> interest&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;


With no viable alt, there is no token to inspect as there was no token
missing etc. You can use the bitmap of expected tokens to say what tokens
could be there at that point. Hence there is no token in the exception as
there is no specific token that is in error. At least off the top of my head
that is the case.

You are approaching the problem from the wrong end:

varorFunc
 : i=IDENT
       (
          LPAREN fa=funcArgs? RPAREN
             { you could issue an error here if $i is not a function or wait
until the tree walk }
           -&gt; ^(FUNCTION $i $fa?)

        | -&gt; {isFunction($i)}? -&gt; ^(FUNCTION $i)
          -&gt; $i
       )
  ;

You can get an IDENT with or without function parameters and the syntax
(which is what your parser is concerned with) is always valid. Later you can
verify if the names that were used were valid functions and issue a much
nicer message than the parser could generate alone.

Jim



&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Karim Chichakly
</I>&gt;<i> Sent: Monday, June 07, 2010 10:46 AM
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A> interest
</I>&gt;<i> Subject: [antlr-interest] Fwd: Semantic predicate losing token/char
</I>&gt;<i> position on error
</I>&gt;<i>
</I>&gt;<i> Hi Jim,
</I>&gt;<i>
</I>&gt;<i> Thank you.  I am sorry, but I completely missed that on the support
</I>&gt;<i> page.
</I>&gt;<i>
</I>&gt;<i> I understand your point (and thanks for the tip about pANTLR3_STRING),
</I>&gt;<i> but in your example, what is funcCall?  In my full grammar, I also have
</I>&gt;<i> a branch that looks for var_id(args), so perhaps funcCall : (args)?
</I>&gt;<i> However, the problem I have is that the grammar I am parsing allows an
</I>&gt;<i> identifier by itself (i.e., no distiguishing syntactical features, such
</I>&gt;<i> as parens) to represent either a variable or a zero-argument function
</I>&gt;<i> call.  All function names are reserved, so I can distinguish zero-
</I>&gt;<i> argument function calls from variables via a symbol table lookup.
</I>&gt;<i>
</I>&gt;<i> In the spirit of what you are saying, I think would have to pass the
</I>&gt;<i> var_ids through as var_ids and then do the lookup in a follow-on pass
</I>&gt;<i> that modifies the AST as needed.  Is this really the best way, i.e., to
</I>&gt;<i> add another pass?
</I>&gt;<i>
</I>&gt;<i> I enclose my nascent error handler.  As you can see, I am trying to
</I>&gt;<i> supply uniform behavior rather than do different things based on the
</I>&gt;<i> specific error (all I want is a clear indication of what went wrong and
</I>&gt;<i> the position where it went wrong).  Perhaps this is folly.  The error
</I>&gt;<i> in this case was ANTLR3_NO_VIABLE_ALT_EXCEPTION.
</I>&gt;<i>
</I>&gt;<i> Thanks again,
</I>&gt;<i>
</I>&gt;<i> Karim
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ---------- Forwarded message ----------
</I>&gt;<i> From: Jim Idle &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jimi at temporal-wave.com</A>&gt;
</I>&gt;<i> Date: Mon, Jun 7, 2010 at 1:02 PM
</I>&gt;<i> Subject: Re: [antlr-interest] Semantic predicate losing token/char
</I>&gt;<i> position on error
</I>&gt;<i> To: &quot;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A> interest&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-bounces at antlr.org</A> [mailto:antlr-interest-
</I>&gt;<i> &gt; <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">bounces at antlr.org</A>] On Behalf Of Karim Chichakly
</I>&gt;<i> &gt; Sent: Monday, June 07, 2010 8:44 AM
</I>&gt;<i> &gt; To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A> interest
</I>&gt;<i> &gt; Subject: [antlr-interest] Semantic predicate losing token/char
</I>&gt;<i> &gt; position on error
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Thank you again for your previous help.  I now know about
</I>&gt;<i> &gt; antlr.markmail.org(perhaps a link from www.antlr.org would help
</I>&gt;<i> &gt; others)
</I>&gt;<i>
</I>&gt;<i> You mean like the one on the support page with a box that you can type
</I>&gt;<i> your search terms in and a logo saying &quot;Mark mail&quot;? ;-)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; If, however, I add a semantic predicate to that grammar (enclosed) to
</I>&gt;<i> &gt; distinguish between X as a function call and X as a variable (which
</I>&gt;<i> is
</I>&gt;<i> &gt; described starting on page 297 of the Definitive ANTLR Reference), I
</I>&gt;<i> &gt; no longer get a character position.  All four of the variables
</I>&gt;<i> &gt; involved in the position calculation are set to 1, and the start and
</I>&gt;<i> &gt; stop then become zero.
</I>&gt;<i> &gt; These values are, by the way, a bit peculiar as these fields usually
</I>&gt;<i> &gt; hold pointers into the text.  I also note that token-&gt;input is now
</I>&gt;<i> &gt; NULL.
</I>&gt;<i>
</I>&gt;<i> Well, though this might be shown as an example in the book it isn't
</I>&gt;<i> really the way to do things. You are trying to make a semantic
</I>&gt;<i> distinction via syntax rules and that is always going to give you a
</I>&gt;<i> headache. You should parse as:
</I>&gt;<i>
</I>&gt;<i> var_id:
</I>&gt;<i>        ( funcCall -&gt; ^(FUNCTION var_id funcCall)
</I>&gt;<i>         | -&gt; var_id
</I>&gt;<i>      )
</I>&gt;<i>   ;
</I>&gt;<i>
</I>&gt;<i> Then check to see if the function construct really was a function when
</I>&gt;<i> you walk the tree in a verification pass.
</I>&gt;<i>
</I>&gt;<i> I need to see your error reporting function to help you more on the
</I>&gt;<i> display stuff. It is likely that you are trying to use elements that
</I>&gt;<i> are not valid for the type of error you are being passed. Not all
</I>&gt;<i> elements are available for all errors.
</I>&gt;<i>
</I>&gt;<i> Finally, do not use the pANTLR3_STRING stuff unless your grammar is
</I>&gt;<i> just a small single-shot parse as you will create a new string every
</I>&gt;<i> time you run that predicate! Call a function, use LT() to get the next
</I>&gt;<i> token, then use the pointers in the token directly. You will use no
</I>&gt;<i> memory that way!
</I>&gt;<i>
</I>&gt;<i> Jim
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> Unsubscribe:
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</I>



List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
Unsubscribe:
<A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="038949.html">[antlr-interest] Fwd: Semantic predicate losing token/char	position on error
</A></li>
	<LI>Next message: <A HREF="038954.html">[antlr-interest] Fwd: Semantic predicate losing token/char	position on error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38953">[ date ]</a>
              <a href="thread.html#38953">[ thread ]</a>
              <a href="subject.html#38953">[ subject ]</a>
              <a href="author.html#38953">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
