<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the	horror, the horror)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20ANTLR%20version%202.X%20to%20ANTLR%20version%203.X%20%28the%0A%09horror%2C%20the%20horror%29&In-Reply-To=%3C002201c8f992%2453314b20%24f993e160%24%40com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029745.html">
   <LINK REL="Next"  HREF="029769.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the	horror, the horror)</H1>
    <B>Foust</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20ANTLR%20version%202.X%20to%20ANTLR%20version%203.X%20%28the%0A%09horror%2C%20the%20horror%29&In-Reply-To=%3C002201c8f992%2453314b20%24f993e160%24%40com%3E"
       TITLE="[antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the	horror, the horror)">javafoust at gmail.com
       </A><BR>
    <I>Fri Aug  8 13:07:01 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="029745.html">[antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the horror, the horror)
</A></li>
        <LI>Next message: <A HREF="029769.html">[antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the horror, the horror)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29756">[ date ]</a>
              <a href="thread.html#29756">[ thread ]</a>
              <a href="subject.html#29756">[ subject ]</a>
              <a href="author.html#29756">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE> 

 

Ian Kaplan wrote:

&gt;<i> More examples which semantic actions (Java code) would be very helpful. 
</I>
&gt;<i> It took me some time, for example, to understand that the blocks follow
</I>each other.

&gt;<i> 
</I>
&gt;<i>  @init{
</I>
&gt;<i>  }
</I>
&gt;<i>  @after{
</I>
&gt;<i>   }
</I>
 

Yes, it is not obvious whether tags like this should go before or after the
colon and that order would matter so much. The order of the options, tokens,
header, members tags is also rigid with confusing error messages when they
are out of order, making it seem as though the tag itself is invalid.

 

 

&gt;<i> As noted in the 2.X to 3.X documentation, there's no built in way to
</I>
&gt;<i> create case insensitivity without overriding the scanner input stream.
</I>
 

It may be noted, but no good solution is. Case-insensitive keywords is such
a common feature that it's difficult to believe that a straightforward
solution is not provided.

 

 

&gt;<i> The good news is that there's documentation, but for some reason with
</I>ANTLR

&gt;<i> there never seems to be enough documentation to make the initial learning
</I>
&gt;<i> curve anything but painful.
</I>
 

Exactly.

 

It's free. It's powerful. There are some great people actively improving the
tool. All this is not taken for granted. But it doesn't change the fact that
even with the DAR (Definitive Antlr Reference), getting it to do what you
want is a frustrating experience. It seems fine once you've gone through the
multi-day learning experience. But the syntax is varied enough and methods
different enough that there will still be some struggling.

 

A v3.1 &quot;gotchas&quot; page, along with an Antlr Cookbook would probably go a long
way toward helping those new to v3 specifically, and ANTLR in general.

 

 

&gt;<i>  I noticed that the person who maintains the 2.X C++ grammar is looking
</I>for someone 

&gt;<i> to take it over since they don't want to deal with the conversion to ANTLR
</I>3.X.  I can't

&gt;<i> say I blame them.   My grammar is a lot smaller and it's going to be at
</I>least a two day 

&gt;<i> slog with a fair amount of frustration.
</I>
 

Likely more than that.

 

 

&gt;<i> In addition to the fact that the 2.X grammar is obsolete, I'm doing the
</I>conversion 

&gt;<i> because I am hoping that the LL(*) will avoid left factoring my grammar
</I>into a less 

&gt;<i> clear form.  I hope that I am not disappointed.
</I>
 

I don't know that LL(*) will solve all of your left-factoring woes, but the
backtracking does help you make your grammar more readable (and therefore
maintainable). It adds some parsing overhead, but it's worth it. (How many
times have we wished an LALR parser generator would just &quot;figure it out&quot;?)
And it can be localized to just the rules you need, once you get it working,
by turning off backtracking at the global level and adding it to individual
rules that are ambiguous to the LL(k) algorithm:

 

stmt  options {backtrack=true; memoize=true;}

      :  expr .

      ;

 

 

Brent

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20080808/c18e1930/attachment-0001.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20080808/c18e1930/attachment-0001.html</A> 
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029745.html">[antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the horror, the horror)
</A></li>
	<LI>Next message: <A HREF="029769.html">[antlr-interest] ANTLR version 2.X to ANTLR version 3.X (the horror, the horror)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29756">[ date ]</a>
              <a href="thread.html#29756">[ thread ]</a>
              <a href="subject.html#29756">[ subject ]</a>
              <a href="author.html#29756">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
