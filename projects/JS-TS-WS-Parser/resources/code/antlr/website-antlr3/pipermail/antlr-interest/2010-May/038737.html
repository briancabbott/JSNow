<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] C target - initialization of return/scope structures
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20C%20target%20-%20initialization%20of%20return/scope%0A%20structures&In-Reply-To=%3C20100520121356.GA5042%40internode.on.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="038735.html">
   <LINK REL="Next"  HREF="038738.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] C target - initialization of return/scope structures</H1>
    <B>Mark Wright</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20C%20target%20-%20initialization%20of%20return/scope%0A%20structures&In-Reply-To=%3C20100520121356.GA5042%40internode.on.net%3E"
       TITLE="[antlr-interest] C target - initialization of return/scope structures">markwright at internode.on.net
       </A><BR>
    <I>Thu May 20 05:13:56 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="038735.html">[antlr-interest] C target - initialization of return/scope	structures
</A></li>
        <LI>Next message: <A HREF="038738.html">[antlr-interest] C target - initialization of return/scope	structures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38737">[ date ]</a>
              <a href="thread.html#38737">[ thread ]</a>
              <a href="subject.html#38737">[ subject ]</a>
              <a href="author.html#38737">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, May 20, 2010 at 10:04:09AM +0300, Cristian T&#226;r&#351;oag&#259; wrote:
&gt;<i> Hi Jim, that is not my problem, let me show you an example
</I>&gt;<i> 
</I>&gt;<i> I want to have a scoped value which is a structure, and my structure holds
</I>&gt;<i> some std::strings
</I>&gt;<i> 
</I>&gt;<i> struct MyStruct
</I>&gt;<i> {
</I>&gt;<i>   std::string s1;
</I>&gt;<i>   std::string s2;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> //this is part of my grammar
</I>&gt;<i> myrule
</I>&gt;<i> scope {MyStruct s;} //scoped VALUE
</I>&gt;<i> @init{}
</I>&gt;<i> @after{}
</I>&gt;<i> : rulegoeshere....;
</I>&gt;<i> 
</I>&gt;<i> As you can see, there is no pointer here, the scoped variable is a 'value'.
</I>&gt;<i> The code generated by antlr creates a scoped wrapper structure that holds
</I>&gt;<i> MyStruct, something like:
</I>&gt;<i> 
</I>&gt;<i> ctx-&gt;pMyParser_myruleTop = pMyParser_myrulePush(ctx); // this will create a
</I>&gt;<i> wrapper for the scoped value by calling ANTLR3_MALLOC
</I>&gt;<i> 
</I>&gt;<i> the wrapper looks like this:
</I>&gt;<i> 
</I>&gt;<i> typedef struct  MyParser_myrule_SCOPE_struct
</I>&gt;<i> {
</I>&gt;<i>     void    (ANTLR3_CDECL *free)    (struct MyParser_myrule_SCOPE_struct *
</I>&gt;<i> frame);
</I>&gt;<i>     MyStruct s;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> As you can see my struct is inside this structure. The problem is that to
</I>&gt;<i> create the wrapper (see pMyParser_myrulePush above)
</I>&gt;<i> antlr calls ANTLR3_MALLOC (which does malloc of course).
</I>&gt;<i> 
</I>&gt;<i> THIS MEANS I'M GONNA GET A CRASH!
</I>&gt;<i> 
</I>&gt;<i> Why? because std::string is a c++ class, which HAS to be created/destroyed
</I>&gt;<i> using new/delete, not malloc/free.
</I>
Hi Cristian,

As Jim advised, you need to initialise it in @init().  As the memory has
already been allocated, the correct way to initialise it is to call the
constructor with placement operator new.

And it is necessary to register your own free method to call the destructor.

grammar MyGrammar;

options {
        language = C;
}

scope GS {
  MyStruct s;
}

@parser::includes {
#include &lt;new&gt;
#include &quot;MyStruct.h&quot;
}

myrule
scope GS;
@init{
  new(&amp;($GS::s))MyStruct;
  ctx-&gt;pMyGrammarParser_GSTop-&gt;free = &amp;free_MyStruct;
}
        : 'foo'
        | 'bar'
        ;

mystruct.h:
#include &lt;string&gt;
#include &lt;antlr3.h&gt;

struct MyStruct
{
  std::string s1;
  std::string s2;
};

extern &quot;C&quot; {
  void ANTLR3_CDECL free_MyStruct(struct MyGrammarParser_GS_SCOPE_struct *scope);
}

mystruct.cpp:
extern &quot;C&quot; {
void ANTLR3_CDECL free_MyStruct(struct MyGrammarParser_GS_SCOPE_struct *scope)
{
  // Call the destructor
  (&amp;(scope-&gt;s))-&gt;MyStruct::~MyStruct();
}
}

Regards, Mark
 
&gt;<i> That means, I cannot use a scoped VALUE, I have to use a scoped POINTER
</I>&gt;<i> instead, as suggested here:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.mail-archive.com/il-antlr-interest@googlegroups.com/msg02614.html">http://www.mail-archive.com/il-antlr-interest@googlegroups.com/msg02614.html</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Suggested Solution 1: local new/delete allocation/deallocation
</I>&gt;<i> ------------------------------
</I>&gt;<i> -----------------------------------------------------------
</I>&gt;<i> So my rule will now look like this:
</I>&gt;<i> 
</I>&gt;<i> myrule
</I>&gt;<i> scope {MyStruct* s;} //scoped POINTER
</I>&gt;<i> @init{ $myrule::s = new MyStruct();} //explicit allocation using new
</I>&gt;<i> @after{ delete $myrule::s; } //explicit deallocation using delete
</I>&gt;<i> : rulegoeshere....;
</I>&gt;<i> 
</I>&gt;<i> Looks good? Well, I think not!
</I>&gt;<i> Because when the rule fails, the @after action is NOT called, and I'm gonna
</I>&gt;<i> get a nice memory leak.
</I>&gt;<i> 
</I>&gt;<i> Solution 1': the scoped wrapper has a member called free that can hold a
</I>&gt;<i> 'deleter', but I couldn't find a way to set that.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Suggested Solution2: override antlr macros ANTLR3_MALLOC and ANTLR3_FREE
</I>&gt;<i> ------------------------------------------------------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Nice try, but ANTLR3_MALLOC is currently defined like this:
</I>&gt;<i> #define    ANTLR3_MALLOC(request)                    malloc
</I>&gt;<i> ((size_t)(request))
</I>&gt;<i> 
</I>&gt;<i> As you can see, the 'request' argument is a SIZE, not a type, which means
</I>&gt;<i> that if I want to override it to make it use 'new' instead of malloc, I
</I>&gt;<i> cannot use it.
</I>&gt;<i> &gt;From the given size I cannot deduce the type (this could work the other way
</I>&gt;<i> around if you change the define, to pass it the type you could get the size,
</I>&gt;<i> and it could be possible to override the default way of antlr's
</I>&gt;<i> allocations/deallocations)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> That is my problem and those are the options I have. Maybe with some
</I>&gt;<i> adjustment some of them will work, but right now, I'm not happy with any of
</I>&gt;<i> them: first one leaks, second one is not usable.
</I>&gt;<i> 
</I>&gt;<i> Maybe you have some hints for me :-)
</I>&gt;<i> 
</I>&gt;<i> Thanks a lot for your answer
</I>&gt;<i> 
</I>&gt;<i>    Chris
</I>&gt;<i> 
</I>&gt;<i> List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</I>&gt;<i> 
</I></PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="038735.html">[antlr-interest] C target - initialization of return/scope	structures
</A></li>
	<LI>Next message: <A HREF="038738.html">[antlr-interest] C target - initialization of return/scope	structures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38737">[ date ]</a>
              <a href="thread.html#38737">[ thread ]</a>
              <a href="subject.html#38737">[ subject ]</a>
              <a href="author.html#38737">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
