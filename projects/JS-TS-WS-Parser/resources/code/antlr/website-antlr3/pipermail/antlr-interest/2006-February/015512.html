<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Tree generation qestion 
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Tree%20generation%20qestion%20&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015510.html">
   <LINK REL="Next"  HREF="015513.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Tree generation qestion </H1>
    <B>=?gb2312?q?=CB=EF=BC=CD=B8=D5=20Jigang=20(Robert)=20Sun?=</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Tree%20generation%20qestion%20&In-Reply-To="
       TITLE="[antlr-interest] Tree generation qestion ">sunjigang1965 at yahoo.com.cn
       </A><BR>
    <I>Fri Feb 24 13:18:53 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="015510.html">[antlr-interest] Need another name for ANTLR Studio's Flux
	Debugger
</A></li>
        <LI>Next message: <A HREF="015513.html">[antlr-interest] Tree generation qestion 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15512">[ date ]</a>
              <a href="thread.html#15512">[ thread ]</a>
              <a href="subject.html#15512">[ subject ]</a>
              <a href="author.html#15512">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Code generated by the attached grammar only produces a
root StatementList node contains an empty list of
Statement. After remove ! from end of 
&quot;statementList&quot;, desired result got. Is this normal?

While the following grammar works well.

formalList!
	:
	 (formal ( COMMA! formal)* { ## =
#(#[FORMAL_LIST,&quot;FORMAL_LIST&quot;],##); })?
	;

formal!
    :	dt:dataType id:ID&lt;AST=MiniJava.Identifier&gt;
	{
		## = #( #[MINI_JAVA_FORMAL, &quot;MINI_JAVA_FORMAL&quot;],
#dt, #id );
	}
	;

dataType
	:
	 (&quot;int&quot; LSQUARE)=&gt; &quot;int&quot;! LSQUARE! RSQUARE
&lt;AST=MiniJava.IntArrayType&gt; //int []
	| &quot;int&quot; &lt;AST=MiniJava.IntegerType &gt;
	| &quot;boolean&quot; &lt;AST=MiniJava.BooleanType&gt;
	|  ID &lt;AST=MiniJava.IdentifierType&gt;
	;
Antlr ver is 2.7.6.

Cheers.

Jigang


		
___________________________________________________________ 
&#206;&#222;&#207;&#222;&#200;&#221;&#193;&#191;&#209;&#197;&#187;&#162;&#207;&#224;&#178;&#225;&#163;&#172;&#212;&#173;&#205;&#188;&#181;&#200;&#180;&#243;&#207;&#194;&#212;&#216;&#163;&#172;&#179;&#172;&#191;&#236;&#203;&#217;&#182;&#200;&#163;&#172;&#184;&#207;&#191;&#236;&#199;&#192;&#215;&#162;&#163;&#161; 
<A HREF="http://cn.photos.yahoo.com">http://cn.photos.yahoo.com</A>
-------------- next part --------------
statementList!
	:
	(statement)* { ## = #(#[STATEMENT_LIST,&quot;STATEMENT_LIST&quot;,&quot;MiniJava.StatementList&quot;],##); }
	;
	
statement
	:
	&quot;System&quot;! DOT! &quot;out&quot;!  DOT! &quot;println&quot;! LPAREN^ &lt;AST=MiniJava.Print&gt; expression RPAREN! SEMI!
	| &quot;while&quot;! LPAREN! expression RPAREN^ &lt;AST=MiniJava.While&gt; statement 
	| &quot;if&quot;! LPAREN!  expression RPAREN^&lt;AST=MiniJava.If&gt; statement &quot;else&quot;! statement 
        | LBRACE^&lt;AST=MiniJava.Block&gt; statementList RBRACE! 
        | (ID BECOMES)=&gt; ID&lt;AST=MiniJava.Identifier&gt; BECOMES^&lt;AST=MiniJava.Assign&gt; expression SEMI!//a=8;
        | ID&lt;AST=MiniJava.Identifier&gt; LSQUARE! expression RSQUARE^&lt;AST=MiniJava.ArrayAssign&gt; BECOMES! expression SEMI! //a[7]=7;
	;
	

expList
	:
	(andExp (COMMA^&lt;AST=MiniJava.ExpList&gt; andExp)* )? 
	;  	
	
expression     
	:
	andExp //EOF
	;		
	
andExp
	:
	lessThanExp ( AND^&lt;AST=MiniJava.And&gt; lessThanExp )*
	;

lessThanExp
	:
	additiveExp (LESS_THAN^ &lt;AST=MiniJava.LessThan&gt; additiveExp)?
	;
		
additiveExp 
	:
	timesExp ((PLUS^&lt;AST=MiniJava.Plus&gt;|MINUS^&lt;AST=MiniJava.Minus&gt;) timesExp)* 
	;
	
timesExp
	:
	prefixExp (TIMES^ &lt;AST=MiniJava.Times&gt;  prefixExp)* 
	;
	
prefixExp
	:
	notExp 
	|suffixExp
	;
	
notExp
	:
	BOMB^ &lt;AST=MiniJava.Not&gt; suffixExp
	; 	
	
suffixExp
	:
	primaryExp 
	(LSQUARE^&lt;AST=MiniJava.ArrayLookup&gt; andExp RSQUARE!//array[index], a[3]
	| (DOT &quot;length&quot;)=&gt; DOT^ &lt;AST=MiniJava.ArrayLength&gt; &quot;length&quot;!  // array.length 
	| DOT^ &lt;AST=MiniJava.Call&gt; ID&lt;AST=MiniJava.Identifier&gt; LPAREN! expList RPAREN! //classname.method(1,2,3), call a class method, class Call.cs 
	)*	
	;	    
   
primaryExp
	:
	INT &lt;AST=MiniJava.IntegerLiteral&gt;
	| &quot;true&quot; &lt;AST=MiniJava.True&gt;
	| &quot;false&quot;&lt;AST=MiniJava.False&gt;
	| ID &lt;AST=MiniJava.Identifier&gt;
	| &quot;this&quot; &lt;AST=MiniJava.This&gt;
	|(&quot;new&quot; ID)=&gt;&quot;new&quot;! ID &lt;AST=MiniJava.NewObject&gt; LPAREN! RPAREN!//new object
	| &quot;new&quot;! (&quot;int&quot;!  LSQUARE &lt;AST=MiniJava.NewArray&gt; andExp RSQUARE!) //new array creation: new int[9] primaryExp is Exp
	| LPAREN! andExp RPAREN! //primaryExp is Exp
	;

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015510.html">[antlr-interest] Need another name for ANTLR Studio's Flux
	Debugger
</A></li>
	<LI>Next message: <A HREF="015513.html">[antlr-interest] Tree generation qestion 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15512">[ date ]</a>
              <a href="thread.html#15512">[ thread ]</a>
              <a href="subject.html#15512">[ subject ]</a>
              <a href="author.html#15512">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
