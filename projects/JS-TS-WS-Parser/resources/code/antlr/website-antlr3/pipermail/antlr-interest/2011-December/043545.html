<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Grammar hints?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Grammar%20hints%3F&In-Reply-To=%3CBAY149-W84A322E0445B8ED6F43E6EDA90%40phx.gbl%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="043543.html">
   <LINK REL="Next"  HREF="043547.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Grammar hints?</H1>
    <B>James Ladd</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Grammar%20hints%3F&In-Reply-To=%3CBAY149-W84A322E0445B8ED6F43E6EDA90%40phx.gbl%3E"
       TITLE="[antlr-interest] Grammar hints?">james_ladd at hotmail.com
       </A><BR>
    <I>Sun Dec 25 13:58:56 PST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="043543.html">[antlr-interest] De-emphasizing tree grammars?
</A></li>
        <LI>Next message: <A HREF="043547.html">[antlr-interest] urgent help required ...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#43545">[ date ]</a>
              <a href="thread.html#43545">[ thread ]</a>
              <a href="subject.html#43545">[ subject ]</a>
              <a href="author.html#43545">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I googles antler grammar hints but I can't find the description of how to 
Hint to antler which path to take. How do I do this?

&gt;<i> From: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-request at antlr.org</A>
</I>&gt;<i> Subject: antlr-interest Digest, Vol 85, Issue 20
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Date: Sun, 25 Dec 2011 12:00:01 -0800
</I>&gt;<i> 
</I>&gt;<i> Send antlr-interest mailing list submissions to
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> 
</I>&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-request at antlr.org</A>
</I>&gt;<i> 
</I>&gt;<i> You can reach the person managing the list at
</I>&gt;<i> 	<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-owner at antlr.org</A>
</I>&gt;<i> 
</I>&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;<i> than &quot;Re: Contents of antlr-interest digest...&quot;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Today's Topics:
</I>&gt;<i> 
</I>&gt;<i>    1. Re: De-emphasizing tree grammars? (Terence Parr)
</I>&gt;<i>    2. Re: Composite Grammars (Benjamin S Wolf)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 1
</I>&gt;<i> Date: Sat, 24 Dec 2011 12:11:13 -0800
</I>&gt;<i> From: Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">parrt at cs.usfca.edu</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] De-emphasizing tree grammars?
</I>&gt;<i> To: antlr-interest Interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Cc: &quot;George S. Cowan&quot; &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">cowang at comcast.net</A>&gt;,	Jason Osgood
</I>&gt;<i> 	&lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jason at jasonosgood.com</A>&gt;
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">D977C814-4754-48F7-BEB1-88DD9798D137 at cs.usfca.edu</A>&gt;
</I>&gt;<i> Content-Type: text/plain;	charset=windows-1252
</I>&gt;<i> 
</I>&gt;<i> Hi gang! Thanks to George, Gavin, Kyle, Jason, et al for bringing up this topic. First, let me point out some blog entries that I have that describe the new parser listener stuff:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.antlr.org/wiki/display/~admin/2011/09/08/Sample+v4+generated+visitor">http://www.antlr.org/wiki/display/~admin/2011/09/08/Sample+v4+generated+visitor</A>
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.antlr.org/wiki/display/~admin/2011/09/05/Auto+tree+construction+and+visitors">http://www.antlr.org/wiki/display/~admin/2011/09/05/Auto+tree+construction+and+visitors</A>
</I>&gt;<i> 
</I>&gt;<i> I recently had the opportunity to examine some software that made extensive use of visitors over a bytecode stream to not only collect information but to translate into another form. I decided to experiment with ANTLR v4's implementation. I was able to collapse all of my tree grammars into a single tree grammar that triggered listener events like SAX. (I did not alter the fact that my parser built an AST not parse tree.) What I ended up with is a tree grammar that sent high-level events like &quot;found rule definition&quot;, &quot;found token reference&quot;, and so on.   It became extremely easy to, say, make another pass over the tree to grab information.  As I looked at the event listener mechanism, I realized that: *a parse tree would give me the exact same thing without a tree grammar and the parse tree can be automatically generated.* My bias towards compiler style AST expression trees may have blinded me to a simple truth. um?for 20 years.
</I>&gt;<i> 
</I>&gt;<i> With a single decision, I had stripped away 2 large pieces of work: AST specification and tree grammar specification. The only question is, is it useful? Well, first, why do we build trees at all? The answer is we sometimes need to process information in a non-sequential   manner and sometimes we need to make multiple passes over the tree. For example, we might want to go find all symbol definitions and then process all symbol references.  Neither requirement says we have to have any particular kind of tree.
</I>&gt;<i> 
</I>&gt;<i> As Gavin points out, getting error nodes into the AST to represent error recovery token consumption is not well done in v3. In v4, it doesn't bother since it puts all of that error information in the parse tree.
</I>&gt;<i> 
</I>&gt;<i> I will also point out that it's really hard to get the original input sequence back from an AST, particularly if you have hidden tokens. Parse trees in contrast make this very easy. Parse trees are just much more natural for use with IDEs.
</I>&gt;<i> 
</I>&gt;<i> Gavin asks about a type safe syntax tree. I believe v4 will provide this because there is a node type for each rule in the grammar, or optionally each alternative in the grammar. The listener interface generates enter and exit rule events for each type. For example,
</I>&gt;<i> 
</I>&gt;<i> public interface TListener extends ParseTreeListener {
</I>&gt;<i>     void enterRule(TParser.ifstatContext ctx);
</I>&gt;<i>     void exitRule(TParser.ifstatContext ctx);
</I>&gt;<i> ?
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> The context object coincidentally is also where I store all parameters, locals, return values, and labels etc. That means that listener methods have access to the complete context of the rule invocation. (In ifstatContext, you'll see the usual double dispatch methods that trigger appropriate event listener.)
</I>&gt;<i> 
</I>&gt;<i> If you don't want to use the listener interface, you have the entire parse tree so you can treat it like a DOM thingie if you want; e.g., you can build your own visitors.
</I>&gt;<i> 
</I>&gt;<i> You can turn this feature on without regenerating anything. just turn on a runtime flag and ANTLR will stitch the rule invocation contexts together to form a parse tree.
</I>&gt;<i> 
</I>&gt;<i> Nothing is lost. tokens consumed or missing during the parse, appear in the parse tree.  For example, here are 2 parse trees associated with extra tokens and missing tokens:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> These were generated by calling inspect on the root of the parse tree--a GUI pops up; some sample code:
</I>&gt;<i> 
</I>&gt;<i> ParserRuleContext tree = parser.prog();
</I>&gt;<i> tree.save(parser, &quot;/tmp/t.ps&quot;); // Generate postscript:
</I>&gt;<i> tree.inspect(parser); // or view in dialog box
</I>&gt;<i> 
</I>&gt;<i> @Jason: yep, I am basically following the approach you have. You no longer have to put actions in the grammar, because the listener methods have access to all labels and other attributes of each rule invocation.   If you take a look at this new mechanism, I think you'll agree that it gives you the super simplicity of the SAX listener you want.
</I>&gt;<i> 
</I>&gt;<i> I like my listener event mechanism because the listener methods do not have to include the boilerplate code to visit the children. all you do is respond to the event.  Listener methods don't have a return value because any values needed by processing up the tree, can simply reference the rule return values which are also stored in the context object.
</I>&gt;<i> 
</I>&gt;<i> As Kyle points out, a big benefit of this automatic parse tree construction and listener event mechanism is that it renders grammars 100% reusable and retargetable to any target programming language. (Sam Harwell has convinced me to include things like skip in setting channels in the lexer with special syntax rather than actions? again we get retargeting).
</I>&gt;<i> 
</I>&gt;<i> Concerning the neutral imperative language, which we discussed before, I love the idea but I'm not sure how much this helps us. I think that the biggest problem in creating a target is not the code generation templates, which are much improved in v4, but rather the largish library. Of course, if we strip out all of the AST stuff in the tree grammar stuff, it's actually pretty simple ;)
</I>&gt;<i> 
</I>&gt;<i> Oh,  let me also mention that I have implemented a twist on Jim Idle's magic sync function to really improve error correction. In a nutshell, it tries extremely hard to stay within the current rule and recover in line instead of punting and consuming until it sees a token in the follow set.
</I>&gt;<i> 
</I>&gt;<i> Gavin says:
</I>&gt;<i> 
</I>&gt;<i> &gt; I was more thinking along the lines of I wish ANTLR would be able to
</I>&gt;<i> &gt; build the tree for me, but out of typesafe node classes, and without
</I>&gt;<i> &gt; the throwing-away-bits-of-the-tree behaviour that caused me so many
</I>&gt;<i> &gt; problems. But perhaps a SAX-style API would just be a simpler, more
</I>&gt;<i> &gt; robust solution.
</I>&gt;<i> 
</I>&gt;<i> Ask and ye shall receive. What I have built is exactly what you asked for. Type safe, automatically constructed, DOM or SAX model.
</I>&gt;<i> 
</I>&gt;<i> sorry for the stream of consciousness? just core dumping so I can get back to work ;) I apologize for my extreme absence on the mailing lists? last semester kicked my ass and I'm now trying to catch up on research.
</I>&gt;<i> 
</I>&gt;<i> Ter
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 2
</I>&gt;<i> Date: Sat, 24 Dec 2011 17:44:12 -0800
</I>&gt;<i> From: Benjamin S Wolf &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jokeserver at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [antlr-interest] Composite Grammars
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;CAN51Nt7zQTP9QCN6GptjWtO1QZp5fX8Ej2B3jExQCuN7=<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">g9zFg at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;iso-8859-1&quot;
</I>&gt;<i> 
</I>&gt;<i> Actually, there are still issues here. Namely GLexer is trying to use
</I>&gt;<i> both A and B directly as delegates, but never initializes the A
</I>&gt;<i> delegate for G_B_A. G_B does, which leads me to believe that this can
</I>&gt;<i> be solved in the constructor by adding &quot;gA = gB.gA&quot; in the Java case,
</I>&gt;<i> &quot;self.gA = self.gB.gA&quot; for Python, &quot;ctx-&gt;gA = ctx-&gt;gB-&gt;gA&quot; for C, etc.
</I>&gt;<i> But then again G_B is delegating to G_B_A; why then does GLexer want
</I>&gt;<i> to delegate directly to G_B_A?
</I>&gt;<i> 
</I>&gt;<i> (Attached GLexer.java and the full grammar in G.zip.)
</I>&gt;<i> 
</I>&gt;<i> On Fri, Dec 23, 2011 at 9:49 PM, Benjamin S Wolf &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">jokeserver at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt; I've gotten some very strange errors while trying to make a composite
</I>&gt;<i> &gt; grammar, and I think I've figured out why and/or a way around it. I'm
</I>&gt;<i> &gt; posting this because the error messages were not that helpful on their
</I>&gt;<i> &gt; own, and I had to fool around for a while with a minimal test case
</I>&gt;<i> &gt; until I found a way out of the errors.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have a composite grammar G, which imports two disjoint lexer
</I>&gt;<i> &gt; grammars A and B, and a parser grammar C (which only requires the
</I>&gt;<i> &gt; tokens from A). Using antlr3.4 on G with varying subsequent changes
</I>&gt;<i> &gt; gives one of the following sets of errors, regardless of output option
</I>&gt;<i> &gt; or language.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. G has no rules.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 2. parser rule ... not allowed in lexer, lexer rule ... not allowed in
</I>&gt;<i> &gt; parser, etc.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 3. java.lang.ClassCastException: org.antlr.runtime.tree.CommonTree
</I>&gt;<i> &gt; cannot be cast to org.antlr.tool.GrammarAST.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The short answer (before I go into details below) is that a) G needs a
</I>&gt;<i> &gt; parser rule, not just lexer rules, and b) G should only import one
</I>&gt;<i> &gt; lexer grammar, and the others should be imported by that one.
</I>&gt;<i> &gt; Strangely, b) does not apply to parser grammars, as I added a second
</I>&gt;<i> &gt; parser grammar D (dependent on both A and B) to test, and G is fine*
</I>&gt;<i> &gt; either way.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The long story: When I encountered (1), I added a dummy lexer rule
</I>&gt;<i> &gt; &quot;COMMA : ',' ;&quot;. This cured G's lack of rules but now antlr3.4 was
</I>&gt;<i> &gt; giving me (2), where it seemed that antlr3 thought I was putting all
</I>&gt;<i> &gt; of A's lexer rules in C and all of C's parser rules in A (and B,
</I>&gt;<i> &gt; etc.). Since I had no rules dependent on B, I removed it from being
</I>&gt;<i> &gt; imported. With G importing only A and C, I was now getting (3). I
</I>&gt;<i> &gt; added the rule &quot;comma : COMMA ;&quot; to G and now antlr3 completed
</I>&gt;<i> &gt; successfully (and still did when I folded these two rules together
</I>&gt;<i> &gt; into &quot;comma : ',' ;&quot;). So I added B back to the import list from G,
</I>&gt;<i> &gt; and it gave me (2) again. But removing B from G's import list and
</I>&gt;<i> &gt; making A import it made it work fine.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So antlr3 successfully produces a recognizer for G when G imports A,
</I>&gt;<i> &gt; C, and D, where A imports B, or when G imports B, C, and D, and B
</I>&gt;<i> &gt; imports A**.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I am not sure of the root reason behind the inability of the top level
</I>&gt;<i> &gt; of a composite grammar to import two lexer grammars (whether a design
</I>&gt;<i> &gt; decision or bug, eg.) as none of the documentation I could find on
</I>&gt;<i> &gt; composite grammars indicates either that this is the case or should be
</I>&gt;<i> &gt; otherwise. I would have liked a better error message in place of (2),
</I>&gt;<i> &gt; at least for the case where G had a lexer rule but not a parser rule,
</I>&gt;<i> &gt; because it would have saved a little bit of stumbling around.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; *By &quot;fine&quot; I mean antlr3 finishes successfully. But if G doesn't
</I>&gt;<i> &gt; import B, then the generated lexer can't produce tokens defined in B
</I>&gt;<i> &gt; and so the rules in D can't be reached.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; **Unless you're like me, and have an unfortunately large lexer grammar
</I>&gt;<i> &gt; B, which causes antlr3 to run out of stack space if G imports A
</I>&gt;<i> &gt; imports B but not if G imports B imports A.
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> A non-text attachment was scrubbed...
</I>&gt;<i> Name: GLexer.java
</I>&gt;<i> Type: application/octet-stream
</I>&gt;<i> Size: 3721 bytes
</I>&gt;<i> Desc: not available
</I>&gt;<i> Url : <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20111224/3b83b18c/attachment-0001.obj">http://www.antlr.org/pipermail/antlr-interest/attachments/20111224/3b83b18c/attachment-0001.obj</A> 
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> A non-text attachment was scrubbed...
</I>&gt;<i> Name: G.zip
</I>&gt;<i> Type: application/zip
</I>&gt;<i> Size: 916 bytes
</I>&gt;<i> Desc: not available
</I>&gt;<i> Url : <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20111224/3b83b18c/attachment-0001.zip">http://www.antlr.org/pipermail/antlr-interest/attachments/20111224/3b83b18c/attachment-0001.zip</A> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> antlr-interest mailing list
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>
</I>&gt;<i> <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> 
</I>&gt;<i> End of antlr-interest Digest, Vol 85, Issue 20
</I>&gt;<i> **********************************************
</I> 		 	   		  
</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="043543.html">[antlr-interest] De-emphasizing tree grammars?
</A></li>
	<LI>Next message: <A HREF="043547.html">[antlr-interest] urgent help required ...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#43545">[ date ]</a>
              <a href="thread.html#43545">[ thread ]</a>
              <a href="subject.html#43545">[ subject ]</a>
              <a href="author.html#43545">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
