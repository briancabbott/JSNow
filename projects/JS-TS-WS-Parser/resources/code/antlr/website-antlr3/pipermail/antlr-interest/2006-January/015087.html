<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] New article on StringTemplates and Treewalkers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20New%20article%20on%20StringTemplates%20and%20Treewalkers&In-Reply-To=43C57E11.5080007%40arabink.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015076.html">
   <LINK REL="Next"  HREF="015077.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] New article on StringTemplates and Treewalkers</H1>
    <B>Andy Tripp</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20New%20article%20on%20StringTemplates%20and%20Treewalkers&In-Reply-To=43C57E11.5080007%40arabink.com"
       TITLE="[antlr-interest] New article on StringTemplates and Treewalkers">antlr at jazillian.com
       </A><BR>
    <I>Thu Jan 12 07:33:32 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="015076.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
        <LI>Next message: <A HREF="015077.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15087">[ date ]</a>
              <a href="thread.html#15087">[ thread ]</a>
              <a href="subject.html#15087">[ subject ]</a>
              <a href="author.html#15087">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

Gregg Reynolds wrote:

&gt;<i>
</I>&gt;<i> Ok, syntactically, maybe the backend code is mixed up.  But 
</I>&gt;<i> conceptually?  After all, what is the difference between many-one and 
</I>&gt;<i> many one-one, rilly?
</I>
I would say that today, Jazillian is just a single one-to-one. There is 
no real &quot;frontend&quot; that could be switched out to handle a different
input language, or a &quot;backend&quot; where there's an ability to add 
additional backends to produce multiple output languages. I guess the only
way this is pertinent is that I'm taking buying what the StringTemplate 
article seems (to me) to be selling: that StringTemplate
can be an effective &quot;backend&quot;. ANTLR may be able to use it that way,  I 
don't think Jazillian could use it to, say, output
C# in addition to Java. Not without major changes to the Jazillian 
engine itself.

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So if it is a problem for Antlr, it is the same problem for 
</I>&gt;&gt;&gt;<i> Jazillion or any other code xformer, regardless of implementation 
</I>&gt;&gt;&gt;<i> technique.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I do agree that (and I'm not sure if this is your point or not) ANTLR 
</I>&gt;&gt;<i> and Jazillian seem like they should both be designed the same way.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Not at all, I'm only trying abstract in order to find the gist nut of 
</I>&gt;<i> the problem.  After all, if you went to the trouble of trying antlr 
</I>&gt;<i> and finding it lacking, there's something there, there.
</I>
Just to be clear: I love ANTLR for lexing and parsing, just not 
treewalking. Even for something that treewalking is best at: 
pretty-printing code,
I prefer to walk the tree &quot;by hand&quot; rather than use a treewalker. And 
(here's my whole point) I don't think treewalking is a good match for
something like a C-to-Java translator at all.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Nobody considers the machine code emitted by a compiler to be a 
</I>&gt;&gt;&gt;<i> &quot;view&quot; of the source code.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ah, but they do. I do, and  that's exactly what Terence is saying in 
</I>&gt;&gt;<i> the StringTemplate article...that the target Java, python, and bytecode
</I>&gt;&gt;<i> are simple three slightly different &quot;views&quot; of the output. I agree 
</I>&gt;&gt;<i> with that.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Well, you're a special case so we get to remove you from the sample.  ;)
</I>&gt;<i>
</I>&gt;<i> But the article was about a straightforward source to source 
</I>&gt;<i> transformation - not machine code generation (Java byte code is not 
</I>&gt;<i> machine code).  I wonder if you and/or Mr. Parr really think of 
</I>&gt;<i> compiled code - machine code - as a &quot;view&quot; of the source.  Ordinarily 
</I>&gt;<i> I mean - of course one can talk about it that way for special purposes.
</I>
Well, I'm the pessimist. I don't think you can even separate &quot;the view&quot; 
in the case of high-level languages. I'm not buying the &quot;StringTemplate lets
you produce Java, C++, and bytecode all from one engine&quot; theme of the 
StringTemplate article. So I obviously don't think it would work
for generating machine code either. Again, it ST great for the simple 
examples given, and so I tried to outline the real-world problems
that ST won't be able to solve. And those real-world problems would 
become huge if you tried to use ST to generate machine code.

&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The real question is not separation of m v and c, but of the 
</I>&gt;&gt;&gt;<i> *genericity* (adaptability, flexibility, whatever) of the &quot;service&quot;: 
</I>&gt;&gt;&gt;<i> given a parser generator, is its backend architecture general enough 
</I>&gt;&gt;&gt;<i> to make it easy to write specialized emitters?  Given a language 
</I>&gt;&gt;&gt;<i> transformer (e.g. Jazillion), is its frontend architecture general 
</I>&gt;&gt;&gt;<i> enough to make it easy to specialize it for a variety of input 
</I>&gt;&gt;&gt;<i> languages?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In my case, I haven't cared too much (yet) that the frontend by able 
</I>&gt;&gt;<i> to handle multiple input languages (or that the backend be able
</I>&gt;&gt;<i> to output multiple languages for that matter). Just a single 
</I>&gt;&gt;<i> C-to-Java translator is hard enough, and I've been happy to spend 3 
</I>&gt;&gt;<i> years full time
</I>&gt;&gt;<i> thinking about all the ways to do that really well, rather than 
</I>&gt;&gt;<i> expanding my scope. Having said that, I'm now working on C++ to Java, 
</I>&gt;&gt;<i> though :)
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> More specifically:  how hard would it be to write an ML or Haskell 
</I>&gt;&gt;&gt;<i> emitter for Antlr (something I'd like to see)?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Good question, and my related question is &quot;will StringTemplate make 
</I>&gt;&gt;<i> that any easier?&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> For the actual text generation, yes (I think); but that has nothing to 
</I>&gt;<i> do with target v. source driven transformation strategies.
</I>
Right, so what I'm trying to say is getting clearer as I read more :)
I have to objections: one is the &quot;target vs. source &quot; (or, I prefer &quot;AST 
walking vs. rule-based&quot;) architecture.
The second is the ability for ST to really add value (or scale) beyond 
things like producing C++/Java/C# output for ANTLR.

&gt;<i> [snip]
</I>

&gt;<i> Yep.  Although I daresay it depends on which language one is most 
</I>&gt;<i> comfortable with.  In lisp dialects it's pretty straightforward to 
</I>&gt;<i> thing in terms of something more treelike.  Then again, given the 
</I>&gt;<i> mainstream resistance to all those parentheses...
</I>
After a year of LISP as an undergrad, I had trouble getting out of the 
LISP mindset.
Just kept thinking &quot;Today is the first day of the rest of my life!&quot;

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Avoiding mental pictures of AST trees altogether is just a HUGE 
</I>&gt;&gt;<i> productivity boost, at least for me.
</I>&gt;&gt;<i> I'd say I'm at least twice as productive in writing rules (both 
</I>&gt;&gt;<i> simple text-replacement ones and
</I>&gt;&gt;<i> complex ones written in Java code), and probably more like 5-10x more 
</I>&gt;&gt;<i> productive
</I>&gt;&gt;<i> by largely ignoring AST structures.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That's interesting.  Can't argue with experience.  I suggest we cadge 
</I>&gt;<i> a few million bucks out of the DOD to do a study.
</I>
Problem is, we all have different experiences. I think there are 3 major 
things coming into play here.
First is intelligence. Some people are so smart that they don't see the 
uglyness of code that the rest of us do, because
the code looks straightforward to them.
Second is experience. Obviously, someone who knows ANLTR really well is 
not thrown off by a mix of ANTLR and Java code.
Third is mindset.
&lt;rant&gt;
People in the compiler crowd tend to enjoy playing with symbols and 
languages. They enjoy discussing
the merits of various syntax issues and enjoy learning new languages. 
But there are those of us who want to build
real-world apps and use language tools, but just aren't into debating 
whether to use a '[' or a '{' at some point
and aren't smart enough or knowledgable enough to know how to convert a 
a NFA to a DFA. We've got our
BSCS and MSCS degrees and 20 years of development experience - we're not 
newbies. It's just that it can take
some work for us to see the benefits of a tool like ST or an approach 
like treewalking

&lt;/rant&gt;
Andy

&gt;<i>
</I>&gt;<i> -gregg
</I>&gt;<i>
</I></PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015076.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
	<LI>Next message: <A HREF="015077.html">[antlr-interest] New article on StringTemplates and Treewalkers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15087">[ date ]</a>
              <a href="thread.html#15087">[ thread ]</a>
              <a href="subject.html#15087">[ subject ]</a>
              <a href="author.html#15087">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
