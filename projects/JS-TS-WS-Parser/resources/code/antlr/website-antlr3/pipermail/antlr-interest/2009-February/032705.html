<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Fwd: Error: TokenStreamException while reading	Grammer
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Fwd%3A%20Error%3A%20TokenStreamException%20while%20reading%0A%09Grammer&In-Reply-To=%3Cf205f60902032151k198e9e67nf64752b9a25de72f%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="032709.html">
   <LINK REL="Next"  HREF="032710.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Fwd: Error: TokenStreamException while reading	Grammer</H1>
    <B>Chal Chale apne Ghar</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Fwd%3A%20Error%3A%20TokenStreamException%20while%20reading%0A%09Grammer&In-Reply-To=%3Cf205f60902032151k198e9e67nf64752b9a25de72f%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Fwd: Error: TokenStreamException while reading	Grammer">gunjgupta at gmail.com
       </A><BR>
    <I>Tue Feb  3 21:51:32 PST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="032709.html">[antlr-interest] Error: TokenStreamException while reading	Grammer
</A></li>
        <LI>Next message: <A HREF="032710.html">[antlr-interest] Lexer/parser grammer for Antlrv2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32705">[ date ]</a>
              <a href="thread.html#32705">[ thread ]</a>
              <a href="subject.html#32705">[ subject ]</a>
              <a href="author.html#32705">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE> Hi Gavin,
Thanks for quick Response.
It was really helpful to me.
After trying with the antlr v3 , I am getting different error in console.

D:\Actuate\Samplelexer-parser\ConversionTool&gt;java org.antlr.Tool
D:\Actuate\VB\v
b_org.g
ANTLR Parser Generator  Version 3.1.1
error(100): D:\Actuate\VB\vb_org.g:1:1: syntax error: antlr:
D:\Actuate\VB\vb_or
g.g:1:1: unexpected token: class
warning(149): D:\Actuate\VB\vb_org.g:0:0: rewrite syntax or operator with no
out
put option; setting output=AST
error(150):  grammar file D:\Actuate\VB\vb_org.g has no rules
error(100): D:\Actuate\VB\vb_org.g:0:0: syntax error: assign.types:
&lt;AST&gt;:0:0: u
nexpected end of subtree
error(100): D:\Actuate\VB\vb_org.g:0:0: syntax error: define: &lt;AST&gt;:0:0:
unexpec
ted end of subtree
i am attching my .g file fro reference.
Any help would be appriciated.
regards,
Gunjan
  On Tue, Feb 3, 2009 at 1:23 AM, Gavin Lambert &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at mirality.co.nz</A>&gt;wrote:

&gt;<i> At 21:45 2/02/2009, Chal Chale apne Ghar wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> D:\Actuate\Samplelexer-parser\ConversionTool&gt;java antlr.Tool vb_org.txt
</I>&gt;&gt;<i> ANTLR Parser Generator   Version 2.7.5 (20050128)   1989-2005 jGuru.com
</I>&gt;&gt;<i> error: Token stream error reading grammar(s):
</I>&gt;&gt;<i> vb_org.txt:45:7: expecting ''', found 'p'
</I>&gt;&gt;<i> TokenStreamException: expecting ''', found 'p'
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> as seen, i am getting TokenStream Exception. But when i am using
</I>&gt;&gt;<i> AntlrWorks to check the Grammer syntax, it is showing correct to me.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You're running ANTLR v2 on the command line, but ANTLRWorks is for ANTLR
</I>&gt;<i> v3.  To run ANTLR v3, you need to use &quot;org.antlr.Tool&quot;, not &quot;antlr.Tool&quot;.
</I>&gt;<i>
</I>&gt;<i> Also, by convention grammar files have a .g extension.  This doesn't really
</I>&gt;<i> matter (ANTLR will still happily compile the file regardless of extension),
</I>&gt;<i> but it's a good idea to follow the convention, since that's what tools are
</I>&gt;<i> expecting.
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20090204/88468635/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20090204/88468635/attachment.html</A> 
-------------- next part --------------
class VisualBasicParser extends Parser;

options {
  buildAST=true;
  k=2;
  exportVocab=VisualBasic;
  defaultErrorHandler=false;
}

tokens {
PROGRAM;
CLASS;
CLASSNAME;
SUPERCLASSNAME;
DECLARE;
METHOD;
STATEMENT;
FUNCTIONAME;
ASSIGNMENT_STATEMENT;
TYPE_NAME;
IF_STATEMENT;
LOOP_STATEMENT;
SET_STATEMENT;
FOR_STATEMENT;
STATIC_STATEMENT;
EXIT_STATEMENT;
VAR_DECLARATION;
VARIABLE_NAME;
VARIABLE_NODE;
ARGUMENT_LIST;
VAR_ARGUMENT_LIST;
ARGUMENT;
VAR_ARGUMENT;
SELECT_STATEMENT;
VARIABLE;
EXPRESSION;
UNARY_MINUS;
OBJECT_NAME;
NEW_OBJECT_DECLN;


}

option_statement!
  : 'option' ( 'base' (NUMBER)?
                   | 'compare' ('text'|'binary'|'database')?
                   | 'explicit'
                   | 'private' 'module'
                   | 'internal' );

goto_statement!
  : 'goto' goto_label;

exit_statement
  : 'exit' ('do' | 'while' | 'try' | 'for' | 'function' | 'property' | 'select' | 'sub' )
  { #exit_statement = #([EXIT_STATEMENT, &quot;exit&quot;], #exit_statement); };

nl!   : ( options { greedy=true; } : NEWLINE)+;

beep_statement!
  : 'beep';

error_statement!
  : 'error' expression (COMMA expression )?;

error_number
  : NUMBER;

goto_label
  : IDENTIFIER | NUMBER;

on_error_statement!
  : 'on' 'error' ( 'goto' goto_label | 'resume' 'next' );

resume_statement!
  : 'resume' ( goto_label | 'next' );

load_statement!
  : 'load' object_name;

message_statement!
  : 'msgbox' expression;

unload_statement!
  : 'unload' object_name;

object_name
  : ( IDENTIFIER | 'me' | 'myclass' | 'mybase' | 'nothing' )
{ #object_name = #([OBJECT_NAME, &quot;object_name&quot;], #object_name); };
expression
  : complete_expression
 { #expression = #([EXPRESSION, &quot;expression&quot;], #expression); };

complete_expression
  : and_expression ( ( 'or'^ | 'orelse'^ | 'xor'^ ) and_expression )*;

and_expression
  : not_expression ( ( 'and'^ | 'andalso'^ ) not_expression )*;

not_expression
  : ('not'^ )? compare_expression;
  

compare_op
  : LT | LE | GT | GE | EQ | NE;

compare_expression
  : shift_expression ( (LT^ | LE^ | GT^ | GE^ | EQ^ | NE^) shift_expression
                           | 'is'^ object_name
                           | 'like' value)?
  | 'typeof' add_expression 'is' object_name;

shift_expression
  : concat_expression ( ( LSHIFT^ | RSHIFT^ ) concat_expression )*;

concat_expression
  : add_expression ( CONCAT^ add_expression )*;

add_expression
  : modulus_expression ( (PLUS^|MINUS^) modulus_expression )*;

modulus_expression
  : intdiv_expression ( 'mod'^ intdiv_expression )?;

intdiv_expression
  : mult_expression  ( INTDIVIDE^ mult_expression )*;

mult_expression
  : negate_expression ( (MULTIPLY^|DIVIDE^) negate_expression )*;

negate_expression
  : (options { greedy=true;} : MINUS^ {#MINUS.setType(UNARY_MINUS);} )? power_expression;

power_expression
  : value ( POWER^ value )?;

value   :
  | ( LPAREN complete_expression RPAREN ) =&gt; LPAREN^ complete_expression RPAREN!
  | ( 'new' ) =&gt; new_object_decln
  | ( variable ) =&gt; variable
  | ( function_call ) =&gt; function_call
  | literal;

idents : IDENTIFIER | 'text' | 'compare' | 'me' | 'new' | 'property';

identifier
  : ( ( idents )? SCOPE )* idents ( DOT idents )*;

new_object_decln
  : 'new' ('persistent')? variable
  { #new_object_decln = #([NEW_OBJECT_DECLN, &quot;new_object_decln&quot;], #new_object_decln); };

literal : 'true' | 'false' | 'me' | 'myclass' | 'mybase' | 'nothing' | NUMBER | STRING;

type_name
  : identifier
 { #type_name = #([TYPE_NAME, &quot;type&quot;], #type_name); };

dim_statement!
  : 'dim'! var_declaration ( COMMA! var_declaration )*;

var_declaration
  : ('withevents'!)? variable_name ( bound_argument_list )? ('as'! ('transient'|'new'|'volatile')? type_name (bound_argument_list)? )? (EQ! expression)?
 { #var_declaration = #([VAR_DECLARATION, &quot;var_decl&quot;], #var_declaration); };

variable_name : ( identifier | 'property' )
 { #variable_name = #([VARIABLE_NAME, &quot;var_name&quot;], #variable_name); };
 
bound_argument_list
  : LPAREN! ( options { greedy=true; } : argument_list )? RPAREN!
 { #bound_argument_list = #([ARGUMENT_LIST, &quot;var_name&quot;], #bound_argument_list); };

argument_list
  : argument ( COMMA! argument )*;

argument
  : ( ( identifier ASSIGN ) =&gt; identifier ASSIGN expression
    | expression ( 'to' complete_expression )? )
 { #argument = #([ARGUMENT, &quot;argument&quot;], #argument); };

var_bound_argument_list
  : LPAREN! ( options { greedy=true; } : var_argument_list )? RPAREN!
  { #var_bound_argument_list = #([VAR_ARGUMENT_LIST, &quot;var_name&quot;], #var_bound_argument_list); };

var_argument_list
  : var_argument ( COMMA! var_argument )*;

var_argument
  : ( identifier ASSIGN ) =&gt; identifier ASSIGN expression
  | expression ( 'to' expression )?
  { #var_argument = #([VAR_ARGUMENT, &quot;var_argument&quot;], #var_argument); };

const_statement!
  : 'const' var_declaration ( COMMA var_declaration )*;

global_statement!
  : 'global' var_declaration ( COMMA var_declaration )*;

static_statement
  : 'static'! var_declaration ( COMMA var_declaration )*
  { #static_statement = #([STATIC_STATEMENT, &quot;static&quot;], #static_statement); };

reset_statement!
  : 'reset';

declaration_statement
  : dim_statement
  | static_statement
  | const_statement
  | global_statement
  | redim_statement;

io_statement
  : reset_statement
  | close_statement
  | kill_statement;

kill_statement!
  : 'kill' expression;

close_statement!
  : 'close' expression;

label_statement!
  : IDENTIFIER COLON;

erase_statement!
  : 'erase' expression;

statement
  : ( ( 'if' )                     =&gt; if_statement
  | ( 'select' )                   =&gt; select_statement
  | ( 'do' | 'while' )             =&gt; loop_statement
  | ( 'for' )                      =&gt; for_statement
  | ( 'dim' | 'const' | 'static' ) =&gt; declaration_statement
  | ( 'option' )                   =&gt; option_statement
  | ( 'load' )                     =&gt; load_statement
  | ( 'unload' )                   =&gt; unload_statement
  | ( 'error')                     =&gt; error_statement
  | ( 'exit' )                     =&gt; exit_statement
  | ( 'goto' )                     =&gt; goto_statement
  | ( 'on' 'error' )               =&gt; on_error_statement
  | ( 'resume' )                   =&gt; resume_statement
  | ( 'reset' | 'kill' | 'close' ) =&gt; io_statement
  | ( 'set' )                      =&gt; set_statement
  | ( 'msgbox' )                   =&gt; message_statement
  | ( 'erase' )                    =&gt; erase_statement  
  | ( label_statement )            =&gt; label_statement
  | assignment_statement );

if_statement
  : 'if'! expression
     ( ( ('then')? nl ) =&gt; ('then'!)? nl ( statement nl )* ( 'elseif' expression ('then')? nl ( statement nl )* )* ('else'nl (statement nl)* )? 'end' 'if'!
     | 'then' statement ( options { greedy=true; } : ('else') =&gt; 'else' statement )?
     )
 { #if_statement = #([IF_STATEMENT, &quot;if&quot;], #if_statement); };

loop_statement
  : ( 'do' ('while' | 'until') expression nl (statement nl)* 'loop'!
  | 'do' nl (statement nl)* 'loop' ( ('while'|'until') expression )?
  | 'while' expression nl (statement nl)* 'end' 'while'! )
 { #loop_statement = #([LOOP_STATEMENT, &quot;loop&quot;], #loop_statement); };

for_statement
  : ( 'for'! identifier EQ expression 'to' expression ( 'step' expression )? nl (statement nl)* 'next' ( identifier )?
  | 'for' 'each' identifier 'in' identifier nl (statement nl)* 'next' ( identifier )? )
 { #for_statement = #([FOR_STATEMENT, &quot;for&quot;], #for_statement); };

select_statement
  : 'select'! ('case'!)? expression nl
          ( options { greedy=true;} : 'case' case_clause_list nl (statement nl)* )*
          ('case' 'else' nl (statement nl)* )? 'end' 'select'
 { #select_statement = #([SELECT_STATEMENT, &quot;select&quot;], #select_statement); };

case_clause_list
  : case_clause (COMMA case_clause )*;


case_clause
  : ( ( ('is')? compare_op ) =&gt; ('is')? compare_op expression 
    | expression ( 'to' expression )? 
    );
    

redim_statement!
  : 'redim' ('preserve')? var_declaration ( COMMA var_declaration )*;

function_call
  : identifier bound_argument_list;

assign_op
  : EQ | POWER_EQ | LSHIFT_EQ | RSHIFT_EQ | MULTIPLY_EQ | DIVIDE_EQ | ADD_EQ | MINUS_EQ | INTDIVIDE_EQ | CONCAT_EQ;

assign_variable
  : ( assign_variable_node ( (SCOPE!|DOT!) assign_variable_node )* )
 { #assign_variable = #([VARIABLE, &quot;variable&quot;], #assign_variable); };

assign_variable_node
  : ( idents ( options { greedy=true; } : var_bound_argument_list)? )
  {#assign_variable_node = #([VARIABLE_NODE, &quot;assign_variable_node&quot;], #assign_variable_node);};

variable
  : ( variable_node ( (SCOPE!|DOT!) variable_node )* )
  {#variable = #([VARIABLE, &quot;variable&quot;], #variable);};

variable_node
  : idents ( options { greedy=true; } : bound_argument_list)?
  {#variable_node = #([VARIABLE_NODE, &quot;variable_node&quot;], #variable_node);};

set_statement
  : 'set'! assign_variable assign_op expression
 { #set_statement = #([SET_STATEMENT, &quot;set&quot;], #set_statement); };

assignment_statement
  : assign_variable ( assign_op expression )?
 { #assignment_statement = #([ASSIGNMENT_STATEMENT, &quot;assignment&quot;], #assignment_statement); };

function_name
  : ( identifier | 'new' )
 { #function_name = #([FUNCTIONAME, &quot;name&quot;], #function_name); };

return_type
  : identifier;

bound_var_decln_list
  : LPAREN ( var_decln_list )? RPAREN;

var_decln_list
  : var_declaration ( COMMA var_declaration )*;

function_definition
  : ( (modifier!)*
    ( 'function'! function_name bound_var_decln_list! 'as'! return_type! nl (statement nl)* 'end'! 'function'!
    | 'sub'! function_name bound_var_decln_list! nl (statement nl)* 'end'! 'sub'!
    ) ) { #function_definition = #([METHOD, &quot;method&quot;], #function_definition); };

modifier
  : 'shadows' | 'shared' | 'mustinherit' | 'notinheritable'
  | 'overridable' | 'notoverridable' | 'mustoverride' | 'overrides'
  | 'overloads' | 'default' | 'readonly' | 'writeonly' | 'global'
  | access;

access  : 'public'
  | 'private'
  | 'friend'
  | 'protected';

class_name
  : identifier
 { #class_name = #([CLASSNAME, &quot;name&quot;], #class_name); };

subclass_name
  : identifier
 { #subclass_name = #([SUPERCLASSNAME, &quot;super class&quot;], #subclass_name); };

class_definition
  : (modifier!)*
    'class'! class_name ( 'subclass'! 'of'! subclass_name )? nl class_members 'end'! 'class'!
 { #class_definition = #([CLASS, &quot;class&quot;], #class_definition); };

class_members
  : ( class_member nl )*;

class_member
  : ( (modifier)* 'class' ) =&gt; class_definition
  | ( (modifier)* ( 'function' | 'sub') ) =&gt; function_definition
  | member_var_definition;

member_var_definition!
  : (modifier)* declaration_statement;

declare_definition!
  : (modifier)* 'declare' nl declare_members 'end' 'declare';
// { #declare_definition = #([DECLARE, &quot;declare&quot;], #declare_definition); };

declare_members
  : ( declare_member nl )*;

declare_member
  : declaration_statement
  | option_statement;

program : (nl)? ( program_member (nl)? )* EOF!
 { #program = #([PROGRAM, &quot;program&quot;], #program); };

program_member
  : ( (modifier)* 'class' ) =&gt; class_definition
  | ( (modifier)* ( 'function' | 'sub' ) ) =&gt; function_definition
  | declare_definition;

class VisualBasicLexer extends Lexer;

options {
  exportVocab=VisualBasic;
  caseSensitive=false;
  caseSensitiveLiterals=false;
  testLiterals=false;
  defaultErrorHandler=false;
  charVocabulary='\u0003'..'\uFFFE';
  k=4;
}

SINGLE_LINE_COMMENT
  : ('\''|'#') (~('\r'|'\n'))* { $setType(Token.SKIP); };

REMARK_COMMENT : 'r' 'e' 'm' (~('a' ..'z'|'0'..'9'|'_'|'$')) (~('\r'|'\n'))* { $setType(Token.SKIP); };

NEWLINE : ( ('\r' ('\n')? | '\n') ( '+' { $setType(Token.SKIP); } )? ) { newline(); };

WHITE_SPACE
  : ( (' ' | '\t')+ | '_' (' '|'\t')* NEWLINE ) { $setType(Token.SKIP); };

STRING  : '&quot;' ( (~('&quot;')) | '&quot;' '&quot;' )* '&quot;';

protected INTEGER : ('0' .. '9')+;

NUMBER : ( INTEGER '.' ) =&gt; INTEGER '.' INTEGER ( 'e' (PLUS|MINUS)? INTEGER)?
       | ( '.' INTEGER ) =&gt; '.' INTEGER ( 'e' (PLUS|MINUS)? INTEGER)?
       | ( INTEGER ) =&gt; INTEGER ( 'e' (PLUS|MINUS)? INTEGER)?
       | '.' { $setType(DOT); };

IDENTIFIER options { testLiterals=true; } : ('a'..'z') ('a'..'z'|'0'..'9'|'_')* ('$')?;

EQ  : '=';

LT  : '&lt;';

LE  : '&lt;=';

GT  : '&gt;';

GE  : '&gt;=';

NE  : '&lt;&gt;';

LSHIFT  : '&lt;&lt;';

RSHIFT  : '&gt;&gt;';

CONCAT  : '&amp;';

PLUS  : '+';

MINUS : '-';

MULTIPLY
  : '*';

DIVIDE  : '/';

INTDIVIDE
  : '\\';

POWER : '^';

LPAREN  : '(';

RPAREN  : ')';

COMMA   : ',';

ASSIGN  : ':=';

SCOPE : '::';

POWER_EQ
  : '^=';

MULTIPLY_EQ
  : '*=';

DIVIDE_EQ
  : '/=';

INTDIVIDE_EQ
  : '\\=';

ADD_EQ  : '+=';

MINUS_EQ
  : '-=';

CONCAT_EQ
  : '&amp;=';

LSHIFT_EQ
  : '&lt;&lt;=';

RSHIFT_EQ
  : '&gt;&gt;=';

COLON : ':';

DOT	:
	;

</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="032709.html">[antlr-interest] Error: TokenStreamException while reading	Grammer
</A></li>
	<LI>Next message: <A HREF="032710.html">[antlr-interest] Lexer/parser grammer for Antlrv2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32705">[ date ]</a>
              <a href="thread.html#32705">[ thread ]</a>
              <a href="subject.html#32705">[ subject ]</a>
              <a href="author.html#32705">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
