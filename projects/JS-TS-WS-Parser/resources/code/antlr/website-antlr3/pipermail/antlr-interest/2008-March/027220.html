<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] postmortem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3C638378.34558.qm%40web55907.mail.re3.yahoo.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027217.html">
   <LINK REL="Next"  HREF="027223.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] postmortem</H1>
    <B>Loring Craymer</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20postmortem&In-Reply-To=%3C638378.34558.qm%40web55907.mail.re3.yahoo.com%3E"
       TITLE="[antlr-interest] postmortem">lgcraymer at yahoo.com
       </A><BR>
    <I>Thu Mar 13 13:05:47 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027217.html">[antlr-interest] &quot;flat&quot; trees
</A></li>
        <LI>Next message: <A HREF="027223.html">[antlr-interest] postmortem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27220">[ date ]</a>
              <a href="thread.html#27220">[ thread ]</a>
              <a href="subject.html#27220">[ subject ]</a>
              <a href="author.html#27220">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Actually, getting ANTLR to generate real parse trees with unique labels for the non-terminals (rule tokens) is fairly easy to do--I did that for ANTLR 2 with about 10 liines of code.  ANTLR 3 is structured a little bit differently than ANTLR 2--it might be doable in 5.  You need to create a token type for every rule name--I used a RULE_ prefix--and then just add the appropriate token as the root of the subtree produced by a rule.

I did not do this because I thought I needed parse trees for routine tasks, but rather to experiment with the idea of &quot;reversible&quot; translation--is there a way to translate language B into language A with minimal effort given a translator from A to B?  Parse trees seemed to provide a useful output form for that purpose since one can just output token text given a parse tree to regenerate the source.  One of these days, I will revisit that idea.

For practical translation, though, parse trees are not particularly helpful--they capture preconceptions about the input language and contribute little to the analysis phase(s) of a translator.  Failure to design a tree structure that helps in performing analysis seems invariably to lead to &quot;action-packed&quot; grammars that become less and less maintainable as they are asked to do more and more.  Eventually, you get to the point where the grammar itself is virtually unmaintainable because it is hidden by a vast amount of target language code.

--Loring


----- Original Message ----
&gt;<i> From: Thomas Brandon &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">tbrandonau at gmail.com</A>&gt;
</I>&gt;<i> To: Andy Tripp &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr at jazillian.com</A>&gt;
</I>&gt;<i> Cc: antlr-interest &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at antlr.org</A>&gt;
</I>&gt;<i> Sent: Thursday, March 13, 2008 1:20:35 AM
</I>&gt;<i> Subject: Re: [antlr-interest] postmortem
</I>&gt;<i> 
</I>&gt;<i> On Thu, Mar 13, 2008 at 7:58 AM, Andy Tripp  wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  Jim Idle wrote:
</I>&gt;<i> &gt; &gt; I think you miss the point. We can't 'know' that they did or didn't want a
</I>&gt;<i> &gt; &gt; flat tree. Who is this someone that you are designating tasks like this to?
</I>&gt;<i> &gt; Well, we can't &quot;know' anything about what anyone wants, in general. The best
</I>&gt;<i> &gt;  we can do is make a best guess. And I think the best guess is that most
</I>&gt;<i> &gt; ANTLR users want a non-flat AST.
</I>&gt;<i> Yes, most ANTLR users want a non-flat tree. But most (if not all) of
</I>&gt;<i> these users do not want a parse tree. The parse trees generated by
</I>&gt;<i> ANTLR are not just like ASTs and cannot be used as such. Parse trees
</I>&gt;<i> consist of standard AST nodes for all the actual language nodes and
</I>&gt;<i> special parse tree nodes (of type ParseTree extending CommonTree) for
</I>&gt;<i> the rule references. These parse tree nodes have a token type of 0.
</I>&gt;<i> Thus you cannot use a tree parser against a parse tree and manually
</I>&gt;<i> walking the tree would be complicated. Parse trees (as generated by
</I>&gt;<i> ANTLR) are more of a debugging aid than a type of AST that
</I>&gt;<i> automatically adds structure.
</I>&gt;<i> 
</I>&gt;<i> Perhaps you could add an output=CST (Concrete Syntax Tree, aka parse
</I>&gt;<i> tree) option. But how would this work?
</I>&gt;<i> Given a rule like:
</I>&gt;<i> myop: modifier MYOP contents;
</I>&gt;<i> what should our proposed CST constructor generate? What token types
</I>&gt;<i> should rule references automatically generate? You could generate a
</I>&gt;<i> token type named after the rule but producing ^(MYOP attributes MYOP
</I>&gt;<i> contents) where the first MYOP is our auto-generated one mapping to no
</I>&gt;<i> part of the input and the second is an actual token seems bizarre and
</I>&gt;<i> likely to cause troubles. Maybe we could do ^(RULE_MYOP modifier MYOP
</I>&gt;<i> contents) but do any of the users who don't want flat ASTs want that?
</I>&gt;<i> And do they also want:
</I>&gt;<i> modifier: PUBLIC | PROTECTED;
</I>&gt;<i> to generate ^(RULE_MODIFIER PUBLIC)?
</I>&gt;<i> I'd imagine what they really want is not a CST but the AST ^(MYOP
</I>&gt;<i> modifier content). With modifier having no dummy parent and contents
</I>&gt;<i> having one.
</I>&gt;<i> OK, so we don't want output=CST we want to auto-generate ASTs. But
</I>&gt;<i> how? Given the above case we might think we could have a rule that if
</I>&gt;<i> there's one token reference and other rule references we make the
</I>&gt;<i> token the root. That's easy but what if we've got:
</I>&gt;<i> method: keywords ID args catch;
</I>&gt;<i> we probably don't want ^(ID keywords args catch) as that's very hard
</I>&gt;<i> for our tree walker to distinguish from:
</I>&gt;<i> field: keywords ID init;
</I>&gt;<i> which makes ^(ID keywords init).
</I>&gt;<i> And what do we do with:
</I>&gt;<i> method: keywords ID LPAREN args RPAREN CATCH catch;
</I>&gt;<i> Here I'd probably want the AST ^(METHOD_CALL ID keywords args catch)
</I>&gt;<i> but how can a tool know that.
</I>&gt;<i> OK, so we want to have some default rules and some syntax to disable
</I>&gt;<i> automatic generation. But how often is this auto generation actually
</I>&gt;<i> going to be used? I think you're very often going to want to disable
</I>&gt;<i> any such automatic generation. OK, so any use of AST rebuild operators
</I>&gt;<i> disables the automatic generation. But what about your &quot;modifiers:
</I>&gt;<i> PUBLIC | PROTECTED;&quot; rule? Adding &quot;options { autoAST=false; }&quot; to all
</I>&gt;<i> such rules is going to be pretty annoying and &quot;modifiers!: PUBLIC |
</I>&gt;<i> PROTECTED;&quot; isn't going to be very understandable for new users.
</I>&gt;<i> 
</I>&gt;<i> I think if you spend a bit of time actually thinking about how you'd
</I>&gt;<i> manage to implement what you want you'll see it really doesn't work.
</I>&gt;<i> 
</I>&gt;<i> Tom.
</I>&gt;<i> 
</I>



      ____________________________________________________________________________________
Never miss a thing.  Make Yahoo your home page. 
<A HREF="http://www.yahoo.com/r/hs">http://www.yahoo.com/r/hs</A>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20080313/8e3405e0/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20080313/8e3405e0/attachment.html</A> 
</PRE>























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027217.html">[antlr-interest] &quot;flat&quot; trees
</A></li>
	<LI>Next message: <A HREF="027223.html">[antlr-interest] postmortem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27220">[ date ]</a>
              <a href="thread.html#27220">[ thread ]</a>
              <a href="subject.html#27220">[ subject ]</a>
              <a href="author.html#27220">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
