<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] philosophy about translation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=45496FB4.2070309%40jazillian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018210.html">
   <LINK REL="Next"  HREF="018225.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] philosophy about translation</H1>
    <B>Micheal J</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20philosophy%20about%20translation&In-Reply-To=45496FB4.2070309%40jazillian.com"
       TITLE="[antlr-interest] philosophy about translation">open.zone at virgin.net
       </A><BR>
    <I>Wed Nov  1 22:53:12 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018210.html">[antlr-interest] philosophy about translation
</A></li>
        <LI>Next message: <A HREF="018225.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18217">[ date ]</a>
              <a href="thread.html#18217">[ thread ]</a>
              <a href="subject.html#18217">[ subject ]</a>
              <a href="author.html#18217">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Andy,

&gt;<i> &gt;&gt;I don't think I'm changing my position. I still disagree with that
</I>&gt;<i> &gt;&gt;quote. I think almost all the great tools
</I>&gt;<i> &gt;&gt;are the ones that the majority of programmers to &quot;get&quot;. In 
</I>&gt;<i> &gt;&gt;fact, that's 
</I>&gt;<i> &gt;&gt;part of what makes them great.
</I>
&gt;<i> &gt;I don't think &quot;popular&quot; and &quot;great&quot; (when applied to tools) are 
</I>&gt;<i> &gt;synonyms.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> I don't either, that's why I said &quot;in part&quot;.
</I>
I should have been clearer: Popularity isn't a measure of greatness.

&gt;<i> &gt;&gt;I disagree. I view Java as being &quot;great&quot; and C++ not being
</I>&gt;<i> &gt;&gt;&quot;great&quot;.
</I>
&gt;<i> &gt;If productivity (not power) is the priority, Java/C# is 
</I>&gt;<i> likely to be a 
</I>&gt;<i> &gt;better tool than C++ for those problems to which Java is applicable.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Otherwise C++ (or some other tool) is better.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> And Java is *always* the priority.
</I>
It's pointless to argue over value judgements so, I won't. 

Incidentally, this statement about Java...

&gt;<i> The only way you'd ever 
</I>&gt;<i> fall back to 
</I>&gt;<i> C++ is if there really
</I>&gt;<i> wasn't enough power in Java. And I've only heard of one or 
</I>&gt;<i> two cases of 
</I>&gt;<i> that.
</I>
...contradicts this later statement about Java.

&gt;<i> &gt;&gt;and I think the
</I>&gt;<i> &gt;&gt;vast majority 
</I>&gt;<i> &gt;&gt;of programmers who know both
</I>&gt;<i> &gt;&gt;agree with me.
</I>
&gt;<i> &gt;I make no such claim (I have no idea what the vast majority of 
</I>&gt;<i> &gt;competent Java/C++ programmers think).
</I>
&gt;<i> Then you should get out more. Talk to 10 co-workers about 
</I>&gt;<i> Java vs. C++, 
</I>&gt;<i> or go to a conference.
</I>&gt;<i> I'd say that less than 5% of those who've actually used both Java and 
</I>&gt;<i> C++ prefer C++.
</I>&gt;<i> That's from my experience of talking to perhaps a few hundred 
</I>&gt;<i> developers 
</I>&gt;<i> about it.
</I>
A few hundred (even a few thousand) developers doesn't equate to the &quot;vast
majority&quot;.

C++ and automatic memory management aren't mutually exclusive. GC systems
for C++ predate Java/C#.
My point?, productivity and C++ aren't mutually exclusive either.

&gt;<i> &gt;&gt;Probably the main benefit is that it's easy to use for
</I>&gt;<i> &gt;&gt;&quot;average programmers&quot;. That's also why
</I>&gt;<i> &gt;&gt;ANTLR is better than the competition - because it's easier to use.
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Not to my mind. Coco/R, JavaCC, SLK are equally easy to use (if one 
</I>&gt;<i> &gt;takes the time to learn them).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;ANTLR's &quot;popularity&quot; is due to a lot if things including: Ter's 
</I>&gt;<i> &gt;predicated
</I>&gt;<i> &gt;LL(k)/LL(*) technology, 
</I>&gt;<i> &gt;
</I>&gt;<i> LL(*) is brand new to V3, so that has nothing to do with it. 
</I>
I disagree. V3 is the reason many ANTLR'ers aren't using some other tool.
V2's performance (and a few missing features) eventually became an issue.
But I digress...

&gt;<i> And some of 
</I>&gt;<i> the others are LL(k), so
</I>&gt;<i> I don't think that's it, either. I'm using Javacc now, and 
</I>&gt;<i> it's driving 
</I>&gt;<i> me nuts, just as lex/yacc
</I>&gt;<i> and similar tools did.
</I>
Once I learned the syntax/semanics and prevailing idioms, javacc was easy
enough.

&gt;<i> &gt;The &quot;vast majority&quot; don't understand the value/utility of 
</I>&gt;<i> MI, mixins, 
</I>&gt;<i> &gt;or the &quot;why?&quot; of AOD  etc.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> That's a circular argument. If someone &quot;understands the value&quot; of MI, 
</I>&gt;<i> etc. then of course they want it.
</I>
It isn't a circular argument. It is perfectly possible to &quot;understand the
value&quot; of a feature and yet not want it. I &quot;understand the value&quot; of MI for
instance and I'm not calling for [standard] Java to include it bacause it
make makes dynamic class loading far more difficult to implement. I'd rather
not be introduced to another slew of Java bugs.

Extended variants of Java such as MIJava (a preprocessor) and MultiJava (a
full compiler - uses ANTLR) etc are available for when I need the extra
power in a project.

&gt;<i> It's that &quot;vast majority&quot; who know what they are and don't want them 
</I>&gt;<i> that matters.
</I>
I doubt that the vast majority truly understand MI et al.

&gt;<i> &gt;In the context of this thread, &quot;compiling by hand&quot; is not a tool.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> The point is that just because one approach (whether tool or not) is 
</I>&gt;<i> less powerful doesn't
</I>&gt;<i> mean that it's worse.
</I>
It means that it's less powerful. That can mean &quot;useless&quot; if one needs the
missing &quot;power features&quot;.

&gt;<i> &gt;How would you change in ANTLR to make it easier?
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Short answer: hide all the details from me. Make it so that I have no 
</I>&gt;<i> idea that
</I>&gt;<i> there is code being generated to do lexing and parsing. Let 
</I>&gt;<i> me just give 
</I>&gt;<i> it a C grammar
</I>&gt;<i> and a Java grammar, and then dive in and start writing 
</I>&gt;<i> translation logic 
</I>&gt;<i> without any
</I>&gt;<i> generated code or even ASTs in sight. How to do that is left as an 
</I>&gt;<i> exercise for the reader.
</I>
Interesting idea. Don't know if it is possible but, interesting nonetheless.
;-)

&gt;<i> &gt;Quite often just getting &quot;something that works&quot; is all that is 
</I>&gt;<i> &gt;required. Getting the best output from a compiler requires 
</I>&gt;<i> knowing more 
</I>&gt;<i> &gt;about what goes on under the hood.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Yea, I know. You can do a better job at garbage collection 
</I>&gt;<i> than java's 
</I>&gt;<i> gc. You can write
</I>&gt;<i> better byte code than javac because you've studied javac and bytecode.
</I>&gt;<i> 
</I>&gt;<i> The Java JIT guys say the first rule of performance 
</I>&gt;<i> optimization is to 
</I>&gt;<i> STOP doing whatever
</I>&gt;<i> it is you're doing that you think is producing better 
</I>&gt;<i> bytecode. And what 
</I>&gt;<i> did Terence find
</I>&gt;<i> out about performance when he tried generating his own bytecode?
</I>
Regardless of what Ter experienced while generating DFAs as bytecode, what
the Java JIT guys may have said or indeed whether I can beat javac's GC
strategy, what I actually said above remains a fact.

&gt;<i> &gt;&gt;But required knowledge of the tool's internals limits the &quot;average&quot;
</I>&gt;<i> &gt;&gt;user's productivity.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;A user is already limited if he/she don't understand how a 
</I>&gt;<i> tool works. 
</I>&gt;<i> &gt;Whether or not that matters depends on what they are trying to 
</I>&gt;<i> &gt;accomplish.
</I>&gt;<i> &gt;
</I>&gt;<i> Yes, we lower 99% of the programming community are writing 
</I>&gt;<i> sub-par code 
</I>&gt;<i> because we don't
</I>&gt;<i> understand how our compilers work. ;)
</I>
Yes we are. ;-)

&gt;<i> &gt;&gt;&gt;I use Java/C# for the productivity benefits. If performance,
</I>&gt;<i> &gt;&gt;&gt;flexibility or expressivity was *more* important in a particular 
</I>&gt;<i> &gt;&gt;&gt;project, there are better tools than Java/C# (e.g. C++, Occaml).
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;Right, so you're just like the rest of us. You've chosen to
</I>&gt;<i> &gt;&gt;limit your 
</I>&gt;<i> &gt;&gt;own &quot;power&quot; by using Java rather
</I>&gt;<i> &gt;&gt;than, say, assembly. So I'm sticking with my claim that
</I>&gt;<i> &gt;&gt;&quot;I think a tool can be great while being simple enough for most 
</I>&gt;<i> &gt;&gt;programmers (e.g. Java).&quot;
</I>&gt;<i> &gt;&gt;and not buying your &quot;Not without limiting it's power&quot; reply.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;It isn't &quot;my&quot; reply. The fact is:
</I>&gt;<i> &gt;- Java/C# is less powerful than assembler, C or C++ (you 
</I>&gt;<i> need them to 
</I>&gt;<i> &gt;build java/c# in the first place).
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> If that's your definition of &quot;power&quot;, I don't see how it relates to 
</I>&gt;<i> anything.
</I>
I defined &quot;power&quot; in terms of performance, flexibility and expressivity
(it's still visible above).

Performance: Given equivalent programs written in Java and asm/C/C++, the
Java version would be slower (or it is always possible to optimize the
asm/C/C++ version so it outperforms the Java version).

Flexibility: Anything program that can be written in Java can be written in
asm/C/C++ (although one might not want to). The reverse is not true.

Expressivity: Java is less expressive than C++ (even without macros). With
[really!] clever use of macros, the same can be said of C and perhaps asm
too.

&gt;<i> &gt;- For some problems, Java/C# is more productive than assembler, C or 
</I>&gt;<i> &gt;C++.
</I>&gt;<i> &gt;  
</I>&gt;<i> I'd say &quot;for almost all problems&quot; but OK.
</I>
Depends on what sort of programming problems you have to solve. A
Windows/Linux device driver developer wouldn't use Java for instance.

&gt;<i> &gt;I disagree. He is working with code generated by ANTLR. He 
</I>&gt;<i> isn't using 
</I>&gt;<i> &gt;ANTLR.
</I>&gt;<i> &gt;  
</I>&gt;<i> Ah, come on. When someone is using a lexer built using ANTLR, 
</I>&gt;<i> you won't 
</I>&gt;<i> consider that to be
</I>&gt;<i> &quot;using ANTLR?&quot; As in &quot;He's using ANTLR without ever seeing the input 
</I>&gt;<i> grammar&quot;. That's
</I>&gt;<i> like saying I'm not &quot;using javac&quot;, I'm just using the 
</I>&gt;<i> bytecode that it 
</I>&gt;<i> generates.
</I>
Which is precisely what many ANTLR users do when they download the binary
distribution. They aren't using javac (some probably don't even know what
javac is). They are just &quot;using bytecode generated by javac&quot;.

&gt;<i> &gt;If he used ANTLR directly (like you did). He can do more. Your DSL 
</I>&gt;<i> &gt;(like
</I>&gt;<i> &gt;Java/C#) favours productivity over power/flexibility.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> The whole point of building the DSL is because I think if he 
</I>&gt;<i> (or I) used 
</I>&gt;<i> ANTLR directly, we'd actually
</I>&gt;<i> &quot;do less&quot;, not &quot;do more&quot;. We'd get less accomplished because we'd be 
</I>&gt;<i> struggling with AST
</I>&gt;<i> shapes in our heads. The DSL lets us tackle the same problem 
</I>&gt;<i> at a higher 
</I>&gt;<i> level of abstraction.
</I>
As I said, it is a more productive tool (for what you want to do) than using
ANTLR directly.

On the other hand, using ANTLR directly affords more &quot;power&quot;.

&gt;<i> &gt;ANTLR *is* a compiler.
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Right, and as such, I believe it can do what &quot;traditional&quot; 
</I>&gt;<i> compilers do: 
</I>&gt;<i> hide all the underlying
</I>&gt;<i> stuff from the users.
</I>
It does. That's why your guy can use the code it generated without knowing
or caring about ANTLR.

&gt;<i> &gt;&gt;Compiler designers take it as a given that users need only know the
</I>&gt;<i> &gt;&gt;syntax/semantics of the input
</I>&gt;<i> &gt;&gt;language. If Ter took it as a given that ANTLR4 users need 
</I>&gt;<i> &gt;&gt;only know the 
</I>&gt;<i> &gt;&gt;syntax/semantics
</I>&gt;<i> &gt;&gt;of the input language, he'd end up with a very different tool.
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;When using ANTLR, that is all one needs to know.
</I>&gt;<i> &gt;
</I>&gt;<i> No. To use ANTLR, you not only need to know the input 
</I>&gt;<i> language (say, C) 
</I>&gt;<i> syntax&amp;symantics, you
</I>&gt;<i> also need to know:
</I>&gt;<i> * The ANTLR syntax&amp;symantics
</I>&gt;<i> * How to hook in actions: where do they make sense? What language are 
</I>&gt;<i> they in?
</I>
ANTLR's input language is a customized variant of EBNF that can include
embedded &quot;action&quot; code written in one of a few general programming
languages. It is used to describe the syntactic structure of other languages
e.g. your ANTLR grammar for the C language.

Learning where actions can be &quot;hooked in&quot; is part of learning about the
syntax/semantics of ANTLR's input language.

&gt;<i> * You often need to know details about the code that's generated to 
</I>&gt;<i> resolve ambiguities
</I>
A test suite mitigates against this. I agree that approximate lookahead
generates spurious warnings.

&gt;<i> * You need to know how the grammar maps to an AST structure. It's not 
</I>&gt;<i> enough to have a mental
</I>&gt;<i>    picture of the input grammar, you need to be able to form a mental 
</I>&gt;<i> picture of the AST each time
</I>&gt;<i>    you see a chunk of code.
</I>
ASTs are optional. You don't use them for instance. In any case, the user
designs an AST not ANTLR. ANTLR simply provides a language for specifying
AST construction.

&gt;<i> &gt;A compiler designer can't determine the best code to 
</I>&gt;<i> generate for every 
</I>&gt;<i> &gt;possible situation in advance.
</I>&gt;<i> &gt;
</I>&gt;<i> He doesn't need to always generate the best code. It's good 
</I>&gt;<i> enough that 
</I>&gt;<i> he just generally do
</I>&gt;<i> better than humans do.
</I>
For some users/projects, that is enough. Not for everyone or every project.

&gt;<i> &gt;This feature makes the tool more useful - for
</I>&gt;<i> &gt;those who care to acquire the knowledge required to use it 
</I>&gt;<i> effectively. 
</I>&gt;<i> &gt;It empowers knowledgeable users to tailor the output for any given 
</I>&gt;<i> &gt;situation.
</I>&gt;<i> &gt;
</I>&gt;<i> And yet, there is no equivalent in Java - no bytecode 
</I>&gt;<i> tweaking. And no 
</I>&gt;<i> one seems to mind.
</I>
Actually, there is. Not just with javac. Javaassist, BCEL etc do just that.

&gt;<i> And there is an equivalent in C/C++ - embedded asm code. That was 
</I>&gt;<i> popular 20 years ago,
</I>&gt;<i> but today's programmers realize that the assembler is 
</I>&gt;<i> probably better at 
</I>&gt;<i> producing good code,
</I>&gt;<i> and they don't need every last 1% of performance anyway.
</I>
Not all the time. When they do, it is reassuring to know that gcc/vc++ still
support it...  ;-)


Micheal


-----------------------
The best way to contact me is via the list/forum. My time is very limited.

</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018210.html">[antlr-interest] philosophy about translation
</A></li>
	<LI>Next message: <A HREF="018225.html">[antlr-interest] philosophy about translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18217">[ date ]</a>
              <a href="thread.html#18217">[ thread ]</a>
              <a href="subject.html#18217">[ subject ]</a>
              <a href="author.html#18217">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
