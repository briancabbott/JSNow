<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Newbie Question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Newbie%20Question&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000091.html">
   <LINK REL="Next"  HREF="000093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Newbie Question</H1>
    <B>mzukowski at bco.com</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Newbie%20Question&In-Reply-To="
       TITLE="[antlr-interest] Newbie Question">mzukowski at bco.com
       </A><BR>
    <I>Wed Oct 10 06:49:31 PDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000091.html">[antlr-interest] Latest development snapshot
</A></li>
        <LI>Next message: <A HREF="000093.html">[antlr-interest] Newbie re: memory management on parse fail (C++)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Tiller, Michael (M.M.) [mailto:<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">mtiller at ford.com</A>]
</I>&gt;<i> Sent: Friday, October 05, 2001 12:14 PM
</I>&gt;<i> To: '<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest at yahoogroups.com</A>'
</I>&gt;<i> Subject: [antlr-interest] Newbie Question
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I'm still trying to understand how to make the best use of 
</I>&gt;<i> ANTLR.  I'd like to describe a simple scenario (that I am 
</I>&gt;<i> currently faced with) and ask a few questions about it...
</I>&gt;<i>  
</I>&gt;<i> As a side project, I would like to build a tool that will 
</I>&gt;<i> check some source code against some style guidelines that we 
</I>&gt;<i> have internally.  Toward this end, I have developed a lexer 
</I>&gt;<i> and parser already that can parse the language that I am 
</I>&gt;<i> interested in.  So far, so good.
</I>
Does your style guide include whitespace, formatting and comment structure?
These are relatively hard problems.
  
&gt;<i> At this point, it seems to me that I have the pieces for 
</I>&gt;<i> turning the characters into tokens and then tokens into 
</I>&gt;<i> productions.  Now what I want to do is walk the tree that 
</I>&gt;<i> gets generated by the parser.
</I>&gt;<i>  
</I>&gt;<i> It seems ugly to actually add my style checking guidelines to 
</I>&gt;<i> the grammar because I might want to use the grammar at some 
</I>&gt;<i> point for some other applications.  My understanding is that 
</I>&gt;<i> I should probably write a tree walker that is specific to my 
</I>&gt;<i> current application and leave the grammar alone.  This 
</I>&gt;<i> protects for future applications.  Is my understanding 
</I>&gt;<i> correct in this regard?
</I>
Yes.  
  
&gt;<i> So, I am currently (perhaps misguidedly) looking at building 
</I>&gt;<i> a tree walker.  But this brings up what seems like an 
</I>&gt;<i> important issue with the grammar.  What kinds of tree 
</I>&gt;<i> construction markup should I do to the grammar to get 
</I>&gt;<i> something that will be easy to walk?  In most of the markups 
</I>&gt;<i> of grammars, I see lines like:
</I>&gt;<i>  
</I>&gt;<i> declaration
</I>&gt;<i>   : type ^IDENT SEMI!
</I>&gt;<i>   ;
</I>&gt;<i> 
</I>&gt;<i> The tree node will now have an IDENT token as the root of the 
</I>&gt;<i> declaration.  This seems like it would make finding a 
</I>&gt;<i> declaration very difficult because your tree would be something like:
</I>&gt;<i>  
</I>&gt;<i> #(IDENT &lt;type info&gt;)
</I>&gt;<i>  
</I>&gt;<i> Is my understanding of this correct?
</I>
Yes.

&gt;<i> It seems like a much better way would be to provide tree node 
</I>&gt;<i> types for the productions so it would be more like:
</I>&gt;<i>  
</I>&gt;<i> #(DECLARATION type name)
</I>&gt;<i>  
</I>&gt;<i> Am I correct in assuming that ANTLR doesn't do something like 
</I>&gt;<i> this because the tree would get really cluttered with 
</I>&gt;<i> production names as well as tokens?  So, it would seem you 
</I>&gt;<i> might want to selectively choose the most important 
</I>&gt;<i> productions to use for nodes.  In this case, should protected 
</I>&gt;<i> tokens be introduced in the lexer for this purpose?
</I>
Yes, preserving the structure of the parse would give you a parse tree that
is tedious to use, especially for expressions.

&gt;<i> I'm 
</I>&gt;<i> guessing that this is why the 'GNU C' grammar in the 
</I>&gt;<i> resources section of the ANTLR web page has things like this:
</I>&gt;<i>  declaration
</I>&gt;<i>         : ds:declSpecifiers (initDeclList[ds1])? ( SEMI )+
</I>&gt;<i>               { ## = #( #[NDeclaration], ##); }
</I>&gt;<i>         ;
</I>&gt;<i>  
</I>&gt;<i> Am I correct in assuming that this attempting to create a 
</I>&gt;<i> node with a root of 'NDeclaration' so that this is easier to 
</I>&gt;<i> identify later on?
</I>
Exactly!
  
&gt;<i> For my application, it seems quite reasonable to identify 
</I>&gt;<i> certain key structural pieces and do things like the above.  
</I>&gt;<i> If I start doing this, I would like to protect for the 
</I>&gt;<i> possibility of having both Java and C++ tree walkers.  Is it, 
</I>&gt;<i> in general, possible to build a parser grammar with markups 
</I>&gt;<i> and so on without having to write any target language 
</I>&gt;<i> specific actions?  I assume this would be the goal if 
</I>&gt;<i> somebody were trying to develop a language neutral grammar?
</I>
When I wrote my translator from AREV R/BASIC to Visual BASIC I made a master
tree grammar that encompassed both languages so I could represent the
intermediate stages of translation.  You just have to make sure that the
tokens used by each parser don't overlap.
  
&gt;<i> From a software engineering perspective, it seems somewhat 
</I>&gt;<i> strange that the treewalker mimics the structure of the 
</I>&gt;<i> grammar so heavily.  It seems like this is pretty redundant.  
</I>&gt;<i> The tree walkers don't follow the exact same structure as the 
</I>&gt;<i> grammar, but I'm trying to understand the relationship 
</I>&gt;<i> between the two structures and what the implications are if 
</I>&gt;<i> the grammar structure is changed.  It seems like it would be 
</I>&gt;<i> pretty undesirable to have changes in the grammar creating 
</I>&gt;<i> lots of problems in a tree walker if the grammar change was 
</I>&gt;<i> only a minor syntactical modification.  How do you avoid 
</I>&gt;<i> these kinds of issues?
</I>
My GNU C grammar source is actually a noweb file which I've structured so
that similar rules from the parser and tree walkers are all close to each
other.  That way when I change a grammar rule it's right in my face to
change the tree grammars too.  In general the parser grammar (and hence the
tree grammar) usually comes to a fixed state once you've debugged it.  Then
the interesting work is in specializing the actions of your tree grammar,
for which antlr subclassing is useful.

&gt;<i> Finally, I haven't had enough experience playing around with 
</I>&gt;<i> the tree walkers, but I recall that there is some mention in 
</I>&gt;<i> the documentation about the matching rules being different 
</I>&gt;<i> for tree walkers.  I can go back and read the rules again, 
</I>&gt;<i> but I have a bigger question than how the rules work.  What I 
</I>&gt;<i> want to understand are the implications.  It seems as though 
</I>&gt;<i> the tree walking is designed so that you don't have to mimic 
</I>&gt;<i> the grammar structure but instead you can just pluck patterns 
</I>&gt;<i> you are interested in out of the tree generated by the 
</I>&gt;<i> parser.  Do these matching rules for tree parsers essentially 
</I>&gt;<i> mean that you can get away with this (i.e. only writing rules 
</I>&gt;<i> for particular patterns you are interested in)?  Does this, 
</I>&gt;<i> to some extent, mitigate the problems of grammar changes 
</I>&gt;<i> causing lots of tearup in the tree walker?
</I>
Generally you structure your trees so they are easy to walk.  The degenerate
case would be a tree which is nothing but a flat sibling list of the tokens
as they were parsed.  Then your tree grammar is your parser and you haven't
gained anything by creating a tree.  Adding the parent/child relationships
gives structure to your tree.  Certain things can be encoded just in the
structure of the tree, so parens and semicolons can be left out.

I typically have a complete tree grammar empty of actions that I then
subclass and override just the actions I'm interested in to do some
transformations.

&gt;<i> I guess my overall impression (although I haven't had enough 
</I>&gt;<i> time to actually try much of this out so far) is that it 
</I>&gt;<i> would be important to markup the grammar so that the 
</I>&gt;<i> resulting tree distills out much of the tiny syntax minutiae 
</I>&gt;<i> and instead try and capture (in the tree being built) the 
</I>&gt;<i> fundamental structure.  In other words, a declaration 
</I>&gt;<i> consists of a name, type information and possibly array size 
</I>&gt;<i> but you would avoid recording things like the braces or the 
</I>&gt;<i> semicolon in the tree.  If you assume that the fundamental 
</I>&gt;<i> structure (i.e. all declarations have a type and name) isn't 
</I>&gt;<i> likely to change then changes in the grammar wouldn't really 
</I>&gt;<i> propagate to the tree walker.
</I>&gt;<i>  
</I>&gt;<i> Is (any of) this correct? :-)
</I>
Yep, you've got the basic concepts right.

Monty 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://www.antlr.org/pipermail/antlr-interest/attachments/20011010/b423e011/attachment.html">http://www.antlr.org/pipermail/antlr-interest/attachments/20011010/b423e011/attachment.html</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000091.html">[antlr-interest] Latest development snapshot
</A></li>
	<LI>Next message: <A HREF="000093.html">[antlr-interest] Newbie re: memory management on parse fail (C++)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
