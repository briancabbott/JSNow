<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] unexpected char error
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20unexpected%20char%20error&In-Reply-To=%3CB56C45B6-327E-4B1A-9A4E-87763B0F1DB2%40martin-probst.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019790.html">
   <LINK REL="Next"  HREF="019792.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] unexpected char error</H1>
    <B>Martin Probst</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20unexpected%20char%20error&In-Reply-To=%3CB56C45B6-327E-4B1A-9A4E-87763B0F1DB2%40martin-probst.com%3E"
       TITLE="[antlr-interest] unexpected char error">mail at martin-probst.com
       </A><BR>
    <I>Sat Mar 24 02:06:37 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="019790.html">[antlr-interest] unexpected char error
</A></li>
        <LI>Next message: <A HREF="019792.html">[antlr-interest] ANTLR v3 and J# compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19885">[ date ]</a>
              <a href="thread.html#19885">[ thread ]</a>
              <a href="subject.html#19885">[ subject ]</a>
              <a href="author.html#19885">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> But, its supposed to implicitly define the token as a literal when  
</I>&gt;<i> I use
</I>&gt;<i> it.  That's the whole point of allowing me to use the string in the
</I>&gt;<i> parser.  It should then appear in the literal table.  IN the second  
</I>&gt;<i> case
</I>&gt;<i> above, I see:
</I>&gt;<i>
</I>&gt;<i> &quot;=&quot;=11 in my myLexerTokenTypes.txt file.
</I>
It does. But the thing is that this &quot;test literals&quot; feature only  
tests lexed tokens for literals. Meaning, if the lexer reads  
something in, and creates a token from it, it then looks up in a  
table if it's one of the literals (you can switch this behaviour on/ 
off on a per-token type basis). If yes, it sets the type of the token  
to the corresponding type.

Of course this only works if the input can be matched by any lexer  
rule, and if this rule has the test literals thing turned on. This is  
typically done to filter tokens like &quot;if&quot; from the identifier rule of  
the language. I guess in your case, because identifiers are not  
allowed to contain &quot;=&quot; tokens, it won't work.

So generally speaking this test literals feature is nice to easily  
pick keywords that would also be matched by the identifier rule (or  
similar rules), but it's not useful for tokens that do not match the  
identifier production.

Regards,
Martin
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019790.html">[antlr-interest] unexpected char error
</A></li>
	<LI>Next message: <A HREF="019792.html">[antlr-interest] ANTLR v3 and J# compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19885">[ date ]</a>
              <a href="thread.html#19885">[ thread ]</a>
              <a href="subject.html#19885">[ subject ]</a>
              <a href="author.html#19885">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
