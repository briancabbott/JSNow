<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] SeeGramWrap: Yet another refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20SeeGramWrap%3A%20Yet%20another%20refactoring&In-Reply-To=c2607s%2Bcmmd%40eGroups.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006696.html">
   <LINK REL="Next"  HREF="006711.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] SeeGramWrap: Yet another refactoring</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20SeeGramWrap%3A%20Yet%20another%20refactoring&In-Reply-To=c2607s%2Bcmmd%40eGroups.com"
       TITLE="[antlr-interest] SeeGramWrap: Yet another refactoring">parrt at cs.usfca.edu
       </A><BR>
    <I>Wed Mar  3 17:54:42 PST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006696.html">[antlr-interest] SeeGramWrap: Yet another refactoring
</A></li>
        <LI>Next message: <A HREF="006711.html">[antlr-interest] Re: SeeGramWrap: Yet another refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6697">[ date ]</a>
              <a href="thread.html#6697">[ thread ]</a>
              <a href="subject.html#6697">[ subject ]</a>
              <a href="author.html#6697">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Wow!  Great work, Ed!  Should we make the text of this an &quot;article&quot; at 
antlr.org?

Terence

On Mar 3, 2004, at 5:19 PM, edcjones wrote:

&gt;<i> I have placed a re-refactored version of &quot;SeeGramWrap-03.02.2004.tgz&quot;
</I>&gt;<i> on my webpage at &quot;<A HREF="http://members.tripod.com/~edcjones/pycode.html&quot;.">http://members.tripod.com/~edcjones/pycode.html&quot;.</A>
</I>&gt;<i> SeeGramWrap parses a piece of C code and the resulting parse tree is
</I>&gt;<i> output in man and machine readable form. The result can be used for
</I>&gt;<i> program transformations. Since a particular trnsformation algorithm
</I>&gt;<i> may not require all the information present in the tree, the user can
</I>&gt;<i> select what to output.
</I>&gt;<i>
</I>&gt;<i> This program has been written and tested only under linux.
</I>&gt;<i>
</I>&gt;<i> Thanks to John Mitchell and Monty Zukowski for &quot;cgram.tgz&quot;. Every
</I>&gt;<i> parser generator need to have a good C grammar. Also thanks to
</I>&gt;<i> Terrence Parr for ANTLR (<A HREF="http://www.antlr.org/">http://www.antlr.org/</A>).
</I>&gt;<i>
</I>&gt;<i> ==============================================================
</I>&gt;<i>                           CONTEXT
</I>&gt;<i>
</I>&gt;<i> Python (<A HREF="http://www.python.org">http://www.python.org</A>) is a scripting language that is both
</I>&gt;<i> easy to read and easy to write. It is so easy to read that I can
</I>&gt;<i> usually read my own code six months after I write it. But Python is
</I>&gt;<i> slow. If speed is needed for part of a project, Pythonistas write C
</I>&gt;<i> code that call functions in Python's large API. It also common to wrap
</I>&gt;<i> large C libraries so they can be called by Python. The wrapping code
</I>&gt;<i> is repetitive and there may be a lot of it so methods have been
</I>&gt;<i> developed for automated wrapping.
</I>&gt;<i>
</I>&gt;<i> The best-known approach is SWIG (<A HREF="http://www.swig.org/">http://www.swig.org/</A>). For complex
</I>&gt;<i> wrappings, SWIG requires the writing of &quot;typemaps&quot;, an unintuitive
</I>&gt;<i> process where pieces of C code you write are spliced into the wrapper
</I>&gt;<i> code generated by SWIG.
</I>&gt;<i>
</I>&gt;<i> Another wrapper related approach is Pyrex which is found at
</I>&gt;<i>
</I>&gt;<i>     <A HREF="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/</A>
</I>&gt;<i>
</I>&gt;<i> Pyrex has its own repetitive boilerplate that has to be written. But
</I>&gt;<i> the Pyrex boilerplate is so straightforward that it can be taught
</I>&gt;<i> algorithmically. See &quot;Michael's Quick Guide to Pyrex&quot; at
</I>&gt;<i> &quot;<A HREF="http://ldots.org/pyrex-guide/&quot;.">http://ldots.org/pyrex-guide/&quot;.</A>
</I>&gt;<i>
</I>&gt;<i> I think that the Pyrex boilerplate is _so_ straightforward that it can
</I>&gt;<i> be machine generated. Therefore I have been sporatically developing
</I>&gt;<i> software to do this. A thoroughly buggy version of this is on my web
</I>&gt;<i> page, &quot;<A HREF="http://members.tripod.com/~edcjones&quot;.">http://members.tripod.com/~edcjones&quot;.</A> It is called
</I>&gt;<i> &quot;cgram.tar.gz&quot; (The name will be changed). Look at it but don't use
</I>&gt;<i> it. &quot;SeeGramWrap&quot; is a major revision of the front end of 
</I>&gt;<i> &quot;cgram.tr.gz&quot;.
</I>&gt;<i>
</I>&gt;<i> I think the automatic-wrapper program can be made to work. It might be
</I>&gt;<i> easier to use than SWIG. It is still a lot of work to prepare complex
</I>&gt;<i> C header files. What we have is really a &quot;program transformation&quot; or
</I>&gt;<i> &quot;tree transformation&quot; problem.
</I>&gt;<i>
</I>&gt;<i> I think some of the issues are:
</I>&gt;<i>
</I>&gt;<i> 1. Since parser generators have a long and steep learning curve, I
</I>&gt;<i> prefer to use them as black boxes which generate parsers which output
</I>&gt;<i> results that I can analyze using Python. The parser created by a
</I>&gt;<i> parser generator should output trees in two formats: one easy to look
</I>&gt;<i> at and another that a program can easily read. For examples, see below.
</I>&gt;<i>
</I>&gt;<i> 2. I find trees very easy to work with. I want the trees to be front
</I>&gt;<i> and center and highly visible. I prefer to &quot;manipulate a tree&quot; rather
</I>&gt;<i> than &quot;fire a rule&quot;.
</I>&gt;<i>
</I>&gt;<i> 3. The most common type of C macro has a type as one of its arguments:
</I>&gt;<i>
</I>&gt;<i>     #define CAST(x, type) (type *) x
</I>&gt;<i>
</I>&gt;<i> How can these be automatically wrapped for Python which is a
</I>&gt;<i> dynamically typed language?
</I>&gt;<i>
</I>&gt;<i> =============================================================
</I>&gt;<i>                     TECHNICAL OVERVIEW
</I>&gt;<i>
</I>&gt;<i> I use some C grammars associated with ANTLR. The grammar package is
</I>&gt;<i> called &quot;cgram&quot;. See &quot;<A HREF="http://www.antlr.org/resources.html&quot;.">http://www.antlr.org/resources.html&quot;.</A>
</I>&gt;<i>
</I>&gt;<i> In &quot;cgram&quot; there is a java program &quot;TestThrough.java&quot; which parses C
</I>&gt;<i> code into an AST then runs a tree grammar on the AST and outputs the
</I>&gt;<i> original code. The tree grammar is named &quot;GnuCEmitter.g&quot;. I work with
</I>&gt;<i> this grammar because the terminal tokens are printed in the correct
</I>&gt;<i> order. I modified the grammar turning it into a template. A piece of
</I>&gt;<i> the original &quot;GnuCEmitter.g&quot; is:
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i> typeQualifier
</I>&gt;<i>         :       a:&quot;const&quot;                       { print( a ); }
</I>&gt;<i>         |       b:&quot;volatile&quot;                    { print( b ); }
</I>&gt;<i>         ;
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> The modified version is:
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i> typeQualifier
</I>&gt;<i>         :       a:&quot;const&quot;                       { &lt;@ a @&gt; }
</I>&gt;<i>         |       b:&quot;volatile&quot;                    { &lt;@ b @&gt; }
</I>&gt;<i>         ;
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> In this template, strings of the form &quot;&lt;@ ... @&gt;&quot; will each be
</I>&gt;<i> replaced by a set of print statements. Moreover the entire rule will
</I>&gt;<i> be wrapped by prints.  The template is used in
</I>&gt;<i> &quot;emitter/insert_prints.py&quot;. If &quot;insert_prints.py&quot; is run the result is:
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i> typeQualifier
</I>&gt;<i>   { if ( inputState.guessing==0 ) {
</I>&gt;<i>           print(Open);
</I>&gt;<i>           print(&quot;typeQualifier&quot;);
</I>&gt;<i>        }
</I>&gt;<i>     }
</I>&gt;<i>         :  (
</I>&gt;<i>                 a:&quot;const&quot;        {  print(Open);
</I>&gt;<i> print(&quot;typeQualifier.0&quot;); print( a ); print(Close); }
</I>&gt;<i>         |       b:&quot;volatile&quot;     {  print(Open);
</I>&gt;<i> print(&quot;typeQualifier.1&quot;); print( b ); print(Close); }
</I>&gt;<i>            )
</I>&gt;<i>   { currentOutput.print(Close + MyTokenSep); }
</I>&gt;<i>         ;
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> If the original C program , &quot;temp2.c&quot;, is
</I>&gt;<i>
</I>&gt;<i>     char* s = &quot;ab&quot;;
</I>&gt;<i>
</I>&gt;<i> The output of the modified emitter grammar is &quot;temp2.c.data&quot;:
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;
</I>&gt;<i>     externalList             declarator               expr
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;
</I>&gt;<i>     externalDef              pointerGroup             primaryExpr
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;
</I>&gt;<i>     declaration              pointerGroup.0           stringConst
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 *                        &lt;&lt;OPEN&gt;&gt;
</I>&gt;<i>     declSpecifiers           &lt;&lt;CLOSE&gt;&gt;                stringConst.0
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;                &quot;ab&quot;
</I>&gt;<i>     typeSpecifier            &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 declarator.0             &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     typeSpecifier.1          s                        &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     char                     &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     &lt;&lt;CLOSE&gt;&gt;                initDecl.0               &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 =                        ;
</I>&gt;<i>     initDeclList             &lt;&lt;CLOSE&gt;&gt;                &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;OPEN&gt;&gt;                 &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i>     initDecl                 initializer              &lt;&lt;CLOSE&gt;&gt;
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> This output can be processed by &quot;tree.py&quot; to produce &quot;temp2.c.nest&quot;
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i> (externalList,
</I>&gt;<i>   (externalDef,
</I>&gt;<i>     (declaration,
</I>&gt;<i>       (declSpecifiers,
</I>&gt;<i>         (typeSpecifier,
</I>&gt;<i>           (typeSpecifier.1, |char|))),
</I>&gt;<i>       (initDeclList,
</I>&gt;<i>         (initDecl,
</I>&gt;<i>           (declarator,
</I>&gt;<i>             (pointerGroup,
</I>&gt;<i>               (pointerGroup.0, |*|)),
</I>&gt;<i>             (declarator.0, |s|)),
</I>&gt;<i>           (initDecl.0, |=|),
</I>&gt;<i>           (initializer,
</I>&gt;<i>             (expr,
</I>&gt;<i>               (primaryExpr,
</I>&gt;<i>                 (stringConst,
</I>&gt;<i>                   (stringConst.0, |&quot;ab&quot;|))))))), |;|)))
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> or &quot;temp2.c.src&quot;:
</I>&gt;<i>
</I>&gt;<i>     char * s = &quot;ab&quot; ;
</I>&gt;<i>
</I>&gt;<i> If &quot;temp2.c.src&quot; is put through the entire process itself we get
</I>&gt;<i> &quot;temp2.c.src.src&quot; which is identical to &quot;temp2.c.src&quot;. This test is
</I>&gt;<i> done by &quot;docheck.py&quot;.
</I>&gt;<i>
</I>&gt;<i> In the &quot;.data&quot; or &quot;.nest&quot; files the tokens from the original C code
</I>&gt;<i> are in the correct order. It is easy to recover
</I>&gt;<i>
</I>&gt;<i>     ('char', '*', 's', '=', '&quot;ab&quot;', ';')
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i> Ed Jones
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yahoo! Groups Links
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>--
Professor Comp. Sci., University of San Francisco
Creator, ANTLR Parser Generator, <A HREF="http://www.antlr.org">http://www.antlr.org</A>
Cofounder, <A HREF="http://www.jguru.com">http://www.jguru.com</A>
Cofounder, <A HREF="http://www.knowspam.net">http://www.knowspam.net</A> enjoy email again!
Cofounder, <A HREF="http://www.peerscope.com">http://www.peerscope.com</A> pure link sharing





 
Yahoo! Groups Links

&lt;*&gt; To visit your group on the web, go to:
     <A HREF="http://groups.yahoo.com/group/antlr-interest/">http://groups.yahoo.com/group/antlr-interest/</A>

&lt;*&gt; To unsubscribe from this group, send an email to:
     <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">antlr-interest-unsubscribe at yahoogroups.com</A>

&lt;*&gt; Your use of Yahoo! Groups is subject to:
     <A HREF="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</A>
 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006696.html">[antlr-interest] SeeGramWrap: Yet another refactoring
</A></li>
	<LI>Next message: <A HREF="006711.html">[antlr-interest] Re: SeeGramWrap: Yet another refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6697">[ date ]</a>
              <a href="thread.html#6697">[ thread ]</a>
              <a href="subject.html#6697">[ subject ]</a>
              <a href="author.html#6697">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
