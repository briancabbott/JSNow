<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Antlr vs Spirit
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Antlr%20vs%20Spirit&In-Reply-To=001001c51738%24176d1780%240100a8c0%40hrvoje">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011200.html">
   <LINK REL="Next"  HREF="011260.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Antlr vs Spirit</H1>
    <B>Braden McDaniel</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Antlr%20vs%20Spirit&In-Reply-To=001001c51738%24176d1780%240100a8c0%40hrvoje"
       TITLE="[antlr-interest] Antlr vs Spirit">braden at endoframe.com
       </A><BR>
    <I>Fri Feb 25 03:01:26 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011200.html">[antlr-interest] Antlr vs Spirit
</A></li>
        <LI>Next message: <A HREF="011260.html">[antlr-interest] Antlr vs Spirit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11259">[ date ]</a>
              <a href="thread.html#11259">[ thread ]</a>
              <a href="subject.html#11259">[ subject ]</a>
              <a href="author.html#11259">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, 2005-02-20 at 11:36 +0100, Hrvoje Nezic wrote:
&gt;<i> I hope that this subject is not off topic (please excuse me if it
</I>&gt;<i> is). 
</I>&gt;<i>  
</I>&gt;<i> A few days ago I had a heated discussion with my colleagues
</I>&gt;<i> at work about parser generators. I use Antlr while some other
</I>&gt;<i> people use Spirit. It seems that Spirit is rather popular in the C++
</I>&gt;<i> community.
</I>&gt;<i>  
</I>&gt;<i> &quot;Spirit is an object oriented recursive descent parser generator
</I>&gt;<i> framework implemented using template meta-programming techniques.&quot;  &quot;
</I>&gt;<i> Parser objects are composed through operator overloading and the
</I>&gt;<i> result is a backtracking LL(inf) parser that is capable of parsing
</I>&gt;<i> rather ambiguous grammars. &quot;
</I>&gt;<i>  
</I>&gt;<i> Antlr documentation or web site mentions other parser generators like
</I>&gt;<i> JavaCC, but it doesn't mention Spirit. Does Spirit bring something new
</I>&gt;<i> regarding computation of lookahead sets (like Antlr's approximate
</I>&gt;<i> lookahead)?
</I>
I don't think so. Spirit keeps looking ahead until it finds--or
definitely does not find--a match.

&gt;<i> Actually I don't understand how complex algorithms that should analyze
</I>&gt;<i> complex grammars could be implemented with C++ templates, but that is
</I>&gt;<i> another question.
</I>
And one that can only be answered by furthering your understanding of
C++ templates. Some books you may want to look at on the subject are
&quot;C++ Templates&quot; by Vandevoorde and Josuttis, and &quot;C++ Template
Metaprogramming&quot; by Abrahams and Gurtovoy.
 
&gt;<i> Perhaps I should address these questions to the Spirit mailing list,
</I>&gt;<i> but I thought it would be interesting to hear opinions from Antlr
</I>&gt;<i> community. BTW, I don't intend to move to Spirit :)
</I>
I have used both. The main accomplishment of Spirit is what it manages
to let you do without having to resort to a code generator like antlr
(or yacc, etc.). I don't buy the assertion that it is inherently Good
for a grammar to be in a language distinct from the parser
implementation language; most grammars only get implemented by one
parser written in one programming language. What's important is that the
grammar is readable; and Spirit accomplishes that.

But while *what* a Spirit parser is supposed to do is generally lucid,
*how* it does it is a bit obfuscated. As Spirit becomes more featureful
and robust, the need for users to understand these obfuscated bits is
diminished. But I don't think Spirit is &quot;there&quot; yet.

Spirit's feature set is not well-geared to writing parsers for large-,
and probably most medium-, sized languages. I think that is likely to
change as the project continues to evolve. But today it is outclassed in
that role. Spirit does excel at the larger end of small parsing tasks,
where regular expressions would be too unwieldy and writing a parser in
something like antlr is just too inconvenient. Since all you need for
Spirit is a modern C++ compiler *and it imposes no runtime dependency*,
the barrier to entry is pretty low (notwithstanding the prospective
user's understanding of C++ templates).

-- 
Braden McDaniel                           e-mail: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">braden at endoframe.com</A>&gt;
&lt;<A HREF="http://endoframe.com">http://endoframe.com</A>&gt;                    Jabber: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">braden at jabber.org</A>&gt;

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011200.html">[antlr-interest] Antlr vs Spirit
</A></li>
	<LI>Next message: <A HREF="011260.html">[antlr-interest] Antlr vs Spirit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11259">[ date ]</a>
              <a href="thread.html#11259">[ thread ]</a>
              <a href="subject.html#11259">[ subject ]</a>
              <a href="author.html#11259">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
