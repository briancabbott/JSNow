<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Resolving ambiguities between rules
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Resolving%20ambiguities%20between%20rules&In-Reply-To=20050307113908.5CAE4E5BC7%40ws7-2.us4.outblaze.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011323.html">
   <LINK REL="Next"  HREF="011325.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Resolving ambiguities between rules</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=%5Bantlr-interest%5D%20Resolving%20ambiguities%20between%20rules&In-Reply-To=20050307113908.5CAE4E5BC7%40ws7-2.us4.outblaze.com"
       TITLE="[antlr-interest] Resolving ambiguities between rules">parrt at cs.usfca.edu
       </A><BR>
    <I>Mon Mar  7 08:50:52 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011323.html">[antlr-interest] Resolving ambiguities between rules
</A></li>
        <LI>Next message: <A HREF="011325.html">[antlr-interest] Separation of specification and code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11324">[ date ]</a>
              <a href="thread.html#11324">[ thread ]</a>
              <a href="subject.html#11324">[ subject ]</a>
              <a href="author.html#11324">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Mar 7, 2005, at 3:39 AM, togol machillan wrote:

&gt;<i> Hello,
</I>&gt;<i>
</I>&gt;<i> How do I resolve ambiguities between rules when a certain starting 
</I>&gt;<i> part of the rules are the same, like the following two rules.
</I>&gt;<i>
</I>&gt;<i> p_singleline_list { std::string k = &quot;&quot;;}
</I>&gt;<i> 		    : (k = keyword) {std::cout &lt;&lt; &quot;With single line list --- Keyword 
</I>&gt;<i> is &quot; &lt;&lt; k &lt;&lt; std::endl;}
</I>&gt;<i> 		     (VALUE SLASH)+ (VALUE NEWLINE|AMPERSAND NEWLINE (VALUE 
</I>&gt;<i> (SLASH)?)+ NEWLINE)  ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> p_with_sentences { std::string k = &quot;&quot;;}
</I>&gt;<i> 	     :(k = keyword) {std::cout &lt;&lt; &quot;Single line para  with 
</I>&gt;<i> sentences--- Keyword is &quot; &lt;&lt; k &lt;&lt; std::endl;}
</I>&gt;<i> 	     (VALUE|FIGURE|VALUE EQUAL (VALUE|FIGURE))+ NEWLINE (sentence)*;
</I>&gt;<i>
</I>&gt;<i> Here the parser always tries to match with the first rule and throws 
</I>&gt;<i> in an unexpected token error when the structure should match the 
</I>&gt;<i> second rule. Is there any way to prioritise rule matching? Is it 
</I>&gt;<i> possible to use syntactic perdicates to differentiate two rules rather 
</I>&gt;<i> two alternatives of the same rule?
</I>
Hi.  The key is in the rule that calls these.  That is where the 
decision is made about which to call.  You may have to move keyword 
rule reference into that rule and pass k downwards as an argument into 
these rules.

Or just use a syntactic predicate.

Terence



</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011323.html">[antlr-interest] Resolving ambiguities between rules
</A></li>
	<LI>Next message: <A HREF="011325.html">[antlr-interest] Separation of specification and code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11324">[ date ]</a>
              <a href="thread.html#11324">[ thread ]</a>
              <a href="subject.html#11324">[ subject ]</a>
              <a href="author.html#11324">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
