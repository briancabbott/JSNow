<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [antlr-interest] Help with a parser
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Help%20with%20a%20parser&In-Reply-To=%3CCA%2Bbn5ryqQUQqjBdx-V6kz1e%3DsYDt5EecZbEFAMD%3D0SpqvQCZmg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="042316.html">
   <LINK REL="Next"  HREF="042318.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[antlr-interest] Help with a parser</H1>
    <B>Kirby Bohling</B> 
    <A HREF="mailto:antlr-interest%40antlr.org?Subject=Re:%20%5Bantlr-interest%5D%20Help%20with%20a%20parser&In-Reply-To=%3CCA%2Bbn5ryqQUQqjBdx-V6kz1e%3DsYDt5EecZbEFAMD%3D0SpqvQCZmg%40mail.gmail.com%3E"
       TITLE="[antlr-interest] Help with a parser">kirby.bohling at gmail.com
       </A><BR>
    <I>Tue Aug  2 16:50:47 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="042316.html">[antlr-interest] Help with a parser
</A></li>
        <LI>Next message: <A HREF="042318.html">[antlr-interest] Help with a parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#42317">[ date ]</a>
              <a href="thread.html#42317">[ thread ]</a>
              <a href="subject.html#42317">[ subject ]</a>
              <a href="author.html#42317">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>By examination, I didn't run the grammar through ANTLR, I'm pretty
sure this is your problem:

 FIELDNAME
     :    KEYWORD ':' ;

FIELDNAME is a Lexer Rule, and KEYWORD is your lexer rule.  I'm pretty
sure that is at least one of the problem.  For me, every time ANTLR
does this the easiest thing to do is make sure the lexer is generating
the _exactly_ the tokens I think it does.  Generally, if I did
something obviously dumb in the parser, I'll spot it inside of 60
seconds.  The ones that take a long time to spot are when I'm sure I
know what tokens are being generated, and I'm wrong.

My guess here is that your guess as to which tokens are being
generated is wrong.  If you'd given the actual error message output,
it would I'd be more confident in my analysis.  Not sure what the best
way to go about fixing this is.  Not sure if you should create a
fragment named KEYWORD_STUB and then use it both places you use it in
the FIELDNAME and KEYWORD lexer rules, or if you should figure out how
to accomplish this some other way.

I'm 99% sure, this is a case where you are doing too much in the
lexer.  You might consider making a ':' a first class token, and
eliminate the difference between STRING vs. KEYWORD.  As Jim Idle
always points out, Lexer errors are useless to humans.  Parser errors
are better, but Tree Walker errors are the best place to generate
error messages.  If you have on token type for STRING and KEYWORD, and
a separate token for ':', pretty much everything you put in there will
Lex.  Then at least when you get to the parser, you'll be able to
generate a decent error message, rather than saying &quot;Unexpected
character '1' at offset: 4&quot;, for an input like 'A 12:XYZ' (because it
appears keywords aren't allow to start with numbers).  You'd much
rather tell them &quot;12&quot; is not a valid keyword at offset: 4... You can
only do that if it lexes.  The parser will be able to kick out such an
error message (and likely the tree walker also).

Best of luck, I use SOLR and Lucene, so I look forward to better parsers!

Kirby



On Tue, Aug 2, 2011 at 6:11 PM, Scott Smith &lt;<A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">ssmith at mainstreamdata.com</A>&gt; wrote:
&gt;<i> I assume this is the proper place to put this. &#160;I'm trying to build a parser for filters generated by SOLR (lucene.apache.org).
</I>&gt;<i>
</I>&gt;<i> Examples of valid &quot;sentences&quot; the parser should parse are:
</I>&gt;<i>
</I>&gt;<i> fq = fred
</I>&gt;<i>
</I>&gt;<i> fq = (fred OR bill)
</I>&gt;<i>
</I>&gt;<i> fq = harry:(fred OR bill)
</I>&gt;<i>
</I>&gt;<i> fq = (harry:fred OR jack:bill)
</I>&gt;<i>
</I>&gt;<i> fq = ((harry:fred OR bill) AND (jane OR marry:sally))
</I>&gt;<i>
</I>&gt;<i> terms can be nested to arbitrary levels. &#160;The colon really binds to the word before it (e.g., &quot;harry:&quot;).
</I>&gt;<i>
</I>&gt;<i> I've listed the parser below (which doesn't work). &#160;Can someone suggest what I can do? &#160;It seems like a simple problem, but so far I haven't cracked it. &#160;I will admit that I've only been playing with Antlr the last week or so. &#160;I did play all of Scott Stanchfield's excellent videos on vimeo. &#160;But, still I'm confused.
</I>&gt;<i>
</I>&gt;<i> When I run the parser in antlrworks with example 3 (&quot;fq = harry:(fred OR bill)&quot; - no quote marks), it finds &quot;fq = harry:(fred&quot; and then it wants the right paren instead of expanding out the filter_expr rule. &#160;What am I missing?
</I>&gt;<i>
</I>&gt;<i> Thanks
</I>&gt;<i>
</I>&gt;<i> Scott
</I>&gt;<i>
</I>&gt;<i> Here's the parser.
</I>&gt;<i>
</I>&gt;<i> grammar testGrammer;
</I>&gt;<i>
</I>&gt;<i> options {
</I>&gt;<i> &#160;language = Java;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @header {
</I>&gt;<i> &#160;package a.b.c;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @lexer::header {
</I>&gt;<i> &#160;package a.b.c;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> filter:
</I>&gt;<i> &#160;'fq' '=' filter_expr EOF
</I>&gt;<i> &#160;;
</I>&gt;<i>
</I>&gt;<i> term
</I>&gt;<i> &#160;: KEYWORD
</I>&gt;<i> &#160;| STRING
</I>&gt;<i> &#160;| '(' filter_expr ')'
</I>&gt;<i> &#160;;
</I>&gt;<i>
</I>&gt;<i> fieldname
</I>&gt;<i> &#160; &#160; : &#160; &#160;FIELDNAME? term
</I>&gt;<i> &#160; &#160; ;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> filter_expr:
</I>&gt;<i> &#160;fieldname (((AND | OR | NOT))? fieldname)*
</I>&gt;<i> &#160;;
</I>&gt;<i>
</I>&gt;<i> FIELDNAME
</I>&gt;<i> &#160; &#160; : &#160; &#160;KEYWORD ':' ;
</I>&gt;<i>
</I>&gt;<i> AND : 'AND' | '&amp;&amp;' ;
</I>&gt;<i> OR &#160;: 'OR' | '||' ;
</I>&gt;<i> NOT : 'NOT' | '!' ;
</I>&gt;<i> KEYWORD : LETTER (LETTER | NUM_CHAR | '_')*;
</I>&gt;<i> STRING : '&quot;' NONCONTROL_CHAR* '&quot;' ;
</I>&gt;<i> WS &#160;: ' ' | '\t' | '\n' | '\r' | '\u3000' {$channel=HIDDEN; } ;
</I>&gt;<i>
</I>&gt;<i> fragment NONCONTROL_CHAR: LETTER | NUM_CHAR | SPACE | SYMBOL;
</I>&gt;<i> fragment SYMBOL: &#160;' '..'!' | '#'..'/' | ':'..'@' | '['..'`' | '{'..'~';
</I>&gt;<i> fragment LETTER: LOWER | UPPER;
</I>&gt;<i> fragment LOWER: 'a'..'z';
</I>&gt;<i> fragment UPPER: 'A'..'Z';
</I>&gt;<i> fragment NUM_CHAR: '0'..'9';
</I>&gt;<i> fragment SPACE: ' ' | '\t';
</I>&gt;<i>
</I>&gt;<i> List: <A HREF="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</A>
</I>&gt;<i> Unsubscribe: <A HREF="http://www.antlr.org/mailman/options/antlr-interest/your-email-address">http://www.antlr.org/mailman/options/antlr-interest/your-email-address</A>
</I>&gt;<i>
</I></PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="042316.html">[antlr-interest] Help with a parser
</A></li>
	<LI>Next message: <A HREF="042318.html">[antlr-interest] Help with a parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#42317">[ date ]</a>
              <a href="thread.html#42317">[ thread ]</a>
              <a href="subject.html#42317">[ subject ]</a>
              <a href="author.html#42317">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/antlr-interest">More information about the antlr-interest
mailing list</a><br>
</body></html>
