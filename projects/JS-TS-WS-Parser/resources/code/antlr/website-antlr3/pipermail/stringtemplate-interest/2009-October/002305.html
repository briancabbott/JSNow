<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [stringtemplate-interest] null vs missing vs	empty	vs	nonexistent
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:stringtemplate-interest%40antlr.org?Subject=Re:%20%5Bstringtemplate-interest%5D%20null%20vs%20missing%20vs%0A%09empty%09vs%09nonexistent&In-Reply-To=%3C7E4066AA90634047A7ACFD441F4E1E57%40wprod.ds.aphp.fr%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002310.html">
   <LINK REL="Next"  HREF="002316.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[stringtemplate-interest] null vs missing vs	empty	vs	nonexistent</H1>
    <B>Harry Karadimas</B> 
    <A HREF="mailto:stringtemplate-interest%40antlr.org?Subject=Re:%20%5Bstringtemplate-interest%5D%20null%20vs%20missing%20vs%0A%09empty%09vs%09nonexistent&In-Reply-To=%3C7E4066AA90634047A7ACFD441F4E1E57%40wprod.ds.aphp.fr%3E"
       TITLE="[stringtemplate-interest] null vs missing vs	empty	vs	nonexistent">harry.karadimas at hmn.aphp.fr
       </A><BR>
    <I>Tue Oct 20 07:48:26 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002310.html">[stringtemplate-interest] On Pragmatism Violating Purity	For	The Win
</A></li>
        <LI>Next message: <A HREF="002316.html">[stringtemplate-interest] null vs missing vs empty	vs	nonexistent
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2305">[ date ]</a>
              <a href="thread.html#2305">[ thread ]</a>
              <a href="subject.html#2305">[ subject ]</a>
              <a href="author.html#2305">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

Sorry for the reply not appearing with the other messages; I
have subscribed to &quot;the stringtemplate-interest Digest&quot; so
I cut and paste the subject for the response, and apparently this does not
always
work so well.

Here are my comments :

&gt;<i> Date: Sun, 18 Oct 2009 12:52:18 +1100
</I>&gt;<i> From: Zenaan Harkness &lt;<A HREF="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">zen at freedbms.net</A>&gt;
</I>&gt;<i> Subject: Re: [stringtemplate-interest] null vs missing vs 
</I>&gt;<i> empty	vs
</I>&gt;<i> 	nonexistent
</I>&gt;<i> To: <A HREF="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">stringtemplate-interest at antlr.org</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">20091018015218.GA4077 at ip61</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=us-ascii
</I>&gt;<i> 
</I>&gt;<i> On Fri, Oct 16, 2009 at 11:41:43AM +0200, Harry Karadimas wrote:
</I>&gt;<i> &gt; Reminds me of the debates about SQL Null
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; <A HREF="http://en.wikipedia.org/wiki/Null_(SQL">http://en.wikipedia.org/wiki/Null_(SQL</A>)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; One other question is :
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What must the user know about handling of null values to use st ?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If st becomes too complex, this will also hinder its adoption, so 
</I>&gt;<i> &gt; maybe let's not put too many operators/values/cases/options/etc.
</I>&gt;<i> 
</I>&gt;<i> Complexity can be ok, as long as there are counterbalancing 
</I>&gt;<i> factors, such as consistency defaults, consistent treatment/ 
</I>&gt;<i> application of the concept, completeness - not arbitrarily 
</I>&gt;<i> missing key use cases, clean syntax, and flexibility for the 
</I>&gt;<i> ST user/ system designer to choose _where_ in his system to 
</I>&gt;<i> handle different parts of the system's complexity. Handling 
</I>&gt;<i> strictly view-specific &quot;processing&quot; in the view specific tool 
</I>&gt;<i> (ST) rather than having to handle that view specific 
</I>&gt;<i> complexity somewhere else, provides for sanity in the design 
</I>&gt;<i> of the system, even if that means a slightly more featureful ST.
</I>&gt;<i> 
</I>&gt;<i> Hopefully I'm just reiterating the self evident.
</I>&gt;<i> 
</I>&gt;<i> Concept handling consistency, is much more important to 
</I>&gt;<i> ease-of-use (particularly for casual but also regular) ST 
</I>&gt;<i> users, than mere reduction in number of concepts handled/ 
</I>&gt;<i> provided for.
</I>&gt;<i> 
</I>&gt;<i> Eg:
</I>&gt;<i> If I have one part of ST (say IF conditional handling) which 
</I>&gt;<i> compresses all into true or false (btw forcing me to handle 
</I>&gt;<i> 'empty' special casing with view-model 'hacks'/ view-model 
</I>&gt;<i> compexity increase), yet in say anonymous list processing the 
</I>&gt;<i> default ST processing is to treat empty elements as present 
</I>&gt;<i> but empty and I am given special-case option to 'remove' 
</I>&gt;<i> empty elements, then I'm faced with a conceptual inconsistency.
</I>&gt;<i> I am forced to remember, depending on which ST syntax/context 
</I>&gt;<i> I'm in, what the default treatment is in that localised context.
</I>&gt;<i> Increase in cognitive load.
</I>&gt;<i> Bad.
</I>&gt;<i> 
</I>&gt;<i> Conceptual inconsistency is bad complexity.
</I>&gt;<i> 
</I>&gt;<i> Incomplete concept handling for the domain being handled (eg 
</I>&gt;<i> view processing/ ST), is false simplicity.
</I>&gt;<i> 
</I>&gt;<i> Conceptually (syntactically, contextually) consistent and 
</I>&gt;<i> complete tools can and do make the ST user's task easier.
</I>&gt;<i> 
</I>&gt;<i> The real world dictates that we handle complexity.
</I>&gt;<i> 
</I>&gt;<i> The question is always how well does a particular tool, in 
</I>&gt;<i> this case ST, facilitate handling that complexity.
</I>&gt;<i>
</I>
In short, I agree.
 
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; For me mainly three cases are relevant :
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; * there is no attribute named &quot;foo&quot;
</I>&gt;<i> &gt; * there is an attribute named &quot;foo&quot;, and its value is : null
</I>&gt;<i> &gt; * there is an attribute named &quot;foo&quot;, and its value is a string,
</I>&gt;<i> &gt;   which is : &quot;...(whatever, including the empty string)&quot;
</I>&gt;<i> 
</I>&gt;<i> And for the next guy, the empty string is as good as a 
</I>&gt;<i> non-existent or null element.
</I>&gt;<i> 
</I>&gt;<i> It is difficult to argue that empty-string vs 
</I>&gt;<i> non-empty-string is any less valid-view-logic than is 
</I>&gt;<i> existence or non-existence of an attribute.
</I>&gt;<i> 
</I>&gt;<i> Guaranteed, there will be someone's view, somewhere, that 
</I>&gt;<i> requires one, another that requires the other, and another 
</I>&gt;<i> that requires both, in order to generate the corresponding 
</I>&gt;<i> systems respective views.
</I>&gt;<i> 
</I>&gt;<i> &gt; Maybe a fourth case to test if the value is the empty 
</I>&gt;<i> string could be 
</I>&gt;<i> &gt; relevant, and this would autmatically lead to a fifth case 
</I>&gt;<i> where the 
</I>&gt;<i> &gt; trimmed value (removing all spaces, tabs, form feeds, vertical form 
</I>&gt;<i> &gt; feeds, ...) is the empty string.
</I>&gt;<i> 
</I>&gt;<i> Ah yes, you see the possibility.
</I>&gt;<i> 
</I>&gt;<i> :)
</I>
I do indeed ...

&gt;<i> 
</I>&gt;<i> Now we're back to handling all cases.
</I>&gt;<i> 
</I>&gt;<i> To summarise my points:
</I>&gt;<i> 
</I>&gt;<i>    -  Real world dictates we handle complexity.
</I>&gt;<i> 
</I>&gt;<i>    -  Incomplete concept handling is false simplicity.
</I>&gt;<i> 
</I>&gt;<i>    -  Concept handling inconsistency is bad complexity.
</I>&gt;<i> 
</I>&gt;<i>    -  We should aim for conceptually complete, yet consistent, tools
</I>&gt;<i>       (according to the domain of the tool eg view handling,
</I>&gt;<i>       programming, etc)
</I>&gt;<i> 
</I>&gt;<i> cheers
</I>&gt;<i> zen
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> Homepage: www.SoulSound.net -- Free Australia: www.UPMART.org 
</I>&gt;<i> Please respect the confidentiality of this email as sensibly 
</I>&gt;<i> warranted.
</I>&gt;<i> 
</I>&gt;<i> 
</I>

Let's not overrate these issues; after all st has worked quite 
well for me (and for others I guess) in the current form. After 
all, having only whitespace in the model may also be treated as
a model issue; if whitespace means empty, the model could be 
responsible for trimming strings.

The choice of the operators to propose is not so trivial,
I guess. Self-explanatory words are difficult to find,
because of the ambiguity of words like &quot;empty&quot;. Here are
the terms that I use in my java code, let me know what 
you think of it, I don't say they are ideal :

1) A general, broad-use operator, to be used in 80-99% of the cases :
if isempty(foo) : foo is undefined, or null, or the empty string, 
  or only whitespace : in short, it does not contain a meaningful,
  useable, displayable value.

2) Specific operators, to be used in more specific cases :
if isundefined(foo) : foo is not defined, no attribute has been set
  for foo in st
if isnull(foo) : foo exists but it contains the value null
if isemptystring(foo) : foo exists but it is equal to the 
  empty string
if iswhitespace(foo) : foo exists but it contains only whitespace
  or the empty string

3) Boolean operators
if istrue(foo) : foo contains a boolean with the value true, or
  a string that is equal to &quot;true&quot; (case-insensitive)
if isfalse(foo) : foo contains a boolean with the value false, or
  a string that is equal to &quot;false&quot; (case-insensitive)

4) No operator at all
if (foo) : what should that mean ? The more practical case would be
  for me the value of !isempty(foo). But I admit this might not
  have the same meaning for everybody. For me 99% of the times
  I want to test if there is something to display, in constructs
  like the ones that appear in Terence's paper :
  $if(title)$
  &lt;h1&gt;$title$&lt;/h1&gt;
  $endif$

As for an &quot;ismissing&quot; operator, I don't see how we can introduce 
a special value that would mean : &quot;foo is defined, and it contains
a value that indicates that a value is missing for it&quot;
Similarly, we could also have a value that indicates &quot;foo is 
defined, and it contains a value that indicates that an error has 
occurred when its value had to be computed / retrieved&quot;

For the cases of missing value in the model (different from not 
defining the attribute in st), and error value in the model, we 
should leave the decisions of artifacts of representation to the
model, as there is no accepted standard to represent this in 
java/C#, AFAIK.

Best regards,


                                                  Harry Karadimas

______________________________________________________________________
Dr Harry Karadimas,  Medecin Ingenieur
resp. Recherche et Developpement, Applications medicales
Departement d'Information Hospitalier (DIH)
C.H.U. Albert Chenevier - Henri Mondor 
51, av. du Marechal de Lattre de Tassigny               94010  CRETEIL
tel : (00 33 1) 49 81 21 79, [0687353384]  fax : (00 33 1) 49 81 27 08
secr.: (00 33 1) 49 81 23 82         m.el.:<A HREF="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">harry.karadimas at hmn.aphp.fr</A>
 



</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002310.html">[stringtemplate-interest] On Pragmatism Violating Purity	For	The Win
</A></li>
	<LI>Next message: <A HREF="002316.html">[stringtemplate-interest] null vs missing vs empty	vs	nonexistent
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2305">[ date ]</a>
              <a href="thread.html#2305">[ thread ]</a>
              <a href="subject.html#2305">[ subject ]</a>
              <a href="author.html#2305">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">More information about the stringtemplate-interest
mailing list</a><br>
</body></html>
