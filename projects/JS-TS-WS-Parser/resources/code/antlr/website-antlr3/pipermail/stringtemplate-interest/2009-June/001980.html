<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [stringtemplate-interest] static typing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:stringtemplate-interest%40antlr.org?Subject=Re:%20%5Bstringtemplate-interest%5D%20static%20typing&In-Reply-To=%3CDC0D1533-4E86-44A1-88A2-7C1D6FE08C6C%40cs.usfca.edu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001982.html">
   <LINK REL="Next"  HREF="001984.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[stringtemplate-interest] static typing</H1>
    <B>Terence Parr</B> 
    <A HREF="mailto:stringtemplate-interest%40antlr.org?Subject=Re:%20%5Bstringtemplate-interest%5D%20static%20typing&In-Reply-To=%3CDC0D1533-4E86-44A1-88A2-7C1D6FE08C6C%40cs.usfca.edu%3E"
       TITLE="[stringtemplate-interest] static typing">parrt at cs.usfca.edu
       </A><BR>
    <I>Fri Jun 19 12:11:26 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001982.html">[stringtemplate-interest] static typing
</A></li>
        <LI>Next message: <A HREF="001984.html">[stringtemplate-interest] static typing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1980">[ date ]</a>
              <a href="thread.html#1980">[ thread ]</a>
              <a href="subject.html#1980">[ subject ]</a>
              <a href="author.html#1980">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Jun 18, 2009, at 6:51 PM, Bill Venners wrote:

&gt;<i> Hi Terrence,
</I>&gt;<i>
</I>&gt;<i> On Thu, Jun 18, 2009 at 11:29 AM, Terence Parr &lt;<A HREF="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">parrt at cs.usfca.edu</A>&gt;  
</I>&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Howdy. One of the things I would like to consider for the next  
</I>&gt;&gt;<i> version
</I>&gt;&gt;<i> of ST is static type checking. Easy way to do that is to generate  
</I>&gt;&gt;<i> Java
</I>&gt;&gt;<i> code from the templates and then let the compiler figure it out. If I
</I>&gt;&gt;<i> want to keep the system interpreted, though, we need to be more
</I>&gt;&gt;<i> clever. We could keep the interpreted nature but generate some  
</I>&gt;&gt;<i> proxies
</I>&gt;&gt;<i> that provided setter methods. For example,
</I>&gt;<i>
</I>&gt;<i> Static typing? Blasphemy!
</I>
Yeah, I know. in my paper, I suggested that type information was an  
entanglement with a model, which is. However, we actually have to know  
the type we are using properties of an incoming object. to be  
completely disentangle, we need to restrict our session to the Object  
interface (i.e., it can answer toString()). In practice, $user.name$  
is required. We don't explicitly say the type, but that doesn't mean  
that user doesn't have to satisfy a certain interface.

I just had a conversation with Tom Burns, the coinventor of ST. He  
pointed out that, while it sometimes bites you, getting the name wrong  
and the type wrong is not a huge stumbling block. In fact, he points  
out that sometimes he relies on inexact type. So, $user.name$ should  
work in most cases, but if he passes in something without a name  
property, it just evaluates to null. He relies on that for flexibility.

He also indicated that he has perhaps 40,000 templates ( multilingual  
stuff). creating 40,000 classes to get static typing is not a good  
trade.

He things that ST could be faster, but he just throws hardware the  
problem for now.

&gt;<i> Actually, I must say that one problem I've had with ST is that I have
</I>&gt;<i> on occasion deployed bugs that were simply typos. I like being able to
</I>&gt;<i> run in interpreted mode for quick deployment, but frankly wanted some
</I>&gt;<i> kind of name checking that was automated.
</I>
Yeah, that's my motivation: I want to use the compiler to check for  
problems with names and also with types. after talking to calm this  
morning however, I'm not sure the trade-off is worth it. probably we  
could do some &quot;coverage&quot; type stuff to help us check things at runtime.

&gt;<i> Still don't have it. Type
</I>&gt;<i> checking would do it, but in thinking about it a long time ago, I
</I>&gt;<i> thought there were some dynamic things you do in ST that wouldn't be
</I>&gt;<i> possible with a static approach.
</I>
Yeah, the static thing really screw stuff up. on the other hand, it  
makes a C. and C++ targets impossible in interpreted mode. we could  
generate code that implemented a subset, though.

&gt;<i> I can't remember exactly what I was
</I>&gt;<i> thinking of, but something like selecting a template based on an
</I>&gt;<i> attribute passed in, then using that template? Not sure.
</I>
Yep, you are right.

&gt;<i> So I'm curious, 1) is there any dynamic feature of ST you can think of
</I>&gt;<i> that would not work with a static approach?
</I>
yep.

&gt;<i> And 2), what made you want
</I>&gt;<i> to add static typing?
</I>
I can help it; I like type information for maintenance and I want to  
check for misnamed attributes. I'm beginning to think it's not worth  
it, though. For code generation like ANTLR stuff, generating code  
would be fine. For websites, generating code won't work because of all  
the classes you generate.

Ter
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001982.html">[stringtemplate-interest] static typing
</A></li>
	<LI>Next message: <A HREF="001984.html">[stringtemplate-interest] static typing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1980">[ date ]</a>
              <a href="thread.html#1980">[ thread ]</a>
              <a href="subject.html#1980">[ subject ]</a>
              <a href="author.html#1980">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">More information about the stringtemplate-interest
mailing list</a><br>
</body></html>
