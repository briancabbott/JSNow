<html>
	<head>
		<title>MS SQL Server 2000 SELECT statement</title></head>
	<body>
		<font face="Courier">// Version: 0.8<br>
			// ANTLR Version: 2.7.2<br>
			// Date: 2003.08.25<br>
			//<br>
			// Description: This is a MS SQL Server 2000 SELECT statement grammar.<br>
			//<br>
			// 
			=======================================================================================<br>
			// Author: Tomasz Jastrzebski<br>
			// Contact: <A href="mailto:tdjastrzebski@yahoo.com">tdjastrzebski@yahoo.com</A><br>
			// Working parser/lexer generated based on this grammar will available for some 
			time at:<br>
			// <A href="http://jastrzebski.europe.webmatrixhosting.net/mssqlparser.aspx">http://jastrzebski.europe.webmatrixhosting.net/mssqlparser.aspx</A>
			<br>
			<br>
			options {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;language = "CSharp";<br>
			}<br>
			<br>
			// PARSER 
			********************************************************************************<br>
			<br>
			class SqlParser extends Parser;<br>
			options {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;k = 2;<br>
			}<br>
			<br>
			// starting rule<br>
			statement<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: selectStatement (SEMICOLON)? EOF<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			selectStatement<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;queryExpression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(computeClause)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(forClause)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(optionClause)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			queryExpression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: subQueryExpression (unionOperator 
			subQueryExpression)* (orderByClause)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			subQueryExpression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;querySpecification<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| LPAREN queryExpression RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			querySpecification<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;selectClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(fromClause)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(whereClause)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(groupByClause (havingClause)? )?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
			selectClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: SELECT (ALL | DISTINCT)? (TOP Integer (PERCENT)? 
			(WITH TIES)? )? selectList<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			whereClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: WHERE searchCondition<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			orderByClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: ORDER BY expression (ASC | DESC)? (COMMA expression 
			(ASC | DESC)? )*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			groupByClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: GROUP BY (ALL)? expression (COMMA expression)* (WITH 
			(CUBE | ROLLUP) )?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			havingClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: HAVING searchCondition<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			optionClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: OPTION LPAREN queryHint (COMMA queryHint)* RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			queryHint<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(HASH | ORDER) GROUP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (CONCAT | HASH | MERGE) UNION<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (LOOP | MERGE | HASH) JOIN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| FAST Integer<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| FORCE ORDER<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| MAXDOP Integer<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ROBUST PLAN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| KEEP PLAN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| KEEPFIXED PLAN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| EXPAND VIEWS<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			forClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FOR (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BROWSE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| XML (RAW | AUTO | EXPLICIT) (COMMA XMLDATA)? (COMMA 
			ELEMENTS)? (COMMA BINARY BASE64)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			computeClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;COMPUTE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// only allowed functions are: AVG, COUNT, MAX, MIN, 
			STDEV, STDEVP, VAR, VARP, SUM<br>
			&nbsp;&nbsp;&nbsp;&nbsp;identifier LPAREN expression RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(COMMA identifier LPAREN expression RPAREN)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(BY expression (COMMA expression)* )?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			searchCondition<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: subSearchCondition ( (AND | OR) subSearchCondition )*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			subSearchCondition<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(NOT)? (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(LPAREN 
			searchCondition RPAREN) =&gt; LPAREN searchCondition RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| predicate<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			predicate<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expression (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// expression 
			comparisonOperator expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comparisonOperator (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (ALL | SOME | 
			ANY) LPAREN selectStatement RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| IS (NOT)? NULL<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (NOT)? (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIKE 
			expression (ESCAPE expression)? // only single char<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BETWEEN 
			expression AND expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| IN LPAREN (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(selectStatement) 
			=&gt; selectStatement<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
			expression (COMMA expression)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) 
			RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| CONTAINS LPAREN (dbObject | STAR) COMMA 
			(stringLiteral | Variable) RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| FREETEXT LPAREN (dbObject | STAR) COMMA 
			(stringLiteral | Variable) RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| EXISTS LPAREN selectStatement RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			selectList<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: selectItem ( COMMA selectItem )*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			selectItem<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STAR // "*, *" is a valid select list<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// starts with: "alias = column_name"<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alias2) =&gt; (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alias2 dbObject 
			COMMA) =&gt; alias2 column<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (alias2 dbObject 
			(binaryOperator | LPAREN)) =&gt; alias2 expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (alias2 column) =&gt; alias2 
			column<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (alias2 expression) =&gt; 
			alias2 expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// all table columns: "table.*"<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (tableColumns) =&gt; tableColumns<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// some shortcuts:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (dbObject (alias1)? COMMA) =&gt; column (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (dbObject (binaryOperator | LPAREN) ) =&gt; 
			expression (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// less obvious cases:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (column) =&gt; column (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (expression) =&gt; expression (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			fromClause<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: FROM tableSource (COMMA tableSource)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			tableSource<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: subTableSource (joinedTable)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			subTableSource<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPAREN (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(joinedTables) 
			=&gt; joinedTables RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (queryExpression) 
			=&gt; queryExpression RPAREN alias1 // "derived table", mandatory alias<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (function) =&gt; function (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| dbObject (alias1)? ( (WITH)? LPAREN tableHint (COMMA 
			tableHint)* RPAREN )?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| Variable (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (CONTAINSTABLE | FREETEXTTABLE) LPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbObject COMMA (dbObject | 
			STAR) COMMA (stringLiteral | Variable) (COMMA Integer)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RPAREN (alias1)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| COLON COLON function (alias1)? // built-in function<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			joinedTable<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CROSS JOIN subTableSource<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "joinHint JOIN" is invalid join 
			expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ( (INNER | (LEFT | RIGHT | FULL) (OUTER)? ) 
			(joinHint)? )? JOIN tableSource ON searchCondition<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;<br>
			<br>
			joinedTables<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: subTableSource (joinedTable)+<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			joinHint<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOOP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| HASH<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| MERGE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| REMOTE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			tableHint<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INDEX (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPAREN (identifier 
			| Integer) ( COMMA (identifier | Integer) )* RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ASSIGNEQUAL 
			identifier&nbsp;&nbsp;&nbsp;&nbsp;// old index hint syntax<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| FASTFIRSTROW<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| HOLDLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| NOLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| PAGLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| READCOMMITED<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| READPAST<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| READUNCOMMITED<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| REPEATABLEREAD<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ROWLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| SERIALIZABLE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| TABLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| TABLOCKX<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| UPDLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| XLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			collate<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: COLLATE identifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			alias1<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: // alias name can also be single-quoted literal (but 
			not for table names)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(AS)? (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| stringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| keywordAsIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			alias2<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| stringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| keywordAsIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ASSIGNEQUAL<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			tableColumns<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;o:dbObject DOT_STAR<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			column<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(PLUS)* // "++column_name" is valid and updatable 
			column name<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbObject<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for expression like "(column)" SQL 
			Server returns updatable column<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| LPAREN column RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(collate)? // it is not well documented but COLLATE can 
			be used almost anywhere ...<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: // current definition ignores operator precedence<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subExpression (binaryOperator 
			subExpression)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			subExpression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(unaryOperator)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constant<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| Variable<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (function) =&gt; function<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| LPAREN (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(selectStatement) 
			=&gt; selectStatement // select statement returning a single value<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| dbObject&nbsp;&nbsp;&nbsp;&nbsp;// column<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| parameterlessFunction<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| caseFunction<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| castFunction<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(collate)?&nbsp;&nbsp;&nbsp;&nbsp;// it is not well 
			documented but COLLATE can be used almost everywhere ...<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			// todo: create a separate rule for aggregate functions<br>
			function<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: // LEFT and RIGHT keywords are also function names<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(dbObject | LEFT | RIGHT) LPAREN (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expression (COMMA 
			expression)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 
			STAR&nbsp;&nbsp;&nbsp;&nbsp;// aggregate functions like Count(), Checksum() 
			accept "*" as a parameter<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (ALL | DISTINCT) (STAR | 
			expression) // aggregate function<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Variable ASSIGNEQUAL 
			expression (COMMA Variable ASSIGNEQUAL expression)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			caseFunction<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: CASE (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expression (WHEN 
			expression THEN expression)+<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (WHEN searchCondition THEN 
			expression)+&nbsp;&nbsp;&nbsp;&nbsp;// boolean expression<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(ELSE expression)? END<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			castFunction<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: CAST LPAREN expression AS identifier (LPAREN Integer 
			(COMMA Integer)? RPAREN)? RPAREN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			dbObject<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// server.catalog.schema.object<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// server.catalog..object<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(identifier | IDENTITYCOL | ROWGUIDCOL | 
			keywordAsIdentifier) (<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOT (identifier | 
			IDENTITYCOL | ROWGUIDCOL | keywordAsIdentifier)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (DOT DOT) =&gt; DOT DOT 
			(identifier | IDENTITYCOL | ROWGUIDCOL | keywordAsIdentifier)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			parameterlessFunction<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: // any others ?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CURRENT_TIMESTAMP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| CURRENT_USER<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| SESSION_USER<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| SYSTEM_USER<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			systemVariable<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F_CONNECTIONS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_CPU_BUSY
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_CURSOR_ROWS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_DATEFIRST
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_DBTS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_ERROR
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_FETCH_STATUS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_IDENTITY
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_IDLE
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_IO_BUSY
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_LANGID
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_LANGUAGE
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_LOCK_TIMEOUT
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_MAX_CONNECTIONS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_MAX_PRECISION
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_NESTLEVEL
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_OPTIONS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_PACK_RECEIVED
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_PACK_SENT
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_PACKET_ERRORS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_PROCID
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_REMSERVER
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_ROWCOUNT
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_SERVERNAME
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_SERVICENAME
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_SPID
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_TEXTSIZE
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_TIMETICKS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_TOTAL_ERRORS
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_TOTAL_READ
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_TOTAL_WRITE
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_TRANCOUNT
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| F_VERSION<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;<br>
			<br>
			keywordAsIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AUTO<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| BASE64<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| BINARY<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| CAST<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| CONCAT<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| CUBE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ELEMENTS<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| EXPAND<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| EXPLICIT<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| FAST<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| FASTFIRSTROW<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| FORCE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| HASH<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| KEEP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| KEEPFIXED<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| LOOP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| MAXDOP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| MERGE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| NOLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| PAGLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| RAW<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| READCOMMITED<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| READPAST<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| READUNCOMMITED<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| REMOTE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| REPEATABLEREAD<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ROBUST<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ROLLUP<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ROWLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| SERIALIZABLE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| TABLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| TABLOCKX<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| TIES<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| UPDLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| VIEWS<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| XLOCK<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| XML<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| XMLDATA<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			stringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnicodeStringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ASCIIStringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			identifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NonQuotedIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| QuotedIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			constant<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: Integer | Real | NULL | stringLiteral | HexLiteral | 
			Currency | ODBCDateTime | systemVariable<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			unaryOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: PLUS | MINUS | TILDE<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			binaryOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: arithmeticOperator | bitwiseOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			arithmeticOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: PLUS | MINUS | STAR | DIVIDE | MOD<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			bitwiseOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: AMPERSAND | TILDE | BITWISEOR | BITWISEXOR<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			comparisonOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSIGNEQUAL | NOTEQUAL1 | NOTEQUAL2 | 
			LESSTHANOREQUALTO1 | LESSTHANOREQUALTO2
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| LESSTHAN | GREATERTHANOREQUALTO1 | 
			GREATERTHANOREQUALTO2 | GREATERTHAN<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
			logicalOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: ALL | AND | ANY | BETWEEN | EXISTS | IN | LIKE | NOT 
			| OR | SOME<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			unionOperator<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: UNION (ALL)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			// LEXER 
			*********************************************************************************<br>
			<br>
			class SqlLexer extends Lexer;<br>
			<br>
			options {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;testLiterals = false;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;k = 2;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;caseSensitive = false;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;caseSensitiveLiterals = false;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;charVocabulary='\u0000'..'\uFFFE';<br>
			}<br>
			<br>
			tokens {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ADD = "add" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ALL = "all" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ALTER = "alter" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;AND = "and" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ANY = "any" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;AS = "as" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ASC = "asc" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;AUTHORIZATION = "authorization" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;AUTO = "auto" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BACKUP = "backup" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BASE64 = "base64" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BEGIN = "begin" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BETWEEN = "between" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BINARY = "binary" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BREAK = "break" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BROWSE = "browse" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BULK = "bulk" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;BY = "by" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CASCADE = "cascade" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CASE = "case" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CAST = "cast" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CHECK = "check" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CHECKPOINT = "checkpoint" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CLOSE = "close" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CLUSTERED = "clustered" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// COALESCE = "coalesce" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;COLLATE = "collate" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;COLUMN = "column" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;COMMIT = "commit" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;COMPUTE = "compute" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CONCAT = "concat" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CONSTRAINT = "constraint" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CONTAINS = "contains" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CONTAINSTABLE = "containstable" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CONTINUE = "continue" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// CONVERT = "convert" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CREATE = "create" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CROSS = "cross" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CUBE = "cube" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CURRENT = "current" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CURRENT_DATE = "current_date" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CURRENT_TIME = "current_time" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CURRENT_TIMESTAMP = "current_timestamp" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CURRENT_USER = "current_user" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CURSOR = "cursor" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DATABASE = "database" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DBCC = "dbcc" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DEALLOCATE = "deallocate" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DECLARE = "declare" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DEFAULT = "default" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DELETE = "delete" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DENY = "deny" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DESC = "desc" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DISK = "disk" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DISTINCT = "distinct" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DISTRIBUTED = "distributed" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DOUBLE = "double" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DROP = "drop" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// DUMMY = "dummy" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;DUMP = "dump" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ELEMENTS = "elements" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ELSE = "else" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;END = "end" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ERRLVL = "errlvl" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ESCAPE = "escape" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXCEPT = "except" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXEC = "exec" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXECUTE = "execute" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXISTS = "exists" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXIT = "exit" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXPAND = "expand" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;EXPLICIT = "explicit" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FAST = "fast" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FASTFIRSTROW = "fastfirstrow" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FETCH = "fetch" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FILE = "file" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FILLFACTOR = "fillfactor" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FOR = "for" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FORCE = "force" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FOREIGN = "foreign" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FREETEXT = "freetext" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FREETEXTTABLE = "freetexttable" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FROM = "from" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FULL = "full" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;FUNCTION = "function" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;GOTO = "goto" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;GRANT = "grant" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;GROUP = "group" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;HASH = "hash" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;HAVING = "having" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;HOLDLOCK = "holdlock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;IDENTITY = "identity" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;IDENTITY_INSERT = "identity_insert" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;IDENTITYCOL = "identitycol" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;IF = "if" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;IN = "in" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;INDEX = "index" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;INNER = "inner" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;INSERT = "insert" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;INTERSECT = "intersect" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;INTO = "into" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;IS = "is" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;JOIN = "join" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;KEEP = "keep" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;KEEPFIXED = "keepfixed" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;KEY = "key" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;KILL = "kill" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;LEFT = "left" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;LIKE = "like" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;LINENO = "lineno" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;LOAD = "load" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;LOOP = "loop" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;MAXDOP = "maxdop" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;MERGE = "merge" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;NATIONAL = "national" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;NOCHECK = "nocheck" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;NOLOCK = "nolock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;NONCLUSTERED = "nonclustered" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;NOT = "not" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;NULL = "null" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// NULLIF = "nullif" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OF = "of" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OFF = "off" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OFFSETS = "offsets" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ON = "on" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OPEN = "open" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OPENDATASOURCE = "opendatasource" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OPENQUERY = "openquery" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OPENROWSET = "openrowset" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OPENXML = "openxml" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OPTION = "option" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OR = "or" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ORDER = "order" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OUTER = "outer" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;OVER = "over" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PAGLOCK = "paglock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PERCENT = "percent" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PLAN = "plan" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PRECISION = "precision" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY = "primary" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PRINT = "print" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PROC = "proc" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE = "procedure" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;PUBLIC = "public" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RAISERROR = "raiserror" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RAW = "raw" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;READ = "read" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;READCOMMITED = "readcommited" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;READPAST = "readpast" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;READTEXT = "readtext" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;READUNCOMMITED = "readuncommited" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RECONFIGURE = "reconfigure" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;REFERENCES = "references" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;REMOTE = "remote" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;REPEATABLEREAD = "repeatableread" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;REPLICATION = "replication" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RESTORE = "restore" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RESTRICT = "restrict" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RETURN = "return" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;REVOKE = "revoke" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RIGHT = "right" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ROBUST = "robust" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK = "rollback" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ROLLUP = "rollup" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ROWCOUNT = "rowcount" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ROWGUIDCOL = "rowguidcol" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ROWLOCK = "rowlock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;RULE = "rule" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SAVE = "save" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SCHEMA = "schema" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SELECT = "select" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SERIALIZABLE = "serializable" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SESSION_USER = "session_user" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SET = "set" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SETUSER = "setuser" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SHUTDOWN = "shutdown" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SOME = "some" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;STATISTICS = "statistics" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_USER = "system_user" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TABLE = "table" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TABLOCK = "tablock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TABLOCKX = "tablockx" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TEXTSIZE = "textsize" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;THEN = "then" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TIES = "ties" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TO = "to" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TOP = "top" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TRAN = "tran" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TRANSACTION = "transaction" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TRIGGER = "trigger" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TRUNCATE = "truncate" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;TSEQUAL = "tsequal" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;UNION = "union" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;UNIQUE = "unique" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;UPDATE = "update" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;UPDATETEXT = "updatetext" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;UPDLOCK = "updlock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;USE = "use" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;USER = "user" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;VALUES = "values" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;VARYING = "varying" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;VIEW = "view" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;VIEWS = "views" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;WAITFOR = "waitfor" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;WHEN = "when" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;WHERE = "where" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;WHILE = "while" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;WITH = "with" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;WRITETEXT = "writetext" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;XLOCK = "xlock" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;XML = "xml" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;XMLDATA = "xmldata" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// system variables<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_CONNECTIONS = "@@connections" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_CPU_BUSY = "@@cpu_busy" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_CURSOR_ROWS = "@@cursor_rows" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_DATEFIRST = "@@datefirst" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_DBTS = "@@dbts" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_ERROR = "@@error" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_FETCH_STATUS = "@@fetch_status" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_IDENTITY = "@@identity" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_IDLE = "@@idle" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_IO_BUSY = "@@io_busy" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_LANGID = "@@langid" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_LANGUAGE = "@@language" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_LOCK_TIMEOUT = "@@lock_timeout" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_MAX_CONNECTIONS = "@@max_connections" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_MAX_PRECISION = "@@max_precision" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_NESTLEVEL = "@@nestlevel" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_OPTIONS = "@@options" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_PACK_RECEIVED = "@@pack_received" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_PACK_SENT = "@@pack_sent" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_PACKET_ERRORS = "@@packet_errors" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_PROCID = "@@procid" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_REMSERVER = "@@remserver" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_ROWCOUNT = "@@rowcount" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_SERVERNAME = "@@servername" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_SERVICENAME = "@@servicename" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_SPID = "@@spid" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_TEXTSIZE = "@@textsize" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_TIMETICKS = "@@timeticks" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_TOTAL_ERRORS = "@@total_errors" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_TOTAL_READ = "@@total_read" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_TOTAL_WRITE = "@@total_write" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_TRANCOUNT = "@@trancount" ;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;F_VERSION = "@@version" ;<br>
			}<br>
			<br>
			// Operators<br>
			<br>
			protected DOT:; // generated as a part of Number rule<br>
			COLON : ':' ;<br>
			COMMA : ',' ;<br>
			SEMICOLON : ';' ;<br>
			<br>
			LPAREN : '(' ;<br>
			RPAREN : ')' ;<br>
			//LSQUARE : '[' ;<br>
			//RSQUARE : ']' ;<br>
			<br>
			ASSIGNEQUAL : '=' ;<br>
			NOTEQUAL1 : "&lt;&gt;" ;<br>
			NOTEQUAL2 : "!=" ;<br>
			LESSTHANOREQUALTO1 : "&lt;=" ;<br>
			LESSTHANOREQUALTO2 : "!&gt;" ;<br>
			LESSTHAN : "&lt;" ;<br>
			GREATERTHANOREQUALTO1 : "&gt;=" ;<br>
			GREATERTHANOREQUALTO2 : "!&lt;" ;<br>
			GREATERTHAN : "&gt;" ;<br>
			<br>
			DIVIDE : '/' ;<br>
			PLUS : '+' ;<br>
			MINUS : '-' ;<br>
			STAR : '*' ;<br>
			MOD : '%' ;<br>
			<br>
			AMPERSAND : '&amp;' ;<br>
			TILDE : '~' ;<br>
			BITWISEOR : '|' ;<br>
			BITWISEXOR : '^' ;<br>
			DOT_STAR : ".*" ;<br>
			<br>
			Whitespace<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: (' ' | '\t' | '\n' | '\r')<br>
			&nbsp;&nbsp;&nbsp;&nbsp;{ _ttype = Token.SKIP; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			// COMMENTS<br>
			SingleLineComment<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: "--"( ~('\r' | '\n') )*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;{ _ttype = Token.SKIP; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			MultiLineComment<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: "/*" (~'*')* '*' ('*' | ( ~('*' | '/') (~'*')* '*') 
			)* '/'<br>
			&nbsp;&nbsp;&nbsp;&nbsp;{ _ttype = Token.SKIP; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			// LITERALS<br>
			<br>
			protected<br>
			Letter<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: 'a'..'z' | '_' | '#' | '@' | '\u0080'..'\ufffe'<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			protected<br>
			Digit<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: '0'..'9'<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			protected<br>
			Integer :;<br>
			<br>
			protected<br>
			Real :;<br>
			<br>
			protected<br>
			Exponent<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: 'e' ( '+' | '-' )? (Digit)+<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			Number<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( (Digit)+ ('.' | 'e') ) =&gt; (Digit)+ ( 
			'.' (Digit)* (Exponent)? | Exponent) { _ttype = Real; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| '.' { _ttype = DOT; } ( (Digit)+ (Exponent)? { _ttype 
			= Real; } )?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| (Digit)+ { _ttype = Integer; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| "0x" ('a'..'f' | Digit)* { _ttype = HexLiteral; } // 
			"0x" is valid hex literal<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			protected<br>
			Currency<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: // generated as a part of NonQuotedIdentifier rule<br>
			&nbsp;&nbsp;&nbsp;&nbsp;('$' | '\u00a3'..'\u00a5' | '\u09f2'..'\u09f3' | 
			'\u0e3f' | '\u20a0'..'\u20a4' | '\u20a6'..'\u20ab')<br>
			&nbsp;&nbsp;&nbsp;&nbsp;((Digit)+ ('.' (Digit)* )? | '.' (Digit)+)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			ODBCDateTime<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: '{' (Whitespace)? ("ts" | 't' | 'd') (Whitespace)?<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('n')? '\'' (~'\'')* '\'' ( 
			'\'' (~'\'')* '\'' )* (Whitespace)? '}'<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			NonQuotedIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;options { testLiterals = true; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Currency) =&gt; Currency { _ttype = 
			Currency; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| ('a'..'z' | '_' | '#' | '\u0080'..'\ufffe') (Letter | 
			Digit)* // first char other than '@'<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			QuotedIdentifier<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;(<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'[' (~']')* ']' (']' (~']')* ']')*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;| '"' (~'"')* '"' ('"' (~'"')* '"')*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;)<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			Variable<br>
			&nbsp;&nbsp;&nbsp;&nbsp;// test for literals in case of a function begining 
			with '@' (eg. "@@ERROR")<br>
			&nbsp;&nbsp;&nbsp;&nbsp;options { testLiterals = true; }<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: '@' (Letter | Digit)+<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<br>
			ASCIIStringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;'\'' (~'\'')* '\'' ( '\'' (~'\'')* '\'' )*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			UnicodeStringLiteral<br>
			&nbsp;&nbsp;&nbsp;&nbsp;:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;'n' '\'' (~'\'')* '\'' ( '\'' (~'\'')* '\'' )*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
			<br>
			// Numeric Constants<br>
			<br>
			protected<br>
			HexLiteral // generated as a part of Number rule<br>
			&nbsp;&nbsp;&nbsp;&nbsp;: // "0x" ('0'..'9' | 'a'..'f')*<br>
			&nbsp;&nbsp;&nbsp;&nbsp;;<br>
		</font>
	</body>
</html>
