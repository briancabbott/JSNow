<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../../../style.css" type="text/css" media="screen">
<link rel="stylesheet" href="../../../../print.css" type="text/css" media="print">
<meta content="TreeAdaptor,org.antlr.runtime.tree.TreeAdaptor,addChild,becomeRoot,create,createFromToken,createFromType,createWithPayload,deleteChild,dupNode,dupTree,errorNode,getChild,getChildCount,getChildIndex,getParent,getText,getToken,getTokenStartIndex,getTokenStopIndex,getType,getUniqueID,isNil,nil,replaceChildren,rulePostProcessing,setChild,setChildIndex,setParent,setText,setTokenBoundaries,setType" name="keywords">
<title>org.antlr.runtime.tree.TreeAdaptor</title>
</head>
<body>
<script type="text/javascript" language="javascript" src="../../../../asdoc.js"></script><script type="text/javascript" language="javascript" src="../../../../cookies.js"></script><script type="text/javascript" language="javascript">
<!--
				asdocTitle = 'TreeAdaptor - ANTLR 3 Runtime';
				var baseRef = '../../../../';
				window.onload = configPage;
			--></script>
<table style="display:none" id="titleTable" cellspacing="0" cellpadding="0" class="titleTable">
<tr>
<td align="left" class="titleTableTitle">API Documentation</td><td align="right" class="titleTableTopNav"><a onclick="loadClassListFrame('../../../../all-classes.html')" href="../../../../package-summary.html">All&nbsp;Packages</a>&nbsp;|&nbsp;<a onclick="loadClassListFrame('../../../../all-classes.html')" href="../../../../class-summary.html">All&nbsp;Classes</a>&nbsp;|&nbsp;<a onclick="loadClassListFrame('../../../../index-list.html')" href="../../../../all-index-A.html">Index</a>&nbsp;|&nbsp;<a href="../../../../index.html?org/antlr/runtime/tree/TreeAdaptor.html&amp;org/antlr/runtime/tree/class-list.html" id="framesLink1">Frames</a><a onclick="parent.location=document.location" href="" style="display:none" id="noFramesLink1">No&nbsp;Frames</a></td><td rowspan="3" align="right" class="titleTableLogo"><img alt="Adobe Logo" title="Adobe Logo" class="logoImage" src="../../../../images/logo.jpg"></td>
</tr>
<tr class="titleTableRow2">
<td align="left" id="subTitle" class="titleTableSubTitle">Interface&nbsp;TreeAdaptor</td><td align="right" id="subNav" class="titleTableSubNav"><a href="#methodSummary">Methods</a></td>
</tr>
<tr class="titleTableRow3">
<td colspan="2">&nbsp;</td>
</tr>
</table>
<script type="text/javascript" language="javascript">
<!--
if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("InterfaceÂ TreeAdaptor"); titleBar_setSubNav(false,false,false,false,false,false,true,false,false,false,false,false,false,false);}
--></script>
<div class="MainContent">
<table cellspacing="0" cellpadding="0" class="classHeaderTable">
<tr>
<td class="classHeaderTableLabel">Package</td><td><a onclick="javascript:loadClassListFrame('class-list.html')" href="package-detail.html">org.antlr.runtime.tree</a></td>
</tr>
<tr>
<td class="classHeaderTableLabel">Interface</td><td class="classSignature">public interface TreeAdaptor</td>
</tr>
<tr>
<td class="classHeaderTableLabel">Implementors</td><td><a href="../tree/BaseTreeAdaptor.html">BaseTreeAdaptor</a></td>
</tr>
</table>
<p></p> How to create and navigate trees.  Rather than have a separate factory
   and adaptor, I've merged them.  Makes sense to encapsulate.
     This takes the place of the tree construction code generated in the
   generated code in 2.x and the ASTFactory.
     I do not need to know the type of a tree at all so they are all
   generic Objects.  This may increase the amount of typecasting needed. :(
  <p></p>
<br>
<hr>
</div>
<a name="methodSummary"></a>
<div class="summarySection">
<div class="summaryTableTitle">Public Methods</div>
<table id="summaryTableMethod" class="summaryTable " cellpadding="3" cellspacing="0">
<tr>
<th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined&nbsp;by</th>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#addChild()">addChild</a>(t:Object, child:Object):void</div>
<div class="summaryTableDescription"> Add a child to the tree t.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#becomeRoot()">becomeRoot</a>(newRoot:Object, oldRoot:Object):Object</div>
<div class="summaryTableDescription"> If oldRoot is a nil root, just copy or move the children to newRoot.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#create()">create</a>(... args):Object</div>
<div class="summaryTableDescription">
   Private method used by generated code.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#createFromToken()">createFromToken</a>(tokenType:int, fromToken:<a href="../Token.html">Token</a>, text:String = null):Object</div>
<div class="summaryTableDescription"> Create a new node derived from a token, with a new token type.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#createFromType()">createFromType</a>(tokenType:int, text:String):Object</div>
<div class="summaryTableDescription"> Create a new node derived from a token, with a new token type.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#createWithPayload()">createWithPayload</a>(payload:<a href="../Token.html">Token</a>):Object</div>
<div class="summaryTableDescription"> Create a tree node from Token object; for CommonTree type trees,
    then the token just becomes the payload.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#deleteChild()">deleteChild</a>(t:Object, i:int):Object</div>
<div class="summaryTableDescription"> Remove ith child and shift children down from right.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#dupNode()">dupNode</a>(treeNode:Object):Object</div>
<div class="summaryTableDescription"> Duplicate a single tree node.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#dupTree()">dupTree</a>(tree:Object):Object</div>
<div class="summaryTableDescription"> Duplicate tree recursively, using dupNode() for each node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#errorNode()">errorNode</a>(input:<a href="../TokenStream.html">TokenStream</a>, start:<a href="../Token.html">Token</a>, stop:<a href="../Token.html">Token</a>, e:<a href="../RecognitionException.html">RecognitionException</a>):Object</div>
<div class="summaryTableDescription"> Return a tree node representing an error.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getChild()">getChild</a>(t:Object, i:int):Object</div>
<div class="summaryTableDescription"> Get a child 0..n-1 node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getChildCount()">getChildCount</a>(t:Object):int</div>
<div class="summaryTableDescription"> How many children?  If 0, then this is a leaf node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getChildIndex()">getChildIndex</a>(t:Object):int</div>
<div class="summaryTableDescription"> What index is this node in the child list? Range: 0..n-1
    If your node type doesn't handle this, it's ok but the tree rewrites
    in tree parsers need this functionality.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getParent()">getParent</a>(t:Object):Object</div>
<div class="summaryTableDescription"> Who is the parent node of this node; if null, implies node is root.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getText()">getText</a>(t:Object):String</div>
<div class="summaryTableDescription"></div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getToken()">getToken</a>(t:Object):<a href="../../runtime/Token.html">Token</a>
</div>
<div class="summaryTableDescription"> Return the token object from which this node was created.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getTokenStartIndex()">getTokenStartIndex</a>(t:Object):int</div>
<div class="summaryTableDescription"> Get the token start index for this subtree; return -1 if no such index </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getTokenStopIndex()">getTokenStopIndex</a>(t:Object):int</div>
<div class="summaryTableDescription"> Get the token stop index for this subtree; return -1 if no such index </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getType()">getType</a>(t:Object):int</div>
<div class="summaryTableDescription"> For tree parsing, I need to know the token type of a node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#getUniqueID()">getUniqueID</a>(node:Object):int</div>
<div class="summaryTableDescription"> For identifying trees.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#isNil()">isNil</a>(tree:Object):Boolean</div>
<div class="summaryTableDescription"> Is tree considered a nil node used to make lists of child nodes? </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#nil()">nil</a>():Object</div>
<div class="summaryTableDescription"> Return a nil node (an empty but non-null node) that can hold
    a list of element as the children.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#replaceChildren()">replaceChildren</a>(parent:Object, startChildIndex:int, stopChildIndex:int, t:Object):void</div>
<div class="summaryTableDescription"> Replace from start to stop child index of parent with t, which might
    be a list.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#rulePostProcessing()">rulePostProcessing</a>(root:Object):Object</div>
<div class="summaryTableDescription"> Given the root of the subtree created for this rule, post process
    it to do any simplifications or whatever you want.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#setChild()">setChild</a>(t:Object, i:int, child:Object):void</div>
<div class="summaryTableDescription"> Set ith child (0..n-1) to t; t must be non-null and non-nil node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#setChildIndex()">setChildIndex</a>(t:Object, index:int):void</div>
<div class="summaryTableDescription"></div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#setParent()">setParent</a>(t:Object, parent:Object):void</div>
<div class="summaryTableDescription"></div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#setText()">setText</a>(t:Object, text:String):void</div>
<div class="summaryTableDescription"> Node constructors can set the text of a node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#setTokenBoundaries()">setTokenBoundaries</a>(t:Object, startToken:<a href="../Token.html">Token</a>, stopToken:<a href="../Token.html">Token</a>):void</div>
<div class="summaryTableDescription"> Where are the bounds in the input token stream for this node and
    all children?  Each rule that creates AST nodes will call this
    method right before returning.</div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#setType()">setType</a>(t:Object, type:int):void</div>
<div class="summaryTableDescription"> Node constructors can set the type of a node </div>
</td><td class="summaryTableOwnerCol">TreeAdaptor</td>
</tr>
</table>
</div>
<script type="text/javascript" language="javascript">
<!--
showHideInherited();
--></script>
<div class="MainContent">
<a name="methodDetail"></a>
<div class="detailSectionHeader">Method detail</div>
<a name="addChild()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">addChild</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td>
</tr>
</table>
<div class="detailBody">
<code>public function addChild(t:Object, child:Object):void</code><p> Add a child to the tree t.  If child is a flat tree (a list), make all
    in list children of t.  Warning: if t has no children, but child does
    and child isNil then you can decide it is ok to move children to t via
    t.children = child.children; i.e., without copying the array.  Just
    make sure that this is consistent with have the user will build
    ASTs.  Do nothing if t or child is null.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">child</span>:Object</code></td>
</tr>
</table>
</div>
<a name="becomeRoot()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">becomeRoot</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function becomeRoot(newRoot:Object, oldRoot:Object):Object</code><p> If oldRoot is a nil root, just copy or move the children to newRoot.
    If not a nil root, make oldRoot a child of newRoot.
         old=^(nil a b c), new=r yields ^(r a b c)
      old=^(a b c), new=r yields ^(r ^(a b c))
       If newRoot is a nil-rooted single child tree, use the single
    child as the new root node.
         old=^(nil a b c), new=^(nil r) yields ^(r a b c)
      old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
       If oldRoot was null, it's ok, just return newRoot (even if isNil).
         old=null, new=r yields r
      old=null, new=^(nil r) yields ^(nil r)
       Return newRoot.  Throw an exception if newRoot is not a
    simple node or nil root with a single child node--it must be a root
    node.  If newRoot is ^(nil x) return x as newRoot.
       Be advised that it's ok for newRoot to point at oldRoot's
    children; i.e., you don't have to copy the list.  We are
    constructing these nodes so we should have this control for
    efficiency.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">newRoot</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">oldRoot</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="create()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">create</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function create(... args):Object</code><p>
   Private method used by generated code.  Based on type and number of arguments will call one of:
   
    createWithPayload
    createFromToken
    createFromType 
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code>... <span class="label">args</span></code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="createFromToken()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">createFromToken</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function createFromToken(tokenType:int, fromToken:<a href="../Token.html">Token</a>, text:String = null):Object</code><p> Create a new node derived from a token, with a new token type.
    This is invoked from an imaginary node ref on right side of a
    rewrite rule as IMAG[$tokenLabel] or IMAG[$tokenLabel, "IMAG"].
       This should invoke createToken(Token).
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">tokenType</span>:int</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">fromToken</span>:<a href="../Token.html">Token</a></code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">text</span>:String</code> (default = <code>null</code>)<code></code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="createFromType()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">createFromType</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function createFromType(tokenType:int, text:String):Object</code><p> Create a new node derived from a token, with a new token type.
    This is invoked from an imaginary node ref on right side of a
    rewrite rule as IMAG["IMAG"].
       This should invoke createToken(int,String).
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">tokenType</span>:int</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">text</span>:String</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="createWithPayload()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">createWithPayload</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function createWithPayload(payload:<a href="../Token.html">Token</a>):Object</code><p> Create a tree node from Token object; for CommonTree type trees,
    then the token just becomes the payload.  This is the most
    common create call.
   
    Override if you want another kind of node to be built.
      </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">payload</span>:<a href="../Token.html">Token</a></code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="deleteChild()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">deleteChild</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function deleteChild(t:Object, i:int):Object</code><p> Remove ith child and shift children down from right. </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">i</span>:int</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="dupNode()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">dupNode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function dupNode(treeNode:Object):Object</code><p> Duplicate a single tree node.
     Override if you want another kind of node to be built.
    </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">treeNode</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="dupTree()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">dupTree</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function dupTree(tree:Object):Object</code><p> Duplicate tree recursively, using dupNode() for each node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">tree</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="errorNode()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">errorNode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function errorNode(input:<a href="../TokenStream.html">TokenStream</a>, start:<a href="../Token.html">Token</a>, stop:<a href="../Token.html">Token</a>, e:<a href="../RecognitionException.html">RecognitionException</a>):Object</code><p> Return a tree node representing an error.  This node records the
       tokens consumed during error recovery.  The start token indicates the
       input symbol at which the error was detected.  The stop token indicates
       the last symbol consumed during recovery.
             You must specify the input stream so that the erroneous text can
       be packaged up in the error node.  The exception could be useful
       to some applications; default implementation stores ptr to it in
       the CommonErrorNode.
             This only makes sense during token parsing, not tree parsing.
       Tree parsing should happen only when parsing and tree construction
       succeed.
      </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">input</span>:<a href="../TokenStream.html">TokenStream</a></code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">start</span>:<a href="../Token.html">Token</a></code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">stop</span>:<a href="../Token.html">Token</a></code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">e</span>:<a href="../RecognitionException.html">RecognitionException</a></code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="getChild()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getChild</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getChild(t:Object, i:int):Object</code><p> Get a child 0..n-1 node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">i</span>:int</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="getChildCount()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getChildCount</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getChildCount(t:Object):int</code><p> How many children?  If 0, then this is a leaf node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>int</code></td>
</tr>
</table>
</div>
<a name="getChildIndex()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getChildIndex</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getChildIndex(t:Object):int</code><p> What index is this node in the child list? Range: 0..n-1
    If your node type doesn't handle this, it's ok but the tree rewrites
    in tree parsers need this functionality.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>int</code></td>
</tr>
</table>
</div>
<a name="getParent()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getParent</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getParent(t:Object):Object</code><p> Who is the parent node of this node; if null, implies node is root.
    If your node type doesn't handle this, it's ok but the tree rewrites
    in tree parsers need this functionality.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="getText()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getText</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getText(t:Object):String</code><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>String</code></td>
</tr>
</table>
</div>
<a name="getToken()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getToken</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getToken(t:Object):<a href="../../runtime/Token.html">Token</a></code><p> Return the token object from which this node was created.
    Currently used only for printing an error message.
    The error display routine in BaseRecognizer needs to
    display where the input the error occurred. If your
    tree of limitation does not store information that can
    lead you to the token, you can create a token filled with
    the appropriate information and pass that back.  See
    BaseRecognizer.getErrorMessage().
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code><a href="../../runtime/Token.html">Token</a></code></td>
</tr>
</table>
</div>
<a name="getTokenStartIndex()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getTokenStartIndex</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getTokenStartIndex(t:Object):int</code><p> Get the token start index for this subtree; return -1 if no such index </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>int</code></td>
</tr>
</table>
</div>
<a name="getTokenStopIndex()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getTokenStopIndex</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getTokenStopIndex(t:Object):int</code><p> Get the token stop index for this subtree; return -1 if no such index </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>int</code></td>
</tr>
</table>
</div>
<a name="getType()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getType</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getType(t:Object):int</code><p> For tree parsing, I need to know the token type of a node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>int</code></td>
</tr>
</table>
</div>
<a name="getUniqueID()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">getUniqueID</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function getUniqueID(node:Object):int</code><p> For identifying trees.
       How to identify nodes so we can say "add node to a prior node"?
    Even becomeRoot is an issue.  Use System.identityHashCode(node)
    usually.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">node</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>int</code></td>
</tr>
</table>
</div>
<a name="isNil()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">isNil</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function isNil(tree:Object):Boolean</code><p> Is tree considered a nil node used to make lists of child nodes? </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">tree</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Boolean</code></td>
</tr>
</table>
</div>
<a name="nil()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">nil</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function nil():Object</code><p> Return a nil node (an empty but non-null node) that can hold
    a list of element as the children.  If you want a flat tree (a list)
    use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
   </p><p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="replaceChildren()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">replaceChildren</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function replaceChildren(parent:Object, startChildIndex:int, stopChildIndex:int, t:Object):void</code><p> Replace from start to stop child index of parent with t, which might
    be a list.  Number of children may be different
    after this call.
       If parent is null, don't do anything; must be at root of overall tree.
    Can't replace whatever points to the parent externally.  Do nothing.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">parent</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">startChildIndex</span>:int</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">stopChildIndex</span>:int</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
</table>
</div>
<a name="rulePostProcessing()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">rulePostProcessing</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function rulePostProcessing(root:Object):Object</code><p> Given the root of the subtree created for this rule, post process
    it to do any simplifications or whatever you want.  A required
    behavior is to convert ^(nil singleSubtree) to singleSubtree
    as the setting of start/stop indexes relies on a single non-nil root
    for non-flat trees.
       Flat trees such as for lists like "idlist : ID+ ;" are left alone
    unless there is only one ID.  For a list, the start/stop indexes
    are set in the nil node.
       This method is executed after all rule tree construction and right
    before setTokenBoundaries().
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">root</span>:Object</code></td>
</tr>
</table>
<p></p>
<span class="label">Returns</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20"></td><td><code>Object</code></td>
</tr>
</table>
</div>
<a name="setChild()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">setChild</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function setChild(t:Object, i:int, child:Object):void</code><p> Set ith child (0..n-1) to t; t must be non-null and non-nil node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">i</span>:int</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">child</span>:Object</code></td>
</tr>
</table>
</div>
<a name="setChildIndex()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">setChildIndex</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function setChildIndex(t:Object, index:int):void</code><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">index</span>:int</code></td>
</tr>
</table>
</div>
<a name="setParent()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">setParent</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function setParent(t:Object, parent:Object):void</code><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">parent</span>:Object</code></td>
</tr>
</table>
</div>
<a name="setText()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">setText</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function setText(t:Object, text:String):void</code><p> Node constructors can set the text of a node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">text</span>:String</code></td>
</tr>
</table>
</div>
<a name="setTokenBoundaries()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">setTokenBoundaries</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function setTokenBoundaries(t:Object, startToken:<a href="../Token.html">Token</a>, stopToken:<a href="../Token.html">Token</a>):void</code><p> Where are the bounds in the input token stream for this node and
    all children?  Each rule that creates AST nodes will call this
    method right before returning.  Flat trees (i.e., lists) will
    still usually have a nil root node just to hold the children list.
    That node would contain the start/stop indexes then.
   </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">startToken</span>:<a href="../Token.html">Token</a></code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">stopToken</span>:<a href="../Token.html">Token</a></code></td>
</tr>
</table>
</div>
<a name="setType()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">setType</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public function setType(t:Object, type:int):void</code><p> Node constructors can set the type of a node </p><span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">t</span>:Object</code></td>
</tr>
<tr>
<td class="paramSpacer">&nbsp;</td>
</tr>
<tr>
<td width="20px"></td><td><code><span class="label">type</span>:int</code></td>
</tr>
</table>
</div>
<br>
<br>
<hr>
<br>
<p></p>
<center class="copyright"> 
</center>
</div>
</body>
</html>
<!-- -->
