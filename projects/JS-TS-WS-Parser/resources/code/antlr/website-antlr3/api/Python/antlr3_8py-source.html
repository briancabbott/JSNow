<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR Python API: antlr3.py Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>antlr3.py</h1><a href="antlr3_8py.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">##</span>
<a name="l00002"></a>00002 <span class="comment">#  @package antlr3</span>
<a name="l00003"></a>00003 <span class="comment"># @brief ANTLR3 runtime package</span>
<a name="l00004"></a>00004 <span class="comment"># </span>
<a name="l00005"></a>00005 <span class="comment"># This module contains all support classes, which are needed to use recognizers</span>
<a name="l00006"></a>00006 <span class="comment"># generated by ANTLR3.</span>
<a name="l00007"></a>00007 <span class="comment"># </span>
<a name="l00008"></a>00008 <span class="comment"># @mainpage</span>
<a name="l00009"></a>00009 <span class="comment"># </span>
<a name="l00010"></a>00010 <span class="comment"># \note Please be warned that the line numbers in the API documentation do not</span>
<a name="l00011"></a>00011 <span class="comment"># match the real locations in the source code of the package. This is an</span>
<a name="l00012"></a>00012 <span class="comment"># unintended artifact of doxygen, which I could only convince to use the</span>
<a name="l00013"></a>00013 <span class="comment"># correct module names by concatenating all files from the package into a single</span>
<a name="l00014"></a>00014 <span class="comment"># module file...</span>
<a name="l00015"></a>00015 <span class="comment"># </span>
<a name="l00016"></a>00016 <span class="comment"># Here is a little overview over the most commonly used classes provided by</span>
<a name="l00017"></a>00017 <span class="comment"># this runtime:</span>
<a name="l00018"></a>00018 <span class="comment"># </span>
<a name="l00019"></a>00019 <span class="comment"># @section recognizers Recognizers</span>
<a name="l00020"></a>00020 <span class="comment"># </span>
<a name="l00021"></a>00021 <span class="comment"># These recognizers are baseclasses for the code which is generated by ANTLR3.</span>
<a name="l00022"></a>00022 <span class="comment"># </span>
<a name="l00023"></a>00023 <span class="comment"># - BaseRecognizer: Base class with common recognizer functionality.</span>
<a name="l00024"></a>00024 <span class="comment"># - Lexer: Base class for lexers.</span>
<a name="l00025"></a>00025 <span class="comment"># - Parser: Base class for parsers.</span>
<a name="l00026"></a>00026 <span class="comment"># - tree.TreeParser: Base class for %tree parser.</span>
<a name="l00027"></a>00027 <span class="comment"># </span>
<a name="l00028"></a>00028 <span class="comment"># @section streams Streams</span>
<a name="l00029"></a>00029 <span class="comment"># </span>
<a name="l00030"></a>00030 <span class="comment"># Each recognizer pulls its input from one of the stream classes below. Streams</span>
<a name="l00031"></a>00031 <span class="comment"># handle stuff like buffering, look-ahead and seeking.</span>
<a name="l00032"></a>00032 <span class="comment"># </span>
<a name="l00033"></a>00033 <span class="comment"># A character stream is usually the first element in the pipeline of a typical</span>
<a name="l00034"></a>00034 <span class="comment"># ANTLR3 application. It is used as the input for a Lexer.</span>
<a name="l00035"></a>00035 <span class="comment"># </span>
<a name="l00036"></a>00036 <span class="comment"># - ANTLRStringStream: Reads from a string objects. The input should be a unicode</span>
<a name="l00037"></a>00037 <span class="comment">#   object, or ANTLR3 will have trouble decoding non-ascii data.</span>
<a name="l00038"></a>00038 <span class="comment"># - ANTLRFileStream: Opens a file and read the contents, with optional character</span>
<a name="l00039"></a>00039 <span class="comment">#   decoding.</span>
<a name="l00040"></a>00040 <span class="comment"># - ANTLRInputStream: Reads the date from a file-like object, with optional</span>
<a name="l00041"></a>00041 <span class="comment">#   character decoding.</span>
<a name="l00042"></a>00042 <span class="comment"># </span>
<a name="l00043"></a>00043 <span class="comment"># A Parser needs a TokenStream as input (which in turn is usually fed by a</span>
<a name="l00044"></a>00044 <span class="comment"># Lexer):</span>
<a name="l00045"></a>00045 <span class="comment"># </span>
<a name="l00046"></a>00046 <span class="comment"># - CommonTokenStream: A basic and most commonly used TokenStream</span>
<a name="l00047"></a>00047 <span class="comment">#   implementation.</span>
<a name="l00048"></a>00048 <span class="comment"># - TokenRewriteStream: A modification of CommonTokenStream that allows the</span>
<a name="l00049"></a>00049 <span class="comment">#   stream to be altered (by the Parser). See the 'tweak' example for a usecase.</span>
<a name="l00050"></a>00050 <span class="comment"># </span>
<a name="l00051"></a>00051 <span class="comment"># And tree.TreeParser finally fetches its input from a tree.TreeNodeStream:</span>
<a name="l00052"></a>00052 <span class="comment"># </span>
<a name="l00053"></a>00053 <span class="comment"># - tree.CommonTreeNodeStream: A basic and most commonly used tree.TreeNodeStream</span>
<a name="l00054"></a>00054 <span class="comment">#   implementation.</span>
<a name="l00055"></a>00055 <span class="comment">#   </span>
<a name="l00056"></a>00056 <span class="comment"># </span>
<a name="l00057"></a>00057 <span class="comment"># @section tokenstrees Tokens and Trees</span>
<a name="l00058"></a>00058 <span class="comment"># </span>
<a name="l00059"></a>00059 <span class="comment"># A Lexer emits Token objects which are usually buffered by a TokenStream. A</span>
<a name="l00060"></a>00060 <span class="comment"># Parser can build a Tree, if the output=AST option has been set in the grammar.</span>
<a name="l00061"></a>00061 <span class="comment"># </span>
<a name="l00062"></a>00062 <span class="comment"># The runtime provides these Token implementations:</span>
<a name="l00063"></a>00063 <span class="comment"># </span>
<a name="l00064"></a>00064 <span class="comment"># - CommonToken: A basic and most commonly used Token implementation.</span>
<a name="l00065"></a>00065 <span class="comment"># - ClassicToken: A Token object as used in ANTLR 2.x, used to %tree</span>
<a name="l00066"></a>00066 <span class="comment">#   construction.</span>
<a name="l00067"></a>00067 <span class="comment"># </span>
<a name="l00068"></a>00068 <span class="comment"># Tree objects are wrapper for Token objects.</span>
<a name="l00069"></a>00069 <span class="comment"># </span>
<a name="l00070"></a>00070 <span class="comment"># - tree.CommonTree: A basic and most commonly used Tree implementation.</span>
<a name="l00071"></a>00071 <span class="comment"># </span>
<a name="l00072"></a>00072 <span class="comment"># A tree.TreeAdaptor is used by the parser to create tree.Tree objects for the</span>
<a name="l00073"></a>00073 <span class="comment"># input Token objects.</span>
<a name="l00074"></a>00074 <span class="comment"># </span>
<a name="l00075"></a>00075 <span class="comment"># - tree.CommonTreeAdaptor: A basic and most commonly used tree.TreeAdaptor</span>
<a name="l00076"></a>00076 <span class="comment"># implementation.</span>
<a name="l00077"></a>00077 <span class="comment"># </span>
<a name="l00078"></a>00078 <span class="comment"># </span>
<a name="l00079"></a>00079 <span class="comment"># @section Exceptions</span>
<a name="l00080"></a>00080 <span class="comment"># </span>
<a name="l00081"></a>00081 <span class="comment"># RecognitionException are generated, when a recognizer encounters incorrect</span>
<a name="l00082"></a>00082 <span class="comment"># or unexpected input.</span>
<a name="l00083"></a>00083 <span class="comment"># </span>
<a name="l00084"></a>00084 <span class="comment"># - RecognitionException</span>
<a name="l00085"></a>00085 <span class="comment">#   - MismatchedRangeException</span>
<a name="l00086"></a>00086 <span class="comment">#   - MismatchedSetException</span>
<a name="l00087"></a>00087 <span class="comment">#     - MismatchedNotSetException</span>
<a name="l00088"></a>00088 <span class="comment">#     .</span>
<a name="l00089"></a>00089 <span class="comment">#   - MismatchedTokenException</span>
<a name="l00090"></a>00090 <span class="comment">#   - MismatchedTreeNodeException</span>
<a name="l00091"></a>00091 <span class="comment">#   - NoViableAltException</span>
<a name="l00092"></a>00092 <span class="comment">#   - EarlyExitException</span>
<a name="l00093"></a>00093 <span class="comment">#   - FailedPredicateException</span>
<a name="l00094"></a>00094 <span class="comment">#   .</span>
<a name="l00095"></a>00095 <span class="comment"># .</span>
<a name="l00096"></a>00096 <span class="comment"># </span>
<a name="l00097"></a>00097 <span class="comment"># A tree.RewriteCardinalityException is raised, when the parsers hits a</span>
<a name="l00098"></a>00098 <span class="comment"># cardinality mismatch during AST construction. Although this is basically a</span>
<a name="l00099"></a>00099 <span class="comment"># bug in your grammar, it can only be detected at runtime.</span>
<a name="l00100"></a>00100 <span class="comment"># </span>
<a name="l00101"></a>00101 <span class="comment"># - tree.RewriteCardinalityException</span>
<a name="l00102"></a>00102 <span class="comment">#   - tree.RewriteEarlyExitException</span>
<a name="l00103"></a>00103 <span class="comment">#   - tree.RewriteEmptyStreamException</span>
<a name="l00104"></a>00104 <span class="comment">#   .</span>
<a name="l00105"></a>00105 <span class="comment"># .</span>
<a name="l00106"></a>00106 <span class="comment"># </span>
<a name="l00107"></a>00107 <span class="comment"># </span>
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment"># tree.RewriteRuleElementStream</span>
<a name="l00110"></a>00110 <span class="comment"># tree.RewriteRuleSubtreeStream</span>
<a name="l00111"></a>00111 <span class="comment"># tree.RewriteRuleTokenStream</span>
<a name="l00112"></a>00112 <span class="comment"># CharStream</span>
<a name="l00113"></a>00113 <span class="comment"># DFA</span>
<a name="l00114"></a>00114 <span class="comment"># TokenSource</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment"># [The "BSD licence"]</span>
<a name="l00117"></a>00117 <span class="comment"># Copyright (c) 2005-2008 Terence Parr</span>
<a name="l00118"></a>00118 <span class="comment"># All rights reserved.</span>
<a name="l00119"></a>00119 <span class="comment">#</span>
<a name="l00120"></a>00120 <span class="comment"># Redistribution and use in source and binary forms, with or without</span>
<a name="l00121"></a>00121 <span class="comment"># modification, are permitted provided that the following conditions</span>
<a name="l00122"></a>00122 <span class="comment"># are met:</span>
<a name="l00123"></a>00123 <span class="comment"># 1. Redistributions of source code must retain the above copyright</span>
<a name="l00124"></a>00124 <span class="comment">#    notice, this list of conditions and the following disclaimer.</span>
<a name="l00125"></a>00125 <span class="comment"># 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00126"></a>00126 <span class="comment">#    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00127"></a>00127 <span class="comment">#    documentation and/or other materials provided with the distribution.</span>
<a name="l00128"></a>00128 <span class="comment"># 3. The name of the author may not be used to endorse or promote products</span>
<a name="l00129"></a>00129 <span class="comment">#    derived from this software without specific prior written permission.</span>
<a name="l00130"></a>00130 <span class="comment">#</span>
<a name="l00131"></a>00131 <span class="comment"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</span>
<a name="l00132"></a>00132 <span class="comment"># IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<a name="l00133"></a>00133 <span class="comment"># OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00134"></a>00134 <span class="comment"># IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00135"></a>00135 <span class="comment"># INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="l00136"></a>00136 <span class="comment"># NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00137"></a>00137 <span class="comment"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00138"></a>00138 <span class="comment"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00139"></a>00139 <span class="comment"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00140"></a>00140 <span class="comment"># THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00141"></a>00141 
<a name="l00142"></a><a class="code" href="namespaceantlr3.html#945d46186e027986ad55192c2a9cd823">00142</a> __version__ = <span class="stringliteral">'3.1.3'</span>
<a name="l00143"></a>00143 
<a name="l00144"></a><a class="code" href="namespaceantlr3.html#15f5efdb43ec8cfdbbf5d36d1e8a5a35">00144</a> <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#15f5efdb43ec8cfdbbf5d36d1e8a5a35">version_str_to_tuple</a>(version_str):
<a name="l00145"></a>00145     <span class="keyword">import</span> re
<a name="l00146"></a>00146     <span class="keyword">import</span> sys
<a name="l00147"></a>00147 
<a name="l00148"></a>00148     <span class="keywordflow">if</span> version_str == <span class="stringliteral">'HEAD'</span>:
<a name="l00149"></a>00149         <span class="keywordflow">return</span> (sys.maxint, sys.maxint, sys.maxint, sys.maxint)
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     m = re.match(<span class="stringliteral">r'(\d+)\.(\d+)(\.(\d+))?(b(\d+))?'</span>, version_str)
<a name="l00152"></a>00152     <span class="keywordflow">if</span> m <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00153"></a>00153         <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">"Bad version string %r"</span> % version_str)
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     major = int(m.group(1))
<a name="l00156"></a>00156     minor = int(m.group(2))
<a name="l00157"></a>00157     patch = int(m.group(4) <span class="keywordflow">or</span> 0)
<a name="l00158"></a>00158     beta = int(m.group(6) <span class="keywordflow">or</span> sys.maxint)
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="keywordflow">return</span> (major, minor, patch, beta)
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="namespaceantlr3.html#86b3cb3f0bac15312b49011131564381">00163</a> runtime_version_str = __version__
<a name="l00164"></a><a class="code" href="namespaceantlr3.html#38f76a127c8ae4358b83bd8feedde094">00164</a> runtime_version = version_str_to_tuple(runtime_version_str)
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="keyword">from</span> constants <span class="keyword">import</span> *
<a name="l00168"></a>00168 <span class="keyword">from</span> dfa <span class="keyword">import</span> *
<a name="l00169"></a>00169 <span class="keyword">from</span> exceptions <span class="keyword">import</span> *
<a name="l00170"></a>00170 <span class="keyword">from</span> recognizers <span class="keyword">import</span> *
<a name="l00171"></a>00171 <span class="keyword">from</span> streams <span class="keyword">import</span> *
<a name="l00172"></a>00172 <span class="keyword">from</span> tokens <span class="keyword">import</span> *
<a name="l00173"></a>00173 <span class="stringliteral">"""ANTLR3 exception hierarchy"""</span>
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">from</span> antlr3.constants <span class="keyword">import</span> INVALID_TOKEN_TYPE
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="comment">##</span>
<a name="l00180"></a>00180 <span class="comment"># @brief Raised to signal failed backtrack attempt</span>
<a name="l00181"></a><a class="code" href="classantlr3_1_1_backtracking_failed.html">00181</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_backtracking_failed.html" title="Raised to signal failed backtrack attempt.">BacktrackingFailed</a>(Exception):
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     <span class="keywordflow">pass</span>
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">##</span>
<a name="l00187"></a>00187 <span class="comment"># @brief The root of the ANTLR exception hierarchy.</span>
<a name="l00188"></a>00188 <span class="comment"># </span>
<a name="l00189"></a>00189 <span class="comment">#     To avoid English-only error messages and to generally make things</span>
<a name="l00190"></a>00190 <span class="comment">#     as flexible as possible, these exceptions are not created with strings,</span>
<a name="l00191"></a>00191 <span class="comment">#     but rather the information necessary to generate an error.  Then</span>
<a name="l00192"></a>00192 <span class="comment">#     the various reporting methods in Parser and Lexer can be overridden</span>
<a name="l00193"></a>00193 <span class="comment">#     to generate a localized error message.  For example, MismatchedToken</span>
<a name="l00194"></a>00194 <span class="comment">#     exceptions are built with the expected token type.</span>
<a name="l00195"></a>00195 <span class="comment">#     So, don't expect getMessage() to return anything.</span>
<a name="l00196"></a>00196 <span class="comment"># </span>
<a name="l00197"></a>00197 <span class="comment">#     Note that as of Java 1.4, you can access the stack trace, which means</span>
<a name="l00198"></a>00198 <span class="comment">#     that you can compute the complete trace of rules from the start symbol.</span>
<a name="l00199"></a>00199 <span class="comment">#     This gives you considerable context information with which to generate</span>
<a name="l00200"></a>00200 <span class="comment">#     useful error messages.</span>
<a name="l00201"></a>00201 <span class="comment"># </span>
<a name="l00202"></a>00202 <span class="comment">#     ANTLR generates code that throws exceptions upon recognition error and</span>
<a name="l00203"></a>00203 <span class="comment">#     also generates code to catch these exceptions in each rule.  If you</span>
<a name="l00204"></a>00204 <span class="comment">#     want to quit upon first error, you can turn off the automatic error</span>
<a name="l00205"></a>00205 <span class="comment">#     handling mechanism using rulecatch action, but you still need to</span>
<a name="l00206"></a>00206 <span class="comment">#     override methods mismatch and recoverFromMismatchSet.</span>
<a name="l00207"></a>00207 <span class="comment">#     </span>
<a name="l00208"></a>00208 <span class="comment">#     In general, the recognition exceptions can track where in a grammar a</span>
<a name="l00209"></a>00209 <span class="comment">#     problem occurred and/or what was the expected input.  While the parser</span>
<a name="l00210"></a>00210 <span class="comment">#     knows its state (such as current input symbol and line info) that</span>
<a name="l00211"></a>00211 <span class="comment">#     state can change before the exception is reported so current token index</span>
<a name="l00212"></a>00212 <span class="comment">#     is computed and stored at exception time.  From this info, you can</span>
<a name="l00213"></a>00213 <span class="comment">#     perhaps print an entire line of input not just a single token, for example.</span>
<a name="l00214"></a>00214 <span class="comment">#     Better to just say the recognizer had a problem and then let the parser</span>
<a name="l00215"></a>00215 <span class="comment">#     figure out a fancy report.</span>
<a name="l00216"></a>00216 <span class="comment">#     </span>
<a name="l00217"></a>00217 <span class="comment">#     </span>
<a name="l00218"></a><a class="code" href="classantlr3_1_1_recognition_exception.html">00218</a> <span class="keyword">class </span>RecognitionException(Exception):
<a name="l00219"></a>00219 
<a name="l00220"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#3823c07254a1647b467efac56c81218d">00220</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_recognition_exception.html#3823c07254a1647b467efac56c81218d">__init__</a>(self, input=None):
<a name="l00221"></a>00221         Exception.__init__(self)
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         <span class="comment"># What input stream did the error occur in?</span>
<a name="l00224"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">00224</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a> = <span class="keywordtype">None</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         <span class="comment"># What is index of token/char were we looking at when the error</span>
<a name="l00227"></a>00227         <span class="comment"># occurred?</span>
<a name="l00228"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#7b39b108bd8d0a0bd2bf46c37947af7e">00228</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#7b39b108bd8d0a0bd2bf46c37947af7e">index</a> = <span class="keywordtype">None</span>
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <span class="comment"># The current Token when an error occurred.  Since not all streams</span>
<a name="l00231"></a>00231         <span class="comment"># can retrieve the ith Token, we have to track the Token object.</span>
<a name="l00232"></a>00232         <span class="comment"># For parsers.  Even when it's a tree parser, token might be set.</span>
<a name="l00233"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">00233</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a> = <span class="keywordtype">None</span>
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         <span class="comment"># If this is a tree parser exception, node is set to the node with</span>
<a name="l00236"></a>00236         <span class="comment"># the problem.</span>
<a name="l00237"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">00237</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a> = <span class="keywordtype">None</span>
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         <span class="comment"># The current char when an error occurred. For lexers.</span>
<a name="l00240"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#0cdd15a2c4f74b2275a59f3264ff399e">00240</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#0cdd15a2c4f74b2275a59f3264ff399e">c</a> = <span class="keywordtype">None</span>
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="comment"># Track the line at which the error occurred in case this is</span>
<a name="l00243"></a>00243         <span class="comment"># generated from a lexer.  We need to track this since the</span>
<a name="l00244"></a>00244         <span class="comment"># unexpected char doesn't carry the line info.</span>
<a name="l00245"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">00245</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">line</a> = <span class="keywordtype">None</span>
<a name="l00246"></a>00246 
<a name="l00247"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">00247</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">charPositionInLine</a> = <span class="keywordtype">None</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         <span class="comment"># If you are parsing a tree node stream, you will encounter som</span>
<a name="l00250"></a>00250         <span class="comment"># imaginary nodes w/o line/col info.  We now search backwards looking</span>
<a name="l00251"></a>00251         <span class="comment"># for most recent token with line/col info, but notify getErrorHeader()</span>
<a name="l00252"></a>00252         <span class="comment"># that info is approximate.</span>
<a name="l00253"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#7de5abf2d7717aba127acd9215c80290">00253</a>         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#7de5abf2d7717aba127acd9215c80290">approximateLineInfo</a> = <span class="keyword">False</span>
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         
<a name="l00256"></a>00256         <span class="keywordflow">if</span> input <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00257"></a>00257             self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a> = input
<a name="l00258"></a>00258             self.<a class="code" href="classantlr3_1_1_recognition_exception.html#7b39b108bd8d0a0bd2bf46c37947af7e">index</a> = input.index()
<a name="l00259"></a>00259 
<a name="l00260"></a>00260             <span class="comment"># late import to avoid cyclic dependencies</span>
<a name="l00261"></a>00261             <span class="keyword">from</span> antlr3.streams <span class="keyword">import</span> TokenStream, CharStream
<a name="l00262"></a>00262             <span class="keyword">from</span> antlr3.tree <span class="keyword">import</span> TreeNodeStream
<a name="l00263"></a>00263 
<a name="l00264"></a>00264             <span class="keywordflow">if</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>, TokenStream):
<a name="l00265"></a>00265                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>.LT(1)
<a name="l00266"></a>00266                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">line</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a>.line
<a name="l00267"></a>00267                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">charPositionInLine</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a>.charPositionInLine
<a name="l00268"></a>00268 
<a name="l00269"></a>00269             <span class="keywordflow">if</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>, TreeNodeStream):
<a name="l00270"></a>00270                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#23fff4e719e990ba0f22ab60f223e518">extractInformationFromTreeNodeStream</a>(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>)
<a name="l00271"></a>00271 
<a name="l00272"></a>00272             <span class="keywordflow">else</span>:
<a name="l00273"></a>00273                 <span class="keywordflow">if</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>, CharStream):
<a name="l00274"></a>00274                     self.<a class="code" href="classantlr3_1_1_recognition_exception.html#0cdd15a2c4f74b2275a59f3264ff399e">c</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>.LT(1)
<a name="l00275"></a>00275                     self.<a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">line</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>.line
<a name="l00276"></a>00276                     self.<a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">charPositionInLine</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>.charPositionInLine
<a name="l00277"></a>00277 
<a name="l00278"></a>00278                 <span class="keywordflow">else</span>:
<a name="l00279"></a>00279                     self.<a class="code" href="classantlr3_1_1_recognition_exception.html#0cdd15a2c4f74b2275a59f3264ff399e">c</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>.LA(1)
<a name="l00280"></a>00280 
<a name="l00281"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#23fff4e719e990ba0f22ab60f223e518">00281</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_recognition_exception.html#23fff4e719e990ba0f22ab60f223e518">extractInformationFromTreeNodeStream</a>(self, nodes):
<a name="l00282"></a>00282         <span class="keyword">from</span> antlr3.tree <span class="keyword">import</span> Tree, CommonTree
<a name="l00283"></a>00283         <span class="keyword">from</span> antlr3.tokens <span class="keyword">import</span> CommonToken
<a name="l00284"></a>00284         
<a name="l00285"></a>00285         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a> = nodes.LT(1)
<a name="l00286"></a>00286         adaptor = nodes.adaptor
<a name="l00287"></a>00287         payload = adaptor.getToken(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>)
<a name="l00288"></a>00288         <span class="keywordflow">if</span> payload <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00289"></a>00289             self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a> = payload
<a name="l00290"></a>00290             <span class="keywordflow">if</span> payload.line &lt;= 0:
<a name="l00291"></a>00291                 <span class="comment"># imaginary node; no line/pos info; scan backwards</span>
<a name="l00292"></a>00292                 i = -1
<a name="l00293"></a>00293                 priorNode = nodes.LT(i)
<a name="l00294"></a>00294                 <span class="keywordflow">while</span> priorNode <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00295"></a>00295                     priorPayload = adaptor.getToken(priorNode)
<a name="l00296"></a>00296                     <span class="keywordflow">if</span> priorPayload <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> priorPayload.line &gt; 0:
<a name="l00297"></a>00297                         <span class="comment"># we found the most recent real line / pos info</span>
<a name="l00298"></a>00298                         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">line</a> = priorPayload.line
<a name="l00299"></a>00299                         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">charPositionInLine</a> = priorPayload.charPositionInLine
<a name="l00300"></a>00300                         self.<a class="code" href="classantlr3_1_1_recognition_exception.html#7de5abf2d7717aba127acd9215c80290">approximateLineInfo</a> = <span class="keyword">True</span>
<a name="l00301"></a>00301                         <span class="keywordflow">break</span>
<a name="l00302"></a>00302                     
<a name="l00303"></a>00303                     i -= 1
<a name="l00304"></a>00304                     priorNode = nodes.LT(i)
<a name="l00305"></a>00305                     
<a name="l00306"></a>00306             <span class="keywordflow">else</span>: <span class="comment"># node created from real token</span>
<a name="l00307"></a>00307                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">line</a> = payload.line
<a name="l00308"></a>00308                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">charPositionInLine</a> = payload.charPositionInLine
<a name="l00309"></a>00309                 
<a name="l00310"></a>00310         <span class="keywordflow">elif</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>, Tree):
<a name="l00311"></a>00311             self.<a class="code" href="classantlr3_1_1_recognition_exception.html#e0ff35dee5607435c238e1201c174815">line</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>.line
<a name="l00312"></a>00312             self.<a class="code" href="classantlr3_1_1_recognition_exception.html#caba06b97ca08b09c116f26d36943a37">charPositionInLine</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>.charPositionInLine
<a name="l00313"></a>00313             <span class="keywordflow">if</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>, CommonTree):
<a name="l00314"></a>00314                 self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a> = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>.token
<a name="l00315"></a>00315 
<a name="l00316"></a>00316         <span class="keywordflow">else</span>:
<a name="l00317"></a>00317             type = adaptor.getType(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>)
<a name="l00318"></a>00318             text = adaptor.getText(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>)
<a name="l00319"></a>00319             self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a> = CommonToken(type=type, text=text)
<a name="l00320"></a>00320 
<a name="l00321"></a>00321      
<a name="l00322"></a>00322     <span class="comment">##</span>
<a name="l00323"></a>00323     <span class="comment"># Return the token type or char of the unexpected input element</span>
<a name="l00324"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#c263ea865785e4cdd807b43a6fa26df4">00324</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_recognition_exception.html#c263ea865785e4cdd807b43a6fa26df4" title="Return the token type or char of the unexpected input element.">getUnexpectedType</a>(self):
<a name="l00325"></a>00325 
<a name="l00326"></a>00326         <span class="keyword">from</span> antlr3.streams <span class="keyword">import</span> TokenStream
<a name="l00327"></a>00327         <span class="keyword">from</span> antlr3.tree <span class="keyword">import</span> TreeNodeStream
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="keywordflow">if</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>, TokenStream):
<a name="l00330"></a>00330             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_recognition_exception.html#9870fadf037278d40db9e365126cae97">token</a>.type
<a name="l00331"></a>00331 
<a name="l00332"></a>00332         <span class="keywordflow">elif</span> isinstance(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>, TreeNodeStream):
<a name="l00333"></a>00333             adaptor = self.<a class="code" href="classantlr3_1_1_recognition_exception.html#90260bad26bcbeac27bbd06b925737e8">input</a>.treeAdaptor
<a name="l00334"></a>00334             <span class="keywordflow">return</span> adaptor.getType(self.<a class="code" href="classantlr3_1_1_recognition_exception.html#b090e2bd45b8a030e9e51f7583d16824">node</a>)
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         <span class="keywordflow">else</span>:
<a name="l00337"></a>00337             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_recognition_exception.html#0cdd15a2c4f74b2275a59f3264ff399e">c</a>
<a name="l00338"></a>00338 
<a name="l00339"></a><a class="code" href="classantlr3_1_1_recognition_exception.html#6c5cc4ae19b3dd8480651fb79c9c33be">00339</a>     unexpectedType = property(getUnexpectedType)
<a name="l00340"></a>00340     
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="comment">##</span>
<a name="l00343"></a>00343 <span class="comment"># @brief A mismatched char or Token or tree node.</span>
<a name="l00344"></a><a class="code" href="classantlr3_1_1_mismatched_token_exception.html">00344</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_mismatched_token_exception.html" title="A mismatched char or Token or tree node.">MismatchedTokenException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00345"></a>00345     
<a name="l00346"></a><a class="code" href="classantlr3_1_1_mismatched_token_exception.html#cffdd129840bbaccf06f6cc3f4cf9454">00346</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_token_exception.html#cffdd129840bbaccf06f6cc3f4cf9454">__init__</a>(self, expecting, input):
<a name="l00347"></a>00347         RecognitionException.__init__(self, input)
<a name="l00348"></a><a class="code" href="classantlr3_1_1_mismatched_token_exception.html#e77add67f3f2a95576e29a50677420ee">00348</a>         self.<a class="code" href="classantlr3_1_1_mismatched_token_exception.html#e77add67f3f2a95576e29a50677420ee">expecting</a> = expecting
<a name="l00349"></a>00349         
<a name="l00350"></a>00350 
<a name="l00351"></a><a class="code" href="classantlr3_1_1_mismatched_token_exception.html#3976caf834088f94bc06296ef96b714a">00351</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_token_exception.html#3976caf834088f94bc06296ef96b714a">__str__</a>(self):
<a name="l00352"></a>00352         <span class="comment">#return "MismatchedTokenException("+self.expecting+")"</span>
<a name="l00353"></a>00353         <span class="keywordflow">return</span> <span class="stringliteral">"MismatchedTokenException(%r!=%r)"</span> % (
<a name="l00354"></a>00354             self.getUnexpectedType(), self.<a class="code" href="classantlr3_1_1_mismatched_token_exception.html#e77add67f3f2a95576e29a50677420ee">expecting</a>
<a name="l00355"></a>00355             )
<a name="l00356"></a><a class="code" href="classantlr3_1_1_mismatched_token_exception.html#ea2bcb744a6eead77537b7d152ace8d1">00356</a>     __repr__ = __str__
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="comment">##</span>
<a name="l00360"></a>00360 <span class="comment"># An extra token while parsing a TokenStream</span>
<a name="l00361"></a><a class="code" href="classantlr3_1_1_unwanted_token_exception.html">00361</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_unwanted_token_exception.html" title="An extra token while parsing a TokenStream.">UnwantedTokenException</a>(<a class="code" href="classantlr3_1_1_mismatched_token_exception.html" title="A mismatched char or Token or tree node.">MismatchedTokenException</a>):
<a name="l00362"></a>00362 
<a name="l00363"></a><a class="code" href="classantlr3_1_1_unwanted_token_exception.html#1185d9f24ba7fdba9b0fd87c7f057b36">00363</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_unwanted_token_exception.html#1185d9f24ba7fdba9b0fd87c7f057b36">getUnexpectedToken</a>(self):
<a name="l00364"></a>00364         <span class="keywordflow">return</span> self.token
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 
<a name="l00367"></a><a class="code" href="classantlr3_1_1_unwanted_token_exception.html#1e52c742a5241574e23cfa739538999e">00367</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_unwanted_token_exception.html#1e52c742a5241574e23cfa739538999e">__str__</a>(self):
<a name="l00368"></a>00368         exp = <span class="stringliteral">", expected %s"</span> % self.<a class="code" href="classantlr3_1_1_unwanted_token_exception.html#0631fe218c1bae798f33a53599989ba0">expecting</a>
<a name="l00369"></a><a class="code" href="classantlr3_1_1_unwanted_token_exception.html#0631fe218c1bae798f33a53599989ba0">00369</a>         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_unwanted_token_exception.html#0631fe218c1bae798f33a53599989ba0">expecting</a> == INVALID_TOKEN_TYPE:
<a name="l00370"></a>00370             exp = <span class="stringliteral">""</span>
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         <span class="keywordflow">if</span> self.token <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00373"></a>00373             <span class="keywordflow">return</span> <span class="stringliteral">"UnwantedTokenException(found=%s%s)"</span> % (<span class="keywordtype">None</span>, exp)
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <span class="keywordflow">return</span> <span class="stringliteral">"UnwantedTokenException(found=%s%s)"</span> % (self.token.text, exp)
<a name="l00376"></a><a class="code" href="classantlr3_1_1_unwanted_token_exception.html#5031d7ae11f0c8c3f2edc45428de17bd">00376</a>     __repr__ = __str__
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="comment">##</span>
<a name="l00380"></a>00380 <span class="comment"># </span>
<a name="l00381"></a>00381 <span class="comment">#     We were expecting a token but it's not found.  The current token</span>
<a name="l00382"></a>00382 <span class="comment">#     is actually what we wanted next.</span>
<a name="l00383"></a>00383 <span class="comment">#     </span>
<a name="l00384"></a><a class="code" href="classantlr3_1_1_missing_token_exception.html">00384</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_missing_token_exception.html" title="We were expecting a token but it&amp;#39;s not found.">MissingTokenException</a>(<a class="code" href="classantlr3_1_1_mismatched_token_exception.html" title="A mismatched char or Token or tree node.">MismatchedTokenException</a>):
<a name="l00385"></a>00385 
<a name="l00386"></a><a class="code" href="classantlr3_1_1_missing_token_exception.html#b31ff85a619ce53d4d46cb7f58e3b59b">00386</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_missing_token_exception.html#b31ff85a619ce53d4d46cb7f58e3b59b">__init__</a>(self, expecting, input, inserted):
<a name="l00387"></a>00387         MismatchedTokenException.__init__(self, expecting, input)
<a name="l00388"></a>00388 
<a name="l00389"></a><a class="code" href="classantlr3_1_1_missing_token_exception.html#6ef0d40f5d82fb5c9a023b5425a0db05">00389</a>         self.<a class="code" href="classantlr3_1_1_missing_token_exception.html#6ef0d40f5d82fb5c9a023b5425a0db05">inserted</a> = inserted
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 
<a name="l00392"></a><a class="code" href="classantlr3_1_1_missing_token_exception.html#bebe824751eb4d8faba3c3cb0badd07c">00392</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_missing_token_exception.html#bebe824751eb4d8faba3c3cb0badd07c">getMissingType</a>(self):
<a name="l00393"></a>00393         <span class="keywordflow">return</span> self.expecting
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="classantlr3_1_1_missing_token_exception.html#747b63dfdbf5a9121aeb5be55470b0a0">00396</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_missing_token_exception.html#747b63dfdbf5a9121aeb5be55470b0a0">__str__</a>(self):
<a name="l00397"></a>00397         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_missing_token_exception.html#6ef0d40f5d82fb5c9a023b5425a0db05">inserted</a> <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> self.token <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00398"></a>00398             <span class="keywordflow">return</span> <span class="stringliteral">"MissingTokenException(inserted %r at %r)"</span> % (
<a name="l00399"></a>00399                 self.<a class="code" href="classantlr3_1_1_missing_token_exception.html#6ef0d40f5d82fb5c9a023b5425a0db05">inserted</a>, self.token.text)
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         <span class="keywordflow">if</span> self.token <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00402"></a>00402             <span class="keywordflow">return</span> <span class="stringliteral">"MissingTokenException(at %r)"</span> % self.token.text
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         <span class="keywordflow">return</span> <span class="stringliteral">"MissingTokenException"</span>
<a name="l00405"></a><a class="code" href="classantlr3_1_1_missing_token_exception.html#19f3e4086bb81b38017b967a1546d3bb">00405</a>     __repr__ = __str__
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="comment">##</span>
<a name="l00409"></a>00409 <span class="comment"># @brief The next token does not match a range of expected types.</span>
<a name="l00410"></a><a class="code" href="classantlr3_1_1_mismatched_range_exception.html">00410</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_mismatched_range_exception.html" title="The next token does not match a range of expected types.">MismatchedRangeException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00411"></a>00411 
<a name="l00412"></a><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#3bc2f0c58f3e531037c6619e44372baa">00412</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#3bc2f0c58f3e531037c6619e44372baa">__init__</a>(self, a, b, input):
<a name="l00413"></a>00413         RecognitionException.__init__(self, input)
<a name="l00414"></a>00414 
<a name="l00415"></a><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#caa02c0dc45d53e3e12bb7ef025bc503">00415</a>         self.<a class="code" href="classantlr3_1_1_mismatched_range_exception.html#caa02c0dc45d53e3e12bb7ef025bc503">a</a> = a
<a name="l00416"></a><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#ac36e507582251179379af708a5f0709">00416</a>         self.<a class="code" href="classantlr3_1_1_mismatched_range_exception.html#ac36e507582251179379af708a5f0709">b</a> = b
<a name="l00417"></a>00417         
<a name="l00418"></a>00418 
<a name="l00419"></a><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#e6dd3f7775b1b368100d9440acefb471">00419</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#e6dd3f7775b1b368100d9440acefb471">__str__</a>(self):
<a name="l00420"></a>00420         <span class="keywordflow">return</span> <span class="stringliteral">"MismatchedRangeException(%r not in [%r..%r])"</span> % (
<a name="l00421"></a>00421             self.getUnexpectedType(), self.<a class="code" href="classantlr3_1_1_mismatched_range_exception.html#caa02c0dc45d53e3e12bb7ef025bc503">a</a>, self.<a class="code" href="classantlr3_1_1_mismatched_range_exception.html#ac36e507582251179379af708a5f0709">b</a>
<a name="l00422"></a>00422             )
<a name="l00423"></a><a class="code" href="classantlr3_1_1_mismatched_range_exception.html#919b35db589b34368e93e246cb52f009">00423</a>     __repr__ = __str__
<a name="l00424"></a>00424     
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">##</span>
<a name="l00427"></a>00427 <span class="comment"># @brief The next token does not match a set of expected types.</span>
<a name="l00428"></a><a class="code" href="classantlr3_1_1_mismatched_set_exception.html">00428</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_mismatched_set_exception.html" title="The next token does not match a set of expected types.">MismatchedSetException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00429"></a>00429 
<a name="l00430"></a><a class="code" href="classantlr3_1_1_mismatched_set_exception.html#3dddef4f3ccfeb9816679661c928ba8e">00430</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_set_exception.html#3dddef4f3ccfeb9816679661c928ba8e">__init__</a>(self, expecting, input):
<a name="l00431"></a>00431         RecognitionException.__init__(self, input)
<a name="l00432"></a>00432 
<a name="l00433"></a><a class="code" href="classantlr3_1_1_mismatched_set_exception.html#771484e7864decd1810b171963490bfc">00433</a>         self.<a class="code" href="classantlr3_1_1_mismatched_set_exception.html#771484e7864decd1810b171963490bfc">expecting</a> = expecting
<a name="l00434"></a>00434         
<a name="l00435"></a>00435 
<a name="l00436"></a><a class="code" href="classantlr3_1_1_mismatched_set_exception.html#9e9b41a7f50f0e21883b7fd7872bc503">00436</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_set_exception.html#9e9b41a7f50f0e21883b7fd7872bc503">__str__</a>(self):
<a name="l00437"></a>00437         <span class="keywordflow">return</span> <span class="stringliteral">"MismatchedSetException(%r not in %r)"</span> % (
<a name="l00438"></a>00438             self.getUnexpectedType(), self.<a class="code" href="classantlr3_1_1_mismatched_set_exception.html#771484e7864decd1810b171963490bfc">expecting</a>
<a name="l00439"></a>00439             )
<a name="l00440"></a><a class="code" href="classantlr3_1_1_mismatched_set_exception.html#6529db544116395ec0d73ccb27ffc0b2">00440</a>     __repr__ = __str__
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="comment">##</span>
<a name="l00444"></a>00444 <span class="comment"># @brief Used for remote debugger deserialization</span>
<a name="l00445"></a><a class="code" href="classantlr3_1_1_mismatched_not_set_exception.html">00445</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_mismatched_not_set_exception.html" title="Used for remote debugger deserialization.">MismatchedNotSetException</a>(<a class="code" href="classantlr3_1_1_mismatched_set_exception.html" title="The next token does not match a set of expected types.">MismatchedSetException</a>):
<a name="l00446"></a>00446     
<a name="l00447"></a><a class="code" href="classantlr3_1_1_mismatched_not_set_exception.html#5e77768878072daddb97d79edfa74dcc">00447</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_not_set_exception.html#5e77768878072daddb97d79edfa74dcc">__str__</a>(self):
<a name="l00448"></a>00448         <span class="keywordflow">return</span> <span class="stringliteral">"MismatchedNotSetException(%r!=%r)"</span> % (
<a name="l00449"></a>00449             self.getUnexpectedType(), self.expecting
<a name="l00450"></a>00450             )
<a name="l00451"></a><a class="code" href="classantlr3_1_1_mismatched_not_set_exception.html#ebf999fc6571723bab16e1e0bb889f27">00451</a>     __repr__ = __str__
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">##</span>
<a name="l00455"></a>00455 <span class="comment"># @brief Unable to decide which alternative to choose.</span>
<a name="l00456"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html">00456</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html" title="Unable to decide which alternative to choose.">NoViableAltException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00457"></a>00457 
<a name="l00458"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#e82218a94a827cefc5ea26aeba5ce35c">00458</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#e82218a94a827cefc5ea26aeba5ce35c">__init__</a>(
<a name="l00459"></a>00459         self, grammarDecisionDescription, decisionNumber, stateNumber, input
<a name="l00460"></a>00460         ):
<a name="l00461"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#1722739eb9c7b50149e8a412a28579e6">00461</a>         RecognitionException.__init__(self, input)
<a name="l00462"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#5db9e9ee8142ad970ba6bfc912a77e3c">00462</a> 
<a name="l00463"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#49c9854abd44c703ee5a4029dcb6aa93">00463</a>         self.<a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#1722739eb9c7b50149e8a412a28579e6">grammarDecisionDescription</a> = grammarDecisionDescription
<a name="l00464"></a>00464         self.<a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#5db9e9ee8142ad970ba6bfc912a77e3c">decisionNumber</a> = decisionNumber
<a name="l00465"></a>00465         self.<a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#49c9854abd44c703ee5a4029dcb6aa93">stateNumber</a> = stateNumber
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 
<a name="l00468"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#380517edda587d321745789c45da4d2e">00468</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#380517edda587d321745789c45da4d2e">__str__</a>(self):
<a name="l00469"></a>00469         <span class="keywordflow">return</span> <span class="stringliteral">"NoViableAltException(%r!=[%r])"</span> % (
<a name="l00470"></a>00470             self.unexpectedType, self.<a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#1722739eb9c7b50149e8a412a28579e6">grammarDecisionDescription</a>
<a name="l00471"></a>00471             )
<a name="l00472"></a><a class="code" href="classantlr3_1_1_no_viable_alt_exception.html#bd9f4439a879d05a66f6bb3e2d4c7d3b">00472</a>     __repr__ = __str__
<a name="l00473"></a>00473     
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="comment">##</span>
<a name="l00476"></a>00476 <span class="comment"># @brief The recognizer did not match anything for a (..)+ loop.</span>
<a name="l00477"></a><a class="code" href="classantlr3_1_1_early_exit_exception.html">00477</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_early_exit_exception.html" title="The recognizer did not match anything for a (.">EarlyExitException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00478"></a>00478 
<a name="l00479"></a><a class="code" href="classantlr3_1_1_early_exit_exception.html#1617f27c54eaef510cbcb5af2be36f48">00479</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_early_exit_exception.html#1617f27c54eaef510cbcb5af2be36f48">__init__</a>(self, decisionNumber, input):
<a name="l00480"></a>00480         RecognitionException.__init__(self, input)
<a name="l00481"></a>00481 
<a name="l00482"></a><a class="code" href="classantlr3_1_1_early_exit_exception.html#8157790c58021a64d86d92bbcbbe600b">00482</a>         self.<a class="code" href="classantlr3_1_1_early_exit_exception.html#8157790c58021a64d86d92bbcbbe600b">decisionNumber</a> = decisionNumber
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="comment">##</span>
<a name="l00486"></a>00486 <span class="comment"># @brief A semantic predicate failed during validation.</span>
<a name="l00487"></a>00487 <span class="comment"># </span>
<a name="l00488"></a>00488 <span class="comment">#     Validation of predicates</span>
<a name="l00489"></a>00489 <span class="comment">#     occurs when normally parsing the alternative just like matching a token.</span>
<a name="l00490"></a>00490 <span class="comment">#     Disambiguating predicate evaluation occurs when we hoist a predicate into</span>
<a name="l00491"></a>00491 <span class="comment">#     a prediction decision.</span>
<a name="l00492"></a>00492 <span class="comment">#     </span>
<a name="l00493"></a><a class="code" href="classantlr3_1_1_failed_predicate_exception.html">00493</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_failed_predicate_exception.html" title="A semantic predicate failed during validation.">FailedPredicateException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00494"></a>00494 
<a name="l00495"></a><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#e9b9f01724af662328fdb7c18fb75f1d">00495</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#e9b9f01724af662328fdb7c18fb75f1d">__init__</a>(self, input, ruleName, predicateText):
<a name="l00496"></a>00496         RecognitionException.__init__(self, input)
<a name="l00497"></a>00497         
<a name="l00498"></a><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#95d43036c998fa1fed9d895e3f8cd95f">00498</a>         self.<a class="code" href="classantlr3_1_1_failed_predicate_exception.html#95d43036c998fa1fed9d895e3f8cd95f">ruleName</a> = ruleName
<a name="l00499"></a><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#b0bc8c0f188ff0cbf56e5f46ebaedc5f">00499</a>         self.<a class="code" href="classantlr3_1_1_failed_predicate_exception.html#b0bc8c0f188ff0cbf56e5f46ebaedc5f">predicateText</a> = predicateText
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 
<a name="l00502"></a><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#2fbf65069fd4686f29206a7935ea5aac">00502</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#2fbf65069fd4686f29206a7935ea5aac">__str__</a>(self):
<a name="l00503"></a>00503         <span class="keywordflow">return</span> <span class="stringliteral">"FailedPredicateException("</span>+self.<a class="code" href="classantlr3_1_1_failed_predicate_exception.html#95d43036c998fa1fed9d895e3f8cd95f">ruleName</a>+<span class="stringliteral">",{"</span>+self.<a class="code" href="classantlr3_1_1_failed_predicate_exception.html#b0bc8c0f188ff0cbf56e5f46ebaedc5f">predicateText</a>+<span class="stringliteral">"}?)"</span>
<a name="l00504"></a><a class="code" href="classantlr3_1_1_failed_predicate_exception.html#332b640466ca44ec915c0c13191e939d">00504</a>     __repr__ = __str__
<a name="l00505"></a>00505     
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 <span class="comment">##</span>
<a name="l00508"></a>00508 <span class="comment"># @brief The next tree mode does not match the expected type.</span>
<a name="l00509"></a><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html">00509</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html" title="The next tree mode does not match the expected type.">MismatchedTreeNodeException</a>(<a class="code" href="classantlr3_1_1_recognition_exception.html" title="The root of the ANTLR exception hierarchy.">RecognitionException</a>):
<a name="l00510"></a>00510 
<a name="l00511"></a><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#d648cd3b0bb3554f5f1491f957479ad2">00511</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#d648cd3b0bb3554f5f1491f957479ad2">__init__</a>(self, expecting, input):
<a name="l00512"></a>00512         RecognitionException.__init__(self, input)
<a name="l00513"></a>00513         
<a name="l00514"></a><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#0c82bef109b29d102697ce74ae57a841">00514</a>         self.<a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#0c82bef109b29d102697ce74ae57a841">expecting</a> = expecting
<a name="l00515"></a>00515 
<a name="l00516"></a><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#06086ce34c70791bb6f384d52a93306a">00516</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#06086ce34c70791bb6f384d52a93306a">__str__</a>(self):
<a name="l00517"></a>00517         <span class="keywordflow">return</span> <span class="stringliteral">"MismatchedTreeNodeException(%r!=%r)"</span> % (
<a name="l00518"></a>00518             self.getUnexpectedType(), self.<a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#0c82bef109b29d102697ce74ae57a841">expecting</a>
<a name="l00519"></a>00519             )
<a name="l00520"></a><a class="code" href="classantlr3_1_1_mismatched_tree_node_exception.html#22c3dbd3f4bd3c923f6e97fee78e5721">00520</a>     __repr__ = __str__
<a name="l00521"></a>00521 <span class="stringliteral">"""ANTLR3 runtime package"""</span>
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 
<a name="l00524"></a><a class="code" href="namespaceantlr3.html#a1f9401a7f689f41f3540d32de6a4ea0">00524</a> EOF = -1
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="comment">## All tokens go to the parser (unless skip() is called in that rule)</span>
<a name="l00527"></a>00527 <span class="comment"># on a particular "channel".  The parser tunes to a particular channel</span>
<a name="l00528"></a>00528 <span class="comment"># so that whitespace etc... can go to the parser on a "hidden" channel.</span>
<a name="l00529"></a><a class="code" href="namespaceantlr3.html#1dc3ab7cca55610a7a3e33545c75e6de">00529</a> DEFAULT_CHANNEL = 0
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="comment">## Anything on different channel than DEFAULT_CHANNEL is not parsed</span>
<a name="l00532"></a>00532 <span class="comment"># by parser.</span>
<a name="l00533"></a><a class="code" href="namespaceantlr3.html#569b3b96276a4c304f807881f74f89ed">00533</a> HIDDEN_CHANNEL = 99
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="comment"># Predefined token types</span>
<a name="l00536"></a><a class="code" href="namespaceantlr3.html#0e4b94fa51a73372afb86859dd3fb779">00536</a> EOR_TOKEN_TYPE = 1
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="comment">##</span>
<a name="l00539"></a>00539 <span class="comment"># imaginary tree navigation type; traverse "get child" link</span>
<a name="l00540"></a><a class="code" href="namespaceantlr3.html#2ae2f0bdb98db3b37c7efac01ca295ce">00540</a> DOWN = 2
<a name="l00541"></a>00541 <span class="comment">##</span>
<a name="l00542"></a>00542 <span class="comment">#imaginary tree navigation type; finish with a child list</span>
<a name="l00543"></a><a class="code" href="namespaceantlr3.html#27219cc1e6dfbdf59f9218b9432511d7">00543</a> UP = 3
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="namespaceantlr3.html#d7b9f538056f7981e12e864492564ff3">00545</a> MIN_TOKEN_TYPE = UP+1
<a name="l00546"></a>00546         
<a name="l00547"></a><a class="code" href="namespaceantlr3.html#e7f5ac3f9d89173a5d938f4ce3bf7626">00547</a> INVALID_TOKEN_TYPE = 0
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="stringliteral">"""ANTLR3 runtime package"""</span>
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="stringliteral">"""ANTLR3 runtime package"""</span>
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="keyword">from</span> antlr3.constants <span class="keyword">import</span> EOF, DEFAULT_CHANNEL, INVALID_TOKEN_TYPE
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="comment">############################################################################</span>
<a name="l00557"></a>00557 <span class="comment">#</span>
<a name="l00558"></a>00558 <span class="comment"># basic token interface</span>
<a name="l00559"></a>00559 <span class="comment">#</span>
<a name="l00560"></a>00560 <span class="comment">############################################################################</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="comment">##</span>
<a name="l00563"></a>00563 <span class="comment"># @brief Abstract token baseclass.</span>
<a name="l00564"></a><a class="code" href="classantlr3_1_1_token.html">00564</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_token.html" title="Abstract token baseclass.">Token</a>(object):
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     <span class="comment">##</span>
<a name="l00567"></a>00567     <span class="comment"># @brief Get the text of the token.</span>
<a name="l00568"></a>00568     <span class="comment"># </span>
<a name="l00569"></a>00569     <span class="comment">#         Using setter/getter methods is deprecated. Use o.text instead.</span>
<a name="l00570"></a>00570     <span class="comment">#         </span>
<a name="l00571"></a><a class="code" href="classantlr3_1_1_token.html#575bcd2b90f2d231209938903653e168">00571</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#575bcd2b90f2d231209938903653e168" title="Get the text of the token.">getText</a>(self):
<a name="l00572"></a>00572         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00573"></a>00573     
<a name="l00574"></a>00574     <span class="comment">##</span>
<a name="l00575"></a>00575     <span class="comment"># @brief Set the text of the token.</span>
<a name="l00576"></a>00576     <span class="comment"># </span>
<a name="l00577"></a>00577     <span class="comment">#         Using setter/getter methods is deprecated. Use o.text instead.</span>
<a name="l00578"></a>00578     <span class="comment">#         </span>
<a name="l00579"></a><a class="code" href="classantlr3_1_1_token.html#6009c6ff2b1007731a6092040fb39916">00579</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#6009c6ff2b1007731a6092040fb39916" title="Set the text of the token.">setText</a>(self, text):
<a name="l00580"></a>00580         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 
<a name="l00583"></a>00583     <span class="comment">##</span>
<a name="l00584"></a>00584     <span class="comment"># @brief Get the type of the token.</span>
<a name="l00585"></a>00585     <span class="comment"># </span>
<a name="l00586"></a>00586     <span class="comment">#         Using setter/getter methods is deprecated. Use o.type instead.</span>
<a name="l00587"></a><a class="code" href="classantlr3_1_1_token.html#caee9b721119a0e34af2e6b2dfa34509">00587</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#caee9b721119a0e34af2e6b2dfa34509" title="Get the type of the token.">getType</a>(self):
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00590"></a>00590     
<a name="l00591"></a>00591     <span class="comment">##</span>
<a name="l00592"></a>00592     <span class="comment"># @brief Get the type of the token.</span>
<a name="l00593"></a>00593     <span class="comment"># </span>
<a name="l00594"></a>00594     <span class="comment">#         Using setter/getter methods is deprecated. Use o.type instead.</span>
<a name="l00595"></a><a class="code" href="classantlr3_1_1_token.html#6efbb8549ab868b28a71717d5561b7b2">00595</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#6efbb8549ab868b28a71717d5561b7b2" title="Get the type of the token.">setType</a>(self, ttype):
<a name="l00596"></a>00596 
<a name="l00597"></a>00597         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00598"></a>00598     
<a name="l00599"></a>00599     
<a name="l00600"></a>00600     <span class="comment">##</span>
<a name="l00601"></a>00601     <span class="comment"># @brief Get the line number on which this token was matched</span>
<a name="l00602"></a>00602     <span class="comment"># </span>
<a name="l00603"></a>00603     <span class="comment">#         Lines are numbered 1..n</span>
<a name="l00604"></a>00604     <span class="comment">#         </span>
<a name="l00605"></a>00605     <span class="comment">#         Using setter/getter methods is deprecated. Use o.line instead.</span>
<a name="l00606"></a><a class="code" href="classantlr3_1_1_token.html#2114bd0b853fd4d38e85a7f9ad4f7088">00606</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#2114bd0b853fd4d38e85a7f9ad4f7088" title="Get the line number on which this token was matched.">getLine</a>(self):
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00609"></a>00609     
<a name="l00610"></a>00610     <span class="comment">##</span>
<a name="l00611"></a>00611     <span class="comment"># @brief Set the line number on which this token was matched</span>
<a name="l00612"></a>00612     <span class="comment"># </span>
<a name="l00613"></a>00613     <span class="comment">#         Using setter/getter methods is deprecated. Use o.line instead.</span>
<a name="l00614"></a><a class="code" href="classantlr3_1_1_token.html#5a90575b15acd76a53b90482d4ab3ae5">00614</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#5a90575b15acd76a53b90482d4ab3ae5" title="Set the line number on which this token was matched.">setLine</a>(self, line):
<a name="l00615"></a>00615 
<a name="l00616"></a>00616         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00617"></a>00617     
<a name="l00618"></a>00618     
<a name="l00619"></a>00619     <span class="comment">##</span>
<a name="l00620"></a>00620     <span class="comment"># @brief Get the column of the tokens first character,</span>
<a name="l00621"></a>00621     <span class="comment">#         </span>
<a name="l00622"></a>00622     <span class="comment">#         Columns are numbered 0..n-1</span>
<a name="l00623"></a>00623     <span class="comment">#         </span>
<a name="l00624"></a>00624     <span class="comment">#         Using setter/getter methods is deprecated. Use o.charPositionInLine instead.</span>
<a name="l00625"></a><a class="code" href="classantlr3_1_1_token.html#f1cf8d7049243eb0fd566dc6694d8259">00625</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#f1cf8d7049243eb0fd566dc6694d8259" title="Get the column of the tokens first character,.">getCharPositionInLine</a>(self):
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00628"></a>00628     
<a name="l00629"></a>00629     <span class="comment">##</span>
<a name="l00630"></a>00630     <span class="comment"># @brief Set the column of the tokens first character,</span>
<a name="l00631"></a>00631     <span class="comment"># </span>
<a name="l00632"></a>00632     <span class="comment">#         Using setter/getter methods is deprecated. Use o.charPositionInLine instead.</span>
<a name="l00633"></a><a class="code" href="classantlr3_1_1_token.html#fbeecb12fc5a239343c387351e25dbc8">00633</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#fbeecb12fc5a239343c387351e25dbc8" title="Set the column of the tokens first character,.">setCharPositionInLine</a>(self, pos):
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00636"></a>00636     
<a name="l00637"></a>00637 
<a name="l00638"></a>00638     <span class="comment">##</span>
<a name="l00639"></a>00639     <span class="comment"># @brief Get the channel of the token</span>
<a name="l00640"></a>00640     <span class="comment"># </span>
<a name="l00641"></a>00641     <span class="comment">#         Using setter/getter methods is deprecated. Use o.channel instead.</span>
<a name="l00642"></a><a class="code" href="classantlr3_1_1_token.html#330019515134b1741ca2eb07e534a279">00642</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#330019515134b1741ca2eb07e534a279" title="Get the channel of the token.">getChannel</a>(self):
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00645"></a>00645     
<a name="l00646"></a>00646     <span class="comment">##</span>
<a name="l00647"></a>00647     <span class="comment"># @brief Set the channel of the token</span>
<a name="l00648"></a>00648     <span class="comment"># </span>
<a name="l00649"></a>00649     <span class="comment">#         Using setter/getter methods is deprecated. Use o.channel instead.</span>
<a name="l00650"></a><a class="code" href="classantlr3_1_1_token.html#0a9d8d63c1b390eb44e3b94cd7b82e7d">00650</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#0a9d8d63c1b390eb44e3b94cd7b82e7d" title="Set the channel of the token.">setChannel</a>(self, channel):
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00653"></a>00653     
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     <span class="comment">##</span>
<a name="l00656"></a>00656     <span class="comment"># @brief Get the index in the input stream.</span>
<a name="l00657"></a>00657     <span class="comment"># </span>
<a name="l00658"></a>00658     <span class="comment">#         An index from 0..n-1 of the token object in the input stream.</span>
<a name="l00659"></a>00659     <span class="comment">#         This must be valid in order to use the ANTLRWorks debugger.</span>
<a name="l00660"></a>00660     <span class="comment">#         </span>
<a name="l00661"></a>00661     <span class="comment">#         Using setter/getter methods is deprecated. Use o.index instead.</span>
<a name="l00662"></a><a class="code" href="classantlr3_1_1_token.html#74e2c8bf50d5e372d5311aed2458704f">00662</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#74e2c8bf50d5e372d5311aed2458704f" title="Get the index in the input stream.">getTokenIndex</a>(self):
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00665"></a>00665     
<a name="l00666"></a>00666     <span class="comment">##</span>
<a name="l00667"></a>00667     <span class="comment"># @brief Set the index in the input stream.</span>
<a name="l00668"></a>00668     <span class="comment"># </span>
<a name="l00669"></a>00669     <span class="comment">#         Using setter/getter methods is deprecated. Use o.index instead.</span>
<a name="l00670"></a><a class="code" href="classantlr3_1_1_token.html#7e572452080e98a04f2ea0d50a5b7cfb">00670</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#7e572452080e98a04f2ea0d50a5b7cfb" title="Set the index in the input stream.">setTokenIndex</a>(self, index):
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     <span class="comment">##</span>
<a name="l00676"></a>00676     <span class="comment"># @brief From what character stream was this token created.</span>
<a name="l00677"></a>00677     <span class="comment"># </span>
<a name="l00678"></a>00678     <span class="comment">#         You don't have to implement but it's nice to know where a Token</span>
<a name="l00679"></a>00679     <span class="comment">#         comes from if you have include files etc... on the input.</span>
<a name="l00680"></a><a class="code" href="classantlr3_1_1_token.html#b2c296b972b53de1f8076cb29f918c65">00680</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#b2c296b972b53de1f8076cb29f918c65" title="From what character stream was this token created.">getInputStream</a>(self):
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     <span class="comment">##</span>
<a name="l00685"></a>00685     <span class="comment"># @brief From what character stream was this token created.</span>
<a name="l00686"></a>00686     <span class="comment"># </span>
<a name="l00687"></a>00687     <span class="comment">#         You don't have to implement but it's nice to know where a Token</span>
<a name="l00688"></a>00688     <span class="comment">#         comes from if you have include files etc... on the input.</span>
<a name="l00689"></a><a class="code" href="classantlr3_1_1_token.html#99f1e1734647778789a7eea58be21908">00689</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token.html#99f1e1734647778789a7eea58be21908" title="From what character stream was this token created.">setInputStream</a>(self, input):
<a name="l00690"></a>00690 
<a name="l00691"></a>00691         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="comment">############################################################################</span>
<a name="l00695"></a>00695 <span class="comment">#</span>
<a name="l00696"></a>00696 <span class="comment"># token implementations</span>
<a name="l00697"></a>00697 <span class="comment">#</span>
<a name="l00698"></a>00698 <span class="comment"># Token</span>
<a name="l00699"></a>00699 <span class="comment"># +- CommonToken</span>
<a name="l00700"></a>00700 <span class="comment"># \- ClassicToken</span>
<a name="l00701"></a>00701 <span class="comment">#</span>
<a name="l00702"></a>00702 <span class="comment">############################################################################</span>
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="comment">##</span>
<a name="l00705"></a>00705 <span class="comment"># @brief Basic token implementation.</span>
<a name="l00706"></a>00706 <span class="comment"># </span>
<a name="l00707"></a>00707 <span class="comment">#     This implementation does not copy the text from the input stream upon</span>
<a name="l00708"></a>00708 <span class="comment">#     creation, but keeps start/stop pointers into the stream to avoid</span>
<a name="l00709"></a>00709 <span class="comment">#     unnecessary copy operations.</span>
<a name="l00710"></a>00710 <span class="comment"># </span>
<a name="l00711"></a>00711 <span class="comment">#     </span>
<a name="l00712"></a><a class="code" href="classantlr3_1_1_common_token.html">00712</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_common_token.html" title="Basic token implementation.">CommonToken</a>(<a class="code" href="classantlr3_1_1_token.html" title="Abstract token baseclass.">Token</a>):
<a name="l00713"></a>00713     
<a name="l00714"></a><a class="code" href="classantlr3_1_1_common_token.html#f92bf66ac9635b78689e88b088572ad5">00714</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#f92bf66ac9635b78689e88b088572ad5">__init__</a>(self, type=None, channel=DEFAULT_CHANNEL, text=None,
<a name="l00715"></a>00715                  input=<span class="keywordtype">None</span>, start=<span class="keywordtype">None</span>, stop=<span class="keywordtype">None</span>, oldToken=<span class="keywordtype">None</span>):
<a name="l00716"></a>00716         Token.__init__(self)
<a name="l00717"></a>00717         
<a name="l00718"></a><a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">00718</a>         <span class="keywordflow">if</span> oldToken <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00719"></a><a class="code" href="classantlr3_1_1_common_token.html#363f45f220def834d8c86388d55c132f">00719</a>             self.<a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">type</a> = oldToken.type
<a name="l00720"></a><a class="code" href="classantlr3_1_1_common_token.html#13e42e19d1de2dfaf332a4faed54c966">00720</a>             self.<a class="code" href="classantlr3_1_1_common_token.html#363f45f220def834d8c86388d55c132f">line</a> = oldToken.line
<a name="l00721"></a><a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">00721</a>             self.<a class="code" href="classantlr3_1_1_common_token.html#13e42e19d1de2dfaf332a4faed54c966">charPositionInLine</a> = oldToken.charPositionInLine
<a name="l00722"></a><a class="code" href="classantlr3_1_1_common_token.html#0f7038e22b79f38979e2a2a9f20cf8a0">00722</a>             self.<a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">channel</a> = oldToken.channel
<a name="l00723"></a><a class="code" href="classantlr3_1_1_common_token.html#e94fd5019f62ca5a841357473dcb9cb3">00723</a>             self.<a class="code" href="classantlr3_1_1_common_token.html#0f7038e22b79f38979e2a2a9f20cf8a0">index</a> = oldToken.index
<a name="l00724"></a>00724             self.<a class="code" href="classantlr3_1_1_common_token.html#e94fd5019f62ca5a841357473dcb9cb3">_text</a> = oldToken._text
<a name="l00725"></a><a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">00725</a>             <span class="keywordflow">if</span> isinstance(oldToken, CommonToken):
<a name="l00726"></a><a class="code" href="classantlr3_1_1_common_token.html#018ec8283b8fa2e58b6ccd8dec8ad892">00726</a>                 self.<a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">input</a> = oldToken.input
<a name="l00727"></a><a class="code" href="classantlr3_1_1_common_token.html#f9b8a5ed90f7c7f11eae96d0ba2c7a8d">00727</a>                 self.<a class="code" href="classantlr3_1_1_common_token.html#018ec8283b8fa2e58b6ccd8dec8ad892">start</a> = oldToken.start
<a name="l00728"></a>00728                 self.<a class="code" href="classantlr3_1_1_common_token.html#f9b8a5ed90f7c7f11eae96d0ba2c7a8d">stop</a> = oldToken.stop
<a name="l00729"></a>00729             
<a name="l00730"></a>00730         <span class="keywordflow">else</span>:
<a name="l00731"></a>00731             self.<a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">type</a> = type
<a name="l00732"></a>00732             self.<a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">input</a> = input
<a name="l00733"></a>00733             self.<a class="code" href="classantlr3_1_1_common_token.html#13e42e19d1de2dfaf332a4faed54c966">charPositionInLine</a> = -1 <span class="comment"># set to invalid position</span>
<a name="l00734"></a>00734             self.<a class="code" href="classantlr3_1_1_common_token.html#363f45f220def834d8c86388d55c132f">line</a> = 0
<a name="l00735"></a>00735             self.<a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">channel</a> = channel
<a name="l00736"></a>00736             
<a name="l00737"></a>00737             <span class="comment">#What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index</span>
<a name="l00738"></a>00738             self.<a class="code" href="classantlr3_1_1_common_token.html#0f7038e22b79f38979e2a2a9f20cf8a0">index</a> = -1
<a name="l00739"></a>00739             
<a name="l00740"></a>00740             <span class="comment"># We need to be able to change the text once in a while.  If</span>
<a name="l00741"></a>00741             <span class="comment"># this is non-null, then getText should return this.  Note that</span>
<a name="l00742"></a>00742             <span class="comment"># start/stop are not affected by changing this.</span>
<a name="l00743"></a>00743             self.<a class="code" href="classantlr3_1_1_common_token.html#e94fd5019f62ca5a841357473dcb9cb3">_text</a> = text
<a name="l00744"></a>00744 
<a name="l00745"></a>00745             <span class="comment"># The char position into the input buffer where this token starts</span>
<a name="l00746"></a>00746             self.<a class="code" href="classantlr3_1_1_common_token.html#018ec8283b8fa2e58b6ccd8dec8ad892">start</a> = start
<a name="l00747"></a>00747 
<a name="l00748"></a>00748             <span class="comment"># The char position into the input buffer where this token stops</span>
<a name="l00749"></a>00749             <span class="comment"># This is the index of the last char, *not* the index after it!</span>
<a name="l00750"></a>00750             self.<a class="code" href="classantlr3_1_1_common_token.html#f9b8a5ed90f7c7f11eae96d0ba2c7a8d">stop</a> = stop
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 
<a name="l00753"></a><a class="code" href="classantlr3_1_1_common_token.html#aa541e5abc188c3b8251d558cdab8fb5">00753</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#aa541e5abc188c3b8251d558cdab8fb5" title="Get the text of the token.">getText</a>(self):
<a name="l00754"></a>00754         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token.html#e94fd5019f62ca5a841357473dcb9cb3">_text</a> <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00755"></a>00755             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#e94fd5019f62ca5a841357473dcb9cb3">_text</a>
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">input</a> <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00758"></a>00758             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l00759"></a>00759         
<a name="l00760"></a>00760         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">input</a>.substring(self.<a class="code" href="classantlr3_1_1_common_token.html#018ec8283b8fa2e58b6ccd8dec8ad892">start</a>, self.<a class="code" href="classantlr3_1_1_common_token.html#f9b8a5ed90f7c7f11eae96d0ba2c7a8d">stop</a>)
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="comment">##</span>
<a name="l00764"></a>00764     <span class="comment"># </span>
<a name="l00765"></a>00765     <span class="comment">#         Override the text for this token.  getText() will return this text</span>
<a name="l00766"></a>00766     <span class="comment">#         rather than pulling from the buffer.  Note that this does not mean</span>
<a name="l00767"></a>00767     <span class="comment">#         that start/stop indexes are not valid.  It means that that input</span>
<a name="l00768"></a>00768     <span class="comment">#         was converted to a new string in the token object.</span>
<a name="l00769"></a>00769     <span class="comment">#   </span>
<a name="l00770"></a><a class="code" href="classantlr3_1_1_common_token.html#5fa1aa677c0ccc312ad064f5cabb7b8e">00770</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#5fa1aa677c0ccc312ad064f5cabb7b8e" title="Override the text for this token.">setText</a>(self, text):
<a name="l00771"></a>00771         self.<a class="code" href="classantlr3_1_1_common_token.html#e94fd5019f62ca5a841357473dcb9cb3">_text</a> = text
<a name="l00772"></a>00772 
<a name="l00773"></a><a class="code" href="classantlr3_1_1_common_token.html#57b58cb067f4d62440ac49432782e49d">00773</a>     text = property(getText, setText)
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 
<a name="l00776"></a><a class="code" href="classantlr3_1_1_common_token.html#43b5b7320be501b6c104d8c7f7e1c6c7">00776</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#43b5b7320be501b6c104d8c7f7e1c6c7" title="Get the type of the token.">getType</a>(self):
<a name="l00777"></a>00777         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">type</a> 
<a name="l00778"></a>00778 
<a name="l00779"></a><a class="code" href="classantlr3_1_1_common_token.html#567a716e11ba54269ebc7f02d4ca3a5d">00779</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#567a716e11ba54269ebc7f02d4ca3a5d" title="Get the type of the token.">setType</a>(self, ttype):
<a name="l00780"></a>00780         self.<a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">type</a> = ttype
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     
<a name="l00783"></a><a class="code" href="classantlr3_1_1_common_token.html#c347c982192ed82bee308e3194cd5a19">00783</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#c347c982192ed82bee308e3194cd5a19" title="Get the line number on which this token was matched.">getLine</a>(self):
<a name="l00784"></a>00784         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#363f45f220def834d8c86388d55c132f">line</a>
<a name="l00785"></a>00785     
<a name="l00786"></a><a class="code" href="classantlr3_1_1_common_token.html#7f3133c1fed139285267c1859fbf1785">00786</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#7f3133c1fed139285267c1859fbf1785" title="Set the line number on which this token was matched.">setLine</a>(self, line):
<a name="l00787"></a>00787         self.<a class="code" href="classantlr3_1_1_common_token.html#363f45f220def834d8c86388d55c132f">line</a> = line
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 
<a name="l00790"></a><a class="code" href="classantlr3_1_1_common_token.html#0a2f93c12723b8bcc9d5117e72ca2fb7">00790</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#0a2f93c12723b8bcc9d5117e72ca2fb7" title="Get the column of the tokens first character,.">getCharPositionInLine</a>(self):
<a name="l00791"></a>00791         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#13e42e19d1de2dfaf332a4faed54c966">charPositionInLine</a>
<a name="l00792"></a>00792     
<a name="l00793"></a><a class="code" href="classantlr3_1_1_common_token.html#7f7cf22474cb8847ffc49d35298eb68f">00793</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#7f7cf22474cb8847ffc49d35298eb68f" title="Set the column of the tokens first character,.">setCharPositionInLine</a>(self, pos):
<a name="l00794"></a>00794         self.<a class="code" href="classantlr3_1_1_common_token.html#13e42e19d1de2dfaf332a4faed54c966">charPositionInLine</a> = pos
<a name="l00795"></a>00795 
<a name="l00796"></a>00796 
<a name="l00797"></a><a class="code" href="classantlr3_1_1_common_token.html#c1275a50268c93f89f5e0ee3db3cfb0d">00797</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#c1275a50268c93f89f5e0ee3db3cfb0d" title="Get the channel of the token.">getChannel</a>(self):
<a name="l00798"></a>00798         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">channel</a>
<a name="l00799"></a>00799     
<a name="l00800"></a><a class="code" href="classantlr3_1_1_common_token.html#aa87a76250b5fcd76999aa05c9e4b76b">00800</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#aa87a76250b5fcd76999aa05c9e4b76b" title="Set the channel of the token.">setChannel</a>(self, channel):
<a name="l00801"></a>00801         self.<a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">channel</a> = channel
<a name="l00802"></a>00802     
<a name="l00803"></a>00803 
<a name="l00804"></a><a class="code" href="classantlr3_1_1_common_token.html#aed41a0da49a7ceeb6f421689455e59f">00804</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#aed41a0da49a7ceeb6f421689455e59f" title="Get the index in the input stream.">getTokenIndex</a>(self):
<a name="l00805"></a>00805         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#0f7038e22b79f38979e2a2a9f20cf8a0">index</a>
<a name="l00806"></a>00806     
<a name="l00807"></a><a class="code" href="classantlr3_1_1_common_token.html#d98f8aebea069d8fd60c6501d25508c9">00807</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#d98f8aebea069d8fd60c6501d25508c9" title="Set the index in the input stream.">setTokenIndex</a>(self, index):
<a name="l00808"></a>00808         self.<a class="code" href="classantlr3_1_1_common_token.html#0f7038e22b79f38979e2a2a9f20cf8a0">index</a> = index
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 
<a name="l00811"></a><a class="code" href="classantlr3_1_1_common_token.html#2e8d6f2ab1a7b21e42e7527e899f2011">00811</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#2e8d6f2ab1a7b21e42e7527e899f2011" title="From what character stream was this token created.">getInputStream</a>(self):
<a name="l00812"></a>00812         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">input</a>
<a name="l00813"></a>00813 
<a name="l00814"></a><a class="code" href="classantlr3_1_1_common_token.html#a2fc6351fb65408f5adccf08c2624f29">00814</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#a2fc6351fb65408f5adccf08c2624f29" title="From what character stream was this token created.">setInputStream</a>(self, input):
<a name="l00815"></a>00815         self.<a class="code" href="classantlr3_1_1_common_token.html#8bf1c65296f76091a833495fcf92e210">input</a> = input
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 
<a name="l00818"></a><a class="code" href="classantlr3_1_1_common_token.html#e316d675a7b6aa9756787a7a11a0dca3">00818</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token.html#e316d675a7b6aa9756787a7a11a0dca3">__str__</a>(self):
<a name="l00819"></a>00819         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">type</a> == EOF:
<a name="l00820"></a>00820             <span class="keywordflow">return</span> <span class="stringliteral">"&lt;EOF&gt;"</span>
<a name="l00821"></a>00821 
<a name="l00822"></a>00822         channelStr = <span class="stringliteral">""</span>
<a name="l00823"></a>00823         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">channel</a> &gt; 0:
<a name="l00824"></a>00824             channelStr = <span class="stringliteral">",channel="</span> + str(self.<a class="code" href="classantlr3_1_1_common_token.html#04f93da3021d554abd07a5c16b9e04b2">channel</a>)
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         txt = self.<a class="code" href="classantlr3_1_1_common_token.html#57b58cb067f4d62440ac49432782e49d">text</a>
<a name="l00827"></a>00827         <span class="keywordflow">if</span> txt <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00828"></a>00828             txt = txt.replace(<span class="stringliteral">"\n"</span>,<span class="stringliteral">"\\\\n"</span>)
<a name="l00829"></a>00829             txt = txt.replace(<span class="stringliteral">"\r"</span>,<span class="stringliteral">"\\\\</span><span class="stringliteral">r")</span>
<a name="l00830"></a>00830 <span class="stringliteral">            txt = txt.replace(</span><span class="stringliteral">"\t"</span>,<span class="stringliteral">"\\\\t"</span>)
<a name="l00831"></a>00831         <span class="keywordflow">else</span>:
<a name="l00832"></a>00832             txt = <span class="stringliteral">"&lt;no text&gt;"</span>
<a name="l00833"></a>00833 
<a name="l00834"></a>00834         <span class="keywordflow">return</span> <span class="stringliteral">"[@%d,%d:%d=%r,&lt;%d&gt;%s,%d:%d]"</span> % (
<a name="l00835"></a>00835             self.<a class="code" href="classantlr3_1_1_common_token.html#0f7038e22b79f38979e2a2a9f20cf8a0">index</a>,
<a name="l00836"></a>00836             self.<a class="code" href="classantlr3_1_1_common_token.html#018ec8283b8fa2e58b6ccd8dec8ad892">start</a>, self.<a class="code" href="classantlr3_1_1_common_token.html#f9b8a5ed90f7c7f11eae96d0ba2c7a8d">stop</a>,
<a name="l00837"></a>00837             txt,
<a name="l00838"></a>00838             self.<a class="code" href="classantlr3_1_1_common_token.html#56fbc4950cebcda2e5dfbaa7c46afd1e">type</a>, channelStr,
<a name="l00839"></a>00839             self.<a class="code" href="classantlr3_1_1_common_token.html#363f45f220def834d8c86388d55c132f">line</a>, self.<a class="code" href="classantlr3_1_1_common_token.html#13e42e19d1de2dfaf332a4faed54c966">charPositionInLine</a>
<a name="l00840"></a>00840             )
<a name="l00841"></a>00841     
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="comment">##</span>
<a name="l00844"></a>00844 <span class="comment"># @brief Alternative token implementation.</span>
<a name="l00845"></a>00845 <span class="comment">#     </span>
<a name="l00846"></a>00846 <span class="comment">#     A Token object like we'd use in ANTLR 2.x; has an actual string created</span>
<a name="l00847"></a>00847 <span class="comment">#     and associated with this object.  These objects are needed for imaginary</span>
<a name="l00848"></a>00848 <span class="comment">#     tree nodes that have payload objects.  We need to create a Token object</span>
<a name="l00849"></a>00849 <span class="comment">#     that has a string; the tree node will point at this token.  CommonToken</span>
<a name="l00850"></a>00850 <span class="comment">#     has indexes into a char stream and hence cannot be used to introduce</span>
<a name="l00851"></a>00851 <span class="comment">#     new strings.</span>
<a name="l00852"></a>00852 <span class="comment">#     </span>
<a name="l00853"></a><a class="code" href="classantlr3_1_1_classic_token.html">00853</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_classic_token.html" title="Alternative token implementation.">ClassicToken</a>(<a class="code" href="classantlr3_1_1_token.html" title="Abstract token baseclass.">Token</a>):
<a name="l00854"></a>00854 
<a name="l00855"></a><a class="code" href="classantlr3_1_1_classic_token.html#8665985401a1319d2e0b564a070c4cfb">00855</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#8665985401a1319d2e0b564a070c4cfb">__init__</a>(self, type=None, text=None, channel=DEFAULT_CHANNEL,
<a name="l00856"></a>00856                  oldToken=<span class="keywordtype">None</span>
<a name="l00857"></a>00857                  ):
<a name="l00858"></a>00858         Token.__init__(self)
<a name="l00859"></a><a class="code" href="classantlr3_1_1_classic_token.html#c0b2e82910349cca9d79571d13b96f14">00859</a>         
<a name="l00860"></a><a class="code" href="classantlr3_1_1_classic_token.html#b35f33b74edc34a7b7c801b62cfa24e4">00860</a>         <span class="keywordflow">if</span> oldToken <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00861"></a><a class="code" href="classantlr3_1_1_classic_token.html#baa832e84831cac6c1010d9848846d09">00861</a>             self.<a class="code" href="classantlr3_1_1_classic_token.html#c0b2e82910349cca9d79571d13b96f14">text</a> = oldToken.text
<a name="l00862"></a><a class="code" href="classantlr3_1_1_classic_token.html#e093f5772469bbbe88ccc210202c2803">00862</a>             self.<a class="code" href="classantlr3_1_1_classic_token.html#b35f33b74edc34a7b7c801b62cfa24e4">type</a> = oldToken.type
<a name="l00863"></a><a class="code" href="classantlr3_1_1_classic_token.html#6403eef27a7e13ba39a391db2e225723">00863</a>             self.<a class="code" href="classantlr3_1_1_classic_token.html#baa832e84831cac6c1010d9848846d09">line</a> = oldToken.line
<a name="l00864"></a>00864             self.<a class="code" href="classantlr3_1_1_classic_token.html#e093f5772469bbbe88ccc210202c2803">charPositionInLine</a> = oldToken.charPositionInLine
<a name="l00865"></a>00865             self.<a class="code" href="classantlr3_1_1_classic_token.html#6403eef27a7e13ba39a391db2e225723">channel</a> = oldToken.channel
<a name="l00866"></a>00866             
<a name="l00867"></a>00867         self.<a class="code" href="classantlr3_1_1_classic_token.html#c0b2e82910349cca9d79571d13b96f14">text</a> = text
<a name="l00868"></a>00868         self.<a class="code" href="classantlr3_1_1_classic_token.html#b35f33b74edc34a7b7c801b62cfa24e4">type</a> = type
<a name="l00869"></a>00869         self.<a class="code" href="classantlr3_1_1_classic_token.html#baa832e84831cac6c1010d9848846d09">line</a> = <span class="keywordtype">None</span>
<a name="l00870"></a><a class="code" href="classantlr3_1_1_classic_token.html#5ffc1965280856019358a805f0f1731c">00870</a>         self.<a class="code" href="classantlr3_1_1_classic_token.html#e093f5772469bbbe88ccc210202c2803">charPositionInLine</a> = <span class="keywordtype">None</span>
<a name="l00871"></a>00871         self.<a class="code" href="classantlr3_1_1_classic_token.html#6403eef27a7e13ba39a391db2e225723">channel</a> = channel
<a name="l00872"></a>00872         self.<a class="code" href="classantlr3_1_1_classic_token.html#5ffc1965280856019358a805f0f1731c">index</a> = <span class="keywordtype">None</span>
<a name="l00873"></a>00873 
<a name="l00874"></a>00874 
<a name="l00875"></a><a class="code" href="classantlr3_1_1_classic_token.html#8fc1b94ae66900e3f2f2bbbb109289d7">00875</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#8fc1b94ae66900e3f2f2bbbb109289d7" title="Get the text of the token.">getText</a>(self):
<a name="l00876"></a>00876         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_classic_token.html#c0b2e82910349cca9d79571d13b96f14">text</a>
<a name="l00877"></a>00877 
<a name="l00878"></a><a class="code" href="classantlr3_1_1_classic_token.html#add6e7e215eb61846cfac9d865cddac1">00878</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#add6e7e215eb61846cfac9d865cddac1" title="Set the text of the token.">setText</a>(self, text):
<a name="l00879"></a>00879         self.<a class="code" href="classantlr3_1_1_classic_token.html#c0b2e82910349cca9d79571d13b96f14">text</a> = text
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 
<a name="l00882"></a><a class="code" href="classantlr3_1_1_classic_token.html#cfbfa6934fc3e84a4258997dcff97686">00882</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#cfbfa6934fc3e84a4258997dcff97686" title="Get the type of the token.">getType</a>(self):
<a name="l00883"></a>00883         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_classic_token.html#b35f33b74edc34a7b7c801b62cfa24e4">type</a> 
<a name="l00884"></a>00884 
<a name="l00885"></a><a class="code" href="classantlr3_1_1_classic_token.html#171ab4b518ade8d444db0fc8604a5e0a">00885</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#171ab4b518ade8d444db0fc8604a5e0a" title="Get the type of the token.">setType</a>(self, ttype):
<a name="l00886"></a>00886         self.<a class="code" href="classantlr3_1_1_classic_token.html#b35f33b74edc34a7b7c801b62cfa24e4">type</a> = ttype
<a name="l00887"></a>00887 
<a name="l00888"></a>00888     
<a name="l00889"></a><a class="code" href="classantlr3_1_1_classic_token.html#c2e6624db75408b3c7dacedf99cb2e7a">00889</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#c2e6624db75408b3c7dacedf99cb2e7a" title="Get the line number on which this token was matched.">getLine</a>(self):
<a name="l00890"></a>00890         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_classic_token.html#baa832e84831cac6c1010d9848846d09">line</a>
<a name="l00891"></a>00891     
<a name="l00892"></a><a class="code" href="classantlr3_1_1_classic_token.html#ac85e1895fa1f6b7964b6ced5e509e51">00892</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#ac85e1895fa1f6b7964b6ced5e509e51" title="Set the line number on which this token was matched.">setLine</a>(self, line):
<a name="l00893"></a>00893         self.<a class="code" href="classantlr3_1_1_classic_token.html#baa832e84831cac6c1010d9848846d09">line</a> = line
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 
<a name="l00896"></a><a class="code" href="classantlr3_1_1_classic_token.html#2c30a9d76902883b64efec4df17534f5">00896</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#2c30a9d76902883b64efec4df17534f5" title="Get the column of the tokens first character,.">getCharPositionInLine</a>(self):
<a name="l00897"></a>00897         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_classic_token.html#e093f5772469bbbe88ccc210202c2803">charPositionInLine</a>
<a name="l00898"></a>00898     
<a name="l00899"></a><a class="code" href="classantlr3_1_1_classic_token.html#0bf7d84ed1dcd90135b576dd9f38001b">00899</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#0bf7d84ed1dcd90135b576dd9f38001b" title="Set the column of the tokens first character,.">setCharPositionInLine</a>(self, pos):
<a name="l00900"></a>00900         self.<a class="code" href="classantlr3_1_1_classic_token.html#e093f5772469bbbe88ccc210202c2803">charPositionInLine</a> = pos
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 
<a name="l00903"></a><a class="code" href="classantlr3_1_1_classic_token.html#cbc56f3073b1b292d65051a5fd5cfe0d">00903</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#cbc56f3073b1b292d65051a5fd5cfe0d" title="Get the channel of the token.">getChannel</a>(self):
<a name="l00904"></a>00904         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_classic_token.html#6403eef27a7e13ba39a391db2e225723">channel</a>
<a name="l00905"></a>00905     
<a name="l00906"></a><a class="code" href="classantlr3_1_1_classic_token.html#a1a63c4c1e08c50bbd1743bada97f058">00906</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#a1a63c4c1e08c50bbd1743bada97f058" title="Set the channel of the token.">setChannel</a>(self, channel):
<a name="l00907"></a>00907         self.<a class="code" href="classantlr3_1_1_classic_token.html#6403eef27a7e13ba39a391db2e225723">channel</a> = channel
<a name="l00908"></a>00908     
<a name="l00909"></a>00909 
<a name="l00910"></a><a class="code" href="classantlr3_1_1_classic_token.html#5c5761d0f8c136422e67e5834b0b237e">00910</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#5c5761d0f8c136422e67e5834b0b237e" title="Get the index in the input stream.">getTokenIndex</a>(self):
<a name="l00911"></a>00911         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_classic_token.html#5ffc1965280856019358a805f0f1731c">index</a>
<a name="l00912"></a>00912     
<a name="l00913"></a><a class="code" href="classantlr3_1_1_classic_token.html#b94512fe5d4ce9f23316af2882244d50">00913</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#b94512fe5d4ce9f23316af2882244d50" title="Set the index in the input stream.">setTokenIndex</a>(self, index):
<a name="l00914"></a>00914         self.<a class="code" href="classantlr3_1_1_classic_token.html#5ffc1965280856019358a805f0f1731c">index</a> = index
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 
<a name="l00917"></a><a class="code" href="classantlr3_1_1_classic_token.html#4ce3eeff40c32e5d15c558e11c554484">00917</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#4ce3eeff40c32e5d15c558e11c554484" title="From what character stream was this token created.">getInputStream</a>(self):
<a name="l00918"></a>00918         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l00919"></a>00919 
<a name="l00920"></a><a class="code" href="classantlr3_1_1_classic_token.html#1a63fb23a3664efbbf4bdb589b69434b">00920</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#1a63fb23a3664efbbf4bdb589b69434b" title="From what character stream was this token created.">setInputStream</a>(self, input):
<a name="l00921"></a>00921         <span class="keywordflow">pass</span>
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 
<a name="l00924"></a><a class="code" href="classantlr3_1_1_classic_token.html#39a3110f8ea932625a3853e948af2168">00924</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_classic_token.html#39a3110f8ea932625a3853e948af2168">toString</a>(self):
<a name="l00925"></a>00925         channelStr = <span class="stringliteral">""</span>
<a name="l00926"></a>00926         <span class="keywordflow">if</span> self.channel &gt; 0:
<a name="l00927"></a>00927             channelStr = <span class="stringliteral">",channel="</span> + str(self.channel)
<a name="l00928"></a>00928             
<a name="l00929"></a>00929         txt = self.text
<a name="l00930"></a>00930         <span class="keywordflow">if</span> txt <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00931"></a>00931             txt = <span class="stringliteral">"&lt;no text&gt;"</span>
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         <span class="keywordflow">return</span> <span class="stringliteral">"[@%r,%r,&lt;%r&gt;%s,%r:%r]"</span> % (self.index,
<a name="l00934"></a>00934                                           txt,
<a name="l00935"></a>00935                                           self.type,
<a name="l00936"></a>00936                                           channelStr,
<a name="l00937"></a>00937                                           self.line,
<a name="l00938"></a>00938                                           self.charPositionInLine
<a name="l00939"></a>00939                                           )
<a name="l00940"></a>00940     
<a name="l00941"></a>00941 
<a name="l00942"></a><a class="code" href="classantlr3_1_1_classic_token.html#8186e97c926fee26a6cf9d449ab98973">00942</a>     __str__ = toString
<a name="l00943"></a><a class="code" href="classantlr3_1_1_classic_token.html#e8b7da9b9e48fc5fba574be5434adb71">00943</a>     __repr__ = toString
<a name="l00944"></a>00944 
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 
<a name="l00947"></a><a class="code" href="namespaceantlr3.html#a5d7c852159cfcb6a10380b0295b90d3">00947</a> EOF_TOKEN = CommonToken(type=EOF)
<a name="l00948"></a>00948         
<a name="l00949"></a><a class="code" href="namespaceantlr3.html#32e1f978a70f45ed2481156400588762">00949</a> INVALID_TOKEN = CommonToken(type=INVALID_TOKEN_TYPE)
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="comment"># In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR</span>
<a name="l00952"></a>00952 <span class="comment"># will avoid creating a token for this symbol and try to fetch another.</span>
<a name="l00953"></a><a class="code" href="namespaceantlr3.html#0b6b83566bbc02006ca908521a0bb7fe">00953</a> SKIP_TOKEN = CommonToken(type=INVALID_TOKEN_TYPE)
<a name="l00954"></a>00954 
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="stringliteral">"""ANTLR3 runtime package"""</span>
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="keyword">import</span> codecs
<a name="l00960"></a>00960 <span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <span class="keyword">from</span> antlr3.constants <span class="keyword">import</span> DEFAULT_CHANNEL, EOF
<a name="l00963"></a>00963 <span class="keyword">from</span> antlr3.tokens <span class="keyword">import</span> Token, EOF_TOKEN
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 <span class="comment">############################################################################</span>
<a name="l00967"></a>00967 <span class="comment">#</span>
<a name="l00968"></a>00968 <span class="comment"># basic interfaces</span>
<a name="l00969"></a>00969 <span class="comment">#   IntStream</span>
<a name="l00970"></a>00970 <span class="comment">#    +- CharStream</span>
<a name="l00971"></a>00971 <span class="comment">#    \- TokenStream</span>
<a name="l00972"></a>00972 <span class="comment">#</span>
<a name="l00973"></a>00973 <span class="comment"># subclasses must implemented all methods</span>
<a name="l00974"></a>00974 <span class="comment">#</span>
<a name="l00975"></a>00975 <span class="comment">############################################################################</span>
<a name="l00976"></a>00976 
<a name="l00977"></a>00977 <span class="comment">##</span>
<a name="l00978"></a>00978 <span class="comment"># </span>
<a name="l00979"></a>00979 <span class="comment">#     @brief Base interface for streams of integer values.</span>
<a name="l00980"></a>00980 <span class="comment"># </span>
<a name="l00981"></a>00981 <span class="comment">#     A simple stream of integers used when all I care about is the char</span>
<a name="l00982"></a>00982 <span class="comment">#     or token type sequence (such as interpretation).</span>
<a name="l00983"></a>00983 <span class="comment">#     </span>
<a name="l00984"></a><a class="code" href="classantlr3_1_1_int_stream.html">00984</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_int_stream.html" title="Base interface for streams of integer values.">IntStream</a>(object):
<a name="l00985"></a>00985 
<a name="l00986"></a><a class="code" href="classantlr3_1_1_int_stream.html#0f8f6b0d2d3ba2317c647e7c4f04db58">00986</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#0f8f6b0d2d3ba2317c647e7c4f04db58">consume</a>(self):
<a name="l00987"></a>00987         <span class="keywordflow">raise</span> NotImplementedError
<a name="l00988"></a>00988     
<a name="l00989"></a>00989 
<a name="l00990"></a>00990     <span class="comment">##</span>
<a name="l00991"></a>00991     <span class="comment"># Get int at current input pointer + i ahead where i=1 is next int.</span>
<a name="l00992"></a>00992     <span class="comment"># </span>
<a name="l00993"></a>00993     <span class="comment">#         Negative indexes are allowed.  LA(-1) is previous token (token</span>
<a name="l00994"></a>00994     <span class="comment">#   just matched).  LA(-i) where i is before first token should</span>
<a name="l00995"></a>00995     <span class="comment">#   yield -1, invalid char / EOF.</span>
<a name="l00996"></a>00996     <span class="comment">#   </span>
<a name="l00997"></a><a class="code" href="classantlr3_1_1_int_stream.html#f51184ac892ca0f89d2b93767201b46d">00997</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#f51184ac892ca0f89d2b93767201b46d" title="Get int at current input pointer + i ahead where i=1 is next int.">LA</a>(self, i):
<a name="l00998"></a>00998         
<a name="l00999"></a>00999         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01000"></a>01000         
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="comment">##</span>
<a name="l01003"></a>01003     <span class="comment"># </span>
<a name="l01004"></a>01004     <span class="comment">#         Tell the stream to start buffering if it hasn't already.  Return</span>
<a name="l01005"></a>01005     <span class="comment">#         current input position, index(), or some other marker so that</span>
<a name="l01006"></a>01006     <span class="comment">#         when passed to rewind() you get back to the same spot.</span>
<a name="l01007"></a>01007     <span class="comment">#         rewind(mark()) should not affect the input cursor.  The Lexer</span>
<a name="l01008"></a>01008     <span class="comment">#         track line/col info as well as input index so its markers are</span>
<a name="l01009"></a>01009     <span class="comment">#         not pure input indexes.  Same for tree node streams.</span>
<a name="l01010"></a>01010     <span class="comment">#         </span>
<a name="l01011"></a><a class="code" href="classantlr3_1_1_int_stream.html#afbd577f3b38eea416c5372cc74a6be4">01011</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#afbd577f3b38eea416c5372cc74a6be4" title="Tell the stream to start buffering if it hasn&amp;#39;t already.">mark</a>(self):
<a name="l01012"></a>01012 
<a name="l01013"></a>01013         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 
<a name="l01016"></a>01016     <span class="comment">##</span>
<a name="l01017"></a>01017     <span class="comment"># </span>
<a name="l01018"></a>01018     <span class="comment">#         Return the current input symbol index 0..n where n indicates the</span>
<a name="l01019"></a>01019     <span class="comment">#         last symbol has been read.  The index is the symbol about to be</span>
<a name="l01020"></a>01020     <span class="comment">#         read not the most recently read symbol.</span>
<a name="l01021"></a>01021     <span class="comment">#         </span>
<a name="l01022"></a><a class="code" href="classantlr3_1_1_int_stream.html#1999c432251110751446e7df9a632c55">01022</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#1999c432251110751446e7df9a632c55" title="Return the current input symbol index 0.">index</a>(self):
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 
<a name="l01027"></a>01027     <span class="comment">##</span>
<a name="l01028"></a>01028     <span class="comment"># </span>
<a name="l01029"></a>01029     <span class="comment">#         Reset the stream so that next call to index would return marker.</span>
<a name="l01030"></a>01030     <span class="comment">#         The marker will usually be index() but it doesn't have to be.  It's</span>
<a name="l01031"></a>01031     <span class="comment">#         just a marker to indicate what state the stream was in.  This is</span>
<a name="l01032"></a>01032     <span class="comment">#         essentially calling release() and seek().  If there are markers</span>
<a name="l01033"></a>01033     <span class="comment">#         created after this marker argument, this routine must unroll them</span>
<a name="l01034"></a>01034     <span class="comment">#         like a stack.  Assume the state the stream was in when this marker</span>
<a name="l01035"></a>01035     <span class="comment">#         was created.</span>
<a name="l01036"></a>01036     <span class="comment"># </span>
<a name="l01037"></a>01037     <span class="comment">#         If marker is None:</span>
<a name="l01038"></a>01038     <span class="comment">#         Rewind to the input position of the last marker.</span>
<a name="l01039"></a>01039     <span class="comment">#         Used currently only after a cyclic DFA and just</span>
<a name="l01040"></a>01040     <span class="comment">#         before starting a sem/syn predicate to get the</span>
<a name="l01041"></a>01041     <span class="comment">#         input position back to the start of the decision.</span>
<a name="l01042"></a>01042     <span class="comment">#         Do not "pop" the marker off the state.  mark(i)</span>
<a name="l01043"></a>01043     <span class="comment">#         and rewind(i) should balance still. It is</span>
<a name="l01044"></a>01044     <span class="comment">#         like invoking rewind(last marker) but it should not "pop"</span>
<a name="l01045"></a>01045     <span class="comment">#         the marker off.  It's like seek(last marker's input position).       </span>
<a name="l01046"></a>01046     <span class="comment">#   </span>
<a name="l01047"></a><a class="code" href="classantlr3_1_1_int_stream.html#4bffd92e48295ba2150778bc9f185524">01047</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#4bffd92e48295ba2150778bc9f185524" title="Reset the stream so that next call to index would return marker.">rewind</a>(self, marker=None):
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 
<a name="l01052"></a>01052     <span class="comment">##</span>
<a name="l01053"></a>01053     <span class="comment"># </span>
<a name="l01054"></a>01054     <span class="comment">#         You may want to commit to a backtrack but don't want to force the</span>
<a name="l01055"></a>01055     <span class="comment">#         stream to keep bookkeeping objects around for a marker that is</span>
<a name="l01056"></a>01056     <span class="comment">#         no longer necessary.  This will have the same behavior as</span>
<a name="l01057"></a>01057     <span class="comment">#         rewind() except it releases resources without the backward seek.</span>
<a name="l01058"></a>01058     <span class="comment">#         This must throw away resources for all markers back to the marker</span>
<a name="l01059"></a>01059     <span class="comment">#         argument.  So if you're nested 5 levels of mark(), and then release(2)</span>
<a name="l01060"></a>01060     <span class="comment">#         you have to release resources for depths 2..5.</span>
<a name="l01061"></a>01061     <span class="comment">#   </span>
<a name="l01062"></a><a class="code" href="classantlr3_1_1_int_stream.html#10f43cad784ad129b8b385b5f655f538">01062</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#10f43cad784ad129b8b385b5f655f538" title="You may want to commit to a backtrack but don&amp;#39;t want to force the stream to keep...">release</a>(self, marker=None):
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 
<a name="l01067"></a>01067     <span class="comment">##</span>
<a name="l01068"></a>01068     <span class="comment"># </span>
<a name="l01069"></a>01069     <span class="comment">#         Set the input cursor to the position indicated by index.  This is</span>
<a name="l01070"></a>01070     <span class="comment">#         normally used to seek ahead in the input stream.  No buffering is</span>
<a name="l01071"></a>01071     <span class="comment">#         required to do this unless you know your stream will use seek to</span>
<a name="l01072"></a>01072     <span class="comment">#         move backwards such as when backtracking.</span>
<a name="l01073"></a>01073     <span class="comment"># </span>
<a name="l01074"></a>01074     <span class="comment">#         This is different from rewind in its multi-directional</span>
<a name="l01075"></a>01075     <span class="comment">#         requirement and in that its argument is strictly an input cursor</span>
<a name="l01076"></a>01076     <span class="comment">#         (index).</span>
<a name="l01077"></a>01077     <span class="comment"># </span>
<a name="l01078"></a>01078     <span class="comment">#         For char streams, seeking forward must update the stream state such</span>
<a name="l01079"></a>01079     <span class="comment">#         as line number.  For seeking backwards, you will be presumably</span>
<a name="l01080"></a>01080     <span class="comment">#         backtracking using the mark/rewind mechanism that restores state and</span>
<a name="l01081"></a>01081     <span class="comment">#         so this method does not need to update state when seeking backwards.</span>
<a name="l01082"></a>01082     <span class="comment"># </span>
<a name="l01083"></a>01083     <span class="comment">#         Currently, this method is only used for efficient backtracking using</span>
<a name="l01084"></a>01084     <span class="comment">#         memoization, but in the future it may be used for incremental parsing.</span>
<a name="l01085"></a>01085     <span class="comment"># </span>
<a name="l01086"></a>01086     <span class="comment">#         The index is 0..n-1.  A seek to position i means that LA(1) will</span>
<a name="l01087"></a>01087     <span class="comment">#         return the ith symbol.  So, seeking to 0 means LA(1) will return the</span>
<a name="l01088"></a>01088     <span class="comment">#         first element in the stream. </span>
<a name="l01089"></a>01089     <span class="comment">#         </span>
<a name="l01090"></a><a class="code" href="classantlr3_1_1_int_stream.html#8a0824a60080e20e622d60a95c55898e">01090</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#8a0824a60080e20e622d60a95c55898e" title="Set the input cursor to the position indicated by index.">seek</a>(self, index):
<a name="l01091"></a>01091 
<a name="l01092"></a>01092         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="comment">##</span>
<a name="l01096"></a>01096     <span class="comment"># </span>
<a name="l01097"></a>01097     <span class="comment">#         Only makes sense for streams that buffer everything up probably, but</span>
<a name="l01098"></a>01098     <span class="comment">#         might be useful to display the entire stream or for testing.  This</span>
<a name="l01099"></a>01099     <span class="comment">#         value includes a single EOF.</span>
<a name="l01100"></a>01100     <span class="comment">#   </span>
<a name="l01101"></a><a class="code" href="classantlr3_1_1_int_stream.html#0884c9d5ed4b6698155a1fe9bfc368df">01101</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#0884c9d5ed4b6698155a1fe9bfc368df" title="Only makes sense for streams that buffer everything up probably, but might be useful...">size</a>(self):
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="comment">##</span>
<a name="l01107"></a>01107     <span class="comment"># </span>
<a name="l01108"></a>01108     <span class="comment">#         Where are you getting symbols from?  Normally, implementations will</span>
<a name="l01109"></a>01109     <span class="comment">#         pass the buck all the way to the lexer who can ask its input stream</span>
<a name="l01110"></a>01110     <span class="comment">#         for the file name or whatever.</span>
<a name="l01111"></a>01111     <span class="comment">#         </span>
<a name="l01112"></a><a class="code" href="classantlr3_1_1_int_stream.html#c73710ffe0451be9d10794d224a8f155">01112</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_int_stream.html#c73710ffe0451be9d10794d224a8f155" title="Where are you getting symbols from? Normally, implementations will pass the buck...">getSourceName</a>(self):
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 
<a name="l01117"></a>01117 <span class="comment">##</span>
<a name="l01118"></a>01118 <span class="comment"># </span>
<a name="l01119"></a>01119 <span class="comment">#     @brief A source of characters for an ANTLR lexer.</span>
<a name="l01120"></a>01120 <span class="comment"># </span>
<a name="l01121"></a>01121 <span class="comment">#     This is an abstract class that must be implemented by a subclass.</span>
<a name="l01122"></a>01122 <span class="comment">#     </span>
<a name="l01123"></a>01123 <span class="comment">#     </span>
<a name="l01124"></a><a class="code" href="classantlr3_1_1_char_stream.html">01124</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_char_stream.html" title="A source of characters for an ANTLR lexer.">CharStream</a>(<a class="code" href="classantlr3_1_1_int_stream.html" title="Base interface for streams of integer values.">IntStream</a>):
<a name="l01125"></a>01125 
<a name="l01126"></a>01126     <span class="comment"># pylint does not realize that this is an interface, too</span>
<a name="l01127"></a>01127     <span class="comment">#pylint: disable-msg=W0223</span>
<a name="l01128"></a>01128     
<a name="l01129"></a><a class="code" href="classantlr3_1_1_char_stream.html#3bc6a2718ef5aa9166751b284b3ca9b7">01129</a>     EOF = -1
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 
<a name="l01132"></a>01132     <span class="comment">##</span>
<a name="l01133"></a>01133     <span class="comment"># </span>
<a name="l01134"></a>01134     <span class="comment">#         For infinite streams, you don't need this; primarily I'm providing</span>
<a name="l01135"></a>01135     <span class="comment">#         a useful interface for action code.  Just make sure actions don't</span>
<a name="l01136"></a>01136     <span class="comment">#         use this on streams that don't support it.</span>
<a name="l01137"></a>01137     <span class="comment">#         </span>
<a name="l01138"></a><a class="code" href="classantlr3_1_1_char_stream.html#1d471ac679a1208ea3e01167fb2b8d29">01138</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_char_stream.html#1d471ac679a1208ea3e01167fb2b8d29" title="For infinite streams, you don&amp;#39;t need this; primarily I&amp;#39;m providing a useful...">substring</a>(self, start, stop):
<a name="l01139"></a>01139 
<a name="l01140"></a>01140         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01141"></a>01141         
<a name="l01142"></a>01142     
<a name="l01143"></a>01143     <span class="comment">##</span>
<a name="l01144"></a>01144     <span class="comment"># </span>
<a name="l01145"></a>01145     <span class="comment">#         Get the ith character of lookahead.  This is the same usually as</span>
<a name="l01146"></a>01146     <span class="comment">#         LA(i).  This will be used for labels in the generated</span>
<a name="l01147"></a>01147     <span class="comment">#         lexer code.  I'd prefer to return a char here type-wise, but it's</span>
<a name="l01148"></a>01148     <span class="comment">#         probably better to be 32-bit clean and be consistent with LA.</span>
<a name="l01149"></a>01149     <span class="comment">#         </span>
<a name="l01150"></a><a class="code" href="classantlr3_1_1_char_stream.html#728908aef158cb00ac7e39ee39df6503">01150</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_char_stream.html#728908aef158cb00ac7e39ee39df6503" title="Get the ith character of lookahead.">LT</a>(self, i):
<a name="l01151"></a>01151 
<a name="l01152"></a>01152         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 
<a name="l01155"></a>01155     <span class="comment">##</span>
<a name="l01156"></a>01156     <span class="comment"># ANTLR tracks the line information automatically</span>
<a name="l01157"></a><a class="code" href="classantlr3_1_1_char_stream.html#ce1c54083495bdc2fdd5a58fab45c5ed">01157</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_char_stream.html#ce1c54083495bdc2fdd5a58fab45c5ed" title="ANTLR tracks the line information automatically.">getLine</a>(self):
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="comment">##</span>
<a name="l01163"></a>01163     <span class="comment"># </span>
<a name="l01164"></a>01164     <span class="comment">#         Because this stream can rewind, we need to be able to reset the line</span>
<a name="l01165"></a>01165     <span class="comment">#         </span>
<a name="l01166"></a><a class="code" href="classantlr3_1_1_char_stream.html#bd7dc920d790b1df5c314a59eaa27546">01166</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_char_stream.html#bd7dc920d790b1df5c314a59eaa27546" title="Because this stream can rewind, we need to be able to reset the line.">setLine</a>(self, line):
<a name="l01167"></a>01167 
<a name="l01168"></a>01168         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01169"></a>01169 
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     <span class="comment">##</span>
<a name="l01172"></a>01172     <span class="comment"># </span>
<a name="l01173"></a>01173     <span class="comment">#         The index of the character relative to the beginning of the line 0..n-1</span>
<a name="l01174"></a>01174     <span class="comment">#         </span>
<a name="l01175"></a><a class="code" href="classantlr3_1_1_char_stream.html#26185e3d6efa0142491ecd653379e418">01175</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_char_stream.html#26185e3d6efa0142491ecd653379e418" title="The index of the character relative to the beginning of the line 0.">getCharPositionInLine</a>(self):
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 
<a name="l01180"></a><a class="code" href="classantlr3_1_1_char_stream.html#1d84df627903c9129c3657003624390e">01180</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_char_stream.html#1d84df627903c9129c3657003624390e">setCharPositionInLine</a>(self, pos):
<a name="l01181"></a>01181         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01182"></a>01182 
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 <span class="comment">##</span>
<a name="l01185"></a>01185 <span class="comment"># </span>
<a name="l01186"></a>01186 <span class="comment"># </span>
<a name="l01187"></a>01187 <span class="comment">#     @brief A stream of tokens accessing tokens from a TokenSource</span>
<a name="l01188"></a>01188 <span class="comment"># </span>
<a name="l01189"></a>01189 <span class="comment">#     This is an abstract class that must be implemented by a subclass.</span>
<a name="l01190"></a>01190 <span class="comment">#     </span>
<a name="l01191"></a>01191 <span class="comment">#     </span>
<a name="l01192"></a><a class="code" href="classantlr3_1_1_token_stream.html">01192</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_token_stream.html" title="A stream of tokens accessing tokens from a TokenSource.">TokenStream</a>(<a class="code" href="classantlr3_1_1_int_stream.html" title="Base interface for streams of integer values.">IntStream</a>):
<a name="l01193"></a>01193     
<a name="l01194"></a>01194     <span class="comment"># pylint does not realize that this is an interface, too</span>
<a name="l01195"></a>01195     <span class="comment">#pylint: disable-msg=W0223</span>
<a name="l01196"></a>01196     
<a name="l01197"></a>01197     <span class="comment">##</span>
<a name="l01198"></a>01198     <span class="comment"># </span>
<a name="l01199"></a>01199     <span class="comment">#         Get Token at current input pointer + i ahead where i=1 is next Token.</span>
<a name="l01200"></a>01200     <span class="comment">#         i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is</span>
<a name="l01201"></a>01201     <span class="comment">#         two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken.</span>
<a name="l01202"></a>01202     <span class="comment">#         Return null for LT(0) and any index that results in an absolute address</span>
<a name="l01203"></a>01203     <span class="comment">#         that is negative.</span>
<a name="l01204"></a>01204     <span class="comment">#   </span>
<a name="l01205"></a><a class="code" href="classantlr3_1_1_token_stream.html#c62d46e9f8a13272198b3a0f9b78def7">01205</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_stream.html#c62d46e9f8a13272198b3a0f9b78def7" title="Get Token at current input pointer + i ahead where i=1 is next Token.">LT</a>(self, k):
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 
<a name="l01210"></a>01210     <span class="comment">##</span>
<a name="l01211"></a>01211     <span class="comment"># </span>
<a name="l01212"></a>01212     <span class="comment">#         Get a token at an absolute index i; 0..n-1.  This is really only</span>
<a name="l01213"></a>01213     <span class="comment">#         needed for profiling and debugging and token stream rewriting.</span>
<a name="l01214"></a>01214     <span class="comment">#         If you don't want to buffer up tokens, then this method makes no</span>
<a name="l01215"></a>01215     <span class="comment">#         sense for you.  Naturally you can't use the rewrite stream feature.</span>
<a name="l01216"></a>01216     <span class="comment">#         I believe DebugTokenStream can easily be altered to not use</span>
<a name="l01217"></a>01217     <span class="comment">#         this method, removing the dependency.</span>
<a name="l01218"></a>01218     <span class="comment">#         </span>
<a name="l01219"></a><a class="code" href="classantlr3_1_1_token_stream.html#98b93e9fefb8bbe51e8659315626f6e5">01219</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_stream.html#98b93e9fefb8bbe51e8659315626f6e5" title="Get a token at an absolute index i; 0.">get</a>(self, i):
<a name="l01220"></a>01220 
<a name="l01221"></a>01221         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="comment">##</span>
<a name="l01225"></a>01225     <span class="comment"># </span>
<a name="l01226"></a>01226     <span class="comment">#         Where is this stream pulling tokens from?  This is not the name, but</span>
<a name="l01227"></a>01227     <span class="comment">#         the object that provides Token objects.</span>
<a name="l01228"></a>01228     <span class="comment">#   </span>
<a name="l01229"></a><a class="code" href="classantlr3_1_1_token_stream.html#0ab4c5f4415e01607e0414051bc19c46">01229</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_stream.html#0ab4c5f4415e01607e0414051bc19c46" title="Where is this stream pulling tokens from? This is not the name, but the object that...">getTokenSource</a>(self):
<a name="l01230"></a>01230 
<a name="l01231"></a>01231         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 
<a name="l01234"></a>01234     <span class="comment">##</span>
<a name="l01235"></a>01235     <span class="comment"># </span>
<a name="l01236"></a>01236     <span class="comment">#         Return the text of all tokens from start to stop, inclusive.</span>
<a name="l01237"></a>01237     <span class="comment">#         If the stream does not buffer all the tokens then it can just</span>
<a name="l01238"></a>01238     <span class="comment">#         return "" or null;  Users should not access $ruleLabel.text in</span>
<a name="l01239"></a>01239     <span class="comment">#         an action of course in that case.</span>
<a name="l01240"></a>01240     <span class="comment"># </span>
<a name="l01241"></a>01241     <span class="comment">#         Because the user is not required to use a token with an index stored</span>
<a name="l01242"></a>01242     <span class="comment">#         in it, we must provide a means for two token objects themselves to</span>
<a name="l01243"></a>01243     <span class="comment">#         indicate the start/end location.  Most often this will just delegate</span>
<a name="l01244"></a>01244     <span class="comment">#         to the other toString(int,int).  This is also parallel with</span>
<a name="l01245"></a>01245     <span class="comment">#         the TreeNodeStream.toString(Object,Object).</span>
<a name="l01246"></a>01246     <span class="comment">#   </span>
<a name="l01247"></a><a class="code" href="classantlr3_1_1_token_stream.html#c4c784192118ac12d167c838c38c4b31">01247</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_stream.html#c4c784192118ac12d167c838c38c4b31" title="Return the text of all tokens from start to stop, inclusive.">toString</a>(self, start=None, stop=None):
<a name="l01248"></a>01248 
<a name="l01249"></a>01249         <span class="keywordflow">raise</span> NotImplementedError
<a name="l01250"></a>01250 
<a name="l01251"></a>01251         
<a name="l01252"></a>01252 <span class="comment">############################################################################</span>
<a name="l01253"></a>01253 <span class="comment">#</span>
<a name="l01254"></a>01254 <span class="comment"># character streams for use in lexers</span>
<a name="l01255"></a>01255 <span class="comment">#   CharStream</span>
<a name="l01256"></a>01256 <span class="comment">#   \- ANTLRStringStream</span>
<a name="l01257"></a>01257 <span class="comment">#</span>
<a name="l01258"></a>01258 <span class="comment">############################################################################</span>
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 
<a name="l01261"></a>01261 <span class="comment">##</span>
<a name="l01262"></a>01262 <span class="comment"># </span>
<a name="l01263"></a>01263 <span class="comment">#     @brief CharStream that pull data from a unicode string.</span>
<a name="l01264"></a>01264 <span class="comment">#     </span>
<a name="l01265"></a>01265 <span class="comment">#     A pretty quick CharStream that pulls all data from an array</span>
<a name="l01266"></a>01266 <span class="comment">#     directly.  Every method call counts in the lexer.</span>
<a name="l01267"></a>01267 <span class="comment"># </span>
<a name="l01268"></a>01268 <span class="comment">#     </span>
<a name="l01269"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html">01269</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html" title="CharStream that pull data from a unicode string.">ANTLRStringStream</a>(<a class="code" href="classantlr3_1_1_char_stream.html" title="A source of characters for an ANTLR lexer.">CharStream</a>):
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     
<a name="l01272"></a>01272     <span class="comment">##</span>
<a name="l01273"></a>01273     <span class="comment"># </span>
<a name="l01274"></a>01274     <span class="comment">#         @param data This should be a unicode string holding the data you want</span>
<a name="l01275"></a>01275     <span class="comment">#            to parse. If you pass in a byte string, the Lexer will choke on</span>
<a name="l01276"></a>01276     <span class="comment">#            non-ascii data.</span>
<a name="l01277"></a>01277     <span class="comment">#            </span>
<a name="l01278"></a>01278     <span class="comment">#         </span>
<a name="l01279"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#67a0f6ba9a475c032933c5838ddf586b">01279</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#67a0f6ba9a475c032933c5838ddf586b">__init__</a>(self, data):
<a name="l01280"></a>01280         
<a name="l01281"></a>01281         CharStream.__init__(self)
<a name="l01282"></a>01282         
<a name="l01283"></a>01283         <span class="comment"># The data being scanned</span>
<a name="l01284"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#7b7abdf2b3e65c0c133f7849c4aa1029">01284</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#7b7abdf2b3e65c0c133f7849c4aa1029">strdata</a> = unicode(data)
<a name="l01285"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#9a248a6cc30f9cde30dc6273c7d21bec">01285</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#9a248a6cc30f9cde30dc6273c7d21bec">data</a> = [ord(c) <span class="keywordflow">for</span> c <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#7b7abdf2b3e65c0c133f7849c4aa1029">strdata</a>]
<a name="l01286"></a>01286         
<a name="l01287"></a>01287         <span class="comment"># How many characters are actually in the buffer</span>
<a name="l01288"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#da3cfee1f7c97dad828ac10c0a201f2d">01288</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#da3cfee1f7c97dad828ac10c0a201f2d">n</a> = len(data)
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         <span class="comment"># 0..n-1 index into string of next char</span>
<a name="l01291"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">01291</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a> = 0
<a name="l01292"></a>01292 
<a name="l01293"></a>01293         <span class="comment"># line number 1..n within the input</span>
<a name="l01294"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">01294</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a> = 1
<a name="l01295"></a>01295 
<a name="l01296"></a>01296         <span class="comment"># The index of the character relative to the beginning of the</span>
<a name="l01297"></a>01297         <span class="comment"># line 0..n-1</span>
<a name="l01298"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">01298</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a> = 0
<a name="l01299"></a>01299 
<a name="l01300"></a>01300         <span class="comment"># A list of CharStreamState objects that tracks the stream state</span>
<a name="l01301"></a>01301         <span class="comment"># values line, charPositionInLine, and p that can change as you</span>
<a name="l01302"></a>01302         <span class="comment"># move through the input stream.  Indexed from 0..markDepth-1.</span>
<a name="l01303"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#699487d71669082b3afed07479343747">01303</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#699487d71669082b3afed07479343747">_markers</a> = [ ]
<a name="l01304"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa21e437fea878c7dd8db28a6ca6ec4e">01304</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa21e437fea878c7dd8db28a6ca6ec4e">lastMarker</a> = <span class="keywordtype">None</span>
<a name="l01305"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#d83174faa8d5558343d41e5c7f096edb">01305</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#d83174faa8d5558343d41e5c7f096edb">markDepth</a> = 0
<a name="l01306"></a>01306 
<a name="l01307"></a>01307         <span class="comment"># What is name or source of this char stream?</span>
<a name="l01308"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#272b406828eca5b4559e6ec609bdddfc">01308</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#272b406828eca5b4559e6ec609bdddfc">name</a> = <span class="keywordtype">None</span>
<a name="l01309"></a>01309 
<a name="l01310"></a>01310 
<a name="l01311"></a>01311     <span class="comment">##</span>
<a name="l01312"></a>01312     <span class="comment"># </span>
<a name="l01313"></a>01313     <span class="comment">#         Reset the stream so that it's in the same state it was</span>
<a name="l01314"></a>01314     <span class="comment">#         when the object was created *except* the data array is not</span>
<a name="l01315"></a>01315     <span class="comment">#         touched.</span>
<a name="l01316"></a>01316     <span class="comment">#         </span>
<a name="l01317"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#4a0287d8be85e84f20a3d0debdc510be">01317</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#4a0287d8be85e84f20a3d0debdc510be" title="Reset the stream so that it&amp;#39;s in the same state it was when the object was created...">reset</a>(self):
<a name="l01318"></a>01318         
<a name="l01319"></a>01319         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a> = 0
<a name="l01320"></a>01320         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a> = 1
<a name="l01321"></a>01321         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a> = 0
<a name="l01322"></a>01322         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#699487d71669082b3afed07479343747">_markers</a> = [ ]
<a name="l01323"></a>01323 
<a name="l01324"></a>01324 
<a name="l01325"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#2a13a3553a62f660b325eecc77efd55b">01325</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#2a13a3553a62f660b325eecc77efd55b">consume</a>(self):
<a name="l01326"></a>01326         <span class="keywordflow">try</span>:
<a name="l01327"></a>01327             <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#9a248a6cc30f9cde30dc6273c7d21bec">data</a>[self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a>] == 10: <span class="comment"># \n</span>
<a name="l01328"></a>01328                 self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a> += 1
<a name="l01329"></a>01329                 self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a> = 0
<a name="l01330"></a>01330             <span class="keywordflow">else</span>:
<a name="l01331"></a>01331                 self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a> += 1
<a name="l01332"></a>01332 
<a name="l01333"></a>01333             self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a> += 1
<a name="l01334"></a>01334             
<a name="l01335"></a>01335         <span class="keywordflow">except</span> IndexError:
<a name="l01336"></a>01336             <span class="comment"># happend when we reached EOF and self.data[self.p] fails</span>
<a name="l01337"></a>01337             <span class="comment"># just do nothing</span>
<a name="l01338"></a>01338             <span class="keywordflow">pass</span>
<a name="l01339"></a>01339 
<a name="l01340"></a>01340 
<a name="l01341"></a>01341 
<a name="l01342"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#a316d82e7b26715a2e3eaec59a9840eb">01342</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#a316d82e7b26715a2e3eaec59a9840eb" title="Get int at current input pointer + i ahead where i=1 is next int.">LA</a>(self, i):
<a name="l01343"></a>01343         <span class="keywordflow">if</span> i == 0:
<a name="l01344"></a>01344             <span class="keywordflow">return</span> 0 <span class="comment"># undefined</span>
<a name="l01345"></a>01345 
<a name="l01346"></a>01346         <span class="keywordflow">if</span> i &lt; 0:
<a name="l01347"></a>01347             i += 1 <span class="comment"># e.g., translate LA(-1) to use offset i=0; then data[p+0-1]</span>
<a name="l01348"></a>01348 
<a name="l01349"></a>01349         <span class="keywordflow">try</span>:
<a name="l01350"></a>01350             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#9a248a6cc30f9cde30dc6273c7d21bec">data</a>[self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a>+i-1]
<a name="l01351"></a>01351         <span class="keywordflow">except</span> IndexError:
<a name="l01352"></a>01352             <span class="keywordflow">return</span> EOF
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 
<a name="l01356"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#0eb3fee0c88f0a34a9c1bb410f60a8c9">01356</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#0eb3fee0c88f0a34a9c1bb410f60a8c9" title="Get the ith character of lookahead.">LT</a>(self, i):
<a name="l01357"></a>01357         <span class="keywordflow">if</span> i == 0:
<a name="l01358"></a>01358             <span class="keywordflow">return</span> 0 <span class="comment"># undefined</span>
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         <span class="keywordflow">if</span> i &lt; 0:
<a name="l01361"></a>01361             i += 1 <span class="comment"># e.g., translate LA(-1) to use offset i=0; then data[p+0-1]</span>
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         <span class="keywordflow">try</span>:
<a name="l01364"></a>01364             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#7b7abdf2b3e65c0c133f7849c4aa1029">strdata</a>[self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a>+i-1]
<a name="l01365"></a>01365         <span class="keywordflow">except</span> IndexError:
<a name="l01366"></a>01366             <span class="keywordflow">return</span> EOF
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 
<a name="l01369"></a>01369     <span class="comment">##</span>
<a name="l01370"></a>01370     <span class="comment"># </span>
<a name="l01371"></a>01371     <span class="comment">#         Return the current input symbol index 0..n where n indicates the</span>
<a name="l01372"></a>01372     <span class="comment">#         last symbol has been read.  The index is the index of char to</span>
<a name="l01373"></a>01373     <span class="comment">#         be returned from LA(1).</span>
<a name="l01374"></a>01374     <span class="comment">#         </span>
<a name="l01375"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#4874aa09aca698af79170577f4329c36">01375</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#4874aa09aca698af79170577f4329c36" title="Return the current input symbol index 0.">index</a>(self):
<a name="l01376"></a>01376         
<a name="l01377"></a>01377         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a>
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 
<a name="l01380"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa2ee0012d551543a682c74c00f484db">01380</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa2ee0012d551543a682c74c00f484db" title="Only makes sense for streams that buffer everything up probably, but might be useful...">size</a>(self):
<a name="l01381"></a>01381         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#da3cfee1f7c97dad828ac10c0a201f2d">n</a>
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 
<a name="l01384"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#253fc1855c2380152e134453153c5dbd">01384</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#253fc1855c2380152e134453153c5dbd" title="Tell the stream to start buffering if it hasn&amp;#39;t already.">mark</a>(self):
<a name="l01385"></a>01385         state = (self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a>, self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a>, self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a>)
<a name="l01386"></a>01386         <span class="keywordflow">try</span>:
<a name="l01387"></a>01387             self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#699487d71669082b3afed07479343747">_markers</a>[self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#d83174faa8d5558343d41e5c7f096edb">markDepth</a>] = state
<a name="l01388"></a>01388         <span class="keywordflow">except</span> IndexError:
<a name="l01389"></a>01389             self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#699487d71669082b3afed07479343747">_markers</a>.append(state)
<a name="l01390"></a>01390         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#d83174faa8d5558343d41e5c7f096edb">markDepth</a> += 1
<a name="l01391"></a>01391         
<a name="l01392"></a>01392         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa21e437fea878c7dd8db28a6ca6ec4e">lastMarker</a> = self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#d83174faa8d5558343d41e5c7f096edb">markDepth</a>
<a name="l01393"></a>01393         
<a name="l01394"></a>01394         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa21e437fea878c7dd8db28a6ca6ec4e">lastMarker</a>
<a name="l01395"></a>01395 
<a name="l01396"></a>01396 
<a name="l01397"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#f1823b77f935a1739acabcfc1bce63d6">01397</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#f1823b77f935a1739acabcfc1bce63d6" title="Reset the stream so that next call to index would return marker.">rewind</a>(self, marker=None):
<a name="l01398"></a>01398         <span class="keywordflow">if</span> marker <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01399"></a>01399             marker = self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa21e437fea878c7dd8db28a6ca6ec4e">lastMarker</a>
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         p, line, charPositionInLine = self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#699487d71669082b3afed07479343747">_markers</a>[marker-1]
<a name="l01402"></a>01402 
<a name="l01403"></a>01403         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#0922c9da1d78820b0c045076daeb87e0" title="consume() ahead until p==index; can&amp;#39;t just set p=index as we must update line...">seek</a>(p)
<a name="l01404"></a>01404         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a> = line
<a name="l01405"></a>01405         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a> = charPositionInLine
<a name="l01406"></a>01406         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#8a8d6d5a6aafd885bbcaaeb1fdd11cab" title="You may want to commit to a backtrack but don&amp;#39;t want to force the stream to keep...">release</a>(marker)
<a name="l01407"></a>01407 
<a name="l01408"></a>01408 
<a name="l01409"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#8a8d6d5a6aafd885bbcaaeb1fdd11cab">01409</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#8a8d6d5a6aafd885bbcaaeb1fdd11cab" title="You may want to commit to a backtrack but don&amp;#39;t want to force the stream to keep...">release</a>(self, marker=None):
<a name="l01410"></a>01410         <span class="keywordflow">if</span> marker <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01411"></a>01411             marker = self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#fa21e437fea878c7dd8db28a6ca6ec4e">lastMarker</a>
<a name="l01412"></a>01412 
<a name="l01413"></a>01413         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#d83174faa8d5558343d41e5c7f096edb">markDepth</a> = marker-1
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 
<a name="l01416"></a>01416     <span class="comment">##</span>
<a name="l01417"></a>01417     <span class="comment"># </span>
<a name="l01418"></a>01418     <span class="comment">#         consume() ahead until p==index; can't just set p=index as we must</span>
<a name="l01419"></a>01419     <span class="comment">#         update line and charPositionInLine.</span>
<a name="l01420"></a>01420     <span class="comment">#         </span>
<a name="l01421"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#0922c9da1d78820b0c045076daeb87e0">01421</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#0922c9da1d78820b0c045076daeb87e0" title="consume() ahead until p==index; can&amp;#39;t just set p=index as we must update line...">seek</a>(self, index):
<a name="l01422"></a>01422         
<a name="l01423"></a>01423         <span class="keywordflow">if</span> index &lt;= self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a>:
<a name="l01424"></a>01424             self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a> = index <span class="comment"># just jump; don't update stream state (line, ...)</span>
<a name="l01425"></a>01425             <span class="keywordflow">return</span>
<a name="l01426"></a>01426 
<a name="l01427"></a>01427         <span class="comment"># seek forward, consume until p hits index</span>
<a name="l01428"></a>01428         <span class="keywordflow">while</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#27665420b041d7060e94446d0b561377">p</a> &lt; index:
<a name="l01429"></a>01429             self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#2a13a3553a62f660b325eecc77efd55b">consume</a>()
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 
<a name="l01432"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#4f98668012398eac013f0c3c20971fa9">01432</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#4f98668012398eac013f0c3c20971fa9" title="For infinite streams, you don&amp;#39;t need this; primarily I&amp;#39;m providing a useful...">substring</a>(self, start, stop):
<a name="l01433"></a>01433         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#7b7abdf2b3e65c0c133f7849c4aa1029">strdata</a>[start:stop+1]
<a name="l01434"></a>01434 
<a name="l01435"></a>01435 
<a name="l01436"></a>01436     <span class="comment">##</span>
<a name="l01437"></a>01437     <span class="comment"># Using setter/getter methods is deprecated. Use o.line instead.</span>
<a name="l01438"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#07b73fb881c563f899b8a0fc270324f6">01438</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#07b73fb881c563f899b8a0fc270324f6" title="Using setter/getter methods is deprecated.">getLine</a>(self):
<a name="l01439"></a>01439         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a>
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     <span class="comment">##</span>
<a name="l01443"></a>01443     <span class="comment"># </span>
<a name="l01444"></a>01444     <span class="comment">#         Using setter/getter methods is deprecated. Use o.charPositionInLine</span>
<a name="l01445"></a>01445     <span class="comment">#         instead.</span>
<a name="l01446"></a>01446     <span class="comment">#         </span>
<a name="l01447"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#73ee59f82115c59493d7cafc749dff3c">01447</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#73ee59f82115c59493d7cafc749dff3c" title="Using setter/getter methods is deprecated.">getCharPositionInLine</a>(self):
<a name="l01448"></a>01448         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a>
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     <span class="comment">##</span>
<a name="l01452"></a>01452     <span class="comment"># Using setter/getter methods is deprecated. Use o.line instead.</span>
<a name="l01453"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#5d9b958e9299b8e2298f906a725690cc">01453</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#5d9b958e9299b8e2298f906a725690cc" title="Using setter/getter methods is deprecated.">setLine</a>(self, line):
<a name="l01454"></a>01454         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#529bc9480b21efc25b549d54c5da5822">line</a> = line
<a name="l01455"></a>01455 
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     <span class="comment">##</span>
<a name="l01458"></a>01458     <span class="comment"># </span>
<a name="l01459"></a>01459     <span class="comment">#         Using setter/getter methods is deprecated. Use o.charPositionInLine</span>
<a name="l01460"></a>01460     <span class="comment">#         instead.</span>
<a name="l01461"></a>01461     <span class="comment">#         </span>
<a name="l01462"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#51450b1b5dd53debcad03dd0b8d8a66f">01462</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#51450b1b5dd53debcad03dd0b8d8a66f" title="Using setter/getter methods is deprecated.">setCharPositionInLine</a>(self, pos):
<a name="l01463"></a>01463         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#84c8b5ddbdd051f5fda5480ed3fc9ff9">charPositionInLine</a> = pos
<a name="l01464"></a>01464 
<a name="l01465"></a>01465 
<a name="l01466"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#ac275221d03abfaa7208035e8e4755fc">01466</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#ac275221d03abfaa7208035e8e4755fc" title="Where are you getting symbols from? Normally, implementations will pass the buck...">getSourceName</a>(self):
<a name="l01467"></a>01467         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html#272b406828eca5b4559e6ec609bdddfc">name</a>
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 <span class="comment">##</span>
<a name="l01471"></a>01471 <span class="comment"># </span>
<a name="l01472"></a>01472 <span class="comment">#     @brief CharStream that opens a file to read the data.</span>
<a name="l01473"></a>01473 <span class="comment">#     </span>
<a name="l01474"></a>01474 <span class="comment">#     This is a char buffer stream that is loaded from a file</span>
<a name="l01475"></a>01475 <span class="comment">#     all at once when you construct the object.</span>
<a name="l01476"></a>01476 <span class="comment">#     </span>
<a name="l01477"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html">01477</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html" title="CharStream that opens a file to read the data.">ANTLRFileStream</a>(<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html" title="CharStream that pull data from a unicode string.">ANTLRStringStream</a>):
<a name="l01478"></a>01478 
<a name="l01479"></a>01479     <span class="comment">##</span>
<a name="l01480"></a>01480     <span class="comment"># </span>
<a name="l01481"></a>01481     <span class="comment">#         @param fileName The path to the file to be opened. The file will be</span>
<a name="l01482"></a>01482     <span class="comment">#            opened with mode 'rb'.</span>
<a name="l01483"></a>01483     <span class="comment"># </span>
<a name="l01484"></a>01484     <span class="comment">#         @param encoding If you set the optional encoding argument, then the</span>
<a name="l01485"></a>01485     <span class="comment">#            data will be decoded on the fly.</span>
<a name="l01486"></a>01486     <span class="comment">#            </span>
<a name="l01487"></a>01487     <span class="comment">#         </span>
<a name="l01488"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#19b1ffefc81709e1a55bf5b4f0b5a370">01488</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#19b1ffefc81709e1a55bf5b4f0b5a370">__init__</a>(self, fileName, encoding=None):
<a name="l01489"></a>01489         
<a name="l01490"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#9faf7c68aaaf325061dc577d9c7127a8">01490</a>         self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#9faf7c68aaaf325061dc577d9c7127a8">fileName</a> = fileName
<a name="l01491"></a>01491 
<a name="l01492"></a>01492         fp = codecs.open(fileName, <span class="stringliteral">'rb'</span>, encoding)
<a name="l01493"></a>01493         <span class="keywordflow">try</span>:
<a name="l01494"></a>01494             data = fp.read()
<a name="l01495"></a>01495         <span class="keywordflow">finally</span>:
<a name="l01496"></a>01496             fp.close()
<a name="l01497"></a>01497             
<a name="l01498"></a>01498         ANTLRStringStream.__init__(self, data)
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 
<a name="l01501"></a>01501     <span class="comment">##</span>
<a name="l01502"></a>01502     <span class="comment"># Deprecated, access o.fileName directly.</span>
<a name="l01503"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#29c119a7398d940822e77846460e12b7">01503</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#29c119a7398d940822e77846460e12b7" title="Deprecated, access o.fileName directly.">getSourceName</a>(self):
<a name="l01504"></a>01504         
<a name="l01505"></a>01505         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_a_n_t_l_r_file_stream.html#9faf7c68aaaf325061dc577d9c7127a8">fileName</a>
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 
<a name="l01508"></a>01508 <span class="comment">##</span>
<a name="l01509"></a>01509 <span class="comment"># </span>
<a name="l01510"></a>01510 <span class="comment">#     @brief CharStream that reads data from a file-like object.</span>
<a name="l01511"></a>01511 <span class="comment"># </span>
<a name="l01512"></a>01512 <span class="comment">#     This is a char buffer stream that is loaded from a file like object</span>
<a name="l01513"></a>01513 <span class="comment">#     all at once when you construct the object.</span>
<a name="l01514"></a>01514 <span class="comment">#     </span>
<a name="l01515"></a>01515 <span class="comment">#     All input is consumed from the file, but it is not closed.</span>
<a name="l01516"></a>01516 <span class="comment">#     </span>
<a name="l01517"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_input_stream.html">01517</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_input_stream.html" title="CharStream that reads data from a file-like object.">ANTLRInputStream</a>(<a class="code" href="classantlr3_1_1_a_n_t_l_r_string_stream.html" title="CharStream that pull data from a unicode string.">ANTLRStringStream</a>):
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="comment">##</span>
<a name="l01520"></a>01520     <span class="comment"># </span>
<a name="l01521"></a>01521     <span class="comment">#         @param file A file-like object holding your input. Only the read()</span>
<a name="l01522"></a>01522     <span class="comment">#            method must be implemented.</span>
<a name="l01523"></a>01523     <span class="comment"># </span>
<a name="l01524"></a>01524     <span class="comment">#         @param encoding If you set the optional encoding argument, then the</span>
<a name="l01525"></a>01525     <span class="comment">#            data will be decoded on the fly.</span>
<a name="l01526"></a>01526     <span class="comment">#            </span>
<a name="l01527"></a>01527     <span class="comment">#         </span>
<a name="l01528"></a><a class="code" href="classantlr3_1_1_a_n_t_l_r_input_stream.html#edf9f564f7c2223fe56951e85a2928d4">01528</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_a_n_t_l_r_input_stream.html#edf9f564f7c2223fe56951e85a2928d4">__init__</a>(self, file, encoding=None):
<a name="l01529"></a>01529         
<a name="l01530"></a>01530         <span class="keywordflow">if</span> encoding <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l01531"></a>01531             <span class="comment"># wrap input in a decoding reader</span>
<a name="l01532"></a>01532             reader = codecs.lookup(encoding)[2]
<a name="l01533"></a>01533             file = reader(file)
<a name="l01534"></a>01534 
<a name="l01535"></a>01535         data = file.read()
<a name="l01536"></a>01536             
<a name="l01537"></a>01537         ANTLRStringStream.__init__(self, data)
<a name="l01538"></a>01538 
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="comment"># I guess the ANTLR prefix exists only to avoid a name clash with some Java</span>
<a name="l01541"></a>01541 <span class="comment"># mumbojumbo. A plain "StringStream" looks better to me, which should be</span>
<a name="l01542"></a>01542 <span class="comment"># the preferred name in Python.</span>
<a name="l01543"></a><a class="code" href="namespaceantlr3.html#6cf368609cd9e21bdc178fe3669d49dc">01543</a> StringStream = ANTLRStringStream
<a name="l01544"></a><a class="code" href="namespaceantlr3.html#4ac57a5c25d532ef5ed8190b7eca4333">01544</a> FileStream = ANTLRFileStream
<a name="l01545"></a><a class="code" href="namespaceantlr3.html#dc6099702a55e0a33654e7ee6adb67f4">01545</a> InputStream = ANTLRInputStream
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 
<a name="l01548"></a>01548 <span class="comment">############################################################################</span>
<a name="l01549"></a>01549 <span class="comment">#</span>
<a name="l01550"></a>01550 <span class="comment"># Token streams</span>
<a name="l01551"></a>01551 <span class="comment">#   TokenStream</span>
<a name="l01552"></a>01552 <span class="comment">#   +- CommonTokenStream</span>
<a name="l01553"></a>01553 <span class="comment">#   \- TokenRewriteStream</span>
<a name="l01554"></a>01554 <span class="comment">#</span>
<a name="l01555"></a>01555 <span class="comment">############################################################################</span>
<a name="l01556"></a>01556 
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="comment">##</span>
<a name="l01559"></a>01559 <span class="comment"># </span>
<a name="l01560"></a>01560 <span class="comment">#     @brief The most common stream of tokens</span>
<a name="l01561"></a>01561 <span class="comment">#     </span>
<a name="l01562"></a>01562 <span class="comment">#     The most common stream of tokens is one where every token is buffered up</span>
<a name="l01563"></a>01563 <span class="comment">#     and tokens are prefiltered for a certain channel (the parser will only</span>
<a name="l01564"></a>01564 <span class="comment">#     see these tokens and cannot change the filter channel number during the</span>
<a name="l01565"></a>01565 <span class="comment">#     parse).</span>
<a name="l01566"></a>01566 <span class="comment">#     </span>
<a name="l01567"></a><a class="code" href="classantlr3_1_1_common_token_stream.html">01567</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_common_token_stream.html" title="The most common stream of tokens.">CommonTokenStream</a>(<a class="code" href="classantlr3_1_1_token_stream.html" title="A stream of tokens accessing tokens from a TokenSource.">TokenStream</a>):
<a name="l01568"></a>01568 
<a name="l01569"></a>01569     <span class="comment">##</span>
<a name="l01570"></a>01570     <span class="comment"># </span>
<a name="l01571"></a>01571     <span class="comment">#         @param tokenSource A TokenSource instance (usually a Lexer) to pull</span>
<a name="l01572"></a>01572     <span class="comment">#             the tokens from.</span>
<a name="l01573"></a>01573     <span class="comment"># </span>
<a name="l01574"></a>01574     <span class="comment">#         @param channel Skip tokens on any channel but this one; this is how we</span>
<a name="l01575"></a>01575     <span class="comment">#             skip whitespace...</span>
<a name="l01576"></a>01576     <span class="comment">#             </span>
<a name="l01577"></a>01577     <span class="comment">#         </span>
<a name="l01578"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#7383fe1cf5fa5d787205fae665a75d25">01578</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#7383fe1cf5fa5d787205fae665a75d25">__init__</a>(self, tokenSource=None, channel=DEFAULT_CHANNEL):
<a name="l01579"></a>01579         
<a name="l01580"></a>01580         TokenStream.__init__(self)
<a name="l01581"></a>01581         
<a name="l01582"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">01582</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">tokenSource</a> = tokenSource
<a name="l01583"></a>01583 
<a name="l01584"></a>01584         <span class="comment"># Record every single token pulled from the source so we can reproduce</span>
<a name="l01585"></a>01585         <span class="comment"># chunks of it later.</span>
<a name="l01586"></a>01586         self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a> = []
<a name="l01587"></a>01587 
<a name="l01588"></a>01588         <span class="comment"># Map&lt;tokentype, channel&gt; to override some Tokens' channel numbers</span>
<a name="l01589"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#584f554eda092e295a28037e6751f675">01589</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#584f554eda092e295a28037e6751f675">channelOverrideMap</a> = {}
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         <span class="comment"># Set&lt;tokentype&gt;; discard any tokens with this type</span>
<a name="l01592"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#3651c6d0f4856a05f264851a8b0caab4">01592</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#3651c6d0f4856a05f264851a8b0caab4">discardSet</a> = set()
<a name="l01593"></a>01593 
<a name="l01594"></a>01594         <span class="comment"># Skip tokens on any channel but this one; this is how we skip whitespace...</span>
<a name="l01595"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">01595</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">channel</a> = channel
<a name="l01596"></a>01596 
<a name="l01597"></a>01597         <span class="comment"># By default, track all incoming tokens</span>
<a name="l01598"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#78bb934fa02a1b6af023fef460cc8822">01598</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#78bb934fa02a1b6af023fef460cc8822">discardOffChannelTokens</a> = <span class="keyword">False</span>
<a name="l01599"></a>01599 
<a name="l01600"></a>01600         <span class="comment"># The index into the tokens list of the current token (next token</span>
<a name="l01601"></a>01601         <span class="comment"># to consume).  p==-1 indicates that the tokens list is empty</span>
<a name="l01602"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">01602</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = -1
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         <span class="comment"># Remember last marked position</span>
<a name="l01605"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#59b85c37d54dcc2ff2c88e074344ede5">01605</a>         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#59b85c37d54dcc2ff2c88e074344ede5">lastMarker</a> = <span class="keywordtype">None</span>
<a name="l01606"></a>01606         
<a name="l01607"></a>01607 
<a name="l01608"></a>01608     <span class="comment">##</span>
<a name="l01609"></a>01609     <span class="comment"># Reset this token stream by setting its token source.</span>
<a name="l01610"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#cd102fc69baabdbf7ac757f970948d1f">01610</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#cd102fc69baabdbf7ac757f970948d1f" title="Reset this token stream by setting its token source.">setTokenSource</a>(self, tokenSource):
<a name="l01611"></a>01611         
<a name="l01612"></a>01612         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">tokenSource</a> = tokenSource
<a name="l01613"></a>01613         self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a> = []
<a name="l01614"></a>01614         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = -1
<a name="l01615"></a>01615         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">channel</a> = DEFAULT_CHANNEL
<a name="l01616"></a>01616 
<a name="l01617"></a>01617 
<a name="l01618"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#99e8e4868240b42ff69bfa635ce922ea">01618</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#99e8e4868240b42ff69bfa635ce922ea">reset</a>(self):
<a name="l01619"></a>01619         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = 0
<a name="l01620"></a>01620         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#59b85c37d54dcc2ff2c88e074344ede5">lastMarker</a> = <span class="keywordtype">None</span>
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 
<a name="l01623"></a>01623     <span class="comment">##</span>
<a name="l01624"></a>01624     <span class="comment"># </span>
<a name="l01625"></a>01625     <span class="comment">#         Load all tokens from the token source and put in tokens.</span>
<a name="l01626"></a>01626     <span class="comment">#   This is done upon first LT request because you might want to</span>
<a name="l01627"></a>01627     <span class="comment">#         set some token type / channel overrides before filling buffer.</span>
<a name="l01628"></a>01628     <span class="comment">#         </span>
<a name="l01629"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#328a43591f5412d2cb3a812e7d7394eb">01629</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#328a43591f5412d2cb3a812e7d7394eb" title="Load all tokens from the token source and put in tokens.">fillBuffer</a>(self):
<a name="l01630"></a>01630         
<a name="l01631"></a>01631 
<a name="l01632"></a>01632         index = 0
<a name="l01633"></a>01633         t = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">tokenSource</a>.nextToken()
<a name="l01634"></a>01634         <span class="keywordflow">while</span> t <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> t.type != EOF:
<a name="l01635"></a>01635             discard = <span class="keyword">False</span>
<a name="l01636"></a>01636             
<a name="l01637"></a>01637             <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#3651c6d0f4856a05f264851a8b0caab4">discardSet</a> <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> t.type <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#3651c6d0f4856a05f264851a8b0caab4">discardSet</a>:
<a name="l01638"></a>01638                 discard = <span class="keyword">True</span>
<a name="l01639"></a>01639 
<a name="l01640"></a>01640             <span class="keywordflow">elif</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#78bb934fa02a1b6af023fef460cc8822">discardOffChannelTokens</a> <span class="keywordflow">and</span> t.channel != self.<a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">channel</a>:
<a name="l01641"></a>01641                 discard = <span class="keyword">True</span>
<a name="l01642"></a>01642 
<a name="l01643"></a>01643             <span class="comment"># is there a channel override for token type?</span>
<a name="l01644"></a>01644             <span class="keywordflow">try</span>:
<a name="l01645"></a>01645                 overrideChannel = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#584f554eda092e295a28037e6751f675">channelOverrideMap</a>[t.type]
<a name="l01646"></a>01646                 
<a name="l01647"></a>01647             <span class="keywordflow">except</span> KeyError:
<a name="l01648"></a>01648                 <span class="comment"># no override for this type</span>
<a name="l01649"></a>01649                 <span class="keywordflow">pass</span>
<a name="l01650"></a>01650             
<a name="l01651"></a>01651             <span class="keywordflow">else</span>:
<a name="l01652"></a>01652                 <span class="keywordflow">if</span> overrideChannel == self.<a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">channel</a>:
<a name="l01653"></a>01653                     t.channel = overrideChannel
<a name="l01654"></a>01654                 <span class="keywordflow">else</span>:
<a name="l01655"></a>01655                     discard = <span class="keyword">True</span>
<a name="l01656"></a>01656             
<a name="l01657"></a>01657             <span class="keywordflow">if</span> <span class="keywordflow">not</span> discard:
<a name="l01658"></a>01658                 t.index = index
<a name="l01659"></a>01659                 self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>.append(t)
<a name="l01660"></a>01660                 index += 1
<a name="l01661"></a>01661 
<a name="l01662"></a>01662             t = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">tokenSource</a>.nextToken()
<a name="l01663"></a>01663        
<a name="l01664"></a>01664         <span class="comment"># leave p pointing at first token on channel</span>
<a name="l01665"></a>01665         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = 0
<a name="l01666"></a>01666         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#6ce9e9f12b10b34ca59eed00fecb938f" title="Given a starting index, return the index of the first on-channel token.">skipOffTokenChannels</a>(self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a>)
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 
<a name="l01669"></a>01669     <span class="comment">##</span>
<a name="l01670"></a>01670     <span class="comment"># </span>
<a name="l01671"></a>01671     <span class="comment">#         Move the input pointer to the next incoming token.  The stream</span>
<a name="l01672"></a>01672     <span class="comment">#         must become active with LT(1) available.  consume() simply</span>
<a name="l01673"></a>01673     <span class="comment">#         moves the input pointer so that LT(1) points at the next</span>
<a name="l01674"></a>01674     <span class="comment">#         input symbol. Consume at least one token.</span>
<a name="l01675"></a>01675     <span class="comment"># </span>
<a name="l01676"></a>01676     <span class="comment">#         Walk past any token not on the channel the parser is listening to.</span>
<a name="l01677"></a>01677     <span class="comment">#         </span>
<a name="l01678"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#f2dda5923a9422f15aa645962f284594">01678</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#f2dda5923a9422f15aa645962f284594" title="Move the input pointer to the next incoming token.">consume</a>(self):
<a name="l01679"></a>01679         
<a name="l01680"></a>01680         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> &lt; len(self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>):
<a name="l01681"></a>01681             self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> += 1
<a name="l01682"></a>01682 
<a name="l01683"></a>01683             self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#6ce9e9f12b10b34ca59eed00fecb938f" title="Given a starting index, return the index of the first on-channel token.">skipOffTokenChannels</a>(self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a>) <span class="comment"># leave p on valid token</span>
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 
<a name="l01686"></a>01686     <span class="comment">##</span>
<a name="l01687"></a>01687     <span class="comment"># </span>
<a name="l01688"></a>01688     <span class="comment">#         Given a starting index, return the index of the first on-channel</span>
<a name="l01689"></a>01689     <span class="comment">#         token.</span>
<a name="l01690"></a>01690     <span class="comment">#         </span>
<a name="l01691"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#6ce9e9f12b10b34ca59eed00fecb938f">01691</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#6ce9e9f12b10b34ca59eed00fecb938f" title="Given a starting index, return the index of the first on-channel token.">skipOffTokenChannels</a>(self, i):
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         <span class="keywordflow">try</span>:
<a name="l01694"></a>01694             <span class="keywordflow">while</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[i].channel != self.<a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">channel</a>:
<a name="l01695"></a>01695                 i += 1
<a name="l01696"></a>01696         <span class="keywordflow">except</span> IndexError:
<a name="l01697"></a>01697             <span class="comment"># hit the end of token stream</span>
<a name="l01698"></a>01698             <span class="keywordflow">pass</span>
<a name="l01699"></a>01699         
<a name="l01700"></a>01700         <span class="keywordflow">return</span> i
<a name="l01701"></a>01701 
<a name="l01702"></a>01702 
<a name="l01703"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#56cb8deb0e5d1995188151cb3de385d3">01703</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#56cb8deb0e5d1995188151cb3de385d3">skipOffTokenChannelsReverse</a>(self, i):
<a name="l01704"></a>01704         <span class="keywordflow">while</span> i &gt;= 0 <span class="keywordflow">and</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[i].channel != self.<a class="code" href="classantlr3_1_1_common_token_stream.html#40e4d3cfe952878a24f0b59d6e731ec5">channel</a>:
<a name="l01705"></a>01705             i -= 1
<a name="l01706"></a>01706 
<a name="l01707"></a>01707         <span class="keywordflow">return</span> i
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     <span class="comment">##</span>
<a name="l01711"></a>01711     <span class="comment"># </span>
<a name="l01712"></a>01712     <span class="comment">#         A simple filter mechanism whereby you can tell this token stream</span>
<a name="l01713"></a>01713     <span class="comment">#         to force all tokens of type ttype to be on channel.  For example,</span>
<a name="l01714"></a>01714     <span class="comment">#         when interpreting, we cannot exec actions so we need to tell</span>
<a name="l01715"></a>01715     <span class="comment">#         the stream to force all WS and NEWLINE to be a different, ignored</span>
<a name="l01716"></a>01716     <span class="comment">#         channel.</span>
<a name="l01717"></a>01717     <span class="comment">#   </span>
<a name="l01718"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#bba83f7bc9cfa2deede4f21f8b233718">01718</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#bba83f7bc9cfa2deede4f21f8b233718" title="A simple filter mechanism whereby you can tell this token stream to force all tokens...">setTokenTypeChannel</a>(self, ttype, channel):
<a name="l01719"></a>01719         
<a name="l01720"></a>01720         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#584f554eda092e295a28037e6751f675">channelOverrideMap</a>[ttype] = channel
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 
<a name="l01723"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#06d8848cb63f4d9809a50b75bed383dc">01723</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#06d8848cb63f4d9809a50b75bed383dc">discardTokenType</a>(self, ttype):
<a name="l01724"></a>01724         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#3651c6d0f4856a05f264851a8b0caab4">discardSet</a>.add(ttype)
<a name="l01725"></a>01725 
<a name="l01726"></a>01726 
<a name="l01727"></a>01727     <span class="comment">##</span>
<a name="l01728"></a>01728     <span class="comment"># </span>
<a name="l01729"></a>01729     <span class="comment">#         Given a start and stop index, return a list of all tokens in</span>
<a name="l01730"></a>01730     <span class="comment">#         the token type set.  Return None if no tokens were found.  This</span>
<a name="l01731"></a>01731     <span class="comment">#         method looks at both on and off channel tokens.</span>
<a name="l01732"></a>01732     <span class="comment">#         </span>
<a name="l01733"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#2c99b390c4550106f1b2ec53612e97b4">01733</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#2c99b390c4550106f1b2ec53612e97b4" title="Given a start and stop index, return a list of all tokens in the token type set.">getTokens</a>(self, start=None, stop=None, types=None):
<a name="l01734"></a>01734 
<a name="l01735"></a>01735         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> == -1:
<a name="l01736"></a>01736             self.<a class="code" href="classantlr3_1_1_common_token_stream.html#328a43591f5412d2cb3a812e7d7394eb" title="Load all tokens from the token source and put in tokens.">fillBuffer</a>()
<a name="l01737"></a>01737 
<a name="l01738"></a>01738         <span class="keywordflow">if</span> stop <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> stop &gt;= len(self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>):
<a name="l01739"></a>01739             stop = len(self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>) - 1
<a name="l01740"></a>01740             
<a name="l01741"></a>01741         <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> stop &lt; 0:
<a name="l01742"></a>01742             start = 0
<a name="l01743"></a>01743 
<a name="l01744"></a>01744         <span class="keywordflow">if</span> start &gt; stop:
<a name="l01745"></a>01745             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         <span class="keywordflow">if</span> isinstance(types, (int, long)):
<a name="l01748"></a>01748             <span class="comment"># called with a single type, wrap into set</span>
<a name="l01749"></a>01749             types = set([types])
<a name="l01750"></a>01750             
<a name="l01751"></a>01751         filteredTokens = [
<a name="l01752"></a>01752             token <span class="keywordflow">for</span> token <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[start:stop]
<a name="l01753"></a>01753             <span class="keywordflow">if</span> types <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> token.type <span class="keywordflow">in</span> types
<a name="l01754"></a>01754             ]
<a name="l01755"></a>01755 
<a name="l01756"></a>01756         <span class="keywordflow">if</span> len(filteredTokens) == 0:
<a name="l01757"></a>01757             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01758"></a>01758 
<a name="l01759"></a>01759         <span class="keywordflow">return</span> filteredTokens
<a name="l01760"></a>01760 
<a name="l01761"></a>01761 
<a name="l01762"></a>01762     <span class="comment">##</span>
<a name="l01763"></a>01763     <span class="comment"># </span>
<a name="l01764"></a>01764     <span class="comment">#         Get the ith token from the current position 1..n where k=1 is the</span>
<a name="l01765"></a>01765     <span class="comment">#         first symbol of lookahead.</span>
<a name="l01766"></a>01766     <span class="comment">#         </span>
<a name="l01767"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#fbc056e47aef193fd9be31f3bafc20b0">01767</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#fbc056e47aef193fd9be31f3bafc20b0" title="Get the ith token from the current position 1.">LT</a>(self, k):
<a name="l01768"></a>01768 
<a name="l01769"></a>01769         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> == -1:
<a name="l01770"></a>01770             self.<a class="code" href="classantlr3_1_1_common_token_stream.html#328a43591f5412d2cb3a812e7d7394eb" title="Load all tokens from the token source and put in tokens.">fillBuffer</a>()
<a name="l01771"></a>01771 
<a name="l01772"></a>01772         <span class="keywordflow">if</span> k == 0:
<a name="l01773"></a>01773             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01774"></a>01774 
<a name="l01775"></a>01775         <span class="keywordflow">if</span> k &lt; 0:
<a name="l01776"></a>01776             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#a6f11faee0a3e12779e7c9ad714f338c" title="Look backwards k tokens on-channel tokens.">LB</a>(-k)
<a name="l01777"></a>01777                 
<a name="l01778"></a>01778         i = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a>
<a name="l01779"></a>01779         n = 1
<a name="l01780"></a>01780         <span class="comment"># find k good tokens</span>
<a name="l01781"></a>01781         <span class="keywordflow">while</span> n &lt; k:
<a name="l01782"></a>01782             <span class="comment"># skip off-channel tokens</span>
<a name="l01783"></a>01783             i = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#6ce9e9f12b10b34ca59eed00fecb938f" title="Given a starting index, return the index of the first on-channel token.">skipOffTokenChannels</a>(i+1) <span class="comment"># leave p on valid token</span>
<a name="l01784"></a>01784             n += 1
<a name="l01785"></a>01785 
<a name="l01786"></a>01786         <span class="keywordflow">try</span>:
<a name="l01787"></a>01787             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[i]
<a name="l01788"></a>01788         <span class="keywordflow">except</span> IndexError:
<a name="l01789"></a>01789             <span class="keywordflow">return</span> EOF_TOKEN
<a name="l01790"></a>01790 
<a name="l01791"></a>01791 
<a name="l01792"></a>01792     <span class="comment">##</span>
<a name="l01793"></a>01793     <span class="comment"># Look backwards k tokens on-channel tokens</span>
<a name="l01794"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#a6f11faee0a3e12779e7c9ad714f338c">01794</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#a6f11faee0a3e12779e7c9ad714f338c" title="Look backwards k tokens on-channel tokens.">LB</a>(self, k):
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> == -1:
<a name="l01797"></a>01797             self.<a class="code" href="classantlr3_1_1_common_token_stream.html#328a43591f5412d2cb3a812e7d7394eb" title="Load all tokens from the token source and put in tokens.">fillBuffer</a>()
<a name="l01798"></a>01798 
<a name="l01799"></a>01799         <span class="keywordflow">if</span> k == 0:
<a name="l01800"></a>01800             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01801"></a>01801 
<a name="l01802"></a>01802         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> - k &lt; 0:
<a name="l01803"></a>01803             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01804"></a>01804 
<a name="l01805"></a>01805         i = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a>
<a name="l01806"></a>01806         n = 1
<a name="l01807"></a>01807         <span class="comment"># find k good tokens looking backwards</span>
<a name="l01808"></a>01808         <span class="keywordflow">while</span> n &lt;= k:
<a name="l01809"></a>01809             <span class="comment"># skip off-channel tokens</span>
<a name="l01810"></a>01810             i = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#56cb8deb0e5d1995188151cb3de385d3">skipOffTokenChannelsReverse</a>(i-1) <span class="comment"># leave p on valid token</span>
<a name="l01811"></a>01811             n += 1
<a name="l01812"></a>01812 
<a name="l01813"></a>01813         <span class="keywordflow">if</span> i &lt; 0:
<a name="l01814"></a>01814             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01815"></a>01815             
<a name="l01816"></a>01816         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[i]
<a name="l01817"></a>01817 
<a name="l01818"></a>01818 
<a name="l01819"></a>01819     <span class="comment">##</span>
<a name="l01820"></a>01820     <span class="comment"># </span>
<a name="l01821"></a>01821     <span class="comment">#         Return absolute token i; ignore which channel the tokens are on;</span>
<a name="l01822"></a>01822     <span class="comment">#         that is, count all tokens not just on-channel tokens.</span>
<a name="l01823"></a>01823     <span class="comment">#         </span>
<a name="l01824"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#38f1e0023727821f87f4106658e1dc82">01824</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#38f1e0023727821f87f4106658e1dc82" title="Return absolute token i; ignore which channel the tokens are on; that is, count all...">get</a>(self, i):
<a name="l01825"></a>01825 
<a name="l01826"></a>01826         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[i]
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 
<a name="l01829"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#44ce1588dafdcebc4e171fad9dfa5e5f">01829</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#44ce1588dafdcebc4e171fad9dfa5e5f" title="Get int at current input pointer + i ahead where i=1 is next int.">LA</a>(self, i):
<a name="l01830"></a>01830         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#fbc056e47aef193fd9be31f3bafc20b0" title="Get the ith token from the current position 1.">LT</a>(i).type
<a name="l01831"></a>01831 
<a name="l01832"></a>01832 
<a name="l01833"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#cc5958ee00816b8a27644f946c9795e1">01833</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#cc5958ee00816b8a27644f946c9795e1" title="Tell the stream to start buffering if it hasn&amp;#39;t already.">mark</a>(self):
<a name="l01834"></a>01834         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#59b85c37d54dcc2ff2c88e074344ede5">lastMarker</a> = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#2a412427476e0f42fbd3447d4774a698" title="Return the current input symbol index 0.">index</a>()
<a name="l01835"></a>01835         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#59b85c37d54dcc2ff2c88e074344ede5">lastMarker</a>
<a name="l01836"></a>01836     
<a name="l01837"></a>01837 
<a name="l01838"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#ca72cdfbce8849fa94d7f82444970323">01838</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#ca72cdfbce8849fa94d7f82444970323" title="You may want to commit to a backtrack but don&amp;#39;t want to force the stream to keep...">release</a>(self, marker=None):
<a name="l01839"></a>01839         <span class="comment"># no resources to release</span>
<a name="l01840"></a>01840         <span class="keywordflow">pass</span>
<a name="l01841"></a>01841     
<a name="l01842"></a>01842 
<a name="l01843"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#12356651fafc7eddafd68869ff4ad85e">01843</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#12356651fafc7eddafd68869ff4ad85e" title="Only makes sense for streams that buffer everything up probably, but might be useful...">size</a>(self):
<a name="l01844"></a>01844         <span class="keywordflow">return</span> len(self.tokens)
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 
<a name="l01847"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#2a412427476e0f42fbd3447d4774a698">01847</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#2a412427476e0f42fbd3447d4774a698" title="Return the current input symbol index 0.">index</a>(self):
<a name="l01848"></a>01848         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a>
<a name="l01849"></a>01849 
<a name="l01850"></a>01850 
<a name="l01851"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#f54737dafe861b1ad2b7c1d034a575b4">01851</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#f54737dafe861b1ad2b7c1d034a575b4" title="Reset the stream so that next call to index would return marker.">rewind</a>(self, marker=None):
<a name="l01852"></a>01852         <span class="keywordflow">if</span> marker <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01853"></a>01853             marker = self.<a class="code" href="classantlr3_1_1_common_token_stream.html#59b85c37d54dcc2ff2c88e074344ede5">lastMarker</a>
<a name="l01854"></a>01854             
<a name="l01855"></a>01855         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#d6e831d45aa3c1c15dbd424cabb9b959" title="Set the input cursor to the position indicated by index.">seek</a>(marker)
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 
<a name="l01858"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#d6e831d45aa3c1c15dbd424cabb9b959">01858</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#d6e831d45aa3c1c15dbd424cabb9b959" title="Set the input cursor to the position indicated by index.">seek</a>(self, index):
<a name="l01859"></a>01859         self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> = index
<a name="l01860"></a>01860 
<a name="l01861"></a>01861 
<a name="l01862"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#855dc33274bf20f9b345fadfcbe4b8d0">01862</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#855dc33274bf20f9b345fadfcbe4b8d0" title="Where is this stream pulling tokens from? This is not the name, but the object that...">getTokenSource</a>(self):
<a name="l01863"></a>01863         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">tokenSource</a>
<a name="l01864"></a>01864 
<a name="l01865"></a>01865 
<a name="l01866"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#298461a7bc7dcaf3ce8054f4f89c1d72">01866</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#298461a7bc7dcaf3ce8054f4f89c1d72" title="Where are you getting symbols from? Normally, implementations will pass the buck...">getSourceName</a>(self):
<a name="l01867"></a>01867         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#8c6e3810be61f67f0716ba2cf24ff563">tokenSource</a>.getSourceName()
<a name="l01868"></a>01868 
<a name="l01869"></a>01869 
<a name="l01870"></a><a class="code" href="classantlr3_1_1_common_token_stream.html#0ce46e8e5765214d6a0ea5509b153416">01870</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_common_token_stream.html#0ce46e8e5765214d6a0ea5509b153416" title="Return the text of all tokens from start to stop, inclusive.">toString</a>(self, start=None, stop=None):
<a name="l01871"></a>01871         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html#29011862547e0ac04d82fc56c844557d">p</a> == -1:
<a name="l01872"></a>01872             self.<a class="code" href="classantlr3_1_1_common_token_stream.html#328a43591f5412d2cb3a812e7d7394eb" title="Load all tokens from the token source and put in tokens.">fillBuffer</a>()
<a name="l01873"></a>01873 
<a name="l01874"></a>01874         <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01875"></a>01875             start = 0
<a name="l01876"></a>01876         <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(start, int):
<a name="l01877"></a>01877             start = start.index
<a name="l01878"></a>01878 
<a name="l01879"></a>01879         <span class="keywordflow">if</span> stop <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01880"></a>01880             stop = len(self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>) - 1
<a name="l01881"></a>01881         <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(stop, int):
<a name="l01882"></a>01882             stop = stop.index
<a name="l01883"></a>01883         
<a name="l01884"></a>01884         <span class="keywordflow">if</span> stop &gt;= len(self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>):
<a name="l01885"></a>01885             stop = len(self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>) - 1
<a name="l01886"></a>01886 
<a name="l01887"></a>01887         <span class="keywordflow">return</span> <span class="stringliteral">''</span>.join([t.text <span class="keywordflow">for</span> t <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_common_token_stream.html">tokens</a>[start:stop+1]])
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 
<a name="l01890"></a>01890 <span class="comment">##</span>
<a name="l01891"></a>01891 <span class="comment"># @brief Internal helper class.</span>
<a name="l01892"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html">01892</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_rewrite_operation.html" title="Internal helper class.">RewriteOperation</a>(object):
<a name="l01893"></a>01893     
<a name="l01894"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#dd3bad598ee0ac7395c345c808da9980">01894</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rewrite_operation.html#dd3bad598ee0ac7395c345c808da9980">__init__</a>(self, stream, index, text):
<a name="l01895"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#3a09861f35fa5bd1221f30f97394a7fc">01895</a>         self.<a class="code" href="classantlr3_1_1_rewrite_operation.html#3a09861f35fa5bd1221f30f97394a7fc">stream</a> = stream
<a name="l01896"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#0fd215bc7a8e0a0ad9438122de8b61a9">01896</a>         self.<a class="code" href="classantlr3_1_1_rewrite_operation.html#0fd215bc7a8e0a0ad9438122de8b61a9">index</a> = index
<a name="l01897"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#5a683eceb608e026501ce6395c13c272">01897</a>         self.<a class="code" href="classantlr3_1_1_rewrite_operation.html#5a683eceb608e026501ce6395c13c272">text</a> = text
<a name="l01898"></a>01898 
<a name="l01899"></a>01899     <span class="comment">##</span>
<a name="l01900"></a>01900     <span class="comment"># Execute the rewrite operation by possibly adding to the buffer.</span>
<a name="l01901"></a>01901     <span class="comment">#         Return the index of the next token to operate on.</span>
<a name="l01902"></a>01902     <span class="comment">#         </span>
<a name="l01903"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#7a92c9e9abf344eb3accbb276c60df78">01903</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rewrite_operation.html#7a92c9e9abf344eb3accbb276c60df78" title="Execute the rewrite operation by possibly adding to the buffer.">execute</a>(self, buf):
<a name="l01904"></a>01904 
<a name="l01905"></a>01905         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_rewrite_operation.html#0fd215bc7a8e0a0ad9438122de8b61a9">index</a>
<a name="l01906"></a>01906 
<a name="l01907"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#f5b50b84eda592e53d5a97664e36d784">01907</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rewrite_operation.html#f5b50b84eda592e53d5a97664e36d784">toString</a>(self):
<a name="l01908"></a>01908         opName = self.__class__.__name__
<a name="l01909"></a>01909         <span class="keywordflow">return</span> <span class="stringliteral">'&lt;%s@%d:"%s"&gt;'</span> % (opName, self.<a class="code" href="classantlr3_1_1_rewrite_operation.html#0fd215bc7a8e0a0ad9438122de8b61a9">index</a>, self.<a class="code" href="classantlr3_1_1_rewrite_operation.html#5a683eceb608e026501ce6395c13c272">text</a>)
<a name="l01910"></a>01910 
<a name="l01911"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#3c95eff32c2fdc6c7f67e27dc002699f">01911</a>     __str__ = toString
<a name="l01912"></a><a class="code" href="classantlr3_1_1_rewrite_operation.html#9b214c155adbceeb2b49dd67c6d8b464">01912</a>     __repr__ = toString
<a name="l01913"></a>01913 
<a name="l01914"></a>01914 
<a name="l01915"></a>01915 <span class="comment">##</span>
<a name="l01916"></a>01916 <span class="comment"># @brief Internal helper class.</span>
<a name="l01917"></a><a class="code" href="classantlr3_1_1_insert_before_op.html">01917</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_insert_before_op.html" title="Internal helper class.">InsertBeforeOp</a>(<a class="code" href="classantlr3_1_1_rewrite_operation.html" title="Internal helper class.">RewriteOperation</a>):
<a name="l01918"></a>01918 
<a name="l01919"></a><a class="code" href="classantlr3_1_1_insert_before_op.html#c4d0f3a0465936d559da65b3a6f90776">01919</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_insert_before_op.html#c4d0f3a0465936d559da65b3a6f90776" title="Execute the rewrite operation by possibly adding to the buffer.">execute</a>(self, buf):
<a name="l01920"></a>01920         buf.write(self.text)
<a name="l01921"></a>01921         buf.write(self.stream.tokens[self.index].text)
<a name="l01922"></a>01922         <span class="keywordflow">return</span> self.index + 1
<a name="l01923"></a>01923 
<a name="l01924"></a>01924 
<a name="l01925"></a>01925 <span class="comment">##</span>
<a name="l01926"></a>01926 <span class="comment"># </span>
<a name="l01927"></a>01927 <span class="comment">#     @brief Internal helper class.</span>
<a name="l01928"></a>01928 <span class="comment">#     </span>
<a name="l01929"></a>01929 <span class="comment">#     I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp</span>
<a name="l01930"></a>01930 <span class="comment">#     instructions.</span>
<a name="l01931"></a>01931 <span class="comment">#     </span>
<a name="l01932"></a><a class="code" href="classantlr3_1_1_replace_op.html">01932</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_replace_op.html" title="Internal helper class.">ReplaceOp</a>(<a class="code" href="classantlr3_1_1_rewrite_operation.html" title="Internal helper class.">RewriteOperation</a>):
<a name="l01933"></a>01933 
<a name="l01934"></a><a class="code" href="classantlr3_1_1_replace_op.html#2dd4bc16c28b79a4ed4270a3e88570de">01934</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_replace_op.html#2dd4bc16c28b79a4ed4270a3e88570de">__init__</a>(self, stream, first, last, text):
<a name="l01935"></a>01935         RewriteOperation.__init__(self, stream, first, text)
<a name="l01936"></a><a class="code" href="classantlr3_1_1_replace_op.html#182f9cd73411052f1943cde276625721">01936</a>         self.<a class="code" href="classantlr3_1_1_replace_op.html#182f9cd73411052f1943cde276625721">lastIndex</a> = last
<a name="l01937"></a>01937 
<a name="l01938"></a>01938 
<a name="l01939"></a><a class="code" href="classantlr3_1_1_replace_op.html#4d92756092b6334603120cacd70ffcd9">01939</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_replace_op.html#4d92756092b6334603120cacd70ffcd9" title="Execute the rewrite operation by possibly adding to the buffer.">execute</a>(self, buf):
<a name="l01940"></a>01940         <span class="keywordflow">if</span> self.text <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l01941"></a>01941             buf.write(self.text)
<a name="l01942"></a>01942 
<a name="l01943"></a>01943         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_replace_op.html#182f9cd73411052f1943cde276625721">lastIndex</a> + 1
<a name="l01944"></a>01944 
<a name="l01945"></a>01945 
<a name="l01946"></a><a class="code" href="classantlr3_1_1_replace_op.html#577594d2c0ab91a2602f6203644666a1">01946</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_replace_op.html#577594d2c0ab91a2602f6203644666a1">toString</a>(self):
<a name="l01947"></a>01947         <span class="keywordflow">return</span> <span class="stringliteral">'&lt;ReplaceOp@%d..%d:"%s"&gt;'</span> % (
<a name="l01948"></a>01948             self.index, self.<a class="code" href="classantlr3_1_1_replace_op.html#182f9cd73411052f1943cde276625721">lastIndex</a>, self.text)
<a name="l01949"></a>01949 
<a name="l01950"></a><a class="code" href="classantlr3_1_1_replace_op.html#d18840008568f0672264e1e358e1e73c">01950</a>     __str__ = toString
<a name="l01951"></a><a class="code" href="classantlr3_1_1_replace_op.html#66d1c06060ea8dd72f7addaa844b7477">01951</a>     __repr__ = toString
<a name="l01952"></a>01952 
<a name="l01953"></a>01953 
<a name="l01954"></a>01954 <span class="comment">##</span>
<a name="l01955"></a>01955 <span class="comment"># </span>
<a name="l01956"></a>01956 <span class="comment">#     @brief Internal helper class.</span>
<a name="l01957"></a>01957 <span class="comment">#     </span>
<a name="l01958"></a><a class="code" href="classantlr3_1_1_delete_op.html">01958</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_delete_op.html" title="Internal helper class.">DeleteOp</a>(<a class="code" href="classantlr3_1_1_replace_op.html" title="Internal helper class.">ReplaceOp</a>):
<a name="l01959"></a>01959 
<a name="l01960"></a><a class="code" href="classantlr3_1_1_delete_op.html#e3e97237fc01ecd7c141dad42eb210c4">01960</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_delete_op.html#e3e97237fc01ecd7c141dad42eb210c4">__init__</a>(self, stream, first, last):
<a name="l01961"></a>01961         ReplaceOp.__init__(self, stream, first, last, <span class="keywordtype">None</span>)
<a name="l01962"></a>01962 
<a name="l01963"></a>01963 
<a name="l01964"></a><a class="code" href="classantlr3_1_1_delete_op.html#699ee332f79451a5d458036dfd14f10d">01964</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_delete_op.html#699ee332f79451a5d458036dfd14f10d">toString</a>(self):
<a name="l01965"></a>01965         <span class="keywordflow">return</span> <span class="stringliteral">'&lt;DeleteOp@%d..%d&gt;'</span> % (self.index, self.lastIndex)
<a name="l01966"></a>01966 
<a name="l01967"></a><a class="code" href="classantlr3_1_1_delete_op.html#179ca387dace175963e5ad9ab90cabdc">01967</a>     __str__ = toString
<a name="l01968"></a><a class="code" href="classantlr3_1_1_delete_op.html#462ec82de41f57d812665ea8551507d5">01968</a>     __repr__ = toString
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 
<a name="l01971"></a>01971 <span class="comment">##</span>
<a name="l01972"></a>01972 <span class="comment"># @brief CommonTokenStream that can be modified.</span>
<a name="l01973"></a>01973 <span class="comment"># </span>
<a name="l01974"></a>01974 <span class="comment">#     Useful for dumping out the input stream after doing some</span>
<a name="l01975"></a>01975 <span class="comment">#     augmentation or other manipulations.</span>
<a name="l01976"></a>01976 <span class="comment"># </span>
<a name="l01977"></a>01977 <span class="comment">#     You can insert stuff, replace, and delete chunks.  Note that the</span>
<a name="l01978"></a>01978 <span class="comment">#     operations are done lazily--only if you convert the buffer to a</span>
<a name="l01979"></a>01979 <span class="comment">#     String.  This is very efficient because you are not moving data around</span>
<a name="l01980"></a>01980 <span class="comment">#     all the time.  As the buffer of tokens is converted to strings, the</span>
<a name="l01981"></a>01981 <span class="comment">#     toString() method(s) check to see if there is an operation at the</span>
<a name="l01982"></a>01982 <span class="comment">#     current index.  If so, the operation is done and then normal String</span>
<a name="l01983"></a>01983 <span class="comment">#     rendering continues on the buffer.  This is like having multiple Turing</span>
<a name="l01984"></a>01984 <span class="comment">#     machine instruction streams (programs) operating on a single input tape. :)</span>
<a name="l01985"></a>01985 <span class="comment"># </span>
<a name="l01986"></a>01986 <span class="comment">#     Since the operations are done lazily at toString-time, operations do not</span>
<a name="l01987"></a>01987 <span class="comment">#     screw up the token index values.  That is, an insert operation at token</span>
<a name="l01988"></a>01988 <span class="comment">#     index i does not change the index values for tokens i+1..n-1.</span>
<a name="l01989"></a>01989 <span class="comment"># </span>
<a name="l01990"></a>01990 <span class="comment">#     Because operations never actually alter the buffer, you may always get</span>
<a name="l01991"></a>01991 <span class="comment">#     the original token stream back without undoing anything.  Since</span>
<a name="l01992"></a>01992 <span class="comment">#     the instructions are queued up, you can easily simulate transactions and</span>
<a name="l01993"></a>01993 <span class="comment">#     roll back any changes if there is an error just by removing instructions.</span>
<a name="l01994"></a>01994 <span class="comment">#     For example,</span>
<a name="l01995"></a>01995 <span class="comment"># </span>
<a name="l01996"></a>01996 <span class="comment">#      CharStream input = new ANTLRFileStream("input");</span>
<a name="l01997"></a>01997 <span class="comment">#      TLexer lex = new TLexer(input);</span>
<a name="l01998"></a>01998 <span class="comment">#      TokenRewriteStream tokens = new TokenRewriteStream(lex);</span>
<a name="l01999"></a>01999 <span class="comment">#      T parser = new T(tokens);</span>
<a name="l02000"></a>02000 <span class="comment">#      parser.startRule();</span>
<a name="l02001"></a>02001 <span class="comment"># </span>
<a name="l02002"></a>02002 <span class="comment">#      Then in the rules, you can execute</span>
<a name="l02003"></a>02003 <span class="comment">#         Token t,u;</span>
<a name="l02004"></a>02004 <span class="comment">#         ...</span>
<a name="l02005"></a>02005 <span class="comment">#         input.insertAfter(t, "text to put after t");}</span>
<a name="l02006"></a>02006 <span class="comment">#         input.insertAfter(u, "text after u");}</span>
<a name="l02007"></a>02007 <span class="comment">#         System.out.println(tokens.toString());</span>
<a name="l02008"></a>02008 <span class="comment"># </span>
<a name="l02009"></a>02009 <span class="comment">#     Actually, you have to cast the 'input' to a TokenRewriteStream. :(</span>
<a name="l02010"></a>02010 <span class="comment"># </span>
<a name="l02011"></a>02011 <span class="comment">#     You can also have multiple "instruction streams" and get multiple</span>
<a name="l02012"></a>02012 <span class="comment">#     rewrites from a single pass over the input.  Just name the instruction</span>
<a name="l02013"></a>02013 <span class="comment">#     streams and use that name again when printing the buffer.  This could be</span>
<a name="l02014"></a>02014 <span class="comment">#     useful for generating a C file and also its header file--all from the</span>
<a name="l02015"></a>02015 <span class="comment">#     same buffer:</span>
<a name="l02016"></a>02016 <span class="comment"># </span>
<a name="l02017"></a>02017 <span class="comment">#         tokens.insertAfter("pass1", t, "text to put after t");}</span>
<a name="l02018"></a>02018 <span class="comment">#         tokens.insertAfter("pass2", u, "text after u");}</span>
<a name="l02019"></a>02019 <span class="comment">#         System.out.println(tokens.toString("pass1"));</span>
<a name="l02020"></a>02020 <span class="comment">#         System.out.println(tokens.toString("pass2"));</span>
<a name="l02021"></a>02021 <span class="comment"># </span>
<a name="l02022"></a>02022 <span class="comment">#     If you don't use named rewrite streams, a "default" stream is used as</span>
<a name="l02023"></a>02023 <span class="comment">#     the first example shows.</span>
<a name="l02024"></a>02024 <span class="comment">#     </span>
<a name="l02025"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html">02025</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html" title="CommonTokenStream that can be modified.">TokenRewriteStream</a>(<a class="code" href="classantlr3_1_1_common_token_stream.html" title="The most common stream of tokens.">CommonTokenStream</a>):
<a name="l02026"></a>02026     
<a name="l02027"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">02027</a>     DEFAULT_PROGRAM_NAME = <span class="stringliteral">"default"</span>
<a name="l02028"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">02028</a>     MIN_TOKEN_INDEX = 0
<a name="l02029"></a>02029 
<a name="l02030"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#7c332b3f6930dc4e35173a036730d9af">02030</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#7c332b3f6930dc4e35173a036730d9af">__init__</a>(self, tokenSource=None, channel=DEFAULT_CHANNEL):
<a name="l02031"></a>02031         CommonTokenStream.__init__(self, tokenSource, channel)
<a name="l02032"></a>02032 
<a name="l02033"></a>02033         <span class="comment"># You may have multiple, named streams of rewrite operations.</span>
<a name="l02034"></a>02034         <span class="comment"># I'm calling these things "programs."</span>
<a name="l02035"></a>02035         <span class="comment">#  Maps String (name) -&gt; rewrite (List)</span>
<a name="l02036"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">02036</a>         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a> = {}
<a name="l02037"></a>02037         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a>[self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>] = []
<a name="l02038"></a>02038         
<a name="l02039"></a>02039         <span class="comment"># Map String (program name) -&gt; Integer index</span>
<a name="l02040"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a71d0a5e1dc95d60a7daf2eb8e631718">02040</a>         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a71d0a5e1dc95d60a7daf2eb8e631718">lastRewriteTokenIndexes</a> = {}
<a name="l02041"></a>02041         
<a name="l02042"></a>02042 
<a name="l02043"></a>02043     <span class="comment">##</span>
<a name="l02044"></a>02044     <span class="comment"># </span>
<a name="l02045"></a>02045     <span class="comment">#         Rollback the instruction stream for a program so that</span>
<a name="l02046"></a>02046     <span class="comment">#         the indicated instruction (via instructionIndex) is no</span>
<a name="l02047"></a>02047     <span class="comment">#         longer in the stream.  UNTESTED!</span>
<a name="l02048"></a>02048     <span class="comment">#         </span>
<a name="l02049"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0e119015ca619e0f7b022f0d7632bc20">02049</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0e119015ca619e0f7b022f0d7632bc20" title="Rollback the instruction stream for a program so that the indicated instruction (via...">rollback</a>(self, *args):
<a name="l02050"></a>02050 
<a name="l02051"></a>02051         <span class="keywordflow">if</span> len(args) == 2:
<a name="l02052"></a>02052             programName = args[0]
<a name="l02053"></a>02053             instructionIndex = args[1]
<a name="l02054"></a>02054         <span class="keywordflow">elif</span> len(args) == 1:
<a name="l02055"></a>02055             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02056"></a>02056             instructionIndex = args[0]
<a name="l02057"></a>02057         <span class="keywordflow">else</span>:
<a name="l02058"></a>02058             <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">"Invalid arguments"</span>)
<a name="l02059"></a>02059         
<a name="l02060"></a>02060         p = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a>.get(programName, <span class="keywordtype">None</span>)
<a name="l02061"></a>02061         <span class="keywordflow">if</span> p <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l02062"></a>02062             self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a>[programName] = (
<a name="l02063"></a>02063                 p[self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>:instructionIndex])
<a name="l02064"></a>02064 
<a name="l02065"></a>02065 
<a name="l02066"></a>02066     <span class="comment">##</span>
<a name="l02067"></a>02067     <span class="comment"># Reset the program so that no instructions exist</span>
<a name="l02068"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#99d8304a9309c1fd4fb0e01bc580f086">02068</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#99d8304a9309c1fd4fb0e01bc580f086" title="Reset the program so that no instructions exist.">deleteProgram</a>(self, programName=DEFAULT_PROGRAM_NAME):
<a name="l02069"></a>02069             
<a name="l02070"></a>02070         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0e119015ca619e0f7b022f0d7632bc20" title="Rollback the instruction stream for a program so that the indicated instruction (via...">rollback</a>(programName, self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>)
<a name="l02071"></a>02071 
<a name="l02072"></a>02072 
<a name="l02073"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0c89013df76541e88d5ae8a28ec9e41b">02073</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0c89013df76541e88d5ae8a28ec9e41b">insertAfter</a>(self, *args):
<a name="l02074"></a>02074         <span class="keywordflow">if</span> len(args) == 2:
<a name="l02075"></a>02075             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02076"></a>02076             index = args[0]
<a name="l02077"></a>02077             text = args[1]
<a name="l02078"></a>02078             
<a name="l02079"></a>02079         <span class="keywordflow">elif</span> len(args) == 3:
<a name="l02080"></a>02080             programName = args[0]
<a name="l02081"></a>02081             index = args[1]
<a name="l02082"></a>02082             text = args[2]
<a name="l02083"></a>02083 
<a name="l02084"></a>02084         <span class="keywordflow">else</span>:
<a name="l02085"></a>02085             <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">"Invalid arguments"</span>)
<a name="l02086"></a>02086 
<a name="l02087"></a>02087         <span class="keywordflow">if</span> isinstance(index, Token):
<a name="l02088"></a>02088             <span class="comment"># index is a Token, grap the stream index from it</span>
<a name="l02089"></a>02089             index = index.index
<a name="l02090"></a>02090 
<a name="l02091"></a>02091         <span class="comment"># to insert after, just insert before next index (even if past end)</span>
<a name="l02092"></a>02092         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#dd101bc84de130caa87d3294626caaf1">insertBefore</a>(programName, index+1, text)
<a name="l02093"></a>02093 
<a name="l02094"></a>02094 
<a name="l02095"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#dd101bc84de130caa87d3294626caaf1">02095</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#dd101bc84de130caa87d3294626caaf1">insertBefore</a>(self, *args):
<a name="l02096"></a>02096         <span class="keywordflow">if</span> len(args) == 2:
<a name="l02097"></a>02097             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02098"></a>02098             index = args[0]
<a name="l02099"></a>02099             text = args[1]
<a name="l02100"></a>02100             
<a name="l02101"></a>02101         <span class="keywordflow">elif</span> len(args) == 3:
<a name="l02102"></a>02102             programName = args[0]
<a name="l02103"></a>02103             index = args[1]
<a name="l02104"></a>02104             text = args[2]
<a name="l02105"></a>02105 
<a name="l02106"></a>02106         <span class="keywordflow">else</span>:
<a name="l02107"></a>02107             <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">"Invalid arguments"</span>)
<a name="l02108"></a>02108 
<a name="l02109"></a>02109         <span class="keywordflow">if</span> isinstance(index, Token):
<a name="l02110"></a>02110             <span class="comment"># index is a Token, grap the stream index from it</span>
<a name="l02111"></a>02111             index = index.index
<a name="l02112"></a>02112 
<a name="l02113"></a>02113         op = InsertBeforeOp(self, index, text)
<a name="l02114"></a>02114         rewrites = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#efb3cf072db2dc913fdc76fed73046a1">getProgram</a>(programName)
<a name="l02115"></a>02115         rewrites.append(op)
<a name="l02116"></a>02116 
<a name="l02117"></a>02117 
<a name="l02118"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a53e867c2bebcee93a1b7cb000ce40dc">02118</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a53e867c2bebcee93a1b7cb000ce40dc">replace</a>(self, *args):
<a name="l02119"></a>02119         <span class="keywordflow">if</span> len(args) == 2:
<a name="l02120"></a>02120             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02121"></a>02121             first = args[0]
<a name="l02122"></a>02122             last = args[0]
<a name="l02123"></a>02123             text = args[1]
<a name="l02124"></a>02124             
<a name="l02125"></a>02125         <span class="keywordflow">elif</span> len(args) == 3:
<a name="l02126"></a>02126             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02127"></a>02127             first = args[0]
<a name="l02128"></a>02128             last = args[1]
<a name="l02129"></a>02129             text = args[2]
<a name="l02130"></a>02130             
<a name="l02131"></a>02131         <span class="keywordflow">elif</span> len(args) == 4:
<a name="l02132"></a>02132             programName = args[0]
<a name="l02133"></a>02133             first = args[1]
<a name="l02134"></a>02134             last = args[2]
<a name="l02135"></a>02135             text = args[3]
<a name="l02136"></a>02136 
<a name="l02137"></a>02137         <span class="keywordflow">else</span>:
<a name="l02138"></a>02138             <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">"Invalid arguments"</span>)
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         <span class="keywordflow">if</span> isinstance(first, Token):
<a name="l02141"></a>02141             <span class="comment"># first is a Token, grap the stream index from it</span>
<a name="l02142"></a>02142             first = first.index
<a name="l02143"></a>02143 
<a name="l02144"></a>02144         <span class="keywordflow">if</span> isinstance(last, Token):
<a name="l02145"></a>02145             <span class="comment"># last is a Token, grap the stream index from it</span>
<a name="l02146"></a>02146             last = last.index
<a name="l02147"></a>02147 
<a name="l02148"></a>02148         <span class="keywordflow">if</span> first &gt; last <span class="keywordflow">or</span> first &lt; 0 <span class="keywordflow">or</span> last &lt; 0 <span class="keywordflow">or</span> last &gt;= len(self.tokens):
<a name="l02149"></a>02149             <span class="keywordflow">raise</span> ValueError(
<a name="l02150"></a>02150                 <span class="stringliteral">"replace: range invalid: "</span>+first+<span class="stringliteral">".."</span>+last+
<a name="l02151"></a>02151                 <span class="stringliteral">"(size="</span>+len(self.tokens)+<span class="stringliteral">")"</span>)
<a name="l02152"></a>02152 
<a name="l02153"></a>02153         op = ReplaceOp(self, first, last, text)
<a name="l02154"></a>02154         rewrites = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#efb3cf072db2dc913fdc76fed73046a1">getProgram</a>(programName)
<a name="l02155"></a>02155         rewrites.append(op)
<a name="l02156"></a>02156         
<a name="l02157"></a>02157 
<a name="l02158"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#fb0bc761bf06f424cfea9c37d064eb9e">02158</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#fb0bc761bf06f424cfea9c37d064eb9e">delete</a>(self, *args):
<a name="l02159"></a>02159         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a53e867c2bebcee93a1b7cb000ce40dc">replace</a>(*(list(args) + [<span class="keywordtype">None</span>]))
<a name="l02160"></a>02160 
<a name="l02161"></a>02161 
<a name="l02162"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#8a3354ceb6358794a9cff90d7625b23f">02162</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#8a3354ceb6358794a9cff90d7625b23f">getLastRewriteTokenIndex</a>(self, programName=DEFAULT_PROGRAM_NAME):
<a name="l02163"></a>02163         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a71d0a5e1dc95d60a7daf2eb8e631718">lastRewriteTokenIndexes</a>.get(programName, -1)
<a name="l02164"></a>02164 
<a name="l02165"></a>02165 
<a name="l02166"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#85c259099df7caddce305832f08030de">02166</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#85c259099df7caddce305832f08030de">setLastRewriteTokenIndex</a>(self, programName, i):
<a name="l02167"></a>02167         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#a71d0a5e1dc95d60a7daf2eb8e631718">lastRewriteTokenIndexes</a>[programName] = i
<a name="l02168"></a>02168 
<a name="l02169"></a>02169 
<a name="l02170"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#efb3cf072db2dc913fdc76fed73046a1">02170</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#efb3cf072db2dc913fdc76fed73046a1">getProgram</a>(self, name):
<a name="l02171"></a>02171         p = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a>.get(name, <span class="keywordtype">None</span>)
<a name="l02172"></a>02172         <span class="keywordflow">if</span> p <span class="keywordflow">is</span>  <span class="keywordtype">None</span>:
<a name="l02173"></a>02173             p = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#511721eeb8579c127bee6ba8067aac8d">initializeProgram</a>(name)
<a name="l02174"></a>02174 
<a name="l02175"></a>02175         <span class="keywordflow">return</span> p
<a name="l02176"></a>02176 
<a name="l02177"></a>02177 
<a name="l02178"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#511721eeb8579c127bee6ba8067aac8d">02178</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#511721eeb8579c127bee6ba8067aac8d">initializeProgram</a>(self, name):
<a name="l02179"></a>02179         p = []
<a name="l02180"></a>02180         self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a>[name] = p
<a name="l02181"></a>02181         <span class="keywordflow">return</span> p
<a name="l02182"></a>02182 
<a name="l02183"></a>02183 
<a name="l02184"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0221e67961412ec70417191dcc176d9c">02184</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0221e67961412ec70417191dcc176d9c">toOriginalString</a>(self, start=None, end=None):
<a name="l02185"></a>02185         <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02186"></a>02186             start = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>
<a name="l02187"></a>02187         <span class="keywordflow">if</span> end <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02188"></a>02188             end = self.size() - 1
<a name="l02189"></a>02189         
<a name="l02190"></a>02190         buf = StringIO()
<a name="l02191"></a>02191         i = start
<a name="l02192"></a>02192         <span class="keywordflow">while</span> i &gt;= self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a> <span class="keywordflow">and</span> i &lt;= end <span class="keywordflow">and</span> i &lt; len(self.tokens):
<a name="l02193"></a>02193             buf.write(self.get(i).text)
<a name="l02194"></a>02194             i += 1
<a name="l02195"></a>02195 
<a name="l02196"></a>02196         <span class="keywordflow">return</span> buf.getvalue()
<a name="l02197"></a>02197 
<a name="l02198"></a>02198 
<a name="l02199"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#7c5a7d74c3849c00fd3bfc5a0a6884b1">02199</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#7c5a7d74c3849c00fd3bfc5a0a6884b1">toString</a>(self, *args):
<a name="l02200"></a>02200         <span class="keywordflow">if</span> len(args) == 0:
<a name="l02201"></a>02201             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02202"></a>02202             start = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>
<a name="l02203"></a>02203             end = self.size() - 1
<a name="l02204"></a>02204             
<a name="l02205"></a>02205         <span class="keywordflow">elif</span> len(args) == 1:
<a name="l02206"></a>02206             programName = args[0]
<a name="l02207"></a>02207             start = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>
<a name="l02208"></a>02208             end = self.size() - 1
<a name="l02209"></a>02209 
<a name="l02210"></a>02210         <span class="keywordflow">elif</span> len(args) == 2:
<a name="l02211"></a>02211             programName = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#aa81b930220030347aa1edbc0bf8e682">DEFAULT_PROGRAM_NAME</a>
<a name="l02212"></a>02212             start = args[0]
<a name="l02213"></a>02213             end = args[1]
<a name="l02214"></a>02214             
<a name="l02215"></a>02215         <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02216"></a>02216             start = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>
<a name="l02217"></a>02217         <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(start, int):
<a name="l02218"></a>02218             start = start.index
<a name="l02219"></a>02219 
<a name="l02220"></a>02220         <span class="keywordflow">if</span> end <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02221"></a>02221             end = len(self.tokens) - 1
<a name="l02222"></a>02222         <span class="keywordflow">elif</span> <span class="keywordflow">not</span> isinstance(end, int):
<a name="l02223"></a>02223             end = end.index
<a name="l02224"></a>02224 
<a name="l02225"></a>02225         <span class="comment"># ensure start/end are in range</span>
<a name="l02226"></a>02226         <span class="keywordflow">if</span> end &gt;= len(self.tokens):
<a name="l02227"></a>02227             end = len(self.tokens) - 1
<a name="l02228"></a>02228 
<a name="l02229"></a>02229         <span class="keywordflow">if</span> start &lt; 0:
<a name="l02230"></a>02230             start = 0
<a name="l02231"></a>02231 
<a name="l02232"></a>02232         rewrites = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d9af9757501a0560aac563d4310b8d50">programs</a>.get(programName)
<a name="l02233"></a>02233         <span class="keywordflow">if</span> rewrites <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> len(rewrites) == 0:
<a name="l02234"></a>02234             <span class="comment"># no instructions to execute</span>
<a name="l02235"></a>02235             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#0221e67961412ec70417191dcc176d9c">toOriginalString</a>(start, end)
<a name="l02236"></a>02236         
<a name="l02237"></a>02237         buf = StringIO()
<a name="l02238"></a>02238 
<a name="l02239"></a>02239         <span class="comment"># First, optimize instruction stream</span>
<a name="l02240"></a>02240         indexToOp = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d84a6342573b28f0fe78cb1ba554b021" title="We need to combine operations and report invalid operations (like overlapping replaces...">reduceToSingleOperationPerIndex</a>(rewrites)
<a name="l02241"></a>02241 
<a name="l02242"></a>02242         <span class="comment"># Walk buffer, executing instructions and emitting tokens</span>
<a name="l02243"></a>02243         i = start
<a name="l02244"></a>02244         <span class="keywordflow">while</span> i &lt;= end <span class="keywordflow">and</span> i &lt; len(self.tokens):
<a name="l02245"></a>02245             op = indexToOp.get(i)
<a name="l02246"></a>02246             <span class="comment"># remove so any left have index size-1</span>
<a name="l02247"></a>02247             <span class="keywordflow">try</span>:
<a name="l02248"></a>02248                 del indexToOp[i]
<a name="l02249"></a>02249             <span class="keywordflow">except</span> KeyError:
<a name="l02250"></a>02250                 <span class="keywordflow">pass</span>
<a name="l02251"></a>02251 
<a name="l02252"></a>02252             t = self.tokens[i]
<a name="l02253"></a>02253             <span class="keywordflow">if</span> op <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02254"></a>02254                 <span class="comment"># no operation at that index, just dump token</span>
<a name="l02255"></a>02255                 buf.write(t.text)
<a name="l02256"></a>02256                 i += 1 <span class="comment"># move to next token</span>
<a name="l02257"></a>02257 
<a name="l02258"></a>02258             <span class="keywordflow">else</span>:
<a name="l02259"></a>02259                 i = op.execute(buf) <span class="comment"># execute operation and skip</span>
<a name="l02260"></a>02260 
<a name="l02261"></a>02261         <span class="comment"># include stuff after end if it's last index in buffer</span>
<a name="l02262"></a>02262         <span class="comment"># So, if they did an insertAfter(lastValidIndex, "foo"), include</span>
<a name="l02263"></a>02263         <span class="comment"># foo if end==lastValidIndex.</span>
<a name="l02264"></a>02264         <span class="keywordflow">if</span> end == len(self.tokens) - 1:
<a name="l02265"></a>02265             <span class="comment"># Scan any remaining operations after last token</span>
<a name="l02266"></a>02266             <span class="comment"># should be included (they will be inserts).</span>
<a name="l02267"></a>02267             <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(indexToOp.keys()):
<a name="l02268"></a>02268                 op = indexToOp[i]
<a name="l02269"></a>02269                 <span class="keywordflow">if</span> op.index &gt;= len(self.tokens)-1:
<a name="l02270"></a>02270                     buf.write(op.text)
<a name="l02271"></a>02271 
<a name="l02272"></a>02272         <span class="keywordflow">return</span> buf.getvalue()
<a name="l02273"></a>02273 
<a name="l02274"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#33b787c7519c68129b72d0789c9a88e8">02274</a>     __str__ = toString
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 
<a name="l02277"></a>02277     <span class="comment">##</span>
<a name="l02278"></a>02278     <span class="comment"># </span>
<a name="l02279"></a>02279     <span class="comment">#         We need to combine operations and report invalid operations (like</span>
<a name="l02280"></a>02280     <span class="comment">#         overlapping replaces that are not completed nested).  Inserts to</span>
<a name="l02281"></a>02281     <span class="comment">#         same index need to be combined etc...   Here are the cases:</span>
<a name="l02282"></a>02282     <span class="comment"># </span>
<a name="l02283"></a>02283     <span class="comment">#         I.i.u I.j.v                           leave alone, nonoverlapping</span>
<a name="l02284"></a>02284     <span class="comment">#         I.i.u I.i.v                           combine: Iivu</span>
<a name="l02285"></a>02285     <span class="comment"># </span>
<a name="l02286"></a>02286     <span class="comment">#         R.i-j.u R.x-y.v | i-j in x-y          delete first R</span>
<a name="l02287"></a>02287     <span class="comment">#         R.i-j.u R.i-j.v                       delete first R</span>
<a name="l02288"></a>02288     <span class="comment">#         R.i-j.u R.x-y.v | x-y in i-j          ERROR</span>
<a name="l02289"></a>02289     <span class="comment">#         R.i-j.u R.x-y.v | boundaries overlap  ERROR</span>
<a name="l02290"></a>02290     <span class="comment"># </span>
<a name="l02291"></a>02291     <span class="comment">#         I.i.u R.x-y.v   | i in x-y            delete I</span>
<a name="l02292"></a>02292     <span class="comment">#         I.i.u R.x-y.v   | i not in x-y        leave alone, nonoverlapping</span>
<a name="l02293"></a>02293     <span class="comment">#         R.x-y.v I.i.u   | i in x-y            ERROR</span>
<a name="l02294"></a>02294     <span class="comment">#         R.x-y.v I.x.u                         R.x-y.uv (combine, delete I)</span>
<a name="l02295"></a>02295     <span class="comment">#         R.x-y.v I.i.u   | i not in x-y        leave alone, nonoverlapping</span>
<a name="l02296"></a>02296     <span class="comment"># </span>
<a name="l02297"></a>02297     <span class="comment">#         I.i.u = insert u before op @ index i</span>
<a name="l02298"></a>02298     <span class="comment">#         R.x-y.u = replace x-y indexed tokens with u</span>
<a name="l02299"></a>02299     <span class="comment"># </span>
<a name="l02300"></a>02300     <span class="comment">#         First we need to examine replaces.  For any replace op:</span>
<a name="l02301"></a>02301     <span class="comment"># </span>
<a name="l02302"></a>02302     <span class="comment">#           1. wipe out any insertions before op within that range.</span>
<a name="l02303"></a>02303     <span class="comment">#           2. Drop any replace op before that is contained completely within</span>
<a name="l02304"></a>02304     <span class="comment">#              that range.</span>
<a name="l02305"></a>02305     <span class="comment">#           3. Throw exception upon boundary overlap with any previous replace.</span>
<a name="l02306"></a>02306     <span class="comment"># </span>
<a name="l02307"></a>02307     <span class="comment">#         Then we can deal with inserts:</span>
<a name="l02308"></a>02308     <span class="comment"># </span>
<a name="l02309"></a>02309     <span class="comment">#           1. for any inserts to same index, combine even if not adjacent.</span>
<a name="l02310"></a>02310     <span class="comment">#           2. for any prior replace with same left boundary, combine this</span>
<a name="l02311"></a>02311     <span class="comment">#              insert with replace and delete this replace.</span>
<a name="l02312"></a>02312     <span class="comment">#           3. throw exception if index in same range as previous replace</span>
<a name="l02313"></a>02313     <span class="comment"># </span>
<a name="l02314"></a>02314     <span class="comment">#         Don't actually delete; make op null in list. Easier to walk list.</span>
<a name="l02315"></a>02315     <span class="comment">#         Later we can throw as we add to index -&gt; op map.</span>
<a name="l02316"></a>02316     <span class="comment"># </span>
<a name="l02317"></a>02317     <span class="comment">#         Note that I.2 R.2-2 will wipe out I.2 even though, technically, the</span>
<a name="l02318"></a>02318     <span class="comment">#         inserted stuff would be before the replace range.  But, if you</span>
<a name="l02319"></a>02319     <span class="comment">#         add tokens in front of a method body '{' and then delete the method</span>
<a name="l02320"></a>02320     <span class="comment">#         body, I think the stuff before the '{' you added should disappear too.</span>
<a name="l02321"></a>02321     <span class="comment"># </span>
<a name="l02322"></a>02322     <span class="comment">#         Return a map from token index to operation.</span>
<a name="l02323"></a>02323     <span class="comment">#         </span>
<a name="l02324"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d84a6342573b28f0fe78cb1ba554b021">02324</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#d84a6342573b28f0fe78cb1ba554b021" title="We need to combine operations and report invalid operations (like overlapping replaces...">reduceToSingleOperationPerIndex</a>(self, rewrites):
<a name="l02325"></a>02325         
<a name="l02326"></a>02326         <span class="comment"># WALK REPLACES</span>
<a name="l02327"></a>02327         <span class="keywordflow">for</span> i, rop <span class="keywordflow">in</span> enumerate(rewrites):
<a name="l02328"></a>02328             <span class="keywordflow">if</span> rop <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02329"></a>02329                 <span class="keywordflow">continue</span>
<a name="l02330"></a>02330 
<a name="l02331"></a>02331             <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(rop, ReplaceOp):
<a name="l02332"></a>02332                 <span class="keywordflow">continue</span>
<a name="l02333"></a>02333 
<a name="l02334"></a>02334             <span class="comment"># Wipe prior inserts within range</span>
<a name="l02335"></a>02335             <span class="keywordflow">for</span> j, iop <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#1ee79bb7a45cca1097a18b6bd055a54c">getKindOfOps</a>(rewrites, InsertBeforeOp, i):
<a name="l02336"></a>02336                 <span class="keywordflow">if</span> iop.index &gt;= rop.index <span class="keywordflow">and</span> iop.index &lt;= rop.lastIndex:
<a name="l02337"></a>02337                     rewrites[j] = <span class="keywordtype">None</span>  <span class="comment"># delete insert as it's a no-op.</span>
<a name="l02338"></a>02338 
<a name="l02339"></a>02339             <span class="comment"># Drop any prior replaces contained within</span>
<a name="l02340"></a>02340             <span class="keywordflow">for</span> j, prevRop <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#1ee79bb7a45cca1097a18b6bd055a54c">getKindOfOps</a>(rewrites, ReplaceOp, i):
<a name="l02341"></a>02341                 <span class="keywordflow">if</span> (prevRop.index &gt;= rop.index
<a name="l02342"></a>02342                     <span class="keywordflow">and</span> prevRop.lastIndex &lt;= rop.lastIndex):
<a name="l02343"></a>02343                     rewrites[j] = <span class="keywordtype">None</span>  <span class="comment"># delete replace as it's a no-op.</span>
<a name="l02344"></a>02344                     <span class="keywordflow">continue</span>
<a name="l02345"></a>02345 
<a name="l02346"></a>02346                 <span class="comment"># throw exception unless disjoint or identical</span>
<a name="l02347"></a>02347                 disjoint = (prevRop.lastIndex &lt; rop.index
<a name="l02348"></a>02348                             <span class="keywordflow">or</span> prevRop.index &gt; rop.lastIndex)
<a name="l02349"></a>02349                 same = (prevRop.index == rop.index
<a name="l02350"></a>02350                         <span class="keywordflow">and</span> prevRop.lastIndex == rop.lastIndex)
<a name="l02351"></a>02351                 <span class="keywordflow">if</span> <span class="keywordflow">not</span> disjoint <span class="keywordflow">and</span> <span class="keywordflow">not</span> same:
<a name="l02352"></a>02352                     <span class="keywordflow">raise</span> ValueError(
<a name="l02353"></a>02353                         <span class="stringliteral">"replace op boundaries of %s overlap with previous %s"</span>
<a name="l02354"></a>02354                         % (rop, prevRop))
<a name="l02355"></a>02355 
<a name="l02356"></a>02356         <span class="comment"># WALK INSERTS</span>
<a name="l02357"></a>02357         <span class="keywordflow">for</span> i, iop <span class="keywordflow">in</span> enumerate(rewrites):
<a name="l02358"></a>02358             <span class="keywordflow">if</span> iop <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02359"></a>02359                 <span class="keywordflow">continue</span>
<a name="l02360"></a>02360 
<a name="l02361"></a>02361             <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(iop, InsertBeforeOp):
<a name="l02362"></a>02362                 <span class="keywordflow">continue</span>
<a name="l02363"></a>02363 
<a name="l02364"></a>02364             <span class="comment"># combine current insert with prior if any at same index</span>
<a name="l02365"></a>02365             <span class="keywordflow">for</span> j, prevIop <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#1ee79bb7a45cca1097a18b6bd055a54c">getKindOfOps</a>(rewrites, InsertBeforeOp, i):
<a name="l02366"></a>02366                 <span class="keywordflow">if</span> prevIop.index == iop.index: <span class="comment"># combine objects</span>
<a name="l02367"></a>02367                     <span class="comment"># convert to strings...we're in process of toString'ing</span>
<a name="l02368"></a>02368                     <span class="comment"># whole token buffer so no lazy eval issue with any</span>
<a name="l02369"></a>02369                     <span class="comment"># templates</span>
<a name="l02370"></a>02370                     iop.text = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#9370e95b1937fdf6bcd1f91ecdb06530">catOpText</a>(iop.text, prevIop.text)
<a name="l02371"></a>02371                     rewrites[j] = <span class="keywordtype">None</span>  <span class="comment"># delete redundant prior insert</span>
<a name="l02372"></a>02372 
<a name="l02373"></a>02373             <span class="comment"># look for replaces where iop.index is in range; error</span>
<a name="l02374"></a>02374             <span class="keywordflow">for</span> j, rop <span class="keywordflow">in</span> self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#1ee79bb7a45cca1097a18b6bd055a54c">getKindOfOps</a>(rewrites, ReplaceOp, i):
<a name="l02375"></a>02375                 <span class="keywordflow">if</span> iop.index == rop.index:
<a name="l02376"></a>02376                     rop.text = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#9370e95b1937fdf6bcd1f91ecdb06530">catOpText</a>(iop.text, rop.text)
<a name="l02377"></a>02377                     rewrites[i] = <span class="keywordtype">None</span>  <span class="comment"># delete current insert</span>
<a name="l02378"></a>02378                     <span class="keywordflow">continue</span>
<a name="l02379"></a>02379 
<a name="l02380"></a>02380                 <span class="keywordflow">if</span> iop.index &gt;= rop.index <span class="keywordflow">and</span> iop.index &lt;= rop.lastIndex:
<a name="l02381"></a>02381                     <span class="keywordflow">raise</span> ValueError(
<a name="l02382"></a>02382                         <span class="stringliteral">"insert op %s within boundaries of previous %s"</span>
<a name="l02383"></a>02383                         % (iop, rop))
<a name="l02384"></a>02384         
<a name="l02385"></a>02385         m = {}
<a name="l02386"></a>02386         <span class="keywordflow">for</span> i, op <span class="keywordflow">in</span> enumerate(rewrites):
<a name="l02387"></a>02387             <span class="keywordflow">if</span> op <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02388"></a>02388                 <span class="keywordflow">continue</span> <span class="comment"># ignore deleted ops</span>
<a name="l02389"></a>02389 
<a name="l02390"></a>02390             <span class="keyword">assert</span> op.index <span class="keywordflow">not</span> <span class="keywordflow">in</span> m, <span class="stringliteral">"should only be one op per index"</span>
<a name="l02391"></a>02391             m[op.index] = op
<a name="l02392"></a>02392 
<a name="l02393"></a>02393         <span class="keywordflow">return</span> m
<a name="l02394"></a>02394 
<a name="l02395"></a>02395 
<a name="l02396"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#9370e95b1937fdf6bcd1f91ecdb06530">02396</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#9370e95b1937fdf6bcd1f91ecdb06530">catOpText</a>(self, a, b):
<a name="l02397"></a>02397         x = <span class="stringliteral">""</span>
<a name="l02398"></a>02398         y = <span class="stringliteral">""</span>
<a name="l02399"></a>02399         <span class="keywordflow">if</span> a <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l02400"></a>02400             x = a
<a name="l02401"></a>02401         <span class="keywordflow">if</span> b <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l02402"></a>02402             y = b
<a name="l02403"></a>02403         <span class="keywordflow">return</span> x + y
<a name="l02404"></a>02404 
<a name="l02405"></a>02405 
<a name="l02406"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#1ee79bb7a45cca1097a18b6bd055a54c">02406</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#1ee79bb7a45cca1097a18b6bd055a54c">getKindOfOps</a>(self, rewrites, kind, before=None):
<a name="l02407"></a>02407         <span class="keywordflow">if</span> before <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02408"></a>02408             before = len(rewrites)
<a name="l02409"></a>02409         <span class="keywordflow">elif</span> before &gt; len(rewrites):
<a name="l02410"></a>02410             before = len(rewrites)
<a name="l02411"></a>02411 
<a name="l02412"></a>02412         <span class="keywordflow">for</span> i, op <span class="keywordflow">in</span> enumerate(rewrites[:before]):
<a name="l02413"></a>02413             <span class="keywordflow">if</span> op <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02414"></a>02414                 <span class="comment"># ignore deleted</span>
<a name="l02415"></a>02415                 <span class="keywordflow">continue</span>
<a name="l02416"></a>02416             <span class="keywordflow">if</span> op.__class__ == kind:
<a name="l02417"></a>02417                 <span class="keywordflow">yield</span> i, op
<a name="l02418"></a>02418 
<a name="l02419"></a>02419 
<a name="l02420"></a><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#e98ce92ef2d20919d58157e1cbb95515">02420</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_rewrite_stream.html#e98ce92ef2d20919d58157e1cbb95515">toDebugString</a>(self, start=None, end=None):
<a name="l02421"></a>02421         <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02422"></a>02422             start = self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a>
<a name="l02423"></a>02423         <span class="keywordflow">if</span> end <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02424"></a>02424             end = self.size() - 1
<a name="l02425"></a>02425 
<a name="l02426"></a>02426         buf = StringIO()
<a name="l02427"></a>02427         i = start
<a name="l02428"></a>02428         <span class="keywordflow">while</span> i &gt;= self.<a class="code" href="classantlr3_1_1_token_rewrite_stream.html#422c887ca04c05773792c23669a3fa52">MIN_TOKEN_INDEX</a> <span class="keywordflow">and</span> i &lt;= end <span class="keywordflow">and</span> i &lt; len(self.tokens):
<a name="l02429"></a>02429             buf.write(self.get(i))
<a name="l02430"></a>02430             i += 1
<a name="l02431"></a>02431 
<a name="l02432"></a>02432         <span class="keywordflow">return</span> buf.getvalue()
<a name="l02433"></a>02433 <span class="stringliteral">"""ANTLR3 runtime package"""</span>
<a name="l02434"></a>02434 
<a name="l02435"></a>02435 
<a name="l02436"></a>02436 <span class="keyword">import</span> sys
<a name="l02437"></a>02437 <span class="keyword">import</span> inspect
<a name="l02438"></a>02438 
<a name="l02439"></a>02439 <span class="keyword">from</span> antlr3 <span class="keyword">import</span> runtime_version, runtime_version_str
<a name="l02440"></a>02440 <span class="keyword">from</span> antlr3.constants <span class="keyword">import</span> DEFAULT_CHANNEL, HIDDEN_CHANNEL, EOF, \
<a name="l02441"></a>02441      EOR_TOKEN_TYPE, INVALID_TOKEN_TYPE
<a name="l02442"></a>02442 <span class="keyword">from</span> antlr3.exceptions <span class="keyword">import</span> RecognitionException, MismatchedTokenException, \
<a name="l02443"></a>02443      MismatchedRangeException, MismatchedTreeNodeException, \
<a name="l02444"></a>02444      NoViableAltException, EarlyExitException, MismatchedSetException, \
<a name="l02445"></a>02445      MismatchedNotSetException, FailedPredicateException, \
<a name="l02446"></a>02446      BacktrackingFailed, UnwantedTokenException, MissingTokenException
<a name="l02447"></a>02447 <span class="keyword">from</span> antlr3.tokens <span class="keyword">import</span> CommonToken, EOF_TOKEN, SKIP_TOKEN
<a name="l02448"></a>02448 <span class="keyword">from</span> antlr3.compat <span class="keyword">import</span> set, frozenset, reversed
<a name="l02449"></a>02449 
<a name="l02450"></a>02450 
<a name="l02451"></a>02451 <span class="comment">##</span>
<a name="l02452"></a>02452 <span class="comment"># </span>
<a name="l02453"></a>02453 <span class="comment">#     The set of fields needed by an abstract recognizer to recognize input</span>
<a name="l02454"></a>02454 <span class="comment">#     and recover from errors etc...  As a separate state object, it can be</span>
<a name="l02455"></a>02455 <span class="comment">#     shared among multiple grammars; e.g., when one grammar imports another.</span>
<a name="l02456"></a>02456 <span class="comment"># </span>
<a name="l02457"></a>02457 <span class="comment">#     These fields are publically visible but the actual state pointer per</span>
<a name="l02458"></a>02458 <span class="comment">#     parser is protected.</span>
<a name="l02459"></a>02459 <span class="comment">#     </span>
<a name="l02460"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html">02460</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_recognizer_shared_state.html" title="The set of fields needed by an abstract recognizer to recognize input and recover...">RecognizerSharedState</a>(object):
<a name="l02461"></a>02461 
<a name="l02462"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#f8f1d90d8a9cfd89dcad472579f5c022">02462</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#f8f1d90d8a9cfd89dcad472579f5c022">__init__</a>(self):
<a name="l02463"></a>02463         <span class="comment"># Track the set of token types that can follow any rule invocation.</span>
<a name="l02464"></a>02464         <span class="comment"># Stack grows upwards.</span>
<a name="l02465"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#bdb61a954c7ca2b0e745bc456b67912f">02465</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#bdb61a954c7ca2b0e745bc456b67912f">following</a> = []
<a name="l02466"></a>02466 
<a name="l02467"></a>02467         <span class="comment"># This is true when we see an error and before having successfully</span>
<a name="l02468"></a>02468         <span class="comment"># matched a token.  Prevents generation of more than one error message</span>
<a name="l02469"></a>02469         <span class="comment"># per error.</span>
<a name="l02470"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#a833962304df5156f3317cfa4662446c">02470</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#a833962304df5156f3317cfa4662446c">errorRecovery</a> = <span class="keyword">False</span>
<a name="l02471"></a>02471 
<a name="l02472"></a>02472         <span class="comment"># The index into the input stream where the last error occurred.</span>
<a name="l02473"></a>02473         <span class="comment"># This is used to prevent infinite loops where an error is found</span>
<a name="l02474"></a>02474         <span class="comment"># but no token is consumed during recovery...another error is found,</span>
<a name="l02475"></a>02475         <span class="comment"># ad naseum.  This is a failsafe mechanism to guarantee that at least</span>
<a name="l02476"></a>02476         <span class="comment"># one token/tree node is consumed for two errors.</span>
<a name="l02477"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#9d623e78ad32881933bf8424ddc707f4">02477</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#9d623e78ad32881933bf8424ddc707f4">lastErrorIndex</a> = -1
<a name="l02478"></a>02478 
<a name="l02479"></a>02479         <span class="comment"># If 0, no backtracking is going on.  Safe to exec actions etc...</span>
<a name="l02480"></a>02480         <span class="comment"># If &gt;0 then it's the level of backtracking.</span>
<a name="l02481"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#0f60b528b1e6691e1d8f2f67654a279d">02481</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#0f60b528b1e6691e1d8f2f67654a279d">backtracking</a> = 0
<a name="l02482"></a>02482 
<a name="l02483"></a>02483         <span class="comment"># An array[size num rules] of Map&lt;Integer,Integer&gt; that tracks</span>
<a name="l02484"></a>02484         <span class="comment"># the stop token index for each rule.  ruleMemo[ruleIndex] is</span>
<a name="l02485"></a>02485         <span class="comment"># the memoization table for ruleIndex.  For key ruleStartIndex, you</span>
<a name="l02486"></a>02486         <span class="comment"># get back the stop token for associated rule or MEMO_RULE_FAILED.</span>
<a name="l02487"></a>02487         <span class="comment">#</span>
<a name="l02488"></a>02488         <span class="comment"># This is only used if rule memoization is on (which it is by default).</span>
<a name="l02489"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#35317f48ba60320e2233795bb75ff9f4">02489</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#35317f48ba60320e2233795bb75ff9f4">ruleMemo</a> = <span class="keywordtype">None</span>
<a name="l02490"></a>02490 
<a name="l02491"></a>02491         <span class="comment">## Did the recognizer encounter a syntax error?  Track how many.</span>
<a name="l02492"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#fb3cf269a550fc47b2c763e5d3ab5742">02492</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#fb3cf269a550fc47b2c763e5d3ab5742" title="Did the recognizer encounter a syntax error? Track how many.">syntaxErrors</a> = 0
<a name="l02493"></a>02493 
<a name="l02494"></a>02494 
<a name="l02495"></a>02495         <span class="comment"># LEXER FIELDS (must be in same state object to avoid casting</span>
<a name="l02496"></a>02496         <span class="comment"># constantly in generated code and Lexer object) :(</span>
<a name="l02497"></a>02497 
<a name="l02498"></a>02498 
<a name="l02499"></a>02499         <span class="comment">## The goal of all lexer rules/methods is to create a token object.</span>
<a name="l02500"></a>02500         <span class="comment"># This is an instance variable as multiple rules may collaborate to</span>
<a name="l02501"></a>02501         <span class="comment"># create a single token.  nextToken will return this object after</span>
<a name="l02502"></a>02502         <span class="comment"># matching lexer rule(s).  If you subclass to allow multiple token</span>
<a name="l02503"></a>02503         <span class="comment"># emissions, then set this to the last token to be matched or</span>
<a name="l02504"></a>02504         <span class="comment"># something nonnull so that the auto token emit mechanism will not</span>
<a name="l02505"></a>02505         <span class="comment"># emit another token.</span>
<a name="l02506"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#b4952fc4d0b9533b74cfb9a05edc8d54">02506</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#b4952fc4d0b9533b74cfb9a05edc8d54" title="The goal of all lexer rules/methods is to create a token object.">token</a> = <span class="keywordtype">None</span>
<a name="l02507"></a>02507 
<a name="l02508"></a>02508         <span class="comment">## What character index in the stream did the current token start at?</span>
<a name="l02509"></a>02509         <span class="comment"># Needed, for example, to get the text for current token.  Set at</span>
<a name="l02510"></a>02510         <span class="comment"># the start of nextToken.</span>
<a name="l02511"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#700e2d43a2ea894d90f5dd145a0f1813">02511</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#700e2d43a2ea894d90f5dd145a0f1813" title="What character index in the stream did the current token start at? Needed, for example...">tokenStartCharIndex</a> = -1
<a name="l02512"></a>02512 
<a name="l02513"></a>02513         <span class="comment">## The line on which the first character of the token resides</span>
<a name="l02514"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#bcaa75d7cbe620a0ed19ac654c27f58b">02514</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#bcaa75d7cbe620a0ed19ac654c27f58b" title="The line on which the first character of the token resides.">tokenStartLine</a> = <span class="keywordtype">None</span>
<a name="l02515"></a>02515 
<a name="l02516"></a>02516         <span class="comment">## The character position of first character within the line</span>
<a name="l02517"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#3ead978fb7a5465b6a13dce91aff2161">02517</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#3ead978fb7a5465b6a13dce91aff2161" title="The character position of first character within the line.">tokenStartCharPositionInLine</a> = <span class="keywordtype">None</span>
<a name="l02518"></a>02518 
<a name="l02519"></a>02519         <span class="comment">## The channel number for the current token</span>
<a name="l02520"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#e1429cc38d76457e6f7dfdd0a8284dd7">02520</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#e1429cc38d76457e6f7dfdd0a8284dd7" title="The channel number for the current token.">channel</a> = <span class="keywordtype">None</span>
<a name="l02521"></a>02521 
<a name="l02522"></a>02522         <span class="comment">## The token type for the current token</span>
<a name="l02523"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#841f4d89ae07ac03f68e560ac9fffe52">02523</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#841f4d89ae07ac03f68e560ac9fffe52" title="The token type for the current token.">type</a> = <span class="keywordtype">None</span>
<a name="l02524"></a>02524 
<a name="l02525"></a>02525         <span class="comment">## You can set the text for the current token to override what is in</span>
<a name="l02526"></a>02526         <span class="comment"># the input char buffer.  Use setText() or can set this instance var.</span>
<a name="l02527"></a><a class="code" href="classantlr3_1_1_recognizer_shared_state.html#9f4581ed16f42e87e8e2868a73e57ec4">02527</a>         self.<a class="code" href="classantlr3_1_1_recognizer_shared_state.html#9f4581ed16f42e87e8e2868a73e57ec4" title="You can set the text for the current token to override what is in the input char...">text</a> = <span class="keywordtype">None</span>
<a name="l02528"></a>02528         
<a name="l02529"></a>02529 
<a name="l02530"></a>02530 <span class="comment">##</span>
<a name="l02531"></a>02531 <span class="comment"># </span>
<a name="l02532"></a>02532 <span class="comment">#     @brief Common recognizer functionality.</span>
<a name="l02533"></a>02533 <span class="comment">#     </span>
<a name="l02534"></a>02534 <span class="comment">#     A generic recognizer that can handle recognizers generated from</span>
<a name="l02535"></a>02535 <span class="comment">#     lexer, parser, and tree grammars.  This is all the parsing</span>
<a name="l02536"></a>02536 <span class="comment">#     support code essentially; most of it is error recovery stuff and</span>
<a name="l02537"></a>02537 <span class="comment">#     backtracking.</span>
<a name="l02538"></a>02538 <span class="comment">#     </span>
<a name="l02539"></a><a class="code" href="classantlr3_1_1_base_recognizer.html">02539</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_base_recognizer.html" title="Common recognizer functionality.">BaseRecognizer</a>(object):
<a name="l02540"></a>02540 
<a name="l02541"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#7716ad8c2dabc1d27930d35c4d5cca82">02541</a>     MEMO_RULE_FAILED = -2
<a name="l02542"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#298a281766cd5ae121b002e4a3ac6183">02542</a>     MEMO_RULE_UNKNOWN = -1
<a name="l02543"></a>02543 
<a name="l02544"></a>02544     <span class="comment"># copies from Token object for convenience in actions</span>
<a name="l02545"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#fe4dc7666fb2620610c3c732c1b93ba3">02545</a>     DEFAULT_TOKEN_CHANNEL = DEFAULT_CHANNEL
<a name="l02546"></a>02546 
<a name="l02547"></a>02547     <span class="comment"># for convenience in actions</span>
<a name="l02548"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#d1014502291224c13fc5c5286e637329">02548</a>     HIDDEN = HIDDEN_CHANNEL
<a name="l02549"></a>02549 
<a name="l02550"></a>02550     <span class="comment"># overridden by generated subclasses</span>
<a name="l02551"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">02551</a>     tokenNames = <span class="keywordtype">None</span>
<a name="l02552"></a>02552 
<a name="l02553"></a>02553     <span class="comment"># The antlr_version attribute has been introduced in 3.1. If it is not</span>
<a name="l02554"></a>02554     <span class="comment"># overwritten in the generated recognizer, we assume a default of 3.0.1.</span>
<a name="l02555"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#3fc337642c5c82dec1b606bf98e6bad6">02555</a>     antlr_version = (3, 0, 1, 0)
<a name="l02556"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">02556</a>     antlr_version_str = <span class="stringliteral">"3.0.1"</span>
<a name="l02557"></a>02557 
<a name="l02558"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#9148800758baf2f1c6437fc25437401b">02558</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#9148800758baf2f1c6437fc25437401b">__init__</a>(self, state=None):
<a name="l02559"></a>02559         <span class="comment"># Input stream of the recognizer. Must be initialized by a subclass.</span>
<a name="l02560"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">02560</a>         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">input</a> = <span class="keywordtype">None</span>
<a name="l02561"></a>02561 
<a name="l02562"></a>02562         <span class="comment">## State of a lexer, parser, or tree parser are collected into a state</span>
<a name="l02563"></a>02563         <span class="comment"># object so the state can be shared.  This sharing is needed to</span>
<a name="l02564"></a>02564         <span class="comment"># have one grammar import others and share same error variables</span>
<a name="l02565"></a>02565         <span class="comment"># and other state variables.  It's a kind of explicit multiple</span>
<a name="l02566"></a>02566         <span class="comment"># inheritance via delegation of methods and shared state.</span>
<a name="l02567"></a>02567         <span class="keywordflow">if</span> state <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02568"></a>02568             state = RecognizerSharedState()
<a name="l02569"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea">02569</a>         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a> = state
<a name="l02570"></a>02570 
<a name="l02571"></a>02571         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#3fc337642c5c82dec1b606bf98e6bad6">antlr_version</a> &gt; runtime_version:
<a name="l02572"></a>02572             <span class="keywordflow">raise</span> RuntimeError(
<a name="l02573"></a>02573                 <span class="stringliteral">"ANTLR version mismatch: "</span>
<a name="l02574"></a>02574                 <span class="stringliteral">"The recognizer has been generated by V%s, but this runtime "</span>
<a name="l02575"></a>02575                 <span class="stringliteral">"is V%s. Please use the V%s runtime or higher."</span>
<a name="l02576"></a>02576                 % (self.<a class="code" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">antlr_version_str</a>,
<a name="l02577"></a>02577                    runtime_version_str,
<a name="l02578"></a>02578                    self.<a class="code" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">antlr_version_str</a>))
<a name="l02579"></a>02579         <span class="keywordflow">elif</span> (self.<a class="code" href="classantlr3_1_1_base_recognizer.html#3fc337642c5c82dec1b606bf98e6bad6">antlr_version</a> &lt; (3, 1, 0, 0) <span class="keywordflow">and</span>
<a name="l02580"></a>02580               self.<a class="code" href="classantlr3_1_1_base_recognizer.html#3fc337642c5c82dec1b606bf98e6bad6">antlr_version</a> != runtime_version):
<a name="l02581"></a>02581             <span class="comment"># FIXME: make the runtime compatible with 3.0.1 codegen</span>
<a name="l02582"></a>02582             <span class="comment"># and remove this block.</span>
<a name="l02583"></a>02583             <span class="keywordflow">raise</span> RuntimeError(
<a name="l02584"></a>02584                 <span class="stringliteral">"ANTLR version mismatch: "</span>
<a name="l02585"></a>02585                 <span class="stringliteral">"The recognizer has been generated by V%s, but this runtime "</span>
<a name="l02586"></a>02586                 <span class="stringliteral">"is V%s. Please use the V%s runtime."</span>
<a name="l02587"></a>02587                 % (self.<a class="code" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">antlr_version_str</a>,
<a name="l02588"></a>02588                    runtime_version_str,
<a name="l02589"></a>02589                    self.<a class="code" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">antlr_version_str</a>))
<a name="l02590"></a>02590 
<a name="l02591"></a>02591     <span class="comment"># this one only exists to shut up pylint :(</span>
<a name="l02592"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#4c08864d687c878069223a2f351b10ae">02592</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#4c08864d687c878069223a2f351b10ae">setInput</a>(self, input):
<a name="l02593"></a>02593         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">input</a> = input
<a name="l02594"></a>02594 
<a name="l02595"></a>02595         
<a name="l02596"></a>02596     <span class="comment">##</span>
<a name="l02597"></a>02597     <span class="comment"># </span>
<a name="l02598"></a>02598     <span class="comment">#         reset the parser's state; subclasses must rewinds the input stream</span>
<a name="l02599"></a>02599     <span class="comment">#         </span>
<a name="l02600"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#56f0125d72c7d27cf75ad122ae7fbbf7">02600</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#56f0125d72c7d27cf75ad122ae7fbbf7" title="reset the parser&amp;#39;s state; subclasses must rewinds the input stream">reset</a>(self):
<a name="l02601"></a>02601         
<a name="l02602"></a>02602         <span class="comment"># wack everything related to error recovery</span>
<a name="l02603"></a>02603         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a> <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02604"></a>02604             <span class="comment"># no shared state work to do</span>
<a name="l02605"></a>02605             <span class="keywordflow">return</span>
<a name="l02606"></a>02606         
<a name="l02607"></a>02607         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.following = []
<a name="l02608"></a>02608         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.errorRecovery = <span class="keyword">False</span>
<a name="l02609"></a>02609         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.lastErrorIndex = -1
<a name="l02610"></a>02610         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.syntaxErrors = 0
<a name="l02611"></a>02611         <span class="comment"># wack everything related to backtracking and memoization</span>
<a name="l02612"></a>02612         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.backtracking = 0
<a name="l02613"></a>02613         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.ruleMemo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l02614"></a>02614             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.ruleMemo = {}
<a name="l02615"></a>02615 
<a name="l02616"></a>02616 
<a name="l02617"></a>02617     <span class="comment">##</span>
<a name="l02618"></a>02618     <span class="comment"># </span>
<a name="l02619"></a>02619     <span class="comment">#         Match current input symbol against ttype.  Attempt</span>
<a name="l02620"></a>02620     <span class="comment">#         single token insertion or deletion error recovery.  If</span>
<a name="l02621"></a>02621     <span class="comment">#         that fails, throw MismatchedTokenException.</span>
<a name="l02622"></a>02622     <span class="comment"># </span>
<a name="l02623"></a>02623     <span class="comment">#         To turn off single token insertion or deletion error</span>
<a name="l02624"></a>02624     <span class="comment">#         recovery, override recoverFromMismatchedToken() and have it</span>
<a name="l02625"></a>02625     <span class="comment">#         throw an exception. See TreeParser.recoverFromMismatchedToken().</span>
<a name="l02626"></a>02626     <span class="comment">#         This way any error in a rule will cause an exception and</span>
<a name="l02627"></a>02627     <span class="comment">#         immediate exit from rule.  Rule would recover by resynchronizing</span>
<a name="l02628"></a>02628     <span class="comment">#         to the set of symbols that can follow rule ref.</span>
<a name="l02629"></a>02629     <span class="comment">#         </span>
<a name="l02630"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7">02630</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7" title="Match current input symbol against ttype.">match</a>(self, input, ttype, follow):
<a name="l02631"></a>02631         
<a name="l02632"></a>02632         matchedSymbol = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#2c908793a6c88fdf53a227fa7480c407" title="Match needs to return the current input symbol, which gets put into the label for...">getCurrentInputSymbol</a>(input)
<a name="l02633"></a>02633         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">input</a>.LA(1) == ttype:
<a name="l02634"></a>02634             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">input</a>.consume()
<a name="l02635"></a>02635             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.errorRecovery = <span class="keyword">False</span>
<a name="l02636"></a>02636             <span class="keywordflow">return</span> matchedSymbol
<a name="l02637"></a>02637 
<a name="l02638"></a>02638         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.backtracking &gt; 0:
<a name="l02639"></a>02639             <span class="comment"># FIXME: need to return matchedSymbol here as well. damn!!</span>
<a name="l02640"></a>02640             <span class="keywordflow">raise</span> BacktrackingFailed
<a name="l02641"></a>02641 
<a name="l02642"></a>02642         matchedSymbol = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#6866fbb79a115e58c949834ace5bba17" title="Attempt to recover from a single missing or extra token.">recoverFromMismatchedToken</a>(input, ttype, follow)
<a name="l02643"></a>02643         <span class="keywordflow">return</span> matchedSymbol
<a name="l02644"></a>02644 
<a name="l02645"></a>02645 
<a name="l02646"></a>02646     <span class="comment">##</span>
<a name="l02647"></a>02647     <span class="comment"># Match the wildcard: in a symbol</span>
<a name="l02648"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#44e9115eae6b5f11ca09bdc170928382">02648</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#44e9115eae6b5f11ca09bdc170928382" title="Match the wildcard: in a symbol.">matchAny</a>(self, input):
<a name="l02649"></a>02649 
<a name="l02650"></a>02650         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.errorRecovery = <span class="keyword">False</span>
<a name="l02651"></a>02651         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">input</a>.consume()
<a name="l02652"></a>02652 
<a name="l02653"></a>02653 
<a name="l02654"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#7a44a211c8f34a5743a72da0b373a74e">02654</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#7a44a211c8f34a5743a72da0b373a74e">mismatchIsUnwantedToken</a>(self, input, ttype):
<a name="l02655"></a>02655         <span class="keywordflow">return</span> input.LA(2) == ttype
<a name="l02656"></a>02656 
<a name="l02657"></a>02657 
<a name="l02658"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#2482f7bff153e1ccc1ed218e5172c870">02658</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#2482f7bff153e1ccc1ed218e5172c870">mismatchIsMissingToken</a>(self, input, follow):
<a name="l02659"></a>02659         <span class="keywordflow">if</span> follow <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02660"></a>02660             <span class="comment"># we have no information about the follow; we can only consume</span>
<a name="l02661"></a>02661             <span class="comment"># a single token and hope for the best</span>
<a name="l02662"></a>02662             <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l02663"></a>02663         
<a name="l02664"></a>02664         <span class="comment"># compute what can follow this grammar element reference</span>
<a name="l02665"></a>02665         <span class="keywordflow">if</span> EOR_TOKEN_TYPE <span class="keywordflow">in</span> follow:
<a name="l02666"></a>02666             viableTokensFollowingThisRule = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#b3dd7de1dc6760f5f634ed996c5a6769" title="Compute the context-sensitive FOLLOW set for current rule.">computeContextSensitiveRuleFOLLOW</a>()
<a name="l02667"></a>02667             follow = follow | viableTokensFollowingThisRule
<a name="l02668"></a>02668 
<a name="l02669"></a>02669             <span class="keywordflow">if</span> len(self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.following) &gt; 0:
<a name="l02670"></a>02670                 <span class="comment"># remove EOR if we're not the start symbol</span>
<a name="l02671"></a>02671                 follow = follow - set([EOR_TOKEN_TYPE])
<a name="l02672"></a>02672 
<a name="l02673"></a>02673         <span class="comment"># if current token is consistent with what could come after set</span>
<a name="l02674"></a>02674         <span class="comment"># then we know we're missing a token; error recovery is free to</span>
<a name="l02675"></a>02675         <span class="comment"># "insert" the missing token</span>
<a name="l02676"></a>02676         <span class="keywordflow">if</span> input.LA(1) <span class="keywordflow">in</span> follow <span class="keywordflow">or</span> EOR_TOKEN_TYPE <span class="keywordflow">in</span> follow:
<a name="l02677"></a>02677             <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l02678"></a>02678 
<a name="l02679"></a>02679         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l02680"></a>02680 
<a name="l02681"></a>02681 
<a name="l02682"></a>02682     <span class="comment">##</span>
<a name="l02683"></a>02683     <span class="comment"># Report a recognition problem.</span>
<a name="l02684"></a>02684     <span class="comment">#             </span>
<a name="l02685"></a>02685     <span class="comment">#         This method sets errorRecovery to indicate the parser is recovering</span>
<a name="l02686"></a>02686     <span class="comment">#         not parsing.  Once in recovery mode, no errors are generated.</span>
<a name="l02687"></a>02687     <span class="comment">#         To get out of recovery mode, the parser must successfully match</span>
<a name="l02688"></a>02688     <span class="comment">#         a token (after a resync).  So it will go:</span>
<a name="l02689"></a>02689     <span class="comment"># </span>
<a name="l02690"></a>02690     <span class="comment">#         1. error occurs</span>
<a name="l02691"></a>02691     <span class="comment">#         2. enter recovery mode, report error</span>
<a name="l02692"></a>02692     <span class="comment">#         3. consume until token found in resynch set</span>
<a name="l02693"></a>02693     <span class="comment">#         4. try to resume parsing</span>
<a name="l02694"></a>02694     <span class="comment">#         5. next match() will reset errorRecovery mode</span>
<a name="l02695"></a>02695     <span class="comment"># </span>
<a name="l02696"></a>02696     <span class="comment">#         If you override, make sure to update syntaxErrors if you care about</span>
<a name="l02697"></a>02697     <span class="comment">#         that.</span>
<a name="l02698"></a>02698     <span class="comment">#         </span>
<a name="l02699"></a>02699     <span class="comment">#         </span>
<a name="l02700"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c">02700</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c" title="Report a recognition problem.">reportError</a>(self, e):
<a name="l02701"></a>02701         
<a name="l02702"></a>02702         <span class="comment"># if we've already reported an error and have not matched a token</span>
<a name="l02703"></a>02703         <span class="comment"># yet successfully, don't report any errors.</span>
<a name="l02704"></a>02704         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.errorRecovery:
<a name="l02705"></a>02705             <span class="keywordflow">return</span>
<a name="l02706"></a>02706 
<a name="l02707"></a>02707         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.syntaxErrors += 1 <span class="comment"># don't count spurious</span>
<a name="l02708"></a>02708         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.errorRecovery = <span class="keyword">True</span>
<a name="l02709"></a>02709 
<a name="l02710"></a>02710         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#a295e906ee74022cfb0b72b2c56e9f62">displayRecognitionError</a>(self.<a class="code" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">tokenNames</a>, e)
<a name="l02711"></a>02711 
<a name="l02712"></a>02712 
<a name="l02713"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#a295e906ee74022cfb0b72b2c56e9f62">02713</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#a295e906ee74022cfb0b72b2c56e9f62">displayRecognitionError</a>(self, tokenNames, e):
<a name="l02714"></a>02714         hdr = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#c4497e12036221ace01fdc201d23f8a6" title="What is the error header, normally line/character position information?">getErrorHeader</a>(e)
<a name="l02715"></a>02715         msg = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#3de2a2bc49b21d7d78944d1203aa22c1" title="What error message should be generated for the various exception types?">getErrorMessage</a>(e, tokenNames)
<a name="l02716"></a>02716         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#c4841ded6b308a3f3c48c5b2d3c749d7" title="Override this method to change where error messages go.">emitErrorMessage</a>(hdr+<span class="stringliteral">" "</span>+msg)
<a name="l02717"></a>02717 
<a name="l02718"></a>02718 
<a name="l02719"></a>02719     <span class="comment">##</span>
<a name="l02720"></a>02720     <span class="comment"># </span>
<a name="l02721"></a>02721     <span class="comment">#         What error message should be generated for the various</span>
<a name="l02722"></a>02722     <span class="comment">#         exception types?</span>
<a name="l02723"></a>02723     <span class="comment">#         </span>
<a name="l02724"></a>02724     <span class="comment">#         Not very object-oriented code, but I like having all error message</span>
<a name="l02725"></a>02725     <span class="comment">#         generation within one method rather than spread among all of the</span>
<a name="l02726"></a>02726     <span class="comment">#         exception classes. This also makes it much easier for the exception</span>
<a name="l02727"></a>02727     <span class="comment">#         handling because the exception classes do not have to have pointers back</span>
<a name="l02728"></a>02728     <span class="comment">#         to this object to access utility routines and so on. Also, changing</span>
<a name="l02729"></a>02729     <span class="comment">#         the message for an exception type would be difficult because you</span>
<a name="l02730"></a>02730     <span class="comment">#         would have to subclassing exception, but then somehow get ANTLR</span>
<a name="l02731"></a>02731     <span class="comment">#         to make those kinds of exception objects instead of the default.</span>
<a name="l02732"></a>02732     <span class="comment">#         This looks weird, but trust me--it makes the most sense in terms</span>
<a name="l02733"></a>02733     <span class="comment">#         of flexibility.</span>
<a name="l02734"></a>02734     <span class="comment"># </span>
<a name="l02735"></a>02735     <span class="comment">#         For grammar debugging, you will want to override this to add</span>
<a name="l02736"></a>02736     <span class="comment">#         more information such as the stack frame with</span>
<a name="l02737"></a>02737     <span class="comment">#         getRuleInvocationStack(e, this.getClass().getName()) and,</span>
<a name="l02738"></a>02738     <span class="comment">#         for no viable alts, the decision description and state etc...</span>
<a name="l02739"></a>02739     <span class="comment"># </span>
<a name="l02740"></a>02740     <span class="comment">#         Override this to change the message generated for one or more</span>
<a name="l02741"></a>02741     <span class="comment">#         exception types.</span>
<a name="l02742"></a>02742     <span class="comment">#         </span>
<a name="l02743"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#3de2a2bc49b21d7d78944d1203aa22c1">02743</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#3de2a2bc49b21d7d78944d1203aa22c1" title="What error message should be generated for the various exception types?">getErrorMessage</a>(self, e, tokenNames):
<a name="l02744"></a>02744 
<a name="l02745"></a>02745         <span class="keywordflow">if</span> isinstance(e, UnwantedTokenException):
<a name="l02746"></a>02746             tokenName = <span class="stringliteral">"&lt;unknown&gt;"</span>
<a name="l02747"></a>02747             <span class="keywordflow">if</span> e.expecting == EOF:
<a name="l02748"></a>02748                 tokenName = <span class="stringliteral">"EOF"</span>
<a name="l02749"></a>02749 
<a name="l02750"></a>02750             <span class="keywordflow">else</span>:
<a name="l02751"></a>02751                 tokenName = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">tokenNames</a>[e.expecting]
<a name="l02752"></a>02752 
<a name="l02753"></a>02753             msg = <span class="stringliteral">"extraneous input %s expecting %s"</span> % (
<a name="l02754"></a>02754                 self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.getUnexpectedToken()),
<a name="l02755"></a>02755                 tokenName
<a name="l02756"></a>02756                 )
<a name="l02757"></a>02757 
<a name="l02758"></a>02758         <span class="keywordflow">elif</span> isinstance(e, MissingTokenException):
<a name="l02759"></a>02759             tokenName = <span class="stringliteral">"&lt;unknown&gt;"</span>
<a name="l02760"></a>02760             <span class="keywordflow">if</span> e.expecting == EOF:
<a name="l02761"></a>02761                 tokenName = <span class="stringliteral">"EOF"</span>
<a name="l02762"></a>02762 
<a name="l02763"></a>02763             <span class="keywordflow">else</span>:
<a name="l02764"></a>02764                 tokenName = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">tokenNames</a>[e.expecting]
<a name="l02765"></a>02765 
<a name="l02766"></a>02766             msg = <span class="stringliteral">"missing %s at %s"</span> % (
<a name="l02767"></a>02767                 tokenName, self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.token)
<a name="l02768"></a>02768                 )
<a name="l02769"></a>02769 
<a name="l02770"></a>02770         <span class="keywordflow">elif</span> isinstance(e, MismatchedTokenException):
<a name="l02771"></a>02771             tokenName = <span class="stringliteral">"&lt;unknown&gt;"</span>
<a name="l02772"></a>02772             <span class="keywordflow">if</span> e.expecting == EOF:
<a name="l02773"></a>02773                 tokenName = <span class="stringliteral">"EOF"</span>
<a name="l02774"></a>02774             <span class="keywordflow">else</span>:
<a name="l02775"></a>02775                 tokenName = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">tokenNames</a>[e.expecting]
<a name="l02776"></a>02776 
<a name="l02777"></a>02777             msg = <span class="stringliteral">"mismatched input "</span> \
<a name="l02778"></a>02778                   + self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.token) \
<a name="l02779"></a>02779                   + <span class="stringliteral">" expecting "</span> \
<a name="l02780"></a>02780                   + tokenName
<a name="l02781"></a>02781 
<a name="l02782"></a>02782         <span class="keywordflow">elif</span> isinstance(e, MismatchedTreeNodeException):
<a name="l02783"></a>02783             tokenName = <span class="stringliteral">"&lt;unknown&gt;"</span>
<a name="l02784"></a>02784             <span class="keywordflow">if</span> e.expecting == EOF:
<a name="l02785"></a>02785                 tokenName = <span class="stringliteral">"EOF"</span>
<a name="l02786"></a>02786             <span class="keywordflow">else</span>:
<a name="l02787"></a>02787                 tokenName = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">tokenNames</a>[e.expecting]
<a name="l02788"></a>02788 
<a name="l02789"></a>02789             msg = <span class="stringliteral">"mismatched tree node: %s expecting %s"</span> \
<a name="l02790"></a>02790                   % (e.node, tokenName)
<a name="l02791"></a>02791 
<a name="l02792"></a>02792         <span class="keywordflow">elif</span> isinstance(e, NoViableAltException):
<a name="l02793"></a>02793             msg = <span class="stringliteral">"no viable alternative at input "</span> \
<a name="l02794"></a>02794                   + self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.token)
<a name="l02795"></a>02795 
<a name="l02796"></a>02796         <span class="keywordflow">elif</span> isinstance(e, EarlyExitException):
<a name="l02797"></a>02797             msg = <span class="stringliteral">"required (...)+ loop did not match anything at input "</span> \
<a name="l02798"></a>02798                   + self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.token)
<a name="l02799"></a>02799 
<a name="l02800"></a>02800         <span class="keywordflow">elif</span> isinstance(e, MismatchedSetException):
<a name="l02801"></a>02801             msg = <span class="stringliteral">"mismatched input "</span> \
<a name="l02802"></a>02802                   + self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.token) \
<a name="l02803"></a>02803                   + <span class="stringliteral">" expecting set "</span> \
<a name="l02804"></a>02804                   + repr(e.expecting)
<a name="l02805"></a>02805 
<a name="l02806"></a>02806         <span class="keywordflow">elif</span> isinstance(e, MismatchedNotSetException):
<a name="l02807"></a>02807             msg = <span class="stringliteral">"mismatched input "</span> \
<a name="l02808"></a>02808                   + self.<a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(e.token) \
<a name="l02809"></a>02809                   + <span class="stringliteral">" expecting set "</span> \
<a name="l02810"></a>02810                   + repr(e.expecting)
<a name="l02811"></a>02811 
<a name="l02812"></a>02812         <span class="keywordflow">elif</span> isinstance(e, FailedPredicateException):
<a name="l02813"></a>02813             msg = <span class="stringliteral">"rule "</span> \
<a name="l02814"></a>02814                   + e.ruleName \
<a name="l02815"></a>02815                   + <span class="stringliteral">" failed predicate: {"</span> \
<a name="l02816"></a>02816                   + e.predicateText \
<a name="l02817"></a>02817                   + <span class="stringliteral">"}?"</span>
<a name="l02818"></a>02818 
<a name="l02819"></a>02819         <span class="keywordflow">else</span>:
<a name="l02820"></a>02820             msg = str(e)
<a name="l02821"></a>02821 
<a name="l02822"></a>02822         <span class="keywordflow">return</span> msg
<a name="l02823"></a>02823     
<a name="l02824"></a>02824 
<a name="l02825"></a>02825     <span class="comment">##</span>
<a name="l02826"></a>02826     <span class="comment"># </span>
<a name="l02827"></a>02827     <span class="comment">#         Get number of recognition errors (lexer, parser, tree parser).  Each</span>
<a name="l02828"></a>02828     <span class="comment">#         recognizer tracks its own number.  So parser and lexer each have</span>
<a name="l02829"></a>02829     <span class="comment">#         separate count.  Does not count the spurious errors found between</span>
<a name="l02830"></a>02830     <span class="comment">#         an error and next valid token match</span>
<a name="l02831"></a>02831     <span class="comment"># </span>
<a name="l02832"></a>02832     <span class="comment">#         See also reportError()</span>
<a name="l02833"></a>02833     <span class="comment">#   </span>
<a name="l02834"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#b21052ebf6684117cd0774a5553ec2c0">02834</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#b21052ebf6684117cd0774a5553ec2c0" title="Get number of recognition errors (lexer, parser, tree parser).">getNumberOfSyntaxErrors</a>(self):
<a name="l02835"></a>02835         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.syntaxErrors
<a name="l02836"></a>02836 
<a name="l02837"></a>02837 
<a name="l02838"></a>02838     <span class="comment">##</span>
<a name="l02839"></a>02839     <span class="comment"># </span>
<a name="l02840"></a>02840     <span class="comment">#         What is the error header, normally line/character position information?</span>
<a name="l02841"></a>02841     <span class="comment">#         </span>
<a name="l02842"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#c4497e12036221ace01fdc201d23f8a6">02842</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#c4497e12036221ace01fdc201d23f8a6" title="What is the error header, normally line/character position information?">getErrorHeader</a>(self, e):
<a name="l02843"></a>02843         
<a name="l02844"></a>02844         <span class="keywordflow">return</span> <span class="stringliteral">"line %d:%d"</span> % (e.line, e.charPositionInLine)
<a name="l02845"></a>02845 
<a name="l02846"></a>02846 
<a name="l02847"></a>02847     <span class="comment">##</span>
<a name="l02848"></a>02848     <span class="comment"># </span>
<a name="l02849"></a>02849     <span class="comment">#         How should a token be displayed in an error message? The default</span>
<a name="l02850"></a>02850     <span class="comment">#         is to display just the text, but during development you might</span>
<a name="l02851"></a>02851     <span class="comment">#         want to have a lot of information spit out.  Override in that case</span>
<a name="l02852"></a>02852     <span class="comment">#         to use t.toString() (which, for CommonToken, dumps everything about</span>
<a name="l02853"></a>02853     <span class="comment">#         the token). This is better than forcing you to override a method in</span>
<a name="l02854"></a>02854     <span class="comment">#         your token objects because you don't have to go modify your lexer</span>
<a name="l02855"></a>02855     <span class="comment">#         so that it creates a new Java type.</span>
<a name="l02856"></a>02856     <span class="comment">#         </span>
<a name="l02857"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25">02857</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25" title="How should a token be displayed in an error message? The default is to display just...">getTokenErrorDisplay</a>(self, t):
<a name="l02858"></a>02858         
<a name="l02859"></a>02859         s = t.text
<a name="l02860"></a>02860         <span class="keywordflow">if</span> s <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l02861"></a>02861             <span class="keywordflow">if</span> t.type == EOF:
<a name="l02862"></a>02862                 s = <span class="stringliteral">"&lt;EOF&gt;"</span>
<a name="l02863"></a>02863             <span class="keywordflow">else</span>:
<a name="l02864"></a>02864                 s = <span class="stringliteral">"&lt;"</span>+t.type+<span class="stringliteral">"&gt;"</span>
<a name="l02865"></a>02865 
<a name="l02866"></a>02866         <span class="keywordflow">return</span> repr(s)
<a name="l02867"></a>02867     
<a name="l02868"></a>02868 
<a name="l02869"></a>02869     <span class="comment">##</span>
<a name="l02870"></a>02870     <span class="comment"># Override this method to change where error messages go</span>
<a name="l02871"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#c4841ded6b308a3f3c48c5b2d3c749d7">02871</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#c4841ded6b308a3f3c48c5b2d3c749d7" title="Override this method to change where error messages go.">emitErrorMessage</a>(self, msg):
<a name="l02872"></a>02872         sys.stderr.write(msg + <span class="stringliteral">'\n'</span>)
<a name="l02873"></a>02873 
<a name="l02874"></a>02874 
<a name="l02875"></a>02875     <span class="comment">##</span>
<a name="l02876"></a>02876     <span class="comment"># </span>
<a name="l02877"></a>02877     <span class="comment">#         Recover from an error found on the input stream.  This is</span>
<a name="l02878"></a>02878     <span class="comment">#         for NoViableAlt and mismatched symbol exceptions.  If you enable</span>
<a name="l02879"></a>02879     <span class="comment">#         single token insertion and deletion, this will usually not</span>
<a name="l02880"></a>02880     <span class="comment">#         handle mismatched symbol exceptions but there could be a mismatched</span>
<a name="l02881"></a>02881     <span class="comment">#         token that the match() routine could not recover from.</span>
<a name="l02882"></a>02882     <span class="comment">#         </span>
<a name="l02883"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#0d24b2f60d4efb4ccfcf6aaf0146417e">02883</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#0d24b2f60d4efb4ccfcf6aaf0146417e" title="Recover from an error found on the input stream.">recover</a>(self, input, re):
<a name="l02884"></a>02884         
<a name="l02885"></a>02885         <span class="comment"># PROBLEM? what if input stream is not the same as last time</span>
<a name="l02886"></a>02886         <span class="comment"># perhaps make lastErrorIndex a member of input</span>
<a name="l02887"></a>02887         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.lastErrorIndex == input.index():
<a name="l02888"></a>02888             <span class="comment"># uh oh, another error at same token index; must be a case</span>
<a name="l02889"></a>02889             <span class="comment"># where LT(1) is in the recovery token set so nothing is</span>
<a name="l02890"></a>02890             <span class="comment"># consumed; consume a single token so at least to prevent</span>
<a name="l02891"></a>02891             <span class="comment"># an infinite loop; this is a failsafe.</span>
<a name="l02892"></a>02892             input.consume()
<a name="l02893"></a>02893 
<a name="l02894"></a>02894         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.lastErrorIndex = input.index()
<a name="l02895"></a>02895         followSet = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#90d118af4f9efe0702c795fa325ecc5b" title="Compute the error recovery set for the current rule.">computeErrorRecoverySet</a>()
<a name="l02896"></a>02896         
<a name="l02897"></a>02897         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#a02cc381bcaafbe90d2f07fde144fa6d" title="A hook to listen in on the token consumption during error recovery.">beginResync</a>()
<a name="l02898"></a>02898         self.consumeUntil(input, followSet)
<a name="l02899"></a>02899         self.<a class="code" href="classantlr3_1_1_base_recognizer.html#bf949192a5e5a76204191afea30249f7" title="A hook to listen in on the token consumption during error recovery.">endResync</a>()
<a name="l02900"></a>02900 
<a name="l02901"></a>02901 
<a name="l02902"></a>02902     <span class="comment">##</span>
<a name="l02903"></a>02903     <span class="comment"># </span>
<a name="l02904"></a>02904     <span class="comment">#         A hook to listen in on the token consumption during error recovery.</span>
<a name="l02905"></a>02905     <span class="comment">#         The DebugParser subclasses this to fire events to the listenter.</span>
<a name="l02906"></a>02906     <span class="comment">#         </span>
<a name="l02907"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#a02cc381bcaafbe90d2f07fde144fa6d">02907</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#a02cc381bcaafbe90d2f07fde144fa6d" title="A hook to listen in on the token consumption during error recovery.">beginResync</a>(self):
<a name="l02908"></a>02908 
<a name="l02909"></a>02909         <span class="keywordflow">pass</span>
<a name="l02910"></a>02910 
<a name="l02911"></a>02911 
<a name="l02912"></a>02912     <span class="comment">##</span>
<a name="l02913"></a>02913     <span class="comment"># </span>
<a name="l02914"></a>02914     <span class="comment">#         A hook to listen in on the token consumption during error recovery.</span>
<a name="l02915"></a>02915     <span class="comment">#         The DebugParser subclasses this to fire events to the listenter.</span>
<a name="l02916"></a>02916     <span class="comment">#         </span>
<a name="l02917"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#bf949192a5e5a76204191afea30249f7">02917</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#bf949192a5e5a76204191afea30249f7" title="A hook to listen in on the token consumption during error recovery.">endResync</a>(self):
<a name="l02918"></a>02918 
<a name="l02919"></a>02919         <span class="keywordflow">pass</span>
<a name="l02920"></a>02920 
<a name="l02921"></a>02921 
<a name="l02922"></a>02922     <span class="comment">##</span>
<a name="l02923"></a>02923     <span class="comment"># </span>
<a name="l02924"></a>02924     <span class="comment">#         Compute the error recovery set for the current rule.  During</span>
<a name="l02925"></a>02925     <span class="comment">#         rule invocation, the parser pushes the set of tokens that can</span>
<a name="l02926"></a>02926     <span class="comment">#         follow that rule reference on the stack; this amounts to</span>
<a name="l02927"></a>02927     <span class="comment">#         computing FIRST of what follows the rule reference in the</span>
<a name="l02928"></a>02928     <span class="comment">#         enclosing rule. This local follow set only includes tokens</span>
<a name="l02929"></a>02929     <span class="comment">#         from within the rule; i.e., the FIRST computation done by</span>
<a name="l02930"></a>02930     <span class="comment">#         ANTLR stops at the end of a rule.</span>
<a name="l02931"></a>02931     <span class="comment"># </span>
<a name="l02932"></a>02932     <span class="comment">#         EXAMPLE</span>
<a name="l02933"></a>02933     <span class="comment"># </span>
<a name="l02934"></a>02934     <span class="comment">#         When you find a "no viable alt exception", the input is not</span>
<a name="l02935"></a>02935     <span class="comment">#         consistent with any of the alternatives for rule r.  The best</span>
<a name="l02936"></a>02936     <span class="comment">#         thing to do is to consume tokens until you see something that</span>
<a name="l02937"></a>02937     <span class="comment">#         can legally follow a call to r *or* any rule that called r.</span>
<a name="l02938"></a>02938     <span class="comment">#         You don't want the exact set of viable next tokens because the</span>
<a name="l02939"></a>02939     <span class="comment">#         input might just be missing a token--you might consume the</span>
<a name="l02940"></a>02940     <span class="comment">#         rest of the input looking for one of the missing tokens.</span>
<a name="l02941"></a>02941     <span class="comment"># </span>
<a name="l02942"></a>02942     <span class="comment">#         Consider grammar:</span>
<a name="l02943"></a>02943     <span class="comment"># </span>
<a name="l02944"></a>02944     <span class="comment">#         a : '[' b ']'</span>
<a name="l02945"></a>02945     <span class="comment">#           | '(' b ')'</span>
<a name="l02946"></a>02946     <span class="comment">#           ;</span>
<a name="l02947"></a>02947     <span class="comment">#         b : c '^' INT ;</span>
<a name="l02948"></a>02948     <span class="comment">#         c : ID</span>
<a name="l02949"></a>02949     <span class="comment">#           | INT</span>
<a name="l02950"></a>02950     <span class="comment">#           ;</span>
<a name="l02951"></a>02951     <span class="comment"># </span>
<a name="l02952"></a>02952     <span class="comment">#         At each rule invocation, the set of tokens that could follow</span>
<a name="l02953"></a>02953     <span class="comment">#         that rule is pushed on a stack.  Here are the various "local"</span>
<a name="l02954"></a>02954     <span class="comment">#         follow sets:</span>
<a name="l02955"></a>02955     <span class="comment"># </span>
<a name="l02956"></a>02956     <span class="comment">#         FOLLOW(b1_in_a) = FIRST(']') = ']'</span>
<a name="l02957"></a>02957     <span class="comment">#         FOLLOW(b2_in_a) = FIRST(')') = ')'</span>
<a name="l02958"></a>02958     <span class="comment">#         FOLLOW(c_in_b) = FIRST('^') = '^'</span>
<a name="l02959"></a>02959     <span class="comment"># </span>
<a name="l02960"></a>02960     <span class="comment">#         Upon erroneous input "[]", the call chain is</span>
<a name="l02961"></a>02961     <span class="comment"># </span>
<a name="l02962"></a>02962     <span class="comment">#         a -&gt; b -&gt; c</span>
<a name="l02963"></a>02963     <span class="comment"># </span>
<a name="l02964"></a>02964     <span class="comment">#         and, hence, the follow context stack is:</span>
<a name="l02965"></a>02965     <span class="comment"># </span>
<a name="l02966"></a>02966     <span class="comment">#         depth  local follow set     after call to rule</span>
<a name="l02967"></a>02967     <span class="comment">#           0         &lt;EOF&gt;                    a (from main())</span>
<a name="l02968"></a>02968     <span class="comment">#           1          ']'                     b</span>
<a name="l02969"></a>02969     <span class="comment">#           3          '^'                     c</span>
<a name="l02970"></a>02970     <span class="comment"># </span>
<a name="l02971"></a>02971     <span class="comment">#         Notice that ')' is not included, because b would have to have</span>
<a name="l02972"></a>02972     <span class="comment">#         been called from a different context in rule a for ')' to be</span>
<a name="l02973"></a>02973     <span class="comment">#         included.</span>
<a name="l02974"></a>02974     <span class="comment"># </span>
<a name="l02975"></a>02975     <span class="comment">#         For error recovery, we cannot consider FOLLOW(c)</span>
<a name="l02976"></a>02976     <span class="comment">#         (context-sensitive or otherwise).  We need the combined set of</span>
<a name="l02977"></a>02977     <span class="comment">#         all context-sensitive FOLLOW sets--the set of all tokens that</span>
<a name="l02978"></a>02978     <span class="comment">#         could follow any reference in the call chain.  We need to</span>
<a name="l02979"></a>02979     <span class="comment">#         resync to one of those tokens.  Note that FOLLOW(c)='^' and if</span>
<a name="l02980"></a>02980     <span class="comment">#         we resync'd to that token, we'd consume until EOF.  We need to</span>
<a name="l02981"></a>02981     <span class="comment">#         sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.</span>
<a name="l02982"></a>02982     <span class="comment">#         In this case, for input "[]", LA(1) is in this set so we would</span>
<a name="l02983"></a>02983     <span class="comment">#         not consume anything and after printing an error rule c would</span>
<a name="l02984"></a>02984     <span class="comment">#         return normally.  It would not find the required '^' though.</span>
<a name="l02985"></a>02985     <span class="comment">#         At this point, it gets a mismatched token error and throws an</span>
<a name="l02986"></a>02986     <span class="comment">#         exception (since LA(1) is not in the viable following token</span>
<a name="l02987"></a>02987     <span class="comment">#         set).  The rule exception handler tries to recover, but finds</span>
<a name="l02988"></a>02988     <span class="comment">#         the same recovery set and doesn't consume anything.  Rule b</span>
<a name="l02989"></a>02989     <span class="comment">#         exits normally returning to rule a.  Now it finds the ']' (and</span>
<a name="l02990"></a>02990     <span class="comment">#         with the successful match exits errorRecovery mode).</span>
<a name="l02991"></a>02991     <span class="comment"># </span>
<a name="l02992"></a>02992     <span class="comment">#         So, you cna see that the parser walks up call chain looking</span>
<a name="l02993"></a>02993     <span class="comment">#         for the token that was a member of the recovery set.</span>
<a name="l02994"></a>02994     <span class="comment"># </span>
<a name="l02995"></a>02995     <span class="comment">#         Errors are not generated in errorRecovery mode.</span>
<a name="l02996"></a>02996     <span class="comment"># </span>
<a name="l02997"></a>02997     <span class="comment">#         ANTLR's error recovery mechanism is based upon original ideas:</span>
<a name="l02998"></a>02998     <span class="comment"># </span>
<a name="l02999"></a>02999     <span class="comment">#         "Algorithms + Data Structures = Programs" by Niklaus Wirth</span>
<a name="l03000"></a>03000     <span class="comment"># </span>
<a name="l03001"></a>03001     <span class="comment">#         and</span>
<a name="l03002"></a>03002     <span class="comment"># </span>
<a name="l03003"></a>03003     <span class="comment">#         "A note on error recovery in recursive descent parsers":</span>
<a name="l03004"></a>03004     <span class="comment">#         http://portal.acm.org/citation.cfm?id=947902.947905</span>
<a name="l03005"></a>03005     <span class="comment"># </span>
<a name="l03006"></a>03006     <span class="comment">#         Later, Josef Grosch had some good ideas:</span>
<a name="l03007"></a>03007     <span class="comment"># </span>
<a name="l03008"></a>03008     <span class="comment">#         "Efficient and Comfortable Error Recovery in Recursive Descent</span>
<a name="l03009"></a>03009     <span class="comment">#         Parsers":</span>
<a name="l03010"></a>03010     <span class="comment">#         ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip</span>
<a name="l03011"></a>03011     <span class="comment"># </span>
<a name="l03012"></a>03012     <span class="comment">#         Like Grosch I implemented local FOLLOW sets that are combined</span>
<a name="l03013"></a>03013     <span class="comment">#         at run-time upon error to avoid overhead during parsing.</span>
<a name="l03014"></a>03014     <span class="comment">#         </span>
<a name="l03015"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#90d118af4f9efe0702c795fa325ecc5b">03015</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#90d118af4f9efe0702c795fa325ecc5b" title="Compute the error recovery set for the current rule.">computeErrorRecoverySet</a>(self):
<a name="l03016"></a>03016         
<a name="l03017"></a>03017         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#05b73ea8979dec3f87214b0686ec7c83">combineFollows</a>(<span class="keyword">False</span>)
<a name="l03018"></a>03018 
<a name="l03019"></a>03019         
<a name="l03020"></a>03020     <span class="comment">##</span>
<a name="l03021"></a>03021     <span class="comment"># </span>
<a name="l03022"></a>03022     <span class="comment">#         Compute the context-sensitive FOLLOW set for current rule.</span>
<a name="l03023"></a>03023     <span class="comment">#         This is set of token types that can follow a specific rule</span>
<a name="l03024"></a>03024     <span class="comment">#         reference given a specific call chain.  You get the set of</span>
<a name="l03025"></a>03025     <span class="comment">#         viable tokens that can possibly come next (lookahead depth 1)</span>
<a name="l03026"></a>03026     <span class="comment">#         given the current call chain.  Contrast this with the</span>
<a name="l03027"></a>03027     <span class="comment">#         definition of plain FOLLOW for rule r:</span>
<a name="l03028"></a>03028     <span class="comment"># </span>
<a name="l03029"></a>03029     <span class="comment">#          FOLLOW(r)={x | S=&gt;*alpha r beta in G and x in FIRST(beta)}</span>
<a name="l03030"></a>03030     <span class="comment"># </span>
<a name="l03031"></a>03031     <span class="comment">#         where x in T* and alpha, beta in V*; T is set of terminals and</span>
<a name="l03032"></a>03032     <span class="comment">#         V is the set of terminals and nonterminals.  In other words,</span>
<a name="l03033"></a>03033     <span class="comment">#         FOLLOW(r) is the set of all tokens that can possibly follow</span>
<a name="l03034"></a>03034     <span class="comment">#         references to r in *any* sentential form (context).  At</span>
<a name="l03035"></a>03035     <span class="comment">#         runtime, however, we know precisely which context applies as</span>
<a name="l03036"></a>03036     <span class="comment">#         we have the call chain.  We may compute the exact (rather</span>
<a name="l03037"></a>03037     <span class="comment">#         than covering superset) set of following tokens.</span>
<a name="l03038"></a>03038     <span class="comment"># </span>
<a name="l03039"></a>03039     <span class="comment">#         For example, consider grammar:</span>
<a name="l03040"></a>03040     <span class="comment"># </span>
<a name="l03041"></a>03041     <span class="comment">#         stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}</span>
<a name="l03042"></a>03042     <span class="comment">#              | "return" expr '.'</span>
<a name="l03043"></a>03043     <span class="comment">#              ;</span>
<a name="l03044"></a>03044     <span class="comment">#         expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}</span>
<a name="l03045"></a>03045     <span class="comment">#         atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}</span>
<a name="l03046"></a>03046     <span class="comment">#              | '(' expr ')'</span>
<a name="l03047"></a>03047     <span class="comment">#              ;</span>
<a name="l03048"></a>03048     <span class="comment"># </span>
<a name="l03049"></a>03049     <span class="comment">#         The FOLLOW sets are all inclusive whereas context-sensitive</span>
<a name="l03050"></a>03050     <span class="comment">#         FOLLOW sets are precisely what could follow a rule reference.</span>
<a name="l03051"></a>03051     <span class="comment">#         For input input "i=(3);", here is the derivation:</span>
<a name="l03052"></a>03052     <span class="comment"># </span>
<a name="l03053"></a>03053     <span class="comment">#         stat =&gt; ID '=' expr ';'</span>
<a name="l03054"></a>03054     <span class="comment">#              =&gt; ID '=' atom ('+' atom)* ';'</span>
<a name="l03055"></a>03055     <span class="comment">#              =&gt; ID '=' '(' expr ')' ('+' atom)* ';'</span>
<a name="l03056"></a>03056     <span class="comment">#              =&gt; ID '=' '(' atom ')' ('+' atom)* ';'</span>
<a name="l03057"></a>03057     <span class="comment">#              =&gt; ID '=' '(' INT ')' ('+' atom)* ';'</span>
<a name="l03058"></a>03058     <span class="comment">#              =&gt; ID '=' '(' INT ')' ';'</span>
<a name="l03059"></a>03059     <span class="comment"># </span>
<a name="l03060"></a>03060     <span class="comment">#         At the "3" token, you'd have a call chain of</span>
<a name="l03061"></a>03061     <span class="comment"># </span>
<a name="l03062"></a>03062     <span class="comment">#           stat -&gt; expr -&gt; atom -&gt; expr -&gt; atom</span>
<a name="l03063"></a>03063     <span class="comment"># </span>
<a name="l03064"></a>03064     <span class="comment">#         What can follow that specific nested ref to atom?  Exactly ')'</span>
<a name="l03065"></a>03065     <span class="comment">#         as you can see by looking at the derivation of this specific</span>
<a name="l03066"></a>03066     <span class="comment">#         input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.</span>
<a name="l03067"></a>03067     <span class="comment"># </span>
<a name="l03068"></a>03068     <span class="comment">#         You want the exact viable token set when recovering from a</span>
<a name="l03069"></a>03069     <span class="comment">#         token mismatch.  Upon token mismatch, if LA(1) is member of</span>
<a name="l03070"></a>03070     <span class="comment">#         the viable next token set, then you know there is most likely</span>
<a name="l03071"></a>03071     <span class="comment">#         a missing token in the input stream.  "Insert" one by just not</span>
<a name="l03072"></a>03072     <span class="comment">#         throwing an exception.</span>
<a name="l03073"></a>03073     <span class="comment">#         </span>
<a name="l03074"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#b3dd7de1dc6760f5f634ed996c5a6769">03074</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#b3dd7de1dc6760f5f634ed996c5a6769" title="Compute the context-sensitive FOLLOW set for current rule.">computeContextSensitiveRuleFOLLOW</a>(self):
<a name="l03075"></a>03075 
<a name="l03076"></a>03076         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#05b73ea8979dec3f87214b0686ec7c83">combineFollows</a>(<span class="keyword">True</span>)
<a name="l03077"></a>03077 
<a name="l03078"></a>03078 
<a name="l03079"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#05b73ea8979dec3f87214b0686ec7c83">03079</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#05b73ea8979dec3f87214b0686ec7c83">combineFollows</a>(self, exact):
<a name="l03080"></a>03080         followSet = set()
<a name="l03081"></a>03081         <span class="keywordflow">for</span> idx, localFollowSet <span class="keywordflow">in</span> reversed(list(enumerate(self.<a class="code" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea" title="State of a lexer, parser, or tree parser are collected into a state object so the...">_state</a>.following))):
<a name="l03082"></a>03082             followSet |= localFollowSet
<a name="l03083"></a>03083             <span class="keywordflow">if</span> exact:
<a name="l03084"></a>03084                 <span class="comment"># can we see end of rule?</span>
<a name="l03085"></a>03085                 <span class="keywordflow">if</span> EOR_TOKEN_TYPE <span class="keywordflow">in</span> localFollowSet:
<a name="l03086"></a>03086                     <span class="comment"># Only leave EOR in set if at top (start rule); this lets</span>
<a name="l03087"></a>03087                     <span class="comment"># us know if have to include follow(start rule); i.e., EOF</span>
<a name="l03088"></a>03088                     <span class="keywordflow">if</span> idx &gt; 0:
<a name="l03089"></a>03089                         followSet.remove(EOR_TOKEN_TYPE)
<a name="l03090"></a>03090                         
<a name="l03091"></a>03091                 <span class="keywordflow">else</span>:
<a name="l03092"></a>03092                     <span class="comment"># can't see end of rule, quit</span>
<a name="l03093"></a>03093                     <span class="keywordflow">break</span>
<a name="l03094"></a>03094 
<a name="l03095"></a>03095         <span class="keywordflow">return</span> followSet
<a name="l03096"></a>03096 
<a name="l03097"></a>03097 
<a name="l03098"></a>03098     <span class="comment">##</span>
<a name="l03099"></a>03099     <span class="comment"># Attempt to recover from a single missing or extra token.</span>
<a name="l03100"></a>03100     <span class="comment"># </span>
<a name="l03101"></a>03101     <span class="comment">#         EXTRA TOKEN</span>
<a name="l03102"></a>03102     <span class="comment"># </span>
<a name="l03103"></a>03103     <span class="comment">#         LA(1) is not what we are looking for.  If LA(2) has the right token,</span>
<a name="l03104"></a>03104     <span class="comment">#         however, then assume LA(1) is some extra spurious token.  Delete it</span>
<a name="l03105"></a>03105     <span class="comment">#         and LA(2) as if we were doing a normal match(), which advances the</span>
<a name="l03106"></a>03106     <span class="comment">#         input.</span>
<a name="l03107"></a>03107     <span class="comment"># </span>
<a name="l03108"></a>03108     <span class="comment">#         MISSING TOKEN</span>
<a name="l03109"></a>03109     <span class="comment"># </span>
<a name="l03110"></a>03110     <span class="comment">#         If current token is consistent with what could come after</span>
<a name="l03111"></a>03111     <span class="comment">#         ttype then it is ok to 'insert' the missing token, else throw</span>
<a name="l03112"></a>03112     <span class="comment">#         exception For example, Input 'i=(3;' is clearly missing the</span>
<a name="l03113"></a>03113     <span class="comment">#         ')'.  When the parser returns from the nested call to expr, it</span>
<a name="l03114"></a>03114     <span class="comment">#         will have call chain:</span>
<a name="l03115"></a>03115     <span class="comment"># </span>
<a name="l03116"></a>03116     <span class="comment">#           stat -&gt; expr -&gt; atom</span>
<a name="l03117"></a>03117     <span class="comment"># </span>
<a name="l03118"></a>03118     <span class="comment">#         and it will be trying to match the ')' at this point in the</span>
<a name="l03119"></a>03119     <span class="comment">#         derivation:</span>
<a name="l03120"></a>03120     <span class="comment"># </span>
<a name="l03121"></a>03121     <span class="comment">#              =&gt; ID '=' '(' INT ')' ('+' atom)* ';'</span>
<a name="l03122"></a>03122     <span class="comment">#                                 ^</span>
<a name="l03123"></a>03123     <span class="comment">#         match() will see that ';' doesn't match ')' and report a</span>
<a name="l03124"></a>03124     <span class="comment">#         mismatched token error.  To recover, it sees that LA(1)==';'</span>
<a name="l03125"></a>03125     <span class="comment">#         is in the set of tokens that can follow the ')' token</span>
<a name="l03126"></a>03126     <span class="comment">#         reference in rule atom.  It can assume that you forgot the ')'.</span>
<a name="l03127"></a>03127     <span class="comment">#         </span>
<a name="l03128"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#6866fbb79a115e58c949834ace5bba17">03128</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#6866fbb79a115e58c949834ace5bba17" title="Attempt to recover from a single missing or extra token.">recoverFromMismatchedToken</a>(self, input, ttype, follow):
<a name="l03129"></a>03129 
<a name="l03130"></a>03130         e = <span class="keywordtype">None</span>
<a name="l03131"></a>03131 
<a name="l03132"></a>03132         <span class="comment"># if next token is what we are looking for then "delete" this token</span>
<a name="l03133"></a>03133         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#7a44a211c8f34a5743a72da0b373a74e">mismatchIsUnwantedToken</a>(input, ttype):
<a name="l03134"></a>03134             e = UnwantedTokenException(ttype, input)
<a name="l03135"></a>03135 
<a name="l03136"></a>03136             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#a02cc381bcaafbe90d2f07fde144fa6d" title="A hook to listen in on the token consumption during error recovery.">beginResync</a>()
<a name="l03137"></a>03137             input.consume() <span class="comment"># simply delete extra token</span>
<a name="l03138"></a>03138             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#bf949192a5e5a76204191afea30249f7" title="A hook to listen in on the token consumption during error recovery.">endResync</a>()
<a name="l03139"></a>03139 
<a name="l03140"></a>03140             <span class="comment"># report after consuming so AW sees the token in the exception</span>
<a name="l03141"></a>03141             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c" title="Report a recognition problem.">reportError</a>(e)
<a name="l03142"></a>03142 
<a name="l03143"></a>03143             <span class="comment"># we want to return the token we're actually matching</span>
<a name="l03144"></a>03144             matchedSymbol = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#2c908793a6c88fdf53a227fa7480c407" title="Match needs to return the current input symbol, which gets put into the label for...">getCurrentInputSymbol</a>(input)
<a name="l03145"></a>03145 
<a name="l03146"></a>03146             <span class="comment"># move past ttype token as if all were ok</span>
<a name="l03147"></a>03147             input.consume()
<a name="l03148"></a>03148             <span class="keywordflow">return</span> matchedSymbol
<a name="l03149"></a>03149 
<a name="l03150"></a>03150         <span class="comment"># can't recover with single token deletion, try insertion</span>
<a name="l03151"></a>03151         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#2482f7bff153e1ccc1ed218e5172c870">mismatchIsMissingToken</a>(input, follow):
<a name="l03152"></a>03152             inserted = self.<a class="code" href="classantlr3_1_1_base_recognizer.html#891b5c693ca2b041b81b651d0ad6d2d4" title="Conjure up a missing token during error recovery.">getMissingSymbol</a>(input, e, ttype, follow)
<a name="l03153"></a>03153             e = MissingTokenException(ttype, input, inserted)
<a name="l03154"></a>03154 
<a name="l03155"></a>03155             <span class="comment"># report after inserting so AW sees the token in the exception</span>
<a name="l03156"></a>03156             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c" title="Report a recognition problem.">reportError</a>(e)
<a name="l03157"></a>03157             <span class="keywordflow">return</span> inserted
<a name="l03158"></a>03158 
<a name="l03159"></a>03159         <span class="comment"># even that didn't work; must throw the exception</span>
<a name="l03160"></a>03160         e = MismatchedTokenException(ttype, input)
<a name="l03161"></a>03161         <span class="keywordflow">raise</span> e
<a name="l03162"></a>03162 
<a name="l03163"></a>03163 
<a name="l03164"></a>03164     <span class="comment">##</span>
<a name="l03165"></a>03165     <span class="comment"># Not currently used</span>
<a name="l03166"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#931e37a390b4cf9c3cb33fb407ba9c15">03166</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#931e37a390b4cf9c3cb33fb407ba9c15" title="Not currently used.">recoverFromMismatchedSet</a>(self, input, e, follow):
<a name="l03167"></a>03167 
<a name="l03168"></a>03168         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#2482f7bff153e1ccc1ed218e5172c870">mismatchIsMissingToken</a>(input, follow):
<a name="l03169"></a>03169             self.<a class="code" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c" title="Report a recognition problem.">reportError</a>(e)
<a name="l03170"></a>03170             <span class="comment"># we don't know how to conjure up a token for sets yet</span>
<a name="l03171"></a>03171             <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_base_recognizer.html#891b5c693ca2b041b81b651d0ad6d2d4" title="Conjure up a missing token during error recovery.">getMissingSymbol</a>(input, e, INVALID_TOKEN_TYPE, follow)
<a name="l03172"></a>03172 
<a name="l03173"></a>03173         <span class="comment"># TODO do single token deletion like above for Token mismatch</span>
<a name="l03174"></a>03174         <span class="keywordflow">raise</span> e
<a name="l03175"></a>03175 
<a name="l03176"></a>03176 
<a name="l03177"></a>03177     <span class="comment">##</span>
<a name="l03178"></a>03178     <span class="comment"># </span>
<a name="l03179"></a>03179     <span class="comment">#         Match needs to return the current input symbol, which gets put</span>
<a name="l03180"></a>03180     <span class="comment">#         into the label for the associated token ref; e.g., x=ID.  Token</span>
<a name="l03181"></a>03181     <span class="comment">#         and tree parsers need to return different objects. Rather than test</span>
<a name="l03182"></a>03182     <span class="comment">#         for input stream type or change the IntStream interface, I use</span>
<a name="l03183"></a>03183     <span class="comment">#         a simple method to ask the recognizer to tell me what the current</span>
<a name="l03184"></a>03184     <span class="comment">#         input symbol is.</span>
<a name="l03185"></a>03185     <span class="comment"># </span>
<a name="l03186"></a>03186     <span class="comment">#         This is ignored for lexers.</span>
<a name="l03187"></a>03187     <span class="comment">#         </span>
<a name="l03188"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#2c908793a6c88fdf53a227fa7480c407">03188</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#2c908793a6c88fdf53a227fa7480c407" title="Match needs to return the current input symbol, which gets put into the label for...">getCurrentInputSymbol</a>(self, input):
<a name="l03189"></a>03189         
<a name="l03190"></a>03190         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03191"></a>03191 
<a name="l03192"></a>03192 
<a name="l03193"></a>03193     <span class="comment">##</span>
<a name="l03194"></a>03194     <span class="comment"># Conjure up a missing token during error recovery.</span>
<a name="l03195"></a>03195     <span class="comment"># </span>
<a name="l03196"></a>03196     <span class="comment">#         The recognizer attempts to recover from single missing</span>
<a name="l03197"></a>03197     <span class="comment">#         symbols. But, actions might refer to that missing symbol.</span>
<a name="l03198"></a>03198     <span class="comment">#         For example, x=ID {f($x);}. The action clearly assumes</span>
<a name="l03199"></a>03199     <span class="comment">#         that there has been an identifier matched previously and that</span>
<a name="l03200"></a>03200     <span class="comment">#         $x points at that token. If that token is missing, but</span>
<a name="l03201"></a>03201     <span class="comment">#         the next token in the stream is what we want we assume that</span>
<a name="l03202"></a>03202     <span class="comment">#         this token is missing and we keep going. Because we</span>
<a name="l03203"></a>03203     <span class="comment">#         have to return some token to replace the missing token,</span>
<a name="l03204"></a>03204     <span class="comment">#         we have to conjure one up. This method gives the user control</span>
<a name="l03205"></a>03205     <span class="comment">#         over the tokens returned for missing tokens. Mostly,</span>
<a name="l03206"></a>03206     <span class="comment">#         you will want to create something special for identifier</span>
<a name="l03207"></a>03207     <span class="comment">#         tokens. For literals such as '{' and ',', the default</span>
<a name="l03208"></a>03208     <span class="comment">#         action in the parser or tree parser works. It simply creates</span>
<a name="l03209"></a>03209     <span class="comment">#         a CommonToken of the appropriate type. The text will be the token.</span>
<a name="l03210"></a>03210     <span class="comment">#         If you change what tokens must be created by the lexer,</span>
<a name="l03211"></a>03211     <span class="comment">#         override this method to create the appropriate tokens.</span>
<a name="l03212"></a>03212     <span class="comment">#         </span>
<a name="l03213"></a><a class="code" href="classantlr3_1_1_base_recognizer.html#891b5c693ca2b041b81b651d0ad6d2d4">03213</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_base_recognizer.html#891b5c693ca2b041b81b651d0ad6d2d4" title="Conjure up a missing token during error recovery.">getMissingSymbol</a>(self, input, e, expectedTokenType, follow):
<a name="l03214"></a>03214 
<a name="l03215"></a>03215         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03216"></a>03216 
<a name="l03217"></a>03217 
<a name="l03218"></a>03218 <span class="comment">##     def recoverFromMissingElement(self, input, e, follow):</span>
<a name="l03219"></a>03219 <span class="comment">##         """</span>
<a name="l03220"></a>03220 <span class="comment">##         This code is factored out from mismatched token and mismatched set</span>
<a name="l03221"></a>03221 <span class="comment">##         recovery.  It handles "single token insertion" error recovery for</span>
<a name="l03222"></a>03222 <span class="comment">##         both.  No tokens are consumed to recover from insertions.  Return</span>
<a name="l03223"></a>03223 <span class="comment">##         true if recovery was possible else return false.</span>
<a name="l03224"></a>03224 <span class="comment">##         """</span>
<a name="l03225"></a>03225         
<a name="l03226"></a>03226 <span class="comment">##         if self.mismatchIsMissingToken(input, follow):</span>
<a name="l03227"></a>03227 <span class="comment">##             self.reportError(e)</span>
<a name="l03228"></a>03228 <span class="comment">##             return True</span>
<a name="l03229"></a>03229 
<a name="l03230"></a>03230 <span class="comment">##         # nothing to do; throw exception</span>
<a name="l03231"></a>03231 <span class="comment">##         return False</span>
<a name="l03232"></a>03232 
<a name="l03233"></a>03233 
<a name="l03234"></a>03234     <span class="comment">##</span>
<a name="l03235"></a>03235     <span class="comment"># </span>
<a name="l03236"></a>03236     <span class="comment">#         Consume tokens until one matches the given token or token set</span>
<a name="l03237"></a>03237     <span class="comment"># </span>
<a name="l03238"></a>03238     <span class="comment">#         tokenTypes can be a single token type or a set of token types</span>
<a name="l03239"></a>03239     <span class="comment">#         </span>
<a name="l03240"></a>03240     <span class="comment">#         </span>
<a name="l03241"></a><a class="code" href="namespaceantlr3.html#8c925282186e0f6bbba65e3b38ac0829">03241</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#8c925282186e0f6bbba65e3b38ac0829" title="def recoverFromMissingElement(self, input, e, follow): &amp;quot;&amp;quot;&amp;quot; This code...">consumeUntil</a>(self, input, tokenTypes):
<a name="l03242"></a>03242         
<a name="l03243"></a>03243         <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(tokenTypes, (set, frozenset)):
<a name="l03244"></a>03244             tokenTypes = frozenset([tokenTypes])
<a name="l03245"></a>03245 
<a name="l03246"></a>03246         ttype = input.LA(1)
<a name="l03247"></a>03247         <span class="keywordflow">while</span> ttype != EOF <span class="keywordflow">and</span> ttype <span class="keywordflow">not</span> <span class="keywordflow">in</span> tokenTypes:
<a name="l03248"></a>03248             input.consume()
<a name="l03249"></a>03249             ttype = input.LA(1)
<a name="l03250"></a>03250 
<a name="l03251"></a>03251 
<a name="l03252"></a><a class="code" href="namespaceantlr3.html#9b6d2c2e6264f1a6e3c5e534ea1895dd">03252</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#9b6d2c2e6264f1a6e3c5e534ea1895dd">getRuleInvocationStack</a>(self):
<a name="l03253"></a>03253         <span class="comment">##</span>
<a name="l03254"></a>03254         <span class="comment"># </span>
<a name="l03255"></a>03255         <span class="comment">#         Return List&lt;String&gt; of the rules in your parser instance</span>
<a name="l03256"></a>03256         <span class="comment">#         leading up to a call to this method.  You could override if</span>
<a name="l03257"></a>03257         <span class="comment">#         you want more details such as the file/line info of where</span>
<a name="l03258"></a>03258         <span class="comment">#         in the parser java code a rule is invoked.</span>
<a name="l03259"></a>03259         <span class="comment"># </span>
<a name="l03260"></a>03260         <span class="comment">#         This is very useful for error messages and for context-sensitive</span>
<a name="l03261"></a>03261         <span class="comment">#         error recovery.</span>
<a name="l03262"></a>03262         <span class="comment"># </span>
<a name="l03263"></a>03263         <span class="comment">#         You must be careful, if you subclass a generated recognizers.</span>
<a name="l03264"></a>03264         <span class="comment">#         The default implementation will only search the module of self</span>
<a name="l03265"></a>03265         <span class="comment">#         for rules, but the subclass will not contain any rules.</span>
<a name="l03266"></a>03266         <span class="comment">#         You probably want to override this method to look like</span>
<a name="l03267"></a>03267         <span class="comment"># </span>
<a name="l03268"></a>03268         <span class="comment">#             return self._getRuleInvocationStack(&lt;class&gt;.__module__)</span>
<a name="l03269"></a>03269         <span class="comment"># </span>
<a name="l03270"></a>03270         <span class="comment">#         where &lt;class&gt; is the class of the generated recognizer, e.g.</span>
<a name="l03271"></a>03271         <span class="comment">#         the superclass of self.</span>
<a name="l03272"></a>03272         <span class="comment">#         </span>
<a name="l03273"></a>03273         <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#9b6d2c2e6264f1a6e3c5e534ea1895dd">getRuleInvocationStack</a>(self):
<a name="l03274"></a>03274 
<a name="l03275"></a>03275         <span class="keywordflow">return</span> self._getRuleInvocationStack(self.__module__)
<a name="l03276"></a>03276 
<a name="l03277"></a>03277 
<a name="l03278"></a>03278     <span class="comment">##</span>
<a name="l03279"></a>03279     <span class="comment"># </span>
<a name="l03280"></a>03280     <span class="comment">#         A more general version of getRuleInvocationStack where you can</span>
<a name="l03281"></a>03281     <span class="comment">#         pass in, for example, a RecognitionException to get it's rule</span>
<a name="l03282"></a>03282     <span class="comment">#         stack trace.  This routine is shared with all recognizers, hence,</span>
<a name="l03283"></a>03283     <span class="comment">#         static.</span>
<a name="l03284"></a>03284     <span class="comment"># </span>
<a name="l03285"></a>03285     <span class="comment">#         TODO: move to a utility class or something; weird having lexer call</span>
<a name="l03286"></a>03286     <span class="comment">#         this</span>
<a name="l03287"></a>03287     <span class="comment">#         </span>
<a name="l03288"></a><a class="code" href="namespaceantlr3.html#059545afeb3b1d13a4478faa13845403">03288</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#6d7f1604b85132e62d117ea172b236fe">_getRuleInvocationStack</a>(cls, module):
<a name="l03289"></a>03289 
<a name="l03290"></a>03290         <span class="comment"># mmmhhh,... perhaps look at the first argument</span>
<a name="l03291"></a>03291         <span class="comment"># (f_locals[co_varnames[0]]?) and test if it's a (sub)class of</span>
<a name="l03292"></a>03292         <span class="comment"># requested recognizer...</span>
<a name="l03293"></a>03293         
<a name="l03294"></a>03294         rules = []
<a name="l03295"></a>03295         <span class="keywordflow">for</span> frame <span class="keywordflow">in</span> reversed(inspect.stack()):
<a name="l03296"></a>03296             code = frame[0].f_code
<a name="l03297"></a>03297             codeMod = inspect.getmodule(code)
<a name="l03298"></a>03298             <span class="keywordflow">if</span> codeMod <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l03299"></a>03299                 <span class="keywordflow">continue</span>
<a name="l03300"></a>03300 
<a name="l03301"></a>03301             <span class="comment"># skip frames not in requested module</span>
<a name="l03302"></a>03302             <span class="keywordflow">if</span> codeMod.__name__ != module:
<a name="l03303"></a>03303                 <span class="keywordflow">continue</span>
<a name="l03304"></a>03304 
<a name="l03305"></a>03305             <span class="comment"># skip some unwanted names</span>
<a name="l03306"></a>03306             <span class="keywordflow">if</span> code.co_name <span class="keywordflow">in</span> (<span class="stringliteral">'nextToken'</span>, <span class="stringliteral">'&lt;module&gt;'</span>):
<a name="l03307"></a>03307                 <span class="keywordflow">continue</span>
<a name="l03308"></a>03308 
<a name="l03309"></a>03309             rules.append(code.co_name)
<a name="l03310"></a>03310 
<a name="l03311"></a>03311         <span class="keywordflow">return</span> rules
<a name="l03312"></a>03312         
<a name="l03313"></a><a class="code" href="namespaceantlr3.html#6d7f1604b85132e62d117ea172b236fe">03313</a>     _getRuleInvocationStack = classmethod(_getRuleInvocationStack)
<a name="l03314"></a>03314     
<a name="l03315"></a>03315 
<a name="l03316"></a><a class="code" href="namespaceantlr3.html#950b3a03fc2c011a212f87812b32a68b">03316</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#950b3a03fc2c011a212f87812b32a68b">getBacktrackingLevel</a>(self):
<a name="l03317"></a>03317         <span class="keywordflow">return</span> self._state.backtracking
<a name="l03318"></a>03318 
<a name="l03319"></a><a class="code" href="namespaceantlr3.html#b6ac39dcc495aff56c39c244e9f6a7c5">03319</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#b6ac39dcc495aff56c39c244e9f6a7c5">setBacktrackingLevel</a>(self, n):
<a name="l03320"></a>03320         self._state.backtracking = n
<a name="l03321"></a>03321 
<a name="l03322"></a>03322 
<a name="l03323"></a>03323     <span class="comment">##</span>
<a name="l03324"></a>03324     <span class="comment"># Return whether or not a backtracking attempt failed.</span>
<a name="l03325"></a><a class="code" href="namespaceantlr3.html#faba664923df373a960ff970fd8f97ad">03325</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#faba664923df373a960ff970fd8f97ad" title="Return whether or not a backtracking attempt failed.">failed</a>(self):
<a name="l03326"></a>03326 
<a name="l03327"></a>03327         <span class="keywordflow">return</span> self._state.failed
<a name="l03328"></a>03328 
<a name="l03329"></a>03329 
<a name="l03330"></a>03330     <span class="comment">##</span>
<a name="l03331"></a>03331     <span class="comment"># For debugging and other purposes, might want the grammar name.</span>
<a name="l03332"></a>03332     <span class="comment">#         </span>
<a name="l03333"></a>03333     <span class="comment">#         Have ANTLR generate an implementation for this method.</span>
<a name="l03334"></a>03334     <span class="comment">#         </span>
<a name="l03335"></a><a class="code" href="namespaceantlr3.html#6c4c5ab99c500a9b89ec52fa60ca167c">03335</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#6c4c5ab99c500a9b89ec52fa60ca167c" title="For debugging and other purposes, might want the grammar name.">getGrammarFileName</a>(self):
<a name="l03336"></a>03336 
<a name="l03337"></a>03337         <span class="keywordflow">return</span> self.grammarFileName
<a name="l03338"></a>03338 
<a name="l03339"></a>03339 
<a name="l03340"></a><a class="code" href="namespaceantlr3.html#0cc509a43d9bda9408eaab82d97d1ffe">03340</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#0cc509a43d9bda9408eaab82d97d1ffe">getSourceName</a>(self):
<a name="l03341"></a>03341         <span class="keywordflow">raise</span> NotImplementedError
<a name="l03342"></a>03342 
<a name="l03343"></a>03343     
<a name="l03344"></a>03344     <span class="comment">##</span>
<a name="l03345"></a>03345     <span class="comment"># A convenience method for use most often with template rewrites.</span>
<a name="l03346"></a>03346     <span class="comment"># </span>
<a name="l03347"></a>03347     <span class="comment">#         Convert a List&lt;Token&gt; to List&lt;String&gt;</span>
<a name="l03348"></a>03348     <span class="comment">#         </span>
<a name="l03349"></a><a class="code" href="namespaceantlr3.html#d6213869a37841b1708a132ebb5bdee8">03349</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#d6213869a37841b1708a132ebb5bdee8" title="A convenience method for use most often with template rewrites.">toStrings</a>(self, tokens):
<a name="l03350"></a>03350 
<a name="l03351"></a>03351         <span class="keywordflow">if</span> tokens <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l03352"></a>03352             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03353"></a>03353 
<a name="l03354"></a>03354         <span class="keywordflow">return</span> [token.text <span class="keywordflow">for</span> token <span class="keywordflow">in</span> tokens]
<a name="l03355"></a>03355 
<a name="l03356"></a>03356 
<a name="l03357"></a>03357     <span class="comment">##</span>
<a name="l03358"></a>03358     <span class="comment"># </span>
<a name="l03359"></a>03359     <span class="comment">#         Given a rule number and a start token index number, return</span>
<a name="l03360"></a>03360     <span class="comment">#         MEMO_RULE_UNKNOWN if the rule has not parsed input starting from</span>
<a name="l03361"></a>03361     <span class="comment">#         start index.  If this rule has parsed input starting from the</span>
<a name="l03362"></a>03362     <span class="comment">#         start index before, then return where the rule stopped parsing.</span>
<a name="l03363"></a>03363     <span class="comment">#         It returns the index of the last token matched by the rule.</span>
<a name="l03364"></a>03364     <span class="comment">#         </span>
<a name="l03365"></a><a class="code" href="namespaceantlr3.html#7c916d47a40ba8742848959f1207a3cd">03365</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#7c916d47a40ba8742848959f1207a3cd" title="Given a rule number and a start token index number, return MEMO_RULE_UNKNOWN if the...">getRuleMemoization</a>(self, ruleIndex, ruleStartIndex):
<a name="l03366"></a>03366         
<a name="l03367"></a>03367         <span class="keywordflow">if</span> ruleIndex <span class="keywordflow">not</span> <span class="keywordflow">in</span> self._state.ruleMemo:
<a name="l03368"></a>03368             self._state.ruleMemo[ruleIndex] = {}
<a name="l03369"></a>03369 
<a name="l03370"></a>03370         <span class="keywordflow">return</span> self._state.ruleMemo[ruleIndex].get(
<a name="l03371"></a>03371             ruleStartIndex, self.MEMO_RULE_UNKNOWN
<a name="l03372"></a>03372             )
<a name="l03373"></a>03373 
<a name="l03374"></a>03374 
<a name="l03375"></a>03375     <span class="comment">##</span>
<a name="l03376"></a>03376     <span class="comment"># </span>
<a name="l03377"></a>03377     <span class="comment">#         Has this rule already parsed input at the current index in the</span>
<a name="l03378"></a>03378     <span class="comment">#         input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.</span>
<a name="l03379"></a>03379     <span class="comment">#         If we attempted but failed to parse properly before, return</span>
<a name="l03380"></a>03380     <span class="comment">#         MEMO_RULE_FAILED.</span>
<a name="l03381"></a>03381     <span class="comment"># </span>
<a name="l03382"></a>03382     <span class="comment">#         This method has a side-effect: if we have seen this input for</span>
<a name="l03383"></a>03383     <span class="comment">#         this rule and successfully parsed before, then seek ahead to</span>
<a name="l03384"></a>03384     <span class="comment">#         1 past the stop token matched for this rule last time.</span>
<a name="l03385"></a>03385     <span class="comment">#         </span>
<a name="l03386"></a><a class="code" href="namespaceantlr3.html#ff8a9a11b8e8e7d60eade54f8545e006">03386</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#ff8a9a11b8e8e7d60eade54f8545e006" title="Has this rule already parsed input at the current index in the input stream? Return...">alreadyParsedRule</a>(self, input, ruleIndex):
<a name="l03387"></a>03387 
<a name="l03388"></a>03388         stopIndex = self.getRuleMemoization(ruleIndex, input.index())
<a name="l03389"></a>03389         <span class="keywordflow">if</span> stopIndex == self.MEMO_RULE_UNKNOWN:
<a name="l03390"></a>03390             <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l03391"></a>03391 
<a name="l03392"></a>03392         <span class="keywordflow">if</span> stopIndex == self.MEMO_RULE_FAILED:
<a name="l03393"></a>03393             <span class="keywordflow">raise</span> BacktrackingFailed
<a name="l03394"></a>03394 
<a name="l03395"></a>03395         <span class="keywordflow">else</span>:
<a name="l03396"></a>03396             input.seek(stopIndex + 1)
<a name="l03397"></a>03397 
<a name="l03398"></a>03398         <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l03399"></a>03399 
<a name="l03400"></a>03400 
<a name="l03401"></a>03401     <span class="comment">##</span>
<a name="l03402"></a>03402     <span class="comment"># </span>
<a name="l03403"></a>03403     <span class="comment">#         Record whether or not this rule parsed the input at this position</span>
<a name="l03404"></a>03404     <span class="comment">#         successfully.</span>
<a name="l03405"></a>03405     <span class="comment">#         </span>
<a name="l03406"></a><a class="code" href="namespaceantlr3.html#89c29692ec30bd7dbf12405fd13b3246">03406</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#89c29692ec30bd7dbf12405fd13b3246" title="Record whether or not this rule parsed the input at this position successfully.">memoize</a>(self, input, ruleIndex, ruleStartIndex, success):
<a name="l03407"></a>03407 
<a name="l03408"></a>03408         <span class="keywordflow">if</span> success:
<a name="l03409"></a>03409             stopTokenIndex = input.index() - 1
<a name="l03410"></a>03410         <span class="keywordflow">else</span>:
<a name="l03411"></a>03411             stopTokenIndex = self.MEMO_RULE_FAILED
<a name="l03412"></a>03412         
<a name="l03413"></a>03413         <span class="keywordflow">if</span> ruleIndex <span class="keywordflow">in</span> self._state.ruleMemo:
<a name="l03414"></a>03414             self._state.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 
<a name="l03417"></a><a class="code" href="namespaceantlr3.html#171ebfb10e6c7e07555c5c49c90613bf">03417</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#171ebfb10e6c7e07555c5c49c90613bf">traceIn</a>(self, ruleName, ruleIndex, inputSymbol):
<a name="l03418"></a>03418         sys.stdout.write(<span class="stringliteral">"enter %s %s"</span> % (ruleName, inputSymbol))
<a name="l03419"></a>03419         
<a name="l03420"></a>03420         <span class="keywordflow">if</span> self._state.backtracking &gt; 0:
<a name="l03421"></a>03421             sys.stdout.write(<span class="stringliteral">" backtracking=%s"</span> % self._state.backtracking)
<a name="l03422"></a>03422 
<a name="l03423"></a>03423         sys.stdout.write(<span class="stringliteral">'\n'</span>)
<a name="l03424"></a>03424 
<a name="l03425"></a>03425 
<a name="l03426"></a><a class="code" href="namespaceantlr3.html#5a6e1fcdda845b386e7602eaa5535af0">03426</a>     <span class="keyword">def </span><a class="code" href="namespaceantlr3.html#5a6e1fcdda845b386e7602eaa5535af0">traceOut</a>(self, ruleName, ruleIndex, inputSymbol):
<a name="l03427"></a>03427         sys.stdout.write(<span class="stringliteral">"exit %s %s"</span> % (ruleName, inputSymbol))
<a name="l03428"></a>03428         
<a name="l03429"></a>03429         <span class="keywordflow">if</span> self._state.backtracking &gt; 0:
<a name="l03430"></a>03430             sys.stdout.write(<span class="stringliteral">" backtracking=%s"</span> % self._state.backtracking)
<a name="l03431"></a>03431 
<a name="l03432"></a>03432         <span class="keywordflow">if</span> self._state.failed:
<a name="l03433"></a>03433             sys.stdout.write(<span class="stringliteral">" failed"</span>)
<a name="l03434"></a>03434         <span class="keywordflow">else</span>:
<a name="l03435"></a>03435             sys.stdout.write(<span class="stringliteral">" succeeded"</span>)
<a name="l03436"></a>03436 
<a name="l03437"></a>03437         sys.stdout.write(<span class="stringliteral">'\n'</span>)
<a name="l03438"></a>03438 
<a name="l03439"></a>03439 
<a name="l03440"></a>03440 <span class="comment">##</span>
<a name="l03441"></a>03441 <span class="comment"># </span>
<a name="l03442"></a>03442 <span class="comment">#     @brief Abstract baseclass for token producers.</span>
<a name="l03443"></a>03443 <span class="comment">#     </span>
<a name="l03444"></a>03444 <span class="comment">#     A source of tokens must provide a sequence of tokens via nextToken()</span>
<a name="l03445"></a>03445 <span class="comment">#     and also must reveal it's source of characters; CommonToken's text is</span>
<a name="l03446"></a>03446 <span class="comment">#     computed from a CharStream; it only store indices into the char stream.</span>
<a name="l03447"></a>03447 <span class="comment"># </span>
<a name="l03448"></a>03448 <span class="comment">#     Errors from the lexer are never passed to the parser.  Either you want</span>
<a name="l03449"></a>03449 <span class="comment">#     to keep going or you do not upon token recognition error.  If you do not</span>
<a name="l03450"></a>03450 <span class="comment">#     want to continue lexing then you do not want to continue parsing.  Just</span>
<a name="l03451"></a>03451 <span class="comment">#     throw an exception not under RecognitionException and Java will naturally</span>
<a name="l03452"></a>03452 <span class="comment">#     toss you all the way out of the recognizers.  If you want to continue</span>
<a name="l03453"></a>03453 <span class="comment">#     lexing then you should not throw an exception to the parser--it has already</span>
<a name="l03454"></a>03454 <span class="comment">#     requested a token.  Keep lexing until you get a valid one.  Just report</span>
<a name="l03455"></a>03455 <span class="comment">#     errors and keep going, looking for a valid token.</span>
<a name="l03456"></a>03456 <span class="comment">#     </span>
<a name="l03457"></a><a class="code" href="classantlr3_1_1_token_source.html">03457</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_token_source.html" title="Abstract baseclass for token producers.">TokenSource</a>(object):
<a name="l03458"></a>03458     
<a name="l03459"></a>03459     <span class="comment">##</span>
<a name="l03460"></a>03460     <span class="comment"># Return a Token object from your input stream (usually a CharStream).</span>
<a name="l03461"></a>03461     <span class="comment">#         </span>
<a name="l03462"></a>03462     <span class="comment">#         Do not fail/return upon lexing error; keep chewing on the characters</span>
<a name="l03463"></a>03463     <span class="comment">#         until you get a good one; errors are not passed through to the parser.</span>
<a name="l03464"></a>03464     <span class="comment">#         </span>
<a name="l03465"></a><a class="code" href="classantlr3_1_1_token_source.html#09f0b8a5cccfb074588228e07cec6fce">03465</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_source.html#09f0b8a5cccfb074588228e07cec6fce" title="Return a Token object from your input stream (usually a CharStream).">nextToken</a>(self):
<a name="l03466"></a>03466 
<a name="l03467"></a>03467         <span class="keywordflow">raise</span> NotImplementedError
<a name="l03468"></a>03468     
<a name="l03469"></a>03469 
<a name="l03470"></a>03470     <span class="comment">##</span>
<a name="l03471"></a>03471     <span class="comment"># The TokenSource is an interator.</span>
<a name="l03472"></a>03472     <span class="comment"># </span>
<a name="l03473"></a>03473     <span class="comment">#         The iteration will not include the final EOF token, see also the note</span>
<a name="l03474"></a>03474     <span class="comment">#         for the next() method.</span>
<a name="l03475"></a>03475     <span class="comment"># </span>
<a name="l03476"></a>03476     <span class="comment">#         </span>
<a name="l03477"></a><a class="code" href="classantlr3_1_1_token_source.html#c72e9d8ab3306b9773d28355f2ae2076">03477</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_source.html#c72e9d8ab3306b9773d28355f2ae2076" title="The TokenSource is an interator.">__iter__</a>(self):
<a name="l03478"></a>03478         
<a name="l03479"></a>03479         <span class="keywordflow">return</span> self
<a name="l03480"></a>03480 
<a name="l03481"></a>03481     
<a name="l03482"></a>03482     <span class="comment">##</span>
<a name="l03483"></a>03483     <span class="comment"># Return next token or raise StopIteration.</span>
<a name="l03484"></a>03484     <span class="comment"># </span>
<a name="l03485"></a>03485     <span class="comment">#         Note that this will raise StopIteration when hitting the EOF token,</span>
<a name="l03486"></a>03486     <span class="comment">#         so EOF will not be part of the iteration.</span>
<a name="l03487"></a>03487     <span class="comment">#         </span>
<a name="l03488"></a>03488     <span class="comment">#         </span>
<a name="l03489"></a><a class="code" href="classantlr3_1_1_token_source.html#79fe7864d7e2ff8a9f80fc2d1dfb43f3">03489</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_token_source.html#79fe7864d7e2ff8a9f80fc2d1dfb43f3" title="Return next token or raise StopIteration.">next</a>(self):
<a name="l03490"></a>03490 
<a name="l03491"></a>03491         token = self.<a class="code" href="classantlr3_1_1_token_source.html#09f0b8a5cccfb074588228e07cec6fce" title="Return a Token object from your input stream (usually a CharStream).">nextToken</a>()
<a name="l03492"></a>03492         <span class="keywordflow">if</span> token <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> token.type == EOF:
<a name="l03493"></a>03493             <span class="keywordflow">raise</span> StopIteration
<a name="l03494"></a>03494         <span class="keywordflow">return</span> token
<a name="l03495"></a>03495 
<a name="l03496"></a>03496     
<a name="l03497"></a>03497 <span class="comment">##</span>
<a name="l03498"></a>03498 <span class="comment"># </span>
<a name="l03499"></a>03499 <span class="comment">#     @brief Baseclass for generated lexer classes.</span>
<a name="l03500"></a>03500 <span class="comment">#     </span>
<a name="l03501"></a>03501 <span class="comment">#     A lexer is recognizer that draws input symbols from a character stream.</span>
<a name="l03502"></a>03502 <span class="comment">#     lexer grammars result in a subclass of this object. A Lexer object</span>
<a name="l03503"></a>03503 <span class="comment">#     uses simplified match() and error recovery mechanisms in the interest</span>
<a name="l03504"></a>03504 <span class="comment">#     of speed.</span>
<a name="l03505"></a>03505 <span class="comment">#     </span>
<a name="l03506"></a><a class="code" href="classantlr3_1_1_lexer.html">03506</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_lexer.html" title="Baseclass for generated lexer classes.">Lexer</a>(<a class="code" href="classantlr3_1_1_base_recognizer.html" title="Common recognizer functionality.">BaseRecognizer</a>, <a class="code" href="classantlr3_1_1_token_source.html" title="Abstract baseclass for token producers.">TokenSource</a>):
<a name="l03507"></a>03507 
<a name="l03508"></a><a class="code" href="classantlr3_1_1_lexer.html#74e53d59110bce1b062fc83bb910c979">03508</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#74e53d59110bce1b062fc83bb910c979">__init__</a>(self, input, state=None):
<a name="l03509"></a>03509         BaseRecognizer.__init__(self, state)
<a name="l03510"></a>03510         TokenSource.__init__(self)
<a name="l03511"></a>03511         
<a name="l03512"></a>03512         <span class="comment"># Where is the lexer drawing characters from?</span>
<a name="l03513"></a><a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">03513</a>         self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a> = input
<a name="l03514"></a>03514 
<a name="l03515"></a>03515 
<a name="l03516"></a><a class="code" href="classantlr3_1_1_lexer.html#29edf8e62771c305453d36f01274c549">03516</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#29edf8e62771c305453d36f01274c549" title="reset the parser&amp;#39;s state; subclasses must rewinds the input stream">reset</a>(self):
<a name="l03517"></a>03517         BaseRecognizer.reset(self) <span class="comment"># reset all recognizer state variables</span>
<a name="l03518"></a>03518 
<a name="l03519"></a>03519         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a> <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l03520"></a>03520             <span class="comment"># rewind the input</span>
<a name="l03521"></a>03521             self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.seek(0)
<a name="l03522"></a>03522 
<a name="l03523"></a>03523         <span class="keywordflow">if</span> self._state <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l03524"></a>03524             <span class="comment"># no shared state work to do</span>
<a name="l03525"></a>03525             <span class="keywordflow">return</span>
<a name="l03526"></a>03526         
<a name="l03527"></a>03527         <span class="comment"># wack Lexer state variables</span>
<a name="l03528"></a>03528         self._state.token = <span class="keywordtype">None</span>
<a name="l03529"></a>03529         self._state.type = INVALID_TOKEN_TYPE
<a name="l03530"></a>03530         self._state.channel = DEFAULT_CHANNEL
<a name="l03531"></a>03531         self._state.tokenStartCharIndex = -1
<a name="l03532"></a>03532         self._state.tokenStartLine = -1
<a name="l03533"></a>03533         self._state.tokenStartCharPositionInLine = -1
<a name="l03534"></a>03534         self._state.text = <span class="keywordtype">None</span>
<a name="l03535"></a>03535 
<a name="l03536"></a>03536 
<a name="l03537"></a>03537     <span class="comment">##</span>
<a name="l03538"></a>03538     <span class="comment"># </span>
<a name="l03539"></a>03539     <span class="comment">#         Return a token from this source; i.e., match a token on the char</span>
<a name="l03540"></a>03540     <span class="comment">#         stream.</span>
<a name="l03541"></a>03541     <span class="comment">#         </span>
<a name="l03542"></a><a class="code" href="classantlr3_1_1_lexer.html#d633ccb60756cdf8ace999731b5c34fe">03542</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#d633ccb60756cdf8ace999731b5c34fe" title="Return a token from this source; i.e., match a token on the char stream.">nextToken</a>(self):
<a name="l03543"></a>03543         
<a name="l03544"></a>03544         <span class="keywordflow">while</span> 1:
<a name="l03545"></a>03545             self._state.token = <span class="keywordtype">None</span>
<a name="l03546"></a>03546             self._state.channel = DEFAULT_CHANNEL
<a name="l03547"></a>03547             self._state.tokenStartCharIndex = self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.index()
<a name="l03548"></a>03548             self._state.tokenStartCharPositionInLine = self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.charPositionInLine
<a name="l03549"></a>03549             self._state.tokenStartLine = self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.line
<a name="l03550"></a>03550             self._state.text = <span class="keywordtype">None</span>
<a name="l03551"></a>03551             <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LA(1) == EOF:
<a name="l03552"></a>03552                 <span class="keywordflow">return</span> EOF_TOKEN
<a name="l03553"></a>03553 
<a name="l03554"></a>03554             <span class="keywordflow">try</span>:
<a name="l03555"></a>03555                 self.<a class="code" href="classantlr3_1_1_lexer.html#9f59e332ade5fba382d70a5a8fd28a7d" title="This is the lexer entry point that sets instance var &amp;#39;token&amp;#39;.">mTokens</a>()
<a name="l03556"></a>03556                 
<a name="l03557"></a>03557                 <span class="keywordflow">if</span> self._state.token <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l03558"></a>03558                     self.<a class="code" href="classantlr3_1_1_lexer.html#bac8aa641541e980884f568c233c45ef" title="The standard method called to automatically emit a token at the outermost lexical...">emit</a>()
<a name="l03559"></a>03559                     
<a name="l03560"></a>03560                 <span class="keywordflow">elif</span> self._state.token == SKIP_TOKEN:
<a name="l03561"></a>03561                     <span class="keywordflow">continue</span>
<a name="l03562"></a>03562 
<a name="l03563"></a>03563                 <span class="keywordflow">return</span> self._state.token
<a name="l03564"></a>03564 
<a name="l03565"></a>03565             <span class="keywordflow">except</span> NoViableAltException, re:
<a name="l03566"></a>03566                 self.<a class="code" href="classantlr3_1_1_lexer.html#4b1d0de4fc42a8aeb6e710a679e9685a" title="Report a recognition problem.">reportError</a>(re)
<a name="l03567"></a>03567                 self.<a class="code" href="classantlr3_1_1_lexer.html#bb4254cc0d943c48b00eb18211bc0508" title="Lexers can normally match any char in it&amp;#39;s vocabulary after matching a token...">recover</a>(re) <span class="comment"># throw out current char and try again</span>
<a name="l03568"></a>03568 
<a name="l03569"></a>03569             <span class="keywordflow">except</span> RecognitionException, re:
<a name="l03570"></a>03570                 self.<a class="code" href="classantlr3_1_1_lexer.html#4b1d0de4fc42a8aeb6e710a679e9685a" title="Report a recognition problem.">reportError</a>(re)
<a name="l03571"></a>03571                 <span class="comment"># match() routine has already called recover()</span>
<a name="l03572"></a>03572 
<a name="l03573"></a>03573 
<a name="l03574"></a>03574     <span class="comment">##</span>
<a name="l03575"></a>03575     <span class="comment"># </span>
<a name="l03576"></a>03576     <span class="comment">#         Instruct the lexer to skip creating a token for current lexer rule</span>
<a name="l03577"></a>03577     <span class="comment">#         and look for another token.  nextToken() knows to keep looking when</span>
<a name="l03578"></a>03578     <span class="comment">#         a lexer rule finishes with token set to SKIP_TOKEN.  Recall that</span>
<a name="l03579"></a>03579     <span class="comment">#         if token==null at end of any token rule, it creates one for you</span>
<a name="l03580"></a>03580     <span class="comment">#         and emits it.</span>
<a name="l03581"></a>03581     <span class="comment">#         </span>
<a name="l03582"></a><a class="code" href="classantlr3_1_1_lexer.html#533cae4c5264b3cb7aad7a0de5b9e52a">03582</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#533cae4c5264b3cb7aad7a0de5b9e52a" title="Instruct the lexer to skip creating a token for current lexer rule and look for another...">skip</a>(self):
<a name="l03583"></a>03583         
<a name="l03584"></a>03584         self._state.token = SKIP_TOKEN
<a name="l03585"></a>03585 
<a name="l03586"></a>03586 
<a name="l03587"></a>03587     <span class="comment">##</span>
<a name="l03588"></a>03588     <span class="comment"># This is the lexer entry point that sets instance var 'token'</span>
<a name="l03589"></a><a class="code" href="classantlr3_1_1_lexer.html#9f59e332ade5fba382d70a5a8fd28a7d">03589</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#9f59e332ade5fba382d70a5a8fd28a7d" title="This is the lexer entry point that sets instance var &amp;#39;token&amp;#39;.">mTokens</a>(self):
<a name="l03590"></a>03590 
<a name="l03591"></a>03591         <span class="comment"># abstract method</span>
<a name="l03592"></a>03592         <span class="keywordflow">raise</span> NotImplementedError
<a name="l03593"></a>03593     
<a name="l03594"></a>03594 
<a name="l03595"></a>03595     <span class="comment">##</span>
<a name="l03596"></a>03596     <span class="comment"># Set the char stream and reset the lexer</span>
<a name="l03597"></a><a class="code" href="classantlr3_1_1_lexer.html#b41a2e6af54a6ee3f512fce27c857456">03597</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#b41a2e6af54a6ee3f512fce27c857456" title="Set the char stream and reset the lexer.">setCharStream</a>(self, input):
<a name="l03598"></a>03598         self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a> = <span class="keywordtype">None</span>
<a name="l03599"></a>03599         self.<a class="code" href="classantlr3_1_1_lexer.html#29edf8e62771c305453d36f01274c549" title="reset the parser&amp;#39;s state; subclasses must rewinds the input stream">reset</a>()
<a name="l03600"></a>03600         self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a> = input
<a name="l03601"></a>03601 
<a name="l03602"></a>03602 
<a name="l03603"></a><a class="code" href="classantlr3_1_1_lexer.html#76097677aaa448f400077591a747d32a">03603</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#76097677aaa448f400077591a747d32a">getSourceName</a>(self):
<a name="l03604"></a>03604         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.getSourceName()
<a name="l03605"></a>03605 
<a name="l03606"></a>03606 
<a name="l03607"></a>03607     <span class="comment">##</span>
<a name="l03608"></a>03608     <span class="comment"># </span>
<a name="l03609"></a>03609     <span class="comment">#         The standard method called to automatically emit a token at the</span>
<a name="l03610"></a>03610     <span class="comment">#         outermost lexical rule.  The token object should point into the</span>
<a name="l03611"></a>03611     <span class="comment">#         char buffer start..stop.  If there is a text override in 'text',</span>
<a name="l03612"></a>03612     <span class="comment">#         use that to set the token's text.  Override this method to emit</span>
<a name="l03613"></a>03613     <span class="comment">#         custom Token objects.</span>
<a name="l03614"></a>03614     <span class="comment"># </span>
<a name="l03615"></a>03615     <span class="comment">#         If you are building trees, then you should also override</span>
<a name="l03616"></a>03616     <span class="comment">#         Parser or TreeParser.getMissingSymbol().</span>
<a name="l03617"></a>03617     <span class="comment">#         </span>
<a name="l03618"></a><a class="code" href="classantlr3_1_1_lexer.html#bac8aa641541e980884f568c233c45ef">03618</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#bac8aa641541e980884f568c233c45ef" title="The standard method called to automatically emit a token at the outermost lexical...">emit</a>(self, token=None):
<a name="l03619"></a>03619 
<a name="l03620"></a>03620         <span class="keywordflow">if</span> token <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l03621"></a>03621             token = CommonToken(
<a name="l03622"></a>03622                 input=self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>,
<a name="l03623"></a>03623                 type=self._state.type,
<a name="l03624"></a>03624                 channel=self._state.channel,
<a name="l03625"></a>03625                 start=self._state.tokenStartCharIndex,
<a name="l03626"></a>03626                 stop=self.<a class="code" href="classantlr3_1_1_lexer.html#46df9f51cc8f00164920ac2b1266b525" title="What is the index of the current character of lookahead?">getCharIndex</a>()-1
<a name="l03627"></a>03627                 )
<a name="l03628"></a>03628             token.line = self._state.tokenStartLine
<a name="l03629"></a>03629             token.text = self._state.text
<a name="l03630"></a>03630             token.charPositionInLine = self._state.tokenStartCharPositionInLine
<a name="l03631"></a>03631 
<a name="l03632"></a>03632         self._state.token = token
<a name="l03633"></a>03633         
<a name="l03634"></a>03634         <span class="keywordflow">return</span> token
<a name="l03635"></a>03635 
<a name="l03636"></a>03636 
<a name="l03637"></a><a class="code" href="classantlr3_1_1_lexer.html#350413cd1ec71fcfe4398c2bb48fd0f6">03637</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#350413cd1ec71fcfe4398c2bb48fd0f6">match</a>(self, s):
<a name="l03638"></a>03638         <span class="keywordflow">if</span> isinstance(s, basestring):
<a name="l03639"></a>03639             <span class="keywordflow">for</span> c <span class="keywordflow">in</span> s:
<a name="l03640"></a>03640                 <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LA(1) != ord(c):
<a name="l03641"></a>03641                     <span class="keywordflow">if</span> self._state.backtracking &gt; 0:
<a name="l03642"></a>03642                         <span class="keywordflow">raise</span> BacktrackingFailed
<a name="l03643"></a>03643 
<a name="l03644"></a>03644                     mte = MismatchedTokenException(c, self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>)
<a name="l03645"></a>03645                     self.<a class="code" href="classantlr3_1_1_lexer.html#bb4254cc0d943c48b00eb18211bc0508" title="Lexers can normally match any char in it&amp;#39;s vocabulary after matching a token...">recover</a>(mte)
<a name="l03646"></a>03646                     <span class="keywordflow">raise</span> mte
<a name="l03647"></a>03647 
<a name="l03648"></a>03648                 self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.consume()
<a name="l03649"></a>03649 
<a name="l03650"></a>03650         <span class="keywordflow">else</span>:
<a name="l03651"></a>03651             <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LA(1) != s:
<a name="l03652"></a>03652                 <span class="keywordflow">if</span> self._state.backtracking &gt; 0:
<a name="l03653"></a>03653                     <span class="keywordflow">raise</span> BacktrackingFailed
<a name="l03654"></a>03654 
<a name="l03655"></a>03655                 mte = MismatchedTokenException(unichr(s), self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>)
<a name="l03656"></a>03656                 self.<a class="code" href="classantlr3_1_1_lexer.html#bb4254cc0d943c48b00eb18211bc0508" title="Lexers can normally match any char in it&amp;#39;s vocabulary after matching a token...">recover</a>(mte) <span class="comment"># don't really recover; just consume in lexer</span>
<a name="l03657"></a>03657                 <span class="keywordflow">raise</span> mte
<a name="l03658"></a>03658         
<a name="l03659"></a>03659             self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.consume()
<a name="l03660"></a>03660             
<a name="l03661"></a>03661 
<a name="l03662"></a><a class="code" href="classantlr3_1_1_lexer.html#f48c182a0d03c582e8ffbf961d28cd0f">03662</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#f48c182a0d03c582e8ffbf961d28cd0f">matchAny</a>(self):
<a name="l03663"></a>03663         self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.consume()
<a name="l03664"></a>03664 
<a name="l03665"></a>03665 
<a name="l03666"></a><a class="code" href="classantlr3_1_1_lexer.html#2a2d97b6adedd28b7c85ef4c03b057f1">03666</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#2a2d97b6adedd28b7c85ef4c03b057f1">matchRange</a>(self, a, b):
<a name="l03667"></a>03667         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LA(1) &lt; a <span class="keywordflow">or</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LA(1) &gt; b:
<a name="l03668"></a>03668             <span class="keywordflow">if</span> self._state.backtracking &gt; 0:
<a name="l03669"></a>03669                 <span class="keywordflow">raise</span> BacktrackingFailed
<a name="l03670"></a>03670 
<a name="l03671"></a>03671             mre = MismatchedRangeException(unichr(a), unichr(b), self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>)
<a name="l03672"></a>03672             self.<a class="code" href="classantlr3_1_1_lexer.html#bb4254cc0d943c48b00eb18211bc0508" title="Lexers can normally match any char in it&amp;#39;s vocabulary after matching a token...">recover</a>(mre)
<a name="l03673"></a>03673             <span class="keywordflow">raise</span> mre
<a name="l03674"></a>03674 
<a name="l03675"></a>03675         self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.consume()
<a name="l03676"></a>03676 
<a name="l03677"></a>03677 
<a name="l03678"></a><a class="code" href="classantlr3_1_1_lexer.html#5a42346955050d8e972d42aaf77946f0">03678</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#5a42346955050d8e972d42aaf77946f0">getLine</a>(self):
<a name="l03679"></a>03679         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.line
<a name="l03680"></a>03680 
<a name="l03681"></a>03681 
<a name="l03682"></a><a class="code" href="classantlr3_1_1_lexer.html#c5c70673f2bff276763349952773ff4d">03682</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#c5c70673f2bff276763349952773ff4d">getCharPositionInLine</a>(self):
<a name="l03683"></a>03683         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.charPositionInLine
<a name="l03684"></a>03684 
<a name="l03685"></a>03685 
<a name="l03686"></a>03686     <span class="comment">##</span>
<a name="l03687"></a>03687     <span class="comment"># What is the index of the current character of lookahead?</span>
<a name="l03688"></a><a class="code" href="classantlr3_1_1_lexer.html#46df9f51cc8f00164920ac2b1266b525">03688</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#46df9f51cc8f00164920ac2b1266b525" title="What is the index of the current character of lookahead?">getCharIndex</a>(self):
<a name="l03689"></a>03689         
<a name="l03690"></a>03690         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.index()
<a name="l03691"></a>03691 
<a name="l03692"></a>03692 
<a name="l03693"></a>03693     <span class="comment">##</span>
<a name="l03694"></a>03694     <span class="comment"># </span>
<a name="l03695"></a>03695     <span class="comment">#         Return the text matched so far for the current token or any</span>
<a name="l03696"></a>03696     <span class="comment">#         text override.</span>
<a name="l03697"></a>03697     <span class="comment">#         </span>
<a name="l03698"></a><a class="code" href="classantlr3_1_1_lexer.html#4e911287d18275b19710beeb1f60ae16">03698</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#4e911287d18275b19710beeb1f60ae16" title="Return the text matched so far for the current token or any text override.">getText</a>(self):
<a name="l03699"></a>03699         <span class="keywordflow">if</span> self._state.text <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l03700"></a>03700             <span class="keywordflow">return</span> self._state.text
<a name="l03701"></a>03701         
<a name="l03702"></a>03702         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.substring(
<a name="l03703"></a>03703             self._state.tokenStartCharIndex,
<a name="l03704"></a>03704             self.<a class="code" href="classantlr3_1_1_lexer.html#46df9f51cc8f00164920ac2b1266b525" title="What is the index of the current character of lookahead?">getCharIndex</a>()-1
<a name="l03705"></a>03705             )
<a name="l03706"></a>03706 
<a name="l03707"></a>03707 
<a name="l03708"></a>03708     <span class="comment">##</span>
<a name="l03709"></a>03709     <span class="comment"># </span>
<a name="l03710"></a>03710     <span class="comment">#         Set the complete text of this token; it wipes any previous</span>
<a name="l03711"></a>03711     <span class="comment">#         changes to the text.</span>
<a name="l03712"></a>03712     <span class="comment">#         </span>
<a name="l03713"></a><a class="code" href="classantlr3_1_1_lexer.html#f9b291f493a490b60ab93039c248ee0e">03713</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#f9b291f493a490b60ab93039c248ee0e" title="Set the complete text of this token; it wipes any previous changes to the text.">setText</a>(self, text):
<a name="l03714"></a>03714         self._state.text = text
<a name="l03715"></a>03715 
<a name="l03716"></a>03716 
<a name="l03717"></a><a class="code" href="classantlr3_1_1_lexer.html#4a35fe00d3cec12f4f837d66a2efc8f2">03717</a>     text = property(getText, setText)
<a name="l03718"></a>03718 
<a name="l03719"></a>03719 
<a name="l03720"></a><a class="code" href="classantlr3_1_1_lexer.html#4b1d0de4fc42a8aeb6e710a679e9685a">03720</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#4b1d0de4fc42a8aeb6e710a679e9685a" title="Report a recognition problem.">reportError</a>(self, e):
<a name="l03721"></a>03721         <span class="comment">## TODO: not thought about recovery in lexer yet.</span>
<a name="l03722"></a>03722 
<a name="l03723"></a>03723         <span class="comment">## # if we've already reported an error and have not matched a token</span>
<a name="l03724"></a>03724         <span class="comment">## # yet successfully, don't report any errors.</span>
<a name="l03725"></a>03725         <span class="comment">## if self.errorRecovery:</span>
<a name="l03726"></a>03726         <span class="comment">##     #System.err.print("[SPURIOUS] ");</span>
<a name="l03727"></a>03727         <span class="comment">##     return;</span>
<a name="l03728"></a>03728         <span class="comment">## </span>
<a name="l03729"></a>03729         <span class="comment">## self.errorRecovery = True</span>
<a name="l03730"></a>03730 
<a name="l03731"></a>03731         self.displayRecognitionError(self.tokenNames, e)
<a name="l03732"></a>03732 
<a name="l03733"></a>03733 
<a name="l03734"></a><a class="code" href="classantlr3_1_1_lexer.html#852eab357ba7951afc4573435eadd580">03734</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#852eab357ba7951afc4573435eadd580" title="What error message should be generated for the various exception types?">getErrorMessage</a>(self, e, tokenNames):
<a name="l03735"></a>03735         msg = <span class="keywordtype">None</span>
<a name="l03736"></a>03736         
<a name="l03737"></a>03737         <span class="keywordflow">if</span> isinstance(e, MismatchedTokenException):
<a name="l03738"></a>03738             msg = <span class="stringliteral">"mismatched character "</span> \
<a name="l03739"></a>03739                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.c) \
<a name="l03740"></a>03740                   + <span class="stringliteral">" expecting "</span> \
<a name="l03741"></a>03741                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.expecting)
<a name="l03742"></a>03742 
<a name="l03743"></a>03743         <span class="keywordflow">elif</span> isinstance(e, NoViableAltException):
<a name="l03744"></a>03744             msg = <span class="stringliteral">"no viable alternative at character "</span> \
<a name="l03745"></a>03745                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.c)
<a name="l03746"></a>03746 
<a name="l03747"></a>03747         <span class="keywordflow">elif</span> isinstance(e, EarlyExitException):
<a name="l03748"></a>03748             msg = <span class="stringliteral">"required (...)+ loop did not match anything at character "</span> \
<a name="l03749"></a>03749                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.c)
<a name="l03750"></a>03750             
<a name="l03751"></a>03751         <span class="keywordflow">elif</span> isinstance(e, MismatchedNotSetException):
<a name="l03752"></a>03752             msg = <span class="stringliteral">"mismatched character "</span> \
<a name="l03753"></a>03753                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.c) \
<a name="l03754"></a>03754                   + <span class="stringliteral">" expecting set "</span> \
<a name="l03755"></a>03755                   + repr(e.expecting)
<a name="l03756"></a>03756 
<a name="l03757"></a>03757         <span class="keywordflow">elif</span> isinstance(e, MismatchedSetException):
<a name="l03758"></a>03758             msg = <span class="stringliteral">"mismatched character "</span> \
<a name="l03759"></a>03759                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.c) \
<a name="l03760"></a>03760                   + <span class="stringliteral">" expecting set "</span> \
<a name="l03761"></a>03761                   + repr(e.expecting)
<a name="l03762"></a>03762 
<a name="l03763"></a>03763         <span class="keywordflow">elif</span> isinstance(e, MismatchedRangeException):
<a name="l03764"></a>03764             msg = <span class="stringliteral">"mismatched character "</span> \
<a name="l03765"></a>03765                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.c) \
<a name="l03766"></a>03766                   + <span class="stringliteral">" expecting set "</span> \
<a name="l03767"></a>03767                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.a) \
<a name="l03768"></a>03768                   + <span class="stringliteral">".."</span> \
<a name="l03769"></a>03769                   + self.<a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(e.b)
<a name="l03770"></a>03770 
<a name="l03771"></a>03771         <span class="keywordflow">else</span>:
<a name="l03772"></a>03772             msg = BaseRecognizer.getErrorMessage(self, e, tokenNames)
<a name="l03773"></a>03773 
<a name="l03774"></a>03774         <span class="keywordflow">return</span> msg
<a name="l03775"></a>03775 
<a name="l03776"></a>03776 
<a name="l03777"></a><a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">03777</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#be57e655a815947cb2ece616198a346e">getCharErrorDisplay</a>(self, c):
<a name="l03778"></a>03778         <span class="keywordflow">if</span> c == EOF:
<a name="l03779"></a>03779             c = <span class="stringliteral">'&lt;EOF&gt;'</span>
<a name="l03780"></a>03780         <span class="keywordflow">return</span> repr(c)
<a name="l03781"></a>03781 
<a name="l03782"></a>03782 
<a name="l03783"></a>03783     <span class="comment">##</span>
<a name="l03784"></a>03784     <span class="comment"># </span>
<a name="l03785"></a>03785     <span class="comment">#         Lexers can normally match any char in it's vocabulary after matching</span>
<a name="l03786"></a>03786     <span class="comment">#         a token, so do the easy thing and just kill a character and hope</span>
<a name="l03787"></a>03787     <span class="comment">#         it all works out.  You can instead use the rule invocation stack</span>
<a name="l03788"></a>03788     <span class="comment">#         to do sophisticated error recovery if you are in a fragment rule.</span>
<a name="l03789"></a>03789     <span class="comment">#         </span>
<a name="l03790"></a><a class="code" href="classantlr3_1_1_lexer.html#bb4254cc0d943c48b00eb18211bc0508">03790</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#bb4254cc0d943c48b00eb18211bc0508" title="Lexers can normally match any char in it&amp;#39;s vocabulary after matching a token...">recover</a>(self, re):
<a name="l03791"></a>03791 
<a name="l03792"></a>03792         self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.consume()
<a name="l03793"></a>03793 
<a name="l03794"></a>03794 
<a name="l03795"></a><a class="code" href="classantlr3_1_1_lexer.html#1135ed0da5c1d2a649b3bd4b46dc7aa3">03795</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#1135ed0da5c1d2a649b3bd4b46dc7aa3">traceIn</a>(self, ruleName, ruleIndex):
<a name="l03796"></a>03796         inputSymbol = <span class="stringliteral">"%s line=%d:%s"</span> % (self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LT(1),
<a name="l03797"></a>03797                                          self.<a class="code" href="classantlr3_1_1_lexer.html#5a42346955050d8e972d42aaf77946f0">getLine</a>(),
<a name="l03798"></a>03798                                          self.<a class="code" href="classantlr3_1_1_lexer.html#c5c70673f2bff276763349952773ff4d">getCharPositionInLine</a>()
<a name="l03799"></a>03799                                          )
<a name="l03800"></a>03800         
<a name="l03801"></a>03801         BaseRecognizer.traceIn(self, ruleName, ruleIndex, inputSymbol)
<a name="l03802"></a>03802 
<a name="l03803"></a>03803 
<a name="l03804"></a><a class="code" href="classantlr3_1_1_lexer.html#8a897d310b03b49044c3bab6136624dd">03804</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_lexer.html#8a897d310b03b49044c3bab6136624dd">traceOut</a>(self, ruleName, ruleIndex):
<a name="l03805"></a>03805         inputSymbol = <span class="stringliteral">"%s line=%d:%s"</span> % (self.<a class="code" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">input</a>.LT(1),
<a name="l03806"></a>03806                                          self.<a class="code" href="classantlr3_1_1_lexer.html#5a42346955050d8e972d42aaf77946f0">getLine</a>(),
<a name="l03807"></a>03807                                          self.<a class="code" href="classantlr3_1_1_lexer.html#c5c70673f2bff276763349952773ff4d">getCharPositionInLine</a>()
<a name="l03808"></a>03808                                          )
<a name="l03809"></a>03809 
<a name="l03810"></a>03810         BaseRecognizer.traceOut(self, ruleName, ruleIndex, inputSymbol)
<a name="l03811"></a>03811 
<a name="l03812"></a>03812 
<a name="l03813"></a>03813 
<a name="l03814"></a>03814 <span class="comment">##</span>
<a name="l03815"></a>03815 <span class="comment"># </span>
<a name="l03816"></a>03816 <span class="comment">#     @brief Baseclass for generated parser classes.</span>
<a name="l03817"></a>03817 <span class="comment">#     </span>
<a name="l03818"></a><a class="code" href="classantlr3_1_1_parser.html">03818</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_parser.html" title="Baseclass for generated parser classes.">Parser</a>(<a class="code" href="classantlr3_1_1_base_recognizer.html" title="Common recognizer functionality.">BaseRecognizer</a>):
<a name="l03819"></a>03819     
<a name="l03820"></a><a class="code" href="classantlr3_1_1_parser.html#0079b9cdfe66a0860bd34dd2375fcb9f">03820</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#0079b9cdfe66a0860bd34dd2375fcb9f">__init__</a>(self, lexer, state=None):
<a name="l03821"></a>03821         BaseRecognizer.__init__(self, state)
<a name="l03822"></a>03822 
<a name="l03823"></a>03823         self.<a class="code" href="classantlr3_1_1_parser.html#89a7d6c25c8038ba8e46b30970aaee74" title="Set the token stream and reset the parser.">setTokenStream</a>(lexer)
<a name="l03824"></a>03824 
<a name="l03825"></a>03825 
<a name="l03826"></a><a class="code" href="classantlr3_1_1_parser.html#c2d71fcc004605787060040dfdcf2849">03826</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#c2d71fcc004605787060040dfdcf2849" title="reset the parser&amp;#39;s state; subclasses must rewinds the input stream">reset</a>(self):
<a name="l03827"></a>03827         BaseRecognizer.reset(self) <span class="comment"># reset all recognizer state variables</span>
<a name="l03828"></a>03828         <span class="keywordflow">if</span> self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a> <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l03829"></a>03829             self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a>.seek(0) <span class="comment"># rewind the input</span>
<a name="l03830"></a>03830 
<a name="l03831"></a>03831 
<a name="l03832"></a><a class="code" href="classantlr3_1_1_parser.html#6f86c1c0533ffb0227299a050c4267de">03832</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#6f86c1c0533ffb0227299a050c4267de" title="Match needs to return the current input symbol, which gets put into the label for...">getCurrentInputSymbol</a>(self, input):
<a name="l03833"></a>03833         <span class="keywordflow">return</span> input.LT(1)
<a name="l03834"></a>03834 
<a name="l03835"></a>03835 
<a name="l03836"></a><a class="code" href="classantlr3_1_1_parser.html#8095ef77285cd2c5603f21490be97935">03836</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#8095ef77285cd2c5603f21490be97935" title="Conjure up a missing token during error recovery.">getMissingSymbol</a>(self, input, e, expectedTokenType, follow):
<a name="l03837"></a>03837         <span class="keywordflow">if</span> expectedTokenType == EOF:
<a name="l03838"></a>03838             tokenText = <span class="stringliteral">"&lt;missing EOF&gt;"</span>
<a name="l03839"></a>03839         <span class="keywordflow">else</span>:
<a name="l03840"></a>03840             tokenText = <span class="stringliteral">"&lt;missing "</span> + self.tokenNames[expectedTokenType] + <span class="stringliteral">"&gt;"</span>
<a name="l03841"></a>03841         t = CommonToken(type=expectedTokenType, text=tokenText)
<a name="l03842"></a>03842         current = input.LT(1)
<a name="l03843"></a>03843         <span class="keywordflow">if</span> current.type == EOF:
<a name="l03844"></a>03844             current = input.LT(-1)
<a name="l03845"></a>03845 
<a name="l03846"></a>03846         <span class="keywordflow">if</span> current <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l03847"></a>03847             t.line = current.line
<a name="l03848"></a>03848             t.charPositionInLine = current.charPositionInLine
<a name="l03849"></a>03849         t.channel = DEFAULT_CHANNEL
<a name="l03850"></a>03850         <span class="keywordflow">return</span> t
<a name="l03851"></a>03851 
<a name="l03852"></a>03852 
<a name="l03853"></a>03853     <span class="comment">##</span>
<a name="l03854"></a>03854     <span class="comment"># Set the token stream and reset the parser</span>
<a name="l03855"></a><a class="code" href="classantlr3_1_1_parser.html#89a7d6c25c8038ba8e46b30970aaee74">03855</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#89a7d6c25c8038ba8e46b30970aaee74" title="Set the token stream and reset the parser.">setTokenStream</a>(self, input):
<a name="l03856"></a>03856         
<a name="l03857"></a><a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">03857</a>         self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a> = <span class="keywordtype">None</span>
<a name="l03858"></a>03858         self.<a class="code" href="classantlr3_1_1_parser.html#c2d71fcc004605787060040dfdcf2849" title="reset the parser&amp;#39;s state; subclasses must rewinds the input stream">reset</a>()
<a name="l03859"></a>03859         self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a> = input
<a name="l03860"></a>03860 
<a name="l03861"></a>03861 
<a name="l03862"></a><a class="code" href="classantlr3_1_1_parser.html#446bb0ccb748dabbbbe8dd98b0242125">03862</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#446bb0ccb748dabbbbe8dd98b0242125">getTokenStream</a>(self):
<a name="l03863"></a>03863         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a>
<a name="l03864"></a>03864 
<a name="l03865"></a>03865 
<a name="l03866"></a><a class="code" href="classantlr3_1_1_parser.html#4b8f6543520e64aac8bb88dc21dfd734">03866</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#4b8f6543520e64aac8bb88dc21dfd734">getSourceName</a>(self):
<a name="l03867"></a>03867         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a>.getSourceName()
<a name="l03868"></a>03868 
<a name="l03869"></a>03869 
<a name="l03870"></a><a class="code" href="classantlr3_1_1_parser.html#acf2e4dbd1e43e43c8b4ab5a43c0934a">03870</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#acf2e4dbd1e43e43c8b4ab5a43c0934a">traceIn</a>(self, ruleName, ruleIndex):
<a name="l03871"></a>03871         BaseRecognizer.traceIn(self, ruleName, ruleIndex, self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a>.LT(1))
<a name="l03872"></a>03872 
<a name="l03873"></a>03873 
<a name="l03874"></a><a class="code" href="classantlr3_1_1_parser.html#8363b0b824e0fb175e1dcd66aa88c564">03874</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser.html#8363b0b824e0fb175e1dcd66aa88c564">traceOut</a>(self, ruleName, ruleIndex):
<a name="l03875"></a>03875         BaseRecognizer.traceOut(self, ruleName, ruleIndex, self.<a class="code" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">input</a>.LT(1))
<a name="l03876"></a>03876 
<a name="l03877"></a>03877 
<a name="l03878"></a>03878 <span class="comment">##</span>
<a name="l03879"></a>03879 <span class="comment"># </span>
<a name="l03880"></a>03880 <span class="comment">#     Rules can return start/stop info as well as possible trees and templates.</span>
<a name="l03881"></a>03881 <span class="comment">#     </span>
<a name="l03882"></a><a class="code" href="classantlr3_1_1_rule_return_scope.html">03882</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_rule_return_scope.html" title="Rules can return start/stop info as well as possible trees and templates.">RuleReturnScope</a>(object):
<a name="l03883"></a>03883 
<a name="l03884"></a>03884     <span class="comment">##</span>
<a name="l03885"></a>03885     <span class="comment"># Return the start token or tree.</span>
<a name="l03886"></a><a class="code" href="classantlr3_1_1_rule_return_scope.html#4a594d8bed1a80626ea1e126319dd657">03886</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rule_return_scope.html#4a594d8bed1a80626ea1e126319dd657" title="Return the start token or tree.">getStart</a>(self):
<a name="l03887"></a>03887         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03888"></a>03888     
<a name="l03889"></a>03889 
<a name="l03890"></a>03890     <span class="comment">##</span>
<a name="l03891"></a>03891     <span class="comment"># Return the stop token or tree.</span>
<a name="l03892"></a><a class="code" href="classantlr3_1_1_rule_return_scope.html#01fcdd34d25edad52f8860eda3212821">03892</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rule_return_scope.html#01fcdd34d25edad52f8860eda3212821" title="Return the stop token or tree.">getStop</a>(self):
<a name="l03893"></a>03893         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03894"></a>03894 
<a name="l03895"></a>03895     
<a name="l03896"></a>03896     <span class="comment">##</span>
<a name="l03897"></a>03897     <span class="comment"># Has a value potentially if output=AST.</span>
<a name="l03898"></a><a class="code" href="classantlr3_1_1_rule_return_scope.html#d71d04d8c6dba76d57e068208a5cab2e">03898</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rule_return_scope.html#d71d04d8c6dba76d57e068208a5cab2e" title="Has a value potentially if output=AST.">getTree</a>(self):
<a name="l03899"></a>03899         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03900"></a>03900 
<a name="l03901"></a>03901 
<a name="l03902"></a>03902     <span class="comment">##</span>
<a name="l03903"></a>03903     <span class="comment"># Has a value potentially if output=template.</span>
<a name="l03904"></a><a class="code" href="classantlr3_1_1_rule_return_scope.html#44ae380a0cc19c758cd959deb2098291">03904</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_rule_return_scope.html#44ae380a0cc19c758cd959deb2098291" title="Has a value potentially if output=template.">getTemplate</a>(self):
<a name="l03905"></a>03905         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l03906"></a>03906 
<a name="l03907"></a>03907 
<a name="l03908"></a>03908 <span class="comment">##</span>
<a name="l03909"></a>03909 <span class="comment"># </span>
<a name="l03910"></a>03910 <span class="comment">#     Rules that return more than a single value must return an object</span>
<a name="l03911"></a>03911 <span class="comment">#     containing all the values.  Besides the properties defined in</span>
<a name="l03912"></a>03912 <span class="comment">#     RuleLabelScope.predefinedRulePropertiesScope there may be user-defined</span>
<a name="l03913"></a>03913 <span class="comment">#     return values.  This class simply defines the minimum properties that</span>
<a name="l03914"></a>03914 <span class="comment">#     are always defined and methods to access the others that might be</span>
<a name="l03915"></a>03915 <span class="comment">#     available depending on output option such as template and tree.</span>
<a name="l03916"></a>03916 <span class="comment"># </span>
<a name="l03917"></a>03917 <span class="comment">#     Note text is not an actual property of the return value, it is computed</span>
<a name="l03918"></a>03918 <span class="comment">#     from start and stop using the input stream's toString() method.  I</span>
<a name="l03919"></a>03919 <span class="comment">#     could add a ctor to this so that we can pass in and store the input</span>
<a name="l03920"></a>03920 <span class="comment">#     stream, but I'm not sure we want to do that.  It would seem to be undefined</span>
<a name="l03921"></a>03921 <span class="comment">#     to get the .text property anyway if the rule matches tokens from multiple</span>
<a name="l03922"></a>03922 <span class="comment">#     input streams.</span>
<a name="l03923"></a>03923 <span class="comment"># </span>
<a name="l03924"></a>03924 <span class="comment">#     I do not use getters for fields of objects that are used simply to</span>
<a name="l03925"></a>03925 <span class="comment">#     group values such as this aggregate.  The getters/setters are there to</span>
<a name="l03926"></a>03926 <span class="comment">#     satisfy the superclass interface.</span>
<a name="l03927"></a>03927 <span class="comment">#     </span>
<a name="l03928"></a><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html">03928</a> <span class="keyword">class </span><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html" title="Rules that return more than a single value must return an object containing all the...">ParserRuleReturnScope</a>(<a class="code" href="classantlr3_1_1_rule_return_scope.html" title="Rules can return start/stop info as well as possible trees and templates.">RuleReturnScope</a>):
<a name="l03929"></a>03929 
<a name="l03930"></a><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#43c138a0df455b9bc1b5b7dee4923c02">03930</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#43c138a0df455b9bc1b5b7dee4923c02">__init__</a>(self):
<a name="l03931"></a><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#bdadd7a724ae2b7f7014a8f44e8ac3aa">03931</a>         self.<a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#bdadd7a724ae2b7f7014a8f44e8ac3aa">start</a> = <span class="keywordtype">None</span>
<a name="l03932"></a><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#2c27996ee1edb3edb568db89d348fbdc">03932</a>         self.<a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#2c27996ee1edb3edb568db89d348fbdc">stop</a> = <span class="keywordtype">None</span>
<a name="l03933"></a>03933 
<a name="l03934"></a>03934     
<a name="l03935"></a><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#356e519e54ede355cdda54f17309970e">03935</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#356e519e54ede355cdda54f17309970e" title="Return the start token or tree.">getStart</a>(self):
<a name="l03936"></a>03936         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#bdadd7a724ae2b7f7014a8f44e8ac3aa">start</a>
<a name="l03937"></a>03937 
<a name="l03938"></a>03938 
<a name="l03939"></a><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#8d75459ecfc2ea2d77b70676a190a4ce">03939</a>     <span class="keyword">def </span><a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#8d75459ecfc2ea2d77b70676a190a4ce" title="Return the stop token or tree.">getStop</a>(self):
<a name="l03940"></a>03940         <span class="keywordflow">return</span> self.<a class="code" href="classantlr3_1_1_parser_rule_return_scope.html#2c27996ee1edb3edb568db89d348fbdc">stop</a>
<a name="l03941"></a>03941 
<a name="l03942"></a>03942 
<a name="l03943"></a>03943 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:24 2010 for ANTLR Python API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
