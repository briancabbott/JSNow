<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR Python API: antlr3.BaseRecognizer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceantlr3.html">antlr3</a>.<a class="el" href="classantlr3_1_1_base_recognizer.html">BaseRecognizer</a>
  </div>
</div>
<div class="contents">
<h1>antlr3.BaseRecognizer Class Reference</h1><!-- doxytag: class="antlr3::BaseRecognizer" -->Common recognizer functionality.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for antlr3.BaseRecognizer:</div>
<div class="dynsection">
<p><center><img src="classantlr3_1_1_base_recognizer__inherit__graph.png" border="0" usemap="#antlr3_8_base_recognizer__inherit__map" alt="Inheritance graph"></center>
<map name="antlr3_8_base_recognizer__inherit__map">
<area shape="rect" href="classantlr3_1_1_lexer.html" title="Baseclass for generated lexer classes." alt="" coords="5,80,99,107"><area shape="rect" href="classantlr3_1_1_parser.html" title="Baseclass for generated parser classes." alt="" coords="123,80,224,107"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classantlr3_1_1_base_recognizer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#9148800758baf2f1c6437fc25437401b">__init__</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#4c08864d687c878069223a2f351b10ae">setInput</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#56f0125d72c7d27cf75ad122ae7fbbf7">reset</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reset the parser's state; subclasses must rewinds the input stream  <a href="#56f0125d72c7d27cf75ad122ae7fbbf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7">match</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match current input symbol against ttype.  <a href="#37d2ad26f463de1ba6910f5920a6f4a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#44e9115eae6b5f11ca09bdc170928382">matchAny</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match the wildcard: in a symbol.  <a href="#44e9115eae6b5f11ca09bdc170928382"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#7a44a211c8f34a5743a72da0b373a74e">mismatchIsUnwantedToken</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#2482f7bff153e1ccc1ed218e5172c870">mismatchIsMissingToken</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c">reportError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report a recognition problem.  <a href="#0b3022ecb0d1b0d2a7a9687da842e48c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#a295e906ee74022cfb0b72b2c56e9f62">displayRecognitionError</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#3de2a2bc49b21d7d78944d1203aa22c1">getErrorMessage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What error message should be generated for the various exception types?  <a href="#3de2a2bc49b21d7d78944d1203aa22c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#b21052ebf6684117cd0774a5553ec2c0">getNumberOfSyntaxErrors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of recognition errors (lexer, parser, <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> parser).  <a href="#b21052ebf6684117cd0774a5553ec2c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#c4497e12036221ace01fdc201d23f8a6">getErrorHeader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What is the error header, normally line/character position information?  <a href="#c4497e12036221ace01fdc201d23f8a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#cadce13c913435ef8cbe7a355debcc25">getTokenErrorDisplay</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How should a token be displayed in an error message? The default is to display just the text, but during development you might want to have a lot of information spit out.  <a href="#cadce13c913435ef8cbe7a355debcc25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#c4841ded6b308a3f3c48c5b2d3c749d7">emitErrorMessage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to change where error messages go.  <a href="#c4841ded6b308a3f3c48c5b2d3c749d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#0d24b2f60d4efb4ccfcf6aaf0146417e">recover</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recover from an error found on the input stream.  <a href="#0d24b2f60d4efb4ccfcf6aaf0146417e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#a02cc381bcaafbe90d2f07fde144fa6d">beginResync</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hook to listen in on the token consumption during error recovery.  <a href="#a02cc381bcaafbe90d2f07fde144fa6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#bf949192a5e5a76204191afea30249f7">endResync</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hook to listen in on the token consumption during error recovery.  <a href="#bf949192a5e5a76204191afea30249f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#90d118af4f9efe0702c795fa325ecc5b">computeErrorRecoverySet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the error recovery set for the current rule.  <a href="#90d118af4f9efe0702c795fa325ecc5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#b3dd7de1dc6760f5f634ed996c5a6769">computeContextSensitiveRuleFOLLOW</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the context-sensitive FOLLOW set for current rule.  <a href="#b3dd7de1dc6760f5f634ed996c5a6769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#05b73ea8979dec3f87214b0686ec7c83">combineFollows</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#6866fbb79a115e58c949834ace5bba17">recoverFromMismatchedToken</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to recover from a single missing or extra token.  <a href="#6866fbb79a115e58c949834ace5bba17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#931e37a390b4cf9c3cb33fb407ba9c15">recoverFromMismatchedSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not currently used.  <a href="#931e37a390b4cf9c3cb33fb407ba9c15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#2c908793a6c88fdf53a227fa7480c407">getCurrentInputSymbol</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match needs to return the current input symbol, which gets put into the label for the associated token ref; e.g., x=ID.  <a href="#2c908793a6c88fdf53a227fa7480c407"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#891b5c693ca2b041b81b651d0ad6d2d4">getMissingSymbol</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conjure up a missing token during error recovery.  <a href="#891b5c693ca2b041b81b651d0ad6d2d4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">input</a></td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#7716ad8c2dabc1d27930d35c4d5cca82">MEMO_RULE_FAILED</a> = 2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#298a281766cd5ae121b002e4a3ac6183">MEMO_RULE_UNKNOWN</a> = 1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#fe4dc7666fb2620610c3c732c1b93ba3">DEFAULT_TOKEN_CHANNEL</a> = <a class="el" href="namespaceantlr3.html#1dc3ab7cca55610a7a3e33545c75e6de">DEFAULT_CHANNEL</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#d1014502291224c13fc5c5286e637329">HIDDEN</a> = <a class="el" href="namespaceantlr3.html#569b3b96276a4c304f807881f74f89ed">HIDDEN_CHANNEL</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">tokenNames</a> = None</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">tuple&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#3fc337642c5c82dec1b606bf98e6bad6">antlr_version</a> = (3, 0, 1, 0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">antlr_version_str</a> = &quot;3.0.1&quot;</td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea">_state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State of a lexer, parser, or <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> parser are collected into a state object so the state can be shared.  <a href="#947f29fd5ebcda7fe81aa4ec4693eaea"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Common recognizer functionality. 
<p>
A generic recognizer that can handle recognizers generated from lexer, parser, and <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> grammars. This is all the parsing support code essentially; most of it is error recovery stuff and backtracking. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02539">2539</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9148800758baf2f1c6437fc25437401b"></a><!-- doxytag: member="antlr3::BaseRecognizer::__init__" ref="9148800758baf2f1c6437fc25437401b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.__init__           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02558">2558</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="4c08864d687c878069223a2f351b10ae"></a><!-- doxytag: member="antlr3::BaseRecognizer::setInput" ref="4c08864d687c878069223a2f351b10ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.setInput           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02592">2592</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="56f0125d72c7d27cf75ad122ae7fbbf7"></a><!-- doxytag: member="antlr3::BaseRecognizer::reset" ref="56f0125d72c7d27cf75ad122ae7fbbf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.reset           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reset the parser's state; subclasses must rewinds the input stream 
<p>

<p>Reimplemented in <a class="el" href="classantlr3_1_1_lexer.html#29edf8e62771c305453d36f01274c549">antlr3.Lexer</a>, and <a class="el" href="classantlr3_1_1_parser.html#c2d71fcc004605787060040dfdcf2849">antlr3.Parser</a>.</p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02600">2600</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="37d2ad26f463de1ba6910f5920a6f4a7"></a><!-- doxytag: member="antlr3::BaseRecognizer::match" ref="37d2ad26f463de1ba6910f5920a6f4a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.match           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>ttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>follow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match current input symbol against ttype. 
<p>
Attempt single token insertion or deletion error recovery. If that fails, throw <a class="el" href="classantlr3_1_1_mismatched_token_exception.html" title="A mismatched char or Token or tree node.">MismatchedTokenException</a>.<p>
To turn off single token insertion or deletion error recovery, override <a class="el" href="classantlr3_1_1_base_recognizer.html#6866fbb79a115e58c949834ace5bba17" title="Attempt to recover from a single missing or extra token.">recoverFromMismatchedToken()</a> and have it throw an exception. See TreeParser.recoverFromMismatchedToken(). This way any error in a rule will cause an exception and immediate exit from rule. Rule would recover by resynchronizing to the set of symbols that can follow rule ref. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02630">2630</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="44e9115eae6b5f11ca09bdc170928382"></a><!-- doxytag: member="antlr3::BaseRecognizer::matchAny" ref="44e9115eae6b5f11ca09bdc170928382" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.matchAny           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match the wildcard: in a symbol. 
<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02648">2648</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="7a44a211c8f34a5743a72da0b373a74e"></a><!-- doxytag: member="antlr3::BaseRecognizer::mismatchIsUnwantedToken" ref="7a44a211c8f34a5743a72da0b373a74e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.mismatchIsUnwantedToken           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>ttype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02654">2654</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="2482f7bff153e1ccc1ed218e5172c870"></a><!-- doxytag: member="antlr3::BaseRecognizer::mismatchIsMissingToken" ref="2482f7bff153e1ccc1ed218e5172c870" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.mismatchIsMissingToken           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>follow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02658">2658</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="0b3022ecb0d1b0d2a7a9687da842e48c"></a><!-- doxytag: member="antlr3::BaseRecognizer::reportError" ref="0b3022ecb0d1b0d2a7a9687da842e48c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.reportError           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Report a recognition problem. 
<p>
This method sets errorRecovery to indicate the parser is recovering not parsing. Once in recovery mode, no errors are generated. To get out of recovery mode, the parser must successfully match a token (after a resync). So it will go:<p>
1. error occurs 2. enter recovery mode, report error 3. consume until token found in resynch set 4. try to resume parsing 5. next <a class="el" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7" title="Match current input symbol against ttype.">match()</a> will reset errorRecovery mode<p>
If you override, make sure to update syntaxErrors if you care about that. 
<p>Reimplemented in <a class="el" href="classantlr3_1_1_lexer.html#4b1d0de4fc42a8aeb6e710a679e9685a">antlr3.Lexer</a>.</p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02700">2700</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="a295e906ee74022cfb0b72b2c56e9f62"></a><!-- doxytag: member="antlr3::BaseRecognizer::displayRecognitionError" ref="a295e906ee74022cfb0b72b2c56e9f62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.displayRecognitionError           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>tokenNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02713">2713</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="3de2a2bc49b21d7d78944d1203aa22c1"></a><!-- doxytag: member="antlr3::BaseRecognizer::getErrorMessage" ref="3de2a2bc49b21d7d78944d1203aa22c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.getErrorMessage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>tokenNames</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
What error message should be generated for the various exception types? 
<p>
Not very object-oriented code, but I like having all error message generation within one method rather than spread among all of the exception classes. This also makes it much easier for the exception handling because the exception classes do not have to have pointers back to this object to access utility routines and so on. Also, changing the message for an exception type would be difficult because you would have to subclassing exception, but then somehow get ANTLR to make those kinds of exception objects instead of the default. This looks weird, but trust me--it makes the most sense in terms of flexibility.<p>
For grammar debugging, you will want to override this to add more information such as the stack frame with getRuleInvocationStack(e, this.getClass().getName()) and, for no viable alts, the decision description and state etc...<p>
Override this to change the message generated for one or more exception types. 
<p>Reimplemented in <a class="el" href="classantlr3_1_1_lexer.html#852eab357ba7951afc4573435eadd580">antlr3.Lexer</a>.</p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02743">2743</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="b21052ebf6684117cd0774a5553ec2c0"></a><!-- doxytag: member="antlr3::BaseRecognizer::getNumberOfSyntaxErrors" ref="b21052ebf6684117cd0774a5553ec2c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.getNumberOfSyntaxErrors           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get number of recognition errors (lexer, parser, <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> parser). 
<p>
Each recognizer tracks its own number. So parser and lexer each have separate count. Does not count the spurious errors found between an error and next valid token match<p>
See also <a class="el" href="classantlr3_1_1_base_recognizer.html#0b3022ecb0d1b0d2a7a9687da842e48c" title="Report a recognition problem.">reportError()</a> 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02834">2834</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4497e12036221ace01fdc201d23f8a6"></a><!-- doxytag: member="antlr3::BaseRecognizer::getErrorHeader" ref="c4497e12036221ace01fdc201d23f8a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.getErrorHeader           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
What is the error header, normally line/character position information? 
<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02842">2842</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="cadce13c913435ef8cbe7a355debcc25"></a><!-- doxytag: member="antlr3::BaseRecognizer::getTokenErrorDisplay" ref="cadce13c913435ef8cbe7a355debcc25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.getTokenErrorDisplay           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
How should a token be displayed in an error message? The default is to display just the text, but during development you might want to have a lot of information spit out. 
<p>
Override in that case to use t.toString() (which, for <a class="el" href="classantlr3_1_1_common_token.html" title="Basic token implementation.">CommonToken</a>, dumps everything about the token). This is better than forcing you to override a method in your token objects because you don't have to go modify your lexer so that it creates a new Java type. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02857">2857</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4841ded6b308a3f3c48c5b2d3c749d7"></a><!-- doxytag: member="antlr3::BaseRecognizer::emitErrorMessage" ref="c4841ded6b308a3f3c48c5b2d3c749d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.emitErrorMessage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Override this method to change where error messages go. 
<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02871">2871</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="0d24b2f60d4efb4ccfcf6aaf0146417e"></a><!-- doxytag: member="antlr3::BaseRecognizer::recover" ref="0d24b2f60d4efb4ccfcf6aaf0146417e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.recover           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>re</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recover from an error found on the input stream. 
<p>
This is for NoViableAlt and mismatched symbol exceptions. If you enable single token insertion and deletion, this will usually not handle mismatched symbol exceptions but there could be a mismatched token that the <a class="el" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7" title="Match current input symbol against ttype.">match()</a> routine could not recover from. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02883">2883</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="a02cc381bcaafbe90d2f07fde144fa6d"></a><!-- doxytag: member="antlr3::BaseRecognizer::beginResync" ref="a02cc381bcaafbe90d2f07fde144fa6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.beginResync           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A hook to listen in on the token consumption during error recovery. 
<p>
The DebugParser subclasses this to fire events to the listenter. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02907">2907</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="bf949192a5e5a76204191afea30249f7"></a><!-- doxytag: member="antlr3::BaseRecognizer::endResync" ref="bf949192a5e5a76204191afea30249f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.endResync           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A hook to listen in on the token consumption during error recovery. 
<p>
The DebugParser subclasses this to fire events to the listenter. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02917">2917</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="90d118af4f9efe0702c795fa325ecc5b"></a><!-- doxytag: member="antlr3::BaseRecognizer::computeErrorRecoverySet" ref="90d118af4f9efe0702c795fa325ecc5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.computeErrorRecoverySet           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the error recovery set for the current rule. 
<p>
During rule invocation, the parser pushes the set of tokens that can follow that rule reference on the stack; this amounts to computing FIRST of what follows the rule reference in the enclosing rule. This local follow set only includes tokens from within the rule; i.e., the FIRST computation done by ANTLR stops at the end of a rule.<p>
EXAMPLE<p>
When you find a "no viable alt exception", the input is not consistent with any of the alternatives for rule r. The best thing to do is to consume tokens until you see something that can legally follow a call to r *or* any rule that called r. You don't want the exact set of viable next tokens because the input might just be missing a token--you might consume the rest of the input looking for one of the missing tokens.<p>
Consider grammar:<p>
a : '[' b ']' | '(' b ')' ; b : c '^' INT ; c : ID | INT ;<p>
At each rule invocation, the set of tokens that could follow that rule is pushed on a stack. Here are the various "local" follow sets:<p>
FOLLOW(b1_in_a) = FIRST(']') = ']' FOLLOW(b2_in_a) = FIRST(')') = ')' FOLLOW(c_in_b) = FIRST('^') = '^'<p>
Upon erroneous input "[]", the call chain is<p>
a -&gt; b -&gt; c<p>
and, hence, the follow context stack is:<p>
depth local follow set after call to rule 0 &lt;EOF&gt; a (from main()) 1 ']' b 3 '^' c<p>
Notice that ')' is not included, because b would have to have been called from a different context in rule a for ')' to be included.<p>
For error recovery, we cannot consider FOLLOW(c) (context-sensitive or otherwise). We need the combined set of all context-sensitive FOLLOW sets--the set of all tokens that could follow any reference in the call chain. We need to resync to one of those tokens. Note that FOLLOW(c)='^' and if we resync'd to that token, we'd consume until EOF. We need to sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}. In this case, for input "[]", LA(1) is in this set so we would not consume anything and after printing an error rule c would return normally. It would not find the required '^' though. At this point, it gets a mismatched token error and throws an exception (since LA(1) is not in the viable following token set). The rule exception handler tries to recover, but finds the same recovery set and doesn't consume anything. Rule b exits normally returning to rule a. Now it finds the ']' (and with the successful match exits errorRecovery mode).<p>
So, you cna see that the parser walks up call chain looking for the token that was a member of the recovery set.<p>
Errors are not generated in errorRecovery mode.<p>
ANTLR's error recovery mechanism is based upon original ideas:<p>
"Algorithms + Data Structures = Programs" by Niklaus Wirth<p>
and<p>
"A note on error recovery in recursive descent parsers": <a href="http://portal.acm.org/citation.cfm?id=947902.947905">http://portal.acm.org/citation.cfm?id=947902.947905</a><p>
Later, Josef Grosch had some good ideas:<p>
"Efficient and Comfortable Error Recovery in Recursive Descent Parsers": <a href="ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip">ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip</a><p>
Like Grosch I implemented local FOLLOW sets that are combined at run-time upon error to avoid overhead during parsing. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03015">3015</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="b3dd7de1dc6760f5f634ed996c5a6769"></a><!-- doxytag: member="antlr3::BaseRecognizer::computeContextSensitiveRuleFOLLOW" ref="b3dd7de1dc6760f5f634ed996c5a6769" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.computeContextSensitiveRuleFOLLOW           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the context-sensitive FOLLOW set for current rule. 
<p>
This is set of token types that can follow a specific rule reference given a specific call chain. You get the set of viable tokens that can possibly come next (lookahead depth 1) given the current call chain. Contrast this with the definition of plain FOLLOW for rule r:<p>
FOLLOW(r)={x | S=&gt;*alpha r beta in G and x in FIRST(beta)}<p>
where x in T* and alpha, beta in V*; T is set of terminals and V is the set of terminals and nonterminals. In other words, FOLLOW(r) is the set of all tokens that can possibly follow references to r in *any* sentential form (context). At runtime, however, we know precisely which context applies as we have the call chain. We may compute the exact (rather than covering superset) set of following tokens.<p>
For example, consider grammar:<p>
stat : ID '=' expr ';' // FOLLOW(stat)=={EOF} | "return" expr '.' ; expr : atom ('+' atom)* ; // FOLLOW(expr)=={';','.',')'} atom : INT // FOLLOW(atom)=={'+',')',';','.'} | '(' expr ')' ;<p>
The FOLLOW sets are all inclusive whereas context-sensitive FOLLOW sets are precisely what could follow a rule reference. For input input "i=(3);", here is the derivation:<p>
stat =&gt; ID '=' expr ';' =&gt; ID '=' atom ('+' atom)* ';' =&gt; ID '=' '(' expr ')' ('+' atom)* ';' =&gt; ID '=' '(' atom ')' ('+' atom)* ';' =&gt; ID '=' '(' INT ')' ('+' atom)* ';' =&gt; ID '=' '(' INT ')' ';'<p>
At the "3" token, you'd have a call chain of<p>
stat -&gt; expr -&gt; atom -&gt; expr -&gt; atom<p>
What can follow that specific nested ref to atom? Exactly ')' as you can see by looking at the derivation of this specific input. Contrast this with the FOLLOW(atom)={'+',')',';','.'}.<p>
You want the exact viable token set when recovering from a token mismatch. Upon token mismatch, if LA(1) is member of the viable next token set, then you know there is most likely a missing token in the input stream. "Insert" one by just not throwing an exception. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03074">3074</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="05b73ea8979dec3f87214b0686ec7c83"></a><!-- doxytag: member="antlr3::BaseRecognizer::combineFollows" ref="05b73ea8979dec3f87214b0686ec7c83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.combineFollows           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>exact</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03079">3079</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="6866fbb79a115e58c949834ace5bba17"></a><!-- doxytag: member="antlr3::BaseRecognizer::recoverFromMismatchedToken" ref="6866fbb79a115e58c949834ace5bba17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.recoverFromMismatchedToken           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>ttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>follow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to recover from a single missing or extra token. 
<p>
EXTRA TOKEN<p>
LA(1) is not what we are looking for. If LA(2) has the right token, however, then assume LA(1) is some extra spurious token. Delete it and LA(2) as if we were doing a normal <a class="el" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7" title="Match current input symbol against ttype.">match()</a>, which advances the input.<p>
MISSING TOKEN<p>
If current token is consistent with what could come after ttype then it is ok to 'insert' the missing token, else throw exception For example, Input 'i=(3;' is clearly missing the ')'. When the parser returns from the nested call to expr, it will have call chain:<p>
stat -&gt; expr -&gt; atom<p>
and it will be trying to match the ')' at this point in the derivation:<p>
=&gt; ID '=' '(' INT ')' ('+' atom)* ';' ^ <a class="el" href="classantlr3_1_1_base_recognizer.html#37d2ad26f463de1ba6910f5920a6f4a7" title="Match current input symbol against ttype.">match()</a> will see that ';' doesn't match ')' and report a mismatched token error. To recover, it sees that LA(1)==';' is in the set of tokens that can follow the ')' token reference in rule atom. It can assume that you forgot the ')'. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03128">3128</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="931e37a390b4cf9c3cb33fb407ba9c15"></a><!-- doxytag: member="antlr3::BaseRecognizer::recoverFromMismatchedSet" ref="931e37a390b4cf9c3cb33fb407ba9c15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.recoverFromMismatchedSet           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>follow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Not currently used. 
<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03166">3166</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="2c908793a6c88fdf53a227fa7480c407"></a><!-- doxytag: member="antlr3::BaseRecognizer::getCurrentInputSymbol" ref="2c908793a6c88fdf53a227fa7480c407" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.getCurrentInputSymbol           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match needs to return the current input symbol, which gets put into the label for the associated token ref; e.g., x=ID. 
<p>
<a class="el" href="classantlr3_1_1_token.html" title="Abstract token baseclass.">Token</a> and <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> parsers need to return different objects. Rather than test for input stream type or change the <a class="el" href="classantlr3_1_1_int_stream.html" title="Base interface for streams of integer values.">IntStream</a> interface, I use a simple method to ask the recognizer to tell me what the current input symbol is.<p>
This is ignored for lexers. 
<p>Reimplemented in <a class="el" href="classantlr3_1_1_parser.html#6f86c1c0533ffb0227299a050c4267de">antlr3.Parser</a>.</p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03188">3188</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="891b5c693ca2b041b81b651d0ad6d2d4"></a><!-- doxytag: member="antlr3::BaseRecognizer::getMissingSymbol" ref="891b5c693ca2b041b81b651d0ad6d2d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def antlr3.BaseRecognizer.getMissingSymbol           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>expectedTokenType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>follow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conjure up a missing token during error recovery. 
<p>
The recognizer attempts to recover from single missing symbols. But, actions might refer to that missing symbol. For example, x=ID {f($x);}. The action clearly assumes that there has been an identifier matched previously and that $x points at that token. If that token is missing, but the next token in the stream is what we want we assume that this token is missing and we keep going. Because we have to return some token to replace the missing token, we have to conjure one up. This method gives the user control over the tokens returned for missing tokens. Mostly, you will want to create something special for identifier tokens. For literals such as '{' and ',', the default action in the parser or <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> parser works. It simply creates a <a class="el" href="classantlr3_1_1_common_token.html" title="Basic token implementation.">CommonToken</a> of the appropriate type. The text will be the token. If you change what tokens must be created by the lexer, override this method to create the appropriate tokens. 
<p>Reimplemented in <a class="el" href="classantlr3_1_1_parser.html#8095ef77285cd2c5603f21490be97935">antlr3.Parser</a>.</p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l03213">3213</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="7716ad8c2dabc1d27930d35c4d5cca82"></a><!-- doxytag: member="antlr3::BaseRecognizer::MEMO_RULE_FAILED" ref="7716ad8c2dabc1d27930d35c4d5cca82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classantlr3_1_1_base_recognizer.html#7716ad8c2dabc1d27930d35c4d5cca82">antlr3.BaseRecognizer.MEMO_RULE_FAILED</a> = 2<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02541">2541</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="298a281766cd5ae121b002e4a3ac6183"></a><!-- doxytag: member="antlr3::BaseRecognizer::MEMO_RULE_UNKNOWN" ref="298a281766cd5ae121b002e4a3ac6183" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classantlr3_1_1_base_recognizer.html#298a281766cd5ae121b002e4a3ac6183">antlr3.BaseRecognizer.MEMO_RULE_UNKNOWN</a> = 1<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02542">2542</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="fe4dc7666fb2620610c3c732c1b93ba3"></a><!-- doxytag: member="antlr3::BaseRecognizer::DEFAULT_TOKEN_CHANNEL" ref="fe4dc7666fb2620610c3c732c1b93ba3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr3_1_1_base_recognizer.html#fe4dc7666fb2620610c3c732c1b93ba3">antlr3.BaseRecognizer.DEFAULT_TOKEN_CHANNEL</a> = <a class="el" href="namespaceantlr3.html#1dc3ab7cca55610a7a3e33545c75e6de">DEFAULT_CHANNEL</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02545">2545</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="d1014502291224c13fc5c5286e637329"></a><!-- doxytag: member="antlr3::BaseRecognizer::HIDDEN" ref="d1014502291224c13fc5c5286e637329" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr3_1_1_base_recognizer.html#d1014502291224c13fc5c5286e637329">antlr3.BaseRecognizer.HIDDEN</a> = <a class="el" href="namespaceantlr3.html#569b3b96276a4c304f807881f74f89ed">HIDDEN_CHANNEL</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02548">2548</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="5e4ea8229cdd71d2f280756f91079e0d"></a><!-- doxytag: member="antlr3::BaseRecognizer::tokenNames" ref="5e4ea8229cdd71d2f280756f91079e0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr3_1_1_base_recognizer.html#5e4ea8229cdd71d2f280756f91079e0d">antlr3.BaseRecognizer.tokenNames</a> = None<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02551">2551</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="3fc337642c5c82dec1b606bf98e6bad6"></a><!-- doxytag: member="antlr3::BaseRecognizer::antlr_version" ref="3fc337642c5c82dec1b606bf98e6bad6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple <a class="el" href="classantlr3_1_1_base_recognizer.html#3fc337642c5c82dec1b606bf98e6bad6">antlr3.BaseRecognizer.antlr_version</a> = (3, 0, 1, 0)<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02555">2555</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="29350dc07cb3d2849cc23f5f58ae4922"></a><!-- doxytag: member="antlr3::BaseRecognizer::antlr_version_str" ref="29350dc07cb3d2849cc23f5f58ae4922" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classantlr3_1_1_base_recognizer.html#29350dc07cb3d2849cc23f5f58ae4922">antlr3.BaseRecognizer.antlr_version_str</a> = &quot;3.0.1&quot;<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02556">2556</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="92d15ce6bc1b5dc3867a93a20139553a"></a><!-- doxytag: member="antlr3::BaseRecognizer::input" ref="92d15ce6bc1b5dc3867a93a20139553a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr3_1_1_base_recognizer.html#92d15ce6bc1b5dc3867a93a20139553a">antlr3.BaseRecognizer.input</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classantlr3_1_1_lexer.html#a03d365153fb2b162e3bac64189bb211">antlr3.Lexer</a>, and <a class="el" href="classantlr3_1_1_parser.html#f69342b460960308be2c2b1a81f52ad7">antlr3.Parser</a>.</p>

<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02560">2560</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<a class="anchor" name="947f29fd5ebcda7fe81aa4ec4693eaea"></a><!-- doxytag: member="antlr3::BaseRecognizer::_state" ref="947f29fd5ebcda7fe81aa4ec4693eaea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr3_1_1_base_recognizer.html#947f29fd5ebcda7fe81aa4ec4693eaea">antlr3.BaseRecognizer._state</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
State of a lexer, parser, or <a class="el" href="namespaceantlr3_1_1tree.html" title="ANTLR3 runtime package, tree module.">tree</a> parser are collected into a state object so the state can be shared. 
<p>
This sharing is needed to have one grammar import others and share same error variables and other state variables. It's a kind of explicit multiple inheritance via delegation of methods and shared state. 
<p>Definition at line <a class="el" href="antlr3_8py-source.html#l02569">2569</a> of file <a class="el" href="antlr3_8py-source.html">antlr3.py</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="antlr3_8py-source.html">antlr3.py</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:28 2010 for ANTLR Python API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
