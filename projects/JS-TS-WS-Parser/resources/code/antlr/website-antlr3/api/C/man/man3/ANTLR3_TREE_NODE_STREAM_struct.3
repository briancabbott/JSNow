.TH "ANTLR3_TREE_NODE_STREAM_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_TREE_NODE_STREAM_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3commontreenodestream.h>\fP
.PP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBpANTLR3_BASE_TREE\fP(* \fB_LT\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBANTLR3_INT32\fP k)"
.br
.RI "\fIGet tree node at current input pointer + i ahead where i=1 is next node. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TREE_NODE_STREAM\fP \fBctns\fP"
.br
.RI "\fIAny interface that implements this interface (is a super structure containing this structure), may store the pointer to itself here in the super pointer, which is not used by the tree node stream. \fP"
.ti -1c
.RI "void(* \fBfree\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.br
.RI "\fIRelease up any and all space the the interface allocate, including for this structure. \fP"
.ti -1c
.RI "\fBpANTLR3_BASE_TREE\fP(* \fBget\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBANTLR3_INT32\fP i)"
.br
.RI "\fIGet a tree node at an absolute index i; 0. \fP"
.ti -1c
.RI "\fBpANTLR3_BASE_TREE_ADAPTOR\fP(* \fBgetTreeAdaptor\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.br
.RI "\fIWhat adaptor can tell me how to interpret/navigate nodes and trees. \fP"
.ti -1c
.RI "\fBpANTLR3_BASE_TREE\fP(* \fBgetTreeSource\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.br
.RI "\fIWhere is this stream pulling nodes from? This is not the name, but the object that provides node objects. \fP"
.ti -1c
.RI "\fBpANTLR3_INT_STREAM\fP \fBistream\fP"
.br
.RI "\fIAll input streams implement the ANTLR3_INT_STREAM interface. \fP"
.ti -1c
.RI "void(* \fBreplaceChildren\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBpANTLR3_BASE_TREE\fP parent, \fBANTLR3_INT32\fP startChildIndex, \fBANTLR3_INT32\fP stopChildIndex, \fBpANTLR3_BASE_TREE\fP t)"
.br
.RI "\fIReplace from start to stop child index of parent with t, which might be a list. \fP"
.ti -1c
.RI "void(* \fBsetUniqueNavigationNodes\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBANTLR3_BOOLEAN\fP uniqueNavigationNodes)"
.br
.RI "\fIAs we flatten the tree, we use UP, DOWN nodes to represent the tree structure. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBtoString\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.br
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBtoStringSS\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBpANTLR3_BASE_TREE\fP start, \fBpANTLR3_BASE_TREE\fP stop)"
.br
.RI "\fIReturn the text of all nodes from start to stop, inclusive. \fP"
.ti -1c
.RI "void(* \fBtoStringWork\fP )(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBpANTLR3_BASE_TREE\fP start, \fBpANTLR3_BASE_TREE\fP stop, \fBpANTLR3_STRING\fP buf)"
.br
.RI "\fIReturn the text of all nodes from start to stop, inclusive, into the supplied buffer. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBpANTLR3_BASE_TREE\fP(* \fBANTLR3_TREE_NODE_STREAM_struct::_LT\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBANTLR3_INT32\fP k)"
.PP
Get tree node at current input pointer + i ahead where i=1 is next node. 
.PP
i<0 indicates nodes in the past. So LT(-1) is previous node, but implementations are not required to provide results for k < -1. LT(0) is undefined. For i>=n, return null. Return NULL for LT(0) and any index that results in an absolute address that is negative (beyond the start of the list).
.PP
This is analogous to the \fBLT()\fP method of the TokenStream, but this returns a tree node instead of a token. Makes code gen identical for both parser and tree grammars. :) 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), antlr3RecognitionExceptionNew(), getCurrentInputSymbol(), and getMissingSymbol().
.SS "\fBpANTLR3_COMMON_TREE_NODE_STREAM\fP \fBANTLR3_TREE_NODE_STREAM_struct::ctns\fP"
.PP
Any interface that implements this interface (is a super structure containing this structure), may store the pointer to itself here in the super pointer, which is not used by the tree node stream. 
.PP
This will point to an implementation of ANTLR3_COMMON_TREE_NODE_STREAM in this case. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), getCurrentInputSymbol(), getMissingSymbol(), and LB().
.SS "void(* \fBANTLR3_TREE_NODE_STREAM_struct::free\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.PP
Release up any and all space the the interface allocate, including for this structure. 
.PP
Referenced by antlr3CommonTreeNodeStreamFree(), antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), and antlr3TreeNodeStreamNew().
.SS "\fBpANTLR3_BASE_TREE\fP(* \fBANTLR3_TREE_NODE_STREAM_struct::get\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBANTLR3_INT32\fP i)"
.PP
Get a tree node at an absolute index i; 0. 
.PP
.n-1. If you don't want to buffer up nodes, then this method makes no sense for you. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().
.SS "\fBpANTLR3_BASE_TREE_ADAPTOR\fP(* \fBANTLR3_TREE_NODE_STREAM_struct::getTreeAdaptor\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.PP
What adaptor can tell me how to interpret/navigate nodes and trees. 
.PP
E.g., get text of a node. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().
.SS "\fBpANTLR3_BASE_TREE\fP(* \fBANTLR3_TREE_NODE_STREAM_struct::getTreeSource\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.PP
Where is this stream pulling nodes from? This is not the name, but the object that provides node objects. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().
.SS "\fBpANTLR3_INT_STREAM\fP \fBANTLR3_TREE_NODE_STREAM_struct::istream\fP"
.PP
All input streams implement the ANTLR3_INT_STREAM interface. 
.PP
.. 
.PP
Referenced by alreadyParsedRule(), antlr3CommonTreeNodeStreamFree(), antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), antlr3RecognitionExceptionNew(), consumeUntil(), consumeUntilSet(), displayRecognitionError(), match(), matchAny(), memoize(), recover(), recoverFromMismatchedElement(), recoverFromMismatchedSet(), recoverFromMismatchedToken(), reset(), and synpred().
.SS "void(* \fBANTLR3_TREE_NODE_STREAM_struct::replaceChildren\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBpANTLR3_BASE_TREE\fP parent, \fBANTLR3_INT32\fP startChildIndex, \fBANTLR3_INT32\fP stopChildIndex, \fBpANTLR3_BASE_TREE\fP t)"
.PP
Replace from start to stop child index of parent with t, which might be a list. 
.PP
Number of children may be different after this call. The stream is notified because it is walking the tree and might need to know you are monkeying with the underlying tree. Also, it might be able to modify the node stream to avoid restreaming for future phases.
.PP
If parent is null, don't do anything; must be at root of overall tree. Can't replace whatever points to the parent externally. Do nothing. 
.PP
Referenced by antlr3TreeNodeStreamNew().
.SS "void(* \fBANTLR3_TREE_NODE_STREAM_struct::setUniqueNavigationNodes\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBANTLR3_BOOLEAN\fP uniqueNavigationNodes)"
.PP
As we flatten the tree, we use UP, DOWN nodes to represent the tree structure. 
.PP
When debugging we need unique nodes so we have to instantiate new ones. When doing normal tree parsing, it's slow and a waste of memory to create unique navigation nodes. Default should be false; 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_TREE_NODE_STREAM_struct::toString\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns)"
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_TREE_NODE_STREAM_struct::toStringSS\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBpANTLR3_BASE_TREE\fP start, \fBpANTLR3_BASE_TREE\fP stop)"
.PP
Return the text of all nodes from start to stop, inclusive. 
.PP
If the stream does not buffer all the nodes then it can still walk recursively from start until stop. You can always return null or '' too, but users should not access $ruleLabel.text in an action of course in that case. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().
.SS "void(* \fBANTLR3_TREE_NODE_STREAM_struct::toStringWork\fP)(struct \fBANTLR3_TREE_NODE_STREAM_struct\fP *tns, \fBpANTLR3_BASE_TREE\fP start, \fBpANTLR3_BASE_TREE\fP stop, \fBpANTLR3_STRING\fP buf)"
.PP
Return the text of all nodes from start to stop, inclusive, into the supplied buffer. 
.PP
If the stream does not buffer all the nodes then it can still walk recursively from start until stop. You can always return null or '' too, but users should not access $ruleLabel.text in an action of course in that case. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), and antlr3CommonTreeNodeStreamNewStream().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
