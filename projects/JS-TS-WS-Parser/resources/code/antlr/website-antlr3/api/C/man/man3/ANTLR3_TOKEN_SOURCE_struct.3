.TH "ANTLR3_TOKEN_SOURCE_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_TOKEN_SOURCE_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3tokenstream.h>\fP
.PP
.SH "Detailed Description"
.PP 
Definition of a token source, which has a pointer to a function that returns the next token (using a token factory if it is going to be efficient) and a pointer to an ANTLR3_INPUT_STREAM. 

This is slightly different to the Java interface because we have no way to implement multiple interfaces without defining them in the interface structure or casting (void *), which is too convoluted. 
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBANTLR3_COMMON_TOKEN\fP \fBeofToken\fP"
.br
.RI "\fIA special pre-allocated token, which signifies End Of Tokens. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP \fBfileName\fP"
.br
.RI "\fIWhen the token source is constructed, it is populated with the file name from whence the tokens were produced by the lexer. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TOKEN\fP(* \fBnextToken\fP )(struct \fBANTLR3_TOKEN_SOURCE_struct\fP *tokenSource)"
.br
.RI "\fIPointer to a function that returns the next token in the stream. \fP"
.ti -1c
.RI "\fBANTLR3_COMMON_TOKEN\fP \fBskipToken\fP"
.br
.RI "\fIA special pre-allocated token, which is returned by \fBmTokens()\fP if the lexer rule said to just skip the generated token altogether. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING_FACTORY\fP \fBstrFactory\fP"
.br
.RI "\fIWhoever is providing tokens, needs to provide a string factory too. \fP"
.ti -1c
.RI "void * \fBsuper\fP"
.br
.RI "\fIWhatever is supplying the token source interface, needs a pointer to itself so that this pointer can be passed to it when the nextToken function is called. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBANTLR3_COMMON_TOKEN\fP \fBANTLR3_TOKEN_SOURCE_struct::eofToken\fP"
.PP
A special pre-allocated token, which signifies End Of Tokens. 
.PP
Because this must be set up with the current input index and so on, we embed the structure and return the address of it. It is marked as factoryMade, so that it is never attempted to be freed. 
.PP
Referenced by antlr3LexerNew(), nextTokenStr(), setCharStream(), and tokLT().
.SS "\fBpANTLR3_STRING\fP \fBANTLR3_TOKEN_SOURCE_struct::fileName\fP"
.PP
When the token source is constructed, it is populated with the file name from whence the tokens were produced by the lexer. 
.PP
This pointer is a copy of the one supplied by the CharStream (and may be NULL) so should not be manipulated other than to copy or print it. 
.PP
Referenced by setCharStream().
.SS "\fBpANTLR3_COMMON_TOKEN\fP(* \fBANTLR3_TOKEN_SOURCE_struct::nextToken\fP)(struct \fBANTLR3_TOKEN_SOURCE_struct\fP *tokenSource)"
.PP
Pointer to a function that returns the next token in the stream. 
.PP
Referenced by antlr3LexerNew().
.SS "\fBANTLR3_COMMON_TOKEN\fP \fBANTLR3_TOKEN_SOURCE_struct::skipToken\fP"
.PP
A special pre-allocated token, which is returned by \fBmTokens()\fP if the lexer rule said to just skip the generated token altogether. 
.PP
Having this single token stops us wasting memory by have the token factory actually create something that we are going to SKIP(); anyway. 
.PP
Referenced by antlr3LexerNew(), and nextTokenStr().
.SS "\fBpANTLR3_STRING_FACTORY\fP \fBANTLR3_TOKEN_SOURCE_struct::strFactory\fP"
.PP
Whoever is providing tokens, needs to provide a string factory too. 
.PP
Referenced by antlr3LexerNew(), setCharStream(), and toStringSS().
.SS "void* \fBANTLR3_TOKEN_SOURCE_struct::super\fP"
.PP
Whatever is supplying the token source interface, needs a pointer to itself so that this pointer can be passed to it when the nextToken function is called. 
.PP
Referenced by antlr3LexerNew(), nextToken(), and nextTokenStr().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
