<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR3C: ANTLR3_TREE_NODE_STREAM_struct Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ANTLR3_TREE_NODE_STREAM_struct Struct Reference</h1><!-- doxytag: class="ANTLR3_TREE_NODE_STREAM_struct" --><code>#include &lt;antlr3commontreenodestream.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for ANTLR3_TREE_NODE_STREAM_struct:</div>
<div class="dynsection">
<p><center><img src="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct__coll__graph.png" border="0" usemap="#_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct__coll__map" alt="Collaboration graph"></center>
<map name="_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct__coll__map">
<area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html" title="ANTLR3_COMMON_TREE_NODE_STREAM_struct" alt="" coords="3520,560,3859,587"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html" title="Base string class tracks the allocations and provides simple string tracking functions..." alt="" coords="976,449,1149,476"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html" title="Definition of the string factory interface, which creates and tracks strings for..." alt="" coords="629,449,875,476"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html" title="ANTLR3_INT_STREAM_struct" alt="" coords="1296,380,1504,407"><area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html" title="The definition of an ANTLR3 common token structure, which all implementations of..." alt="" coords="1951,517,2188,544"><area shape="rect" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html" title="Master context structure for an ANTLR3 C runtime based input stream." alt="" coords="1619,420,1845,447"><area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html" title="A generic tree implementation with no payload." alt="" coords="2348,720,2551,747"><area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html" title="ANTLR3_BASE_TREE_ADAPTOR_struct" alt="" coords="2725,323,3000,349"><area shape="rect" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html" title="The ANTLR3 debugging interface for communicating with ANLTR Works." alt="" coords="2301,308,2597,335"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html" title="ANTLR3_VECTOR_struct" alt="" coords="360,877,539,904"><area shape="rect" href="struct_a_n_t_l_r3___s_t_a_c_k__struct.html" title="Structure that represents a Stack collection." alt="" coords="2365,964,2533,991"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r___f_a_c_t_o_r_y__struct.html" title="Structure that tracks vectors in a vector and auto deletes the vectors in the vector..." alt="" coords="2737,941,2988,968"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r___e_l_e_m_e_n_t__struct.html" title="ANTLR3_VECTOR_ELEMENT_struct" alt="" coords="7,877,255,904"><area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_r_e_e__struct.html" title="Interface for an ANTLR3 common tree which is what gets passed around by the AST producing..." alt="" coords="2748,731,2977,757"><area shape="rect" href="struct_a_n_t_l_r3___a_r_b_o_r_e_t_u_m__struct.html" title="ANTLR3 Tree factory interface to create lots of trees efficiently rather than creating..." alt="" coords="3180,829,3388,856"><area shape="rect" href="struct_a_n_t_l_r3___t_o_k_e_n___f_a_c_t_o_r_y__struct.html" title="ANTLR3 Token factory interface to create lots of tokens efficiently rather than creating..." alt="" coords="2329,409,2569,436"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#7e187756cb02b552ce74845ad283c29f">_LT</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get tree node at current input pointer + i ahead where i=1 is next node.  <a href="#7e187756cb02b552ce74845ad283c29f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">pANTLR3_COMMON_TREE_NODE_STREAM</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#844d639cc5d64bd4b5caef3c5bfecbbe">ctns</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Any interface that implements this interface (is a super structure containing this structure), may store the pointer to itself here in the super pointer, which is not used by the tree node stream.  <a href="#844d639cc5d64bd4b5caef3c5bfecbbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#1a026ae809753b3db3f6ad689ead33af">free</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release up any and all space the the interface allocate, including for this structure.  <a href="#1a026ae809753b3db3f6ad689ead33af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#f29135ad561a2c7adc155c8c85e3536e">get</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a tree node at an absolute index i; 0.  <a href="#f29135ad561a2c7adc155c8c85e3536e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html">pANTLR3_BASE_TREE_ADAPTOR</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#a46fce4d8277d8c8ad4fc4a5ecf92116">getTreeAdaptor</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What adaptor can tell me how to interpret/navigate nodes and trees.  <a href="#a46fce4d8277d8c8ad4fc4a5ecf92116"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#8f818b3650b82b6c9a666ed2fed60c85">getTreeSource</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Where is this stream pulling nodes from? This is not the name, but the object that provides node objects.  <a href="#8f818b3650b82b6c9a666ed2fed60c85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html">pANTLR3_INT_STREAM</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#e3d949bb86a708bafeb611157db2b131">istream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All input streams implement the ANTLR3_INT_STREAM interface.  <a href="#e3d949bb86a708bafeb611157db2b131"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#445e9d8e9cf809a0d8dd1d7a96d5ddd1">replaceChildren</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> parent, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> startChildIndex, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> stopChildIndex, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace from start to stop child index of parent with t, which might be a list.  <a href="#445e9d8e9cf809a0d8dd1d7a96d5ddd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#88d9c6dd1cd4de3b2338a44077f10aad">setUniqueNavigationNodes</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> uniqueNavigationNodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As we flatten the tree, we use UP, DOWN nodes to represent the tree structure.  <a href="#88d9c6dd1cd4de3b2338a44077f10aad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#23ecc8ce37b51030490558a7b3cc4e44">toString</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#e867da76a4f0fb0092ca2bbfe424ec56">toStringSS</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> start, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> stop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the text of all nodes from start to stop, inclusive.  <a href="#e867da76a4f0fb0092ca2bbfe424ec56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#bd8afe607714bab5b88c99746f60e4c5">toStringWork</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> start, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> stop, <a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a> buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the text of all nodes from start to stop, inclusive, into the supplied buffer.  <a href="#bd8afe607714bab5b88c99746f60e4c5"></a><br></td></tr>
</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="7e187756cb02b552ce74845ad283c29f"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::_LT" ref="7e187756cb02b552ce74845ad283c29f" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns, ANTLR3_INT32 k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#7e187756cb02b552ce74845ad283c29f">ANTLR3_TREE_NODE_STREAM_struct::_LT</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> k)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get tree node at current input pointer + i ahead where i=1 is next node. 
<p>
i&lt;0 indicates nodes in the past. So LT(-1) is previous node, but implementations are not required to provide results for k &lt; -1. LT(0) is undefined. For i&gt;=n, return null. Return NULL for LT(0) and any index that results in an absolute address that is negative (beyond the start of the list).<p>
This is analogous to the <a class="el" href="antlr3debughandlers_8c.html#1e00f0d3b36741069d450192175ba89a">LT()</a> method of the TokenStream, but this returns a tree node instead of a token. Makes code gen identical for both parser and tree grammars. :) 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00269">antlr3RecognitionExceptionNew()</a>, <a class="el" href="antlr3treeparser_8c-source.html#l00189">getCurrentInputSymbol()</a>, and <a class="el" href="antlr3treeparser_8c-source.html#l00204">getMissingSymbol()</a>.</p>

</div>
</div><p>
<a class="anchor" name="844d639cc5d64bd4b5caef3c5bfecbbe"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::ctns" ref="844d639cc5d64bd4b5caef3c5bfecbbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">pANTLR3_COMMON_TREE_NODE_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#844d639cc5d64bd4b5caef3c5bfecbbe">ANTLR3_TREE_NODE_STREAM_struct::ctns</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Any interface that implements this interface (is a super structure containing this structure), may store the pointer to itself here in the super pointer, which is not used by the tree node stream. 
<p>
This will point to an implementation of ANTLR3_COMMON_TREE_NODE_STREAM in this case. 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>, <a class="el" href="antlr3treeparser_8c-source.html#l00189">getCurrentInputSymbol()</a>, <a class="el" href="antlr3treeparser_8c-source.html#l00204">getMissingSymbol()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00551">LB()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1a026ae809753b3db3f6ad689ead33af"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::free" ref="1a026ae809753b3db3f6ad689ead33af" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#1a026ae809753b3db3f6ad689ead33af">ANTLR3_TREE_NODE_STREAM_struct::free</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release up any and all space the the interface allocate, including for this structure. 
<p>

<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00420">antlr3CommonTreeNodeStreamFree()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00088">antlr3TreeNodeStreamNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f29135ad561a2c7adc155c8c85e3536e"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::get" ref="f29135ad561a2c7adc155c8c85e3536e" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns, ANTLR3_INT32 i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#f29135ad561a2c7adc155c8c85e3536e">ANTLR3_TREE_NODE_STREAM_struct::get</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> i)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a tree node at an absolute index i; 0. 
<p>
.n-1. If you don't want to buffer up nodes, then this method makes no sense for you. 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a46fce4d8277d8c8ad4fc4a5ecf92116"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::getTreeAdaptor" ref="a46fce4d8277d8c8ad4fc4a5ecf92116" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html">pANTLR3_BASE_TREE_ADAPTOR</a>(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#a46fce4d8277d8c8ad4fc4a5ecf92116">ANTLR3_TREE_NODE_STREAM_struct::getTreeAdaptor</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
What adaptor can tell me how to interpret/navigate nodes and trees. 
<p>
E.g., get text of a node. 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8f818b3650b82b6c9a666ed2fed60c85"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::getTreeSource" ref="8f818b3650b82b6c9a666ed2fed60c85" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#8f818b3650b82b6c9a666ed2fed60c85">ANTLR3_TREE_NODE_STREAM_struct::getTreeSource</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Where is this stream pulling nodes from? This is not the name, but the object that provides node objects. 
<p>

<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e3d949bb86a708bafeb611157db2b131"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::istream" ref="e3d949bb86a708bafeb611157db2b131" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html">pANTLR3_INT_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#e3d949bb86a708bafeb611157db2b131">ANTLR3_TREE_NODE_STREAM_struct::istream</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All input streams implement the ANTLR3_INT_STREAM interface. 
<p>
.. 
<p>Referenced by <a class="el" href="antlr3baserecognizer_8c-source.html#l01918">alreadyParsedRule()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00420">antlr3CommonTreeNodeStreamFree()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00269">antlr3RecognitionExceptionNew()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01716">consumeUntil()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01766">consumeUntilSet()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01008">displayRecognitionError()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00415">match()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00489">matchAny()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01989">memoize()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01320">recover()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01619">recoverFromMismatchedElement()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01555">recoverFromMismatchedSet()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01432">recoverFromMismatchedToken()</a>, <a class="el" href="antlr3commontreenodestream_8c-source.html#l00526">reset()</a>, and <a class="el" href="antlr3baserecognizer_8c-source.html#l02055">synpred()</a>.</p>

</div>
</div><p>
<a class="anchor" name="445e9d8e9cf809a0d8dd1d7a96d5ddd1"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::replaceChildren" ref="445e9d8e9cf809a0d8dd1d7a96d5ddd1" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns, pANTLR3_BASE_TREE parent, ANTLR3_INT32 startChildIndex, ANTLR3_INT32 stopChildIndex, pANTLR3_BASE_TREE t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#445e9d8e9cf809a0d8dd1d7a96d5ddd1">ANTLR3_TREE_NODE_STREAM_struct::replaceChildren</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> parent, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> startChildIndex, <a class="el" href="antlr3defs_8h.html#6faef5c4687f8eb633d2aefea93973ca">ANTLR3_INT32</a> stopChildIndex, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace from start to stop child index of parent with t, which might be a list. 
<p>
Number of children may be different after this call. The stream is notified because it is walking the tree and might need to know you are monkeying with the underlying tree. Also, it might be able to modify the node stream to avoid restreaming for future phases.<p>
If parent is null, don't do anything; must be at root of overall tree. Can't replace whatever points to the parent externally. Do nothing. 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00088">antlr3TreeNodeStreamNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="88d9c6dd1cd4de3b2338a44077f10aad"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::setUniqueNavigationNodes" ref="88d9c6dd1cd4de3b2338a44077f10aad" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns, ANTLR3_BOOLEAN uniqueNavigationNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#88d9c6dd1cd4de3b2338a44077f10aad">ANTLR3_TREE_NODE_STREAM_struct::setUniqueNavigationNodes</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> uniqueNavigationNodes)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
As we flatten the tree, we use UP, DOWN nodes to represent the tree structure. 
<p>
When debugging we need unique nodes so we have to instantiate new ones. When doing normal tree parsing, it's slow and a waste of memory to create unique navigation nodes. Default should be false; 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="23ecc8ce37b51030490558a7b3cc4e44"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::toString" ref="23ecc8ce37b51030490558a7b3cc4e44" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#23ecc8ce37b51030490558a7b3cc4e44">ANTLR3_TREE_NODE_STREAM_struct::toString</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e867da76a4f0fb0092ca2bbfe424ec56"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::toStringSS" ref="e867da76a4f0fb0092ca2bbfe424ec56" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns, pANTLR3_BASE_TREE start, pANTLR3_BASE_TREE stop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#e867da76a4f0fb0092ca2bbfe424ec56">ANTLR3_TREE_NODE_STREAM_struct::toStringSS</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> start, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> stop)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the text of all nodes from start to stop, inclusive. 
<p>
If the stream does not buffer all the nodes then it can still walk recursively from start until stop. You can always return null or "" too, but users should not access $ruleLabel.text in an action of course in that case. 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="bd8afe607714bab5b88c99746f60e4c5"></a><!-- doxytag: member="ANTLR3_TREE_NODE_STREAM_struct::toStringWork" ref="bd8afe607714bab5b88c99746f60e4c5" args=")(struct ANTLR3_TREE_NODE_STREAM_struct *tns, pANTLR3_BASE_TREE start, pANTLR3_BASE_TREE stop, pANTLR3_STRING buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html#bd8afe607714bab5b88c99746f60e4c5">ANTLR3_TREE_NODE_STREAM_struct::toStringWork</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_r_e_e___n_o_d_e___s_t_r_e_a_m__struct.html">ANTLR3_TREE_NODE_STREAM_struct</a> *tns, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> start, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> stop, <a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a> buf)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the text of all nodes from start to stop, inclusive, into the supplied buffer. 
<p>
If the stream does not buffer all the nodes then it can still walk recursively from start until stop. You can always return null or "" too, but users should not access $ruleLabel.text in an action of course in that case. 
<p>Referenced by <a class="el" href="antlr3commontreenodestream_8c-source.html#l00270">antlr3CommonTreeNodeStreamNew()</a>, and <a class="el" href="antlr3commontreenodestream_8c-source.html#l00132">antlr3CommonTreeNodeStreamNewStream()</a>.</p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="antlr3commontreenodestream_8h.html">antlr3commontreenodestream.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:07 2010 for ANTLR3C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
