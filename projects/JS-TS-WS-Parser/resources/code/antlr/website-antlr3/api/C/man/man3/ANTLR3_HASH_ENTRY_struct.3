.TH "ANTLR3_HASH_ENTRY_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_HASH_ENTRY_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3collections.h>\fP
.PP
.SH "Detailed Description"
.PP 
Internal structure representing an element in a hash bucket. 

Stores the original key so that duplicate keys can be rejected if necessary, and contains function can be supported. If the hash key could be unique I would have invented the perfect compression algorithm ;-) 
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP (ANTLR3_CDECL *free)(void *\fBdata\fP)"
.br
.RI "\fIPointer to routine that knows how to release the memory structure pointed at by data. \fP"
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "void * \fBdata\fP"
.br
.RI "\fIPointer to the data for this particular entry. \fP"
.ti -1c
.RI "\fBANTLR3_HASH_KEY\fP \fBkeybase\fP"
.br
.RI "\fIKey that created this particular entry. \fP"
.ti -1c
.RI "struct \fBANTLR3_HASH_ENTRY_struct\fP * \fBnextEntry\fP"
.br
.RI "\fIPointer to the next entry in this bucket if there is one. \fP"
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "ANTLR3_HASH_ENTRY_struct::void (ANTLR3_CDECL * free)"
.PP
Pointer to routine that knows how to release the memory structure pointed at by data. 
.PP
If this is NULL then we assume that the data pointer does not need to be freed when the entry is deleted from the table. 
.SH "Field Documentation"
.PP 
.SS "void* \fBANTLR3_HASH_ENTRY_struct::data\fP"
.PP
Pointer to the data for this particular entry. 
.PP
Referenced by antlr3EnumNext(), antlr3HashDelete(), antlr3HashDeleteI(), antlr3HashFree(), antlr3HashGet(), antlr3HashGetI(), antlr3HashPut(), antlr3HashPutI(), and antlr3ListRemove().
.SS "\fBANTLR3_HASH_KEY\fP \fBANTLR3_HASH_ENTRY_struct::keybase\fP"
.PP
Key that created this particular entry. 
.PP
Referenced by antlr3EnumNext(), antlr3HashFree(), antlr3HashGet(), antlr3HashGetI(), antlr3HashPut(), antlr3HashPutI(), antlr3HashRemove(), and antlr3HashRemoveI().
.SS "struct \fBANTLR3_HASH_ENTRY_struct\fP* \fBANTLR3_HASH_ENTRY_struct::nextEntry\fP\fC [read]\fP"
.PP
Pointer to the next entry in this bucket if there is one. 
.PP
Sometimes different keys will hash to the same bucket (especially if the number of buckets is small). We could implement dual hashing algorithms to minimize this, but that seems over the top for what this is needed for. 
.PP
Referenced by antlr3EnumNextEntry(), antlr3HashFree(), antlr3HashGet(), antlr3HashGetI(), antlr3HashPut(), antlr3HashPutI(), antlr3HashRemove(), and antlr3HashRemoveI().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
