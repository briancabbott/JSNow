.TH "ANTLR3_TOKEN_STREAM_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_TOKEN_STREAM_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3tokenstream.h>\fP
.PP
.SH "Detailed Description"
.PP 
Definition of the ANTLR3 common token stream interface. 

\fBRemarks:\fP
.RS 4
Much of the documentation for this interface is stolen from Ter's Java implementation. 
.RE
.PP

.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBpANTLR3_COMMON_TOKEN\fP(* \fB_LT\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_INT32\fP k)"
.br
.RI "\fIGet Token at current input pointer + i ahead where i=1 is next Token. \fP"
.ti -1c
.RI "\fBpANTLR3_DEBUG_EVENT_LISTENER\fP \fBdebugger\fP"
.br
.RI "\fIDebugger interface, is this is a debugging token stream. \fP"
.ti -1c
.RI "void(* \fBfree\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream)"
.br
.RI "\fIFunction that knows how to free the memory for an ANTLR3_TOKEN_STREAM. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TOKEN\fP(* \fBget\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP i)"
.br
.RI "\fIGet a token at an absolute index i; 0. \fP"
.ti -1c
.RI "\fBpANTLR3_TOKEN_SOURCE\fP(* \fBgetTokenSource\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream)"
.br
.RI "\fIWhere is this stream pulling tokens from? This is not the name, but a pointer into an interface that contains a ANTLR3_TOKEN_SOURCE interface. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBinitialStreamState\fP"
.br
.RI "\fIIndicates the initial stream state for \fBdbgConsume()\fP. \fP"
.ti -1c
.RI "\fBpANTLR3_INT_STREAM\fP \fBistream\fP"
.br
.RI "\fIAll input streams implement the ANTLR3_INT_STREAM interface. \fP"
.ti -1c
.RI "void(* \fBsetDebugListener\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBpANTLR3_DEBUG_EVENT_LISTENER\fP \fBdebugger\fP)"
.br
.RI "\fIFunction that sets the token stream into debugging mode. \fP"
.ti -1c
.RI "void(* \fBsetTokenSource\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBpANTLR3_TOKEN_SOURCE\fP \fBtokenSource\fP)"
.br
.RI "\fIFunction that installs a token source for teh stream. \fP"
.ti -1c
.RI "void * \fBsuper\fP"
.br
.RI "\fIWhatever is providing this interface needs a pointer to itself so that this can be passed back to it whenever the api functions are called. \fP"
.ti -1c
.RI "\fBpANTLR3_TOKEN_SOURCE\fP \fBtokenSource\fP"
.br
.RI "\fIPointer to the token source for this stream. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBtoString\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream)"
.br
.RI "\fIReturn the text of all the tokens in the stream, as the old tramp in Leeds market used to say; 'Get the lot!'. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBtoStringSS\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop)"
.br
.RI "\fIReturn the text of all tokens from start to stop, inclusive. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBtoStringTT\fP )(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBpANTLR3_COMMON_TOKEN\fP start, \fBpANTLR3_COMMON_TOKEN\fP stop)"
.br
.RI "\fIBecause the user is not required to use a token with an index stored in it, we must provide a means for two token objects themselves to indicate the start/end location. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBpANTLR3_COMMON_TOKEN\fP(* \fBANTLR3_TOKEN_STREAM_struct::_LT\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_INT32\fP k)"
.PP
Get Token at current input pointer + i ahead where i=1 is next Token. 
.PP
i<0 indicates tokens in the past. So -1 is previous token and -2 is two tokens ago. LT(0) is undefined. For i>=n, return Token.EOFToken. Return null for LT(0) and any index that results in an absolute address that is negative. 
.PP
Referenced by antlr3CommonTokenDebugStreamSourceNew(), antlr3CommonTokenStreamNew(), antlr3RecognitionExceptionNew(), dbgConsume(), getMissingSymbol(), and setDebugListener().
.SS "\fBpANTLR3_DEBUG_EVENT_LISTENER\fP \fBANTLR3_TOKEN_STREAM_struct::debugger\fP"
.PP
Debugger interface, is this is a debugging token stream. 
.PP
Referenced by antlr3CommonTokenDebugStreamSourceNew(), consumeInitialHiddenTokens(), dbgConsume(), and setDebugListener().
.SS "void(* \fBANTLR3_TOKEN_STREAM_struct::free\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream)"
.PP
Function that knows how to free the memory for an ANTLR3_TOKEN_STREAM. 
.PP
Referenced by antlr3CTSFree(), and antlr3TokenStreamNew().
.SS "\fBpANTLR3_COMMON_TOKEN\fP(* \fBANTLR3_TOKEN_STREAM_struct::get\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP i)"
.PP
Get a token at an absolute index i; 0. 
.PP
.n-1. This is really only needed for profiling and debugging and token stream rewriting. If you don't want to buffer up tokens, then this method makes no sense for you. Naturally you can't use the rewrite stream feature. I believe DebugTokenStream can easily be altered to not use this method, removing the dependency. 
.PP
Referenced by antlr3CommonTokenStreamNew(), consumeInitialHiddenTokens(), dbgConsume(), getTokensSet(), and toStringSS().
.SS "\fBpANTLR3_TOKEN_SOURCE\fP(* \fBANTLR3_TOKEN_STREAM_struct::getTokenSource\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream)"
.PP
Where is this stream pulling tokens from? This is not the name, but a pointer into an interface that contains a ANTLR3_TOKEN_SOURCE interface. 
.PP
The Token Source interface contains a pointer to the input stream and a pointer to a function that returns the next token. 
.PP
Referenced by antlr3CommonTokenStreamNew(), and toStringSS().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_TOKEN_STREAM_struct::initialStreamState\fP"
.PP
Indicates the initial stream state for \fBdbgConsume()\fP. 
.PP
Referenced by antlr3CommonTokenDebugStreamSourceNew(), consumeInitialHiddenTokens(), dbgConsume(), dbgTokLT(), and setDebugListener().
.SS "\fBpANTLR3_INT_STREAM\fP \fBANTLR3_TOKEN_STREAM_struct::istream\fP"
.PP
All input streams implement the ANTLR3_INT_STREAM interface. 
.PP
.. 
.PP
Referenced by alreadyParsedRule(), antlr3CommonTokenDebugStreamSourceNew(), antlr3CommonTokenStreamNew(), antlr3CTSFree(), antlr3RecognitionExceptionNew(), consumeUntil(), consumeUntilSet(), dbgTokLT(), displayRecognitionError(), getTokensSet(), match(), matchAny(), memoize(), mismatch(), recover(), recoverFromMismatchedElement(), recoverFromMismatchedSet(), recoverFromMismatchedToken(), setDebugListener(), synpred(), tokLT(), toString(), and toStringSS().
.SS "void(* \fBANTLR3_TOKEN_STREAM_struct::setDebugListener\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBpANTLR3_DEBUG_EVENT_LISTENER\fP \fBdebugger\fP)"
.PP
Function that sets the token stream into debugging mode. 
.PP
Referenced by antlr3CommonTokenStreamNew(), and setDebugListener().
.SS "void(* \fBANTLR3_TOKEN_STREAM_struct::setTokenSource\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBpANTLR3_TOKEN_SOURCE\fP \fBtokenSource\fP)"
.PP
Function that installs a token source for teh stream. 
.PP
Referenced by antlr3CommonTokenStreamNew(), and antlr3CommonTokenStreamSourceNew().
.SS "void* \fBANTLR3_TOKEN_STREAM_struct::super\fP"
.PP
Whatever is providing this interface needs a pointer to itself so that this can be passed back to it whenever the api functions are called. 
.PP
Referenced by antlr3CommonTokenStreamNew(), antlr3CTSFree(), antlr3RecognitionExceptionNew(), consume(), get(), getMissingSymbol(), tokLT(), toString(), and toStringSS().
.SS "\fBpANTLR3_TOKEN_SOURCE\fP \fBANTLR3_TOKEN_STREAM_struct::tokenSource\fP"
.PP
Pointer to the token source for this stream. 
.PP
Referenced by getTokenSource(), setTokenSource(), and tokLT().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_TOKEN_STREAM_struct::toString\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream)"
.PP
Return the text of all the tokens in the stream, as the old tramp in Leeds market used to say; 'Get the lot!'. 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_TOKEN_STREAM_struct::toStringSS\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop)"
.PP
Return the text of all tokens from start to stop, inclusive. 
.PP
If the stream does not buffer all the tokens then it can just return an empty ANTLR3_STRING or NULL; Grammars should not access $ruleLabel.text in an action in that case. 
.PP
Referenced by antlr3CommonTokenStreamNew(), toString(), and toStringTT().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_TOKEN_STREAM_struct::toStringTT\fP)(struct \fBANTLR3_TOKEN_STREAM_struct\fP *tokenStream, \fBpANTLR3_COMMON_TOKEN\fP start, \fBpANTLR3_COMMON_TOKEN\fP stop)"
.PP
Because the user is not required to use a token with an index stored in it, we must provide a means for two token objects themselves to indicate the start/end location. 
.PP
Most often this will just delegate to the other toString(int,int). This is also parallel with the pTREENODE_STREAM->toString(Object,Object). 
.PP
Referenced by antlr3CommonTokenStreamNew().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
