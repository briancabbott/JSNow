.TH "ANTLR3_DEBUG_EVENT_LISTENER_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_DEBUG_EVENT_LISTENER_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3debugeventlistener.h>\fP
.PP
.SH "Detailed Description"
.PP 
The ANTLR3 debugging interface for communicating with ANLTR Works. 

Function comments mostly taken from the Java version. 
.SS "Data Fields"

.in +1c
.ti -1c
.RI "void(* \fBack\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIRetrieve acknowledge response from the debugger. \fP"
.ti -1c
.RI "\fBpANTLR3_BASE_TREE_ADAPTOR\fP \fBadaptor\fP"
.br
.RI "\fIAllows the debug event system to access the adapter in use by the recognizer, if this is a tree parser of some sort. \fP"
.ti -1c
.RI "void(* \fBaddChild\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP root, \fBpANTLR3_BASE_TREE\fP child)"
.br
.RI "\fIMake childID a child of rootID. \fP"
.ti -1c
.RI "void(* \fBbecomeRoot\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP newRoot, \fBpANTLR3_BASE_TREE\fP oldRoot)"
.br
.RI "\fIMake a node the new root of an existing root. \fP"
.ti -1c
.RI "void(* \fBbeginBacktrack\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int level)"
.br
.ti -1c
.RI "void(* \fBbeginResync\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIIndicates the recognizer is about to consume tokens to resynchronize the parser. \fP"
.ti -1c
.RI "void(* \fBcommence\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIAnnounce that parsing has begun. \fP"
.ti -1c
.RI "void(* \fBconsumeHiddenToken\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_COMMON_TOKEN\fP t)"
.br
.RI "\fIAn off-channel input token was consumed. \fP"
.ti -1c
.RI "void(* \fBconsumeNode\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.br
.RI "\fIInput for a tree parser is an AST, but we know nothing for sure about a node except its type and text (obtained from the adaptor). \fP"
.ti -1c
.RI "void(* \fBconsumeToken\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_COMMON_TOKEN\fP t)"
.br
.RI "\fIAn input token was consumed; matched by any kind of element. \fP"
.ti -1c
.RI "void(* \fBcreateNode\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.br
.RI "\fIAnnounce a new node built from token elements such as type etc. \fP"
.ti -1c
.RI "void(* \fBcreateNodeTok\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP node, \fBpANTLR3_COMMON_TOKEN\fP token)"
.br
.RI "\fIAnnounce a new node built from an existing token. \fP"
.ti -1c
.RI "void(* \fBendBacktrack\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int level, \fBANTLR3_BOOLEAN\fP successful)"
.br
.ti -1c
.RI "void(* \fBendResync\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIIndicates that the recognizer has finished consuming tokens in order to resynchronize. \fP"
.ti -1c
.RI "void(* \fBenterAlt\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int alt)"
.br
.RI "\fIBecause rules can have lots of alternatives, it is very useful to know which alt you are entering. \fP"
.ti -1c
.RI "void(* \fBenterDecision\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.br
.RI "\fIEvery decision, fixed k or arbitrary, has an enter/exit event so that a GUI can easily track what LT/consume events are associated with prediction. \fP"
.ti -1c
.RI "void(* \fBenterRule\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, const char *\fBgrammarFileName\fP, const char *ruleName)"
.br
.RI "\fIThe parser has just entered a rule. \fP"
.ti -1c
.RI "void(* \fBenterSubRule\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.br
.RI "\fITrack entry into any (. \fP"
.ti -1c
.RI "void(* \fBerrorNode\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.br
.RI "\fIIf a syntax error occurs, recognizers bracket the error with an error node if they are building ASTs. \fP"
.ti -1c
.RI "void(* \fBexitDecision\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.br
.ti -1c
.RI "void(* \fBexitRule\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, const char *\fBgrammarFileName\fP, const char *ruleName)"
.br
.RI "\fIThis is the last thing executed before leaving a rule. \fP"
.ti -1c
.RI "void(* \fBexitSubRule\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.br
.ti -1c
.RI "void(* \fBfree\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIFree up the resources allocated to this structure. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP \fBgrammarFileName\fP"
.br
.RI "\fIThe name of the grammar file that we are debugging. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP(* \fBhandshake\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIWait for a connection from the debugger and initiate the debugging session. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBinitialized\fP"
.br
.RI "\fIIndicates whether we have already connected or not. \fP"
.ti -1c
.RI "void(* \fBlocation\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int line, int pos)"
.br
.RI "\fITo watch a parser move through the grammar, the parser needs to inform the debugger what line/charPos it is passing in the grammar. \fP"
.ti -1c
.RI "void(* \fBLT\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int i, \fBpANTLR3_COMMON_TOKEN\fP t)"
.br
.RI "\fISomebody (anybody) looked ahead. \fP"
.ti -1c
.RI "void(* \fBLTT\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int i, \fBpANTLR3_BASE_TREE\fP t)"
.br
.RI "\fIThe tree parser looked ahead. \fP"
.ti -1c
.RI "void(* \fBmark\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBANTLR3_MARKER\fP marker)"
.br
.RI "\fIThe parser is going to look arbitrarily ahead; mark this location, the token stream's marker is sent in case you need it. \fP"
.ti -1c
.RI "void(* \fBnilNode\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.br
.RI "\fIA nil was created (even nil nodes have a unique ID. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBport\fP"
.br
.RI "\fIThe port number which the debug listener should listen on for a connection. \fP"
.ti -1c
.RI "int \fBPROTOCOL_VERSION\fP"
.br
.RI "\fIThe version of the debugging protocol supported by the providing instance of the debug event listener. \fP"
.ti -1c
.RI "void(* \fBrecognitionException\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_EXCEPTION\fP e)"
.br
.RI "\fIA recognition exception occurred such as NoViableAltException. \fP"
.ti -1c
.RI "void(* \fBrewind\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBANTLR3_MARKER\fP marker)"
.br
.RI "\fIAfter an arbitrarily long lookahead as with a cyclic DFA (or with any backtrack), this informs the debugger that stream should be rewound to the position associated with marker. \fP"
.ti -1c
.RI "void(* \fBrewindLast\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIRewind to the input position of the last marker. \fP"
.ti -1c
.RI "void(* \fBsemanticPredicate\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBANTLR3_BOOLEAN\fP result, const char *predicate)"
.br
.RI "\fIA semantic predicate was evaluate with this result and action text. \fP"
.ti -1c
.RI "void(* \fBsetTokenBoundaries\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t, \fBANTLR3_MARKER\fP tokenStartIndex, \fBANTLR3_MARKER\fP tokenStopIndex)"
.br
.RI "\fISet the token start/stop token index for a subtree root or node. \fP"
.ti -1c
.RI "\fBSOCKET\fP \fBsocket\fP"
.br
.RI "\fIThe socket structure we receive after a successful accept on the serverSocket. \fP"
.ti -1c
.RI "void(* \fBterminate\fP )(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.br
.RI "\fIParsing is over; successfully or not. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP \fBtokenString\fP"
.br
.RI "\fIUsed to serialize the values of any particular token we need to send back to the debugger. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::ack\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Retrieve acknowledge response from the debugger. 
.PP
in fact this response is never used at the moment. So we just read whatever is in the socket buffer and throw it away. 
.SS "\fBpANTLR3_BASE_TREE_ADAPTOR\fP \fBANTLR3_DEBUG_EVENT_LISTENER_struct::adaptor\fP"
.PP
Allows the debug event system to access the adapter in use by the recognizer, if this is a tree parser of some sort. 
.PP
Referenced by antlr3BaseTreeAdaptorInit(), and serializeNode().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::addChild\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP root, \fBpANTLR3_BASE_TREE\fP child)"
.PP
Make childID a child of rootID. 
.PP
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only IDs are set.
.PP
\fBSee also:\fP
.RS 4
\fBorg.antlr.runtime.tree.TreeAdaptor.addChild()\fP 
.RE
.PP

.PP
Referenced by antlr3DebugListenerNew(), dbgAddChild(), dbgAddChildToken(), and simulateTreeConstruction().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::becomeRoot\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP newRoot, \fBpANTLR3_BASE_TREE\fP oldRoot)"
.PP
Make a node the new root of an existing root. 
.PP
See
.PP
Note: the newRootID parameter is possibly different than the \fBTreeAdaptor.becomeRoot()\fP newRoot parameter. In our case, it will always be the result of calling \fBTreeAdaptor.becomeRoot()\fP and not root_n or whatever.
.PP
The listener should assume that this event occurs only when the current subrule (or rule) subtree is being reset to newRootID.
.PP
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only IDs are set.
.PP
\fBSee also:\fP
.RS 4
\fBorg.antlr.runtime.tree.TreeAdaptor.becomeRoot()\fP 
.RE
.PP

.PP
Referenced by antlr3DebugListenerNew(), dbgBecomeRoot(), and dbgBecomeRootToken().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::beginBacktrack\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int level)"
.PP
Referenced by antlr3DebugListenerNew(), and beginBacktrack().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::beginResync\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Indicates the recognizer is about to consume tokens to resynchronize the parser. 
.PP
Any consume events from here until the recovered event are not part of the parse--they are dead tokens. 
.PP
Referenced by antlr3DebugListenerNew(), beginResync(), and recoverFromMismatchedToken().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::commence\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Announce that parsing has begun. 
.PP
Not technically useful except for sending events over a socket. A GUI for example will launch a thread to connect and communicate with a remote parser. The thread will want to notify the GUI when a connection is made. ANTLR parsers trigger this upon entry to the first rule (the ruleLevel is used to figure this out). 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::consumeHiddenToken\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_COMMON_TOKEN\fP t)"
.PP
An off-channel input token was consumed. 
.PP
Trigger after the token was matched by things like \fBmatch()\fP, \fBmatchAny()\fP. (unless of course the hidden token is first stuff in the input stream). 
.PP
Referenced by antlr3DebugListenerNew(), consumeInitialHiddenTokens(), and dbgConsume().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::consumeNode\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.PP
Input for a tree parser is an AST, but we know nothing for sure about a node except its type and text (obtained from the adaptor). 
.PP
This is the analog of the consumeToken method. The ID is usually the memory address of the node. If the type is UP or DOWN, then the ID is not really meaningful as it's fixed--there is just one UP node and one DOWN navigation node.
.PP
Note that unlike the Java version, the node type of the C parsers is always fixed as pANTLR3_BASE_TREE because all such structures contain a super pointer to their parent, which is generally COMMON_TREE and within that there is a super pointer that can point to a user type that encapsulates it. Almost akin to saying that it is an interface pointer except we don't need to know what the interface is in full, just those bits that are the base. 
.PP
\fBParameters:\fP
.RS 4
\fIt\fP 
.RE
.PP

.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::consumeToken\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_COMMON_TOKEN\fP t)"
.PP
An input token was consumed; matched by any kind of element. 
.PP
Trigger after the token was matched by things like \fBmatch()\fP, \fBmatchAny()\fP. 
.PP
Referenced by antlr3DebugListenerNew(), and dbgConsume().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::createNode\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.PP
Announce a new node built from token elements such as type etc. 
.PP
..
.PP
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID, type, text are set. 
.PP
Referenced by antlr3DebugListenerNew(), dbgCreate(), dbgCreateTypeText(), dbgCreateTypeToken(), dbgCreateTypeTokenText(), dbgNil(), and simulateTreeConstruction().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::createNodeTok\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP node, \fBpANTLR3_COMMON_TOKEN\fP token)"
.PP
Announce a new node built from an existing token. 
.PP
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only node.ID and token.tokenIndex are set. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::endBacktrack\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int level, \fBANTLR3_BOOLEAN\fP successful)"
.PP
Referenced by antlr3DebugListenerNew(), and endBacktrack().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::endResync\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Indicates that the recognizer has finished consuming tokens in order to resynchronize. 
.PP
There may be multiple beginResync/endResync pairs before the recognizer comes out of errorRecovery mode (in which multiple errors are suppressed). This will be useful in a gui where you want to probably grey out tokens that are consumed but not matched to anything in grammar. Anything between a beginResync/endResync pair was tossed out by the parser. 
.PP
Referenced by antlr3DebugListenerNew(), endResync(), and recoverFromMismatchedToken().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::enterAlt\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int alt)"
.PP
Because rules can have lots of alternatives, it is very useful to know which alt you are entering. 
.PP
This is 1..n for n alts. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::enterDecision\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.PP
Every decision, fixed k or arbitrary, has an enter/exit event so that a GUI can easily track what LT/consume events are associated with prediction. 
.PP
You will see a single enter/exit subrule but multiple enter/exit decision events, one for each loop iteration. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::enterRule\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, const char *\fBgrammarFileName\fP, const char *ruleName)"
.PP
The parser has just entered a rule. 
.PP
No decision has been made about which alt is predicted. This is fired AFTER init actions have been executed. Attributes are defined and available etc... 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::enterSubRule\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.PP
Track entry into any (. 
.PP
..) subrule other EBNF construct 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::errorNode\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.PP
If a syntax error occurs, recognizers bracket the error with an error node if they are building ASTs. 
.PP
This event notifies the listener that this is the case 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::exitDecision\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::exitRule\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, const char *\fBgrammarFileName\fP, const char *ruleName)"
.PP
This is the last thing executed before leaving a rule. 
.PP
It is executed even if an exception is thrown. This is triggered after error reporting and recovery have occurred (unless the exception is not caught in this rule). This implies an 'exitAlt' event. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::exitSubRule\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int decisionNumber)"
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::free\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Free up the resources allocated to this structure. 
.PP
.SS "\fBpANTLR3_STRING\fP \fBANTLR3_DEBUG_EVENT_LISTENER_struct::grammarFileName\fP"
.PP
The name of the grammar file that we are debugging. 
.PP
Referenced by handshake(), serializeNode(), and serializeToken().
.SS "\fBANTLR3_BOOLEAN\fP(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::handshake\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Wait for a connection from the debugger and initiate the debugging session. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_DEBUG_EVENT_LISTENER_struct::initialized\fP"
.PP
Indicates whether we have already connected or not. 
.PP
Referenced by handshake().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::location\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int line, int pos)"
.PP
To watch a parser move through the grammar, the parser needs to inform the debugger what line/charPos it is passing in the grammar. 
.PP
For now, this does not know how to switch from one grammar to the other and back for island grammars etc...
.PP
This should also allow breakpoints because the debugger can stop the parser whenever it hits this line/pos. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::LT\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int i, \fBpANTLR3_COMMON_TOKEN\fP t)"
.PP
Somebody (anybody) looked ahead. 
.PP
Note that this actually gets triggered by both LA and LT calls. The debugger will want to know which Token object was examined. Like consumeToken, this indicates what token was seen at that depth. A remote debugger cannot look ahead into a file it doesn't have so LT events must pass the token even if the info is redundant. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::LTT\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, int i, \fBpANTLR3_BASE_TREE\fP t)"
.PP
The tree parser looked ahead. 
.PP
If the type is UP or DOWN, then the ID is not really meaningful as it's fixed--there is just one UP node and one DOWN navigation node. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::mark\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBANTLR3_MARKER\fP marker)"
.PP
The parser is going to look arbitrarily ahead; mark this location, the token stream's marker is sent in case you need it. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::nilNode\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t)"
.PP
A nil was created (even nil nodes have a unique ID. 
.PP
.. they are not 'null' per se). As of 4/28/2006, this seems to be uniquely triggered when starting a new subtree such as when entering a subrule in automatic mode and when building a tree in rewrite mode.
.PP
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID is set. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_DEBUG_EVENT_LISTENER_struct::port\fP"
.PP
The port number which the debug listener should listen on for a connection. 
.PP
Referenced by antlr3DebugListenerNew(), antlr3DebugListenerNewPort(), and handshake().
.SS "int \fBANTLR3_DEBUG_EVENT_LISTENER_struct::PROTOCOL_VERSION\fP"
.PP
The version of the debugging protocol supported by the providing instance of the debug event listener. 
.PP
Referenced by antlr3DebugListenerNew(), and handshake().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::recognitionException\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_EXCEPTION\fP e)"
.PP
A recognition exception occurred such as NoViableAltException. 
.PP
I made this a generic event so that I can alter the exception hierarchy later without having to alter all the debug objects.
.PP
Upon error, the stack of enter rule/subrule must be properly unwound. If no viable alt occurs it is within an enter/exit decision, which also must be rewound. Even the rewind for each mark must be unwound. In the Java target this is pretty easy using try/finally, if a bit ugly in the generated code. The rewind is generated in DFA.predict() actually so no code needs to be generated for that. For languages w/o this 'finally' feature (C++?), the target implementor will have to build an event stack or something.
.PP
Across a socket for remote debugging, only the RecognitionException data fields are transmitted. The token object or whatever that caused the problem was the last object referenced by LT. The immediately preceding LT event should hold the unexpected Token or char.
.PP
Here is a sample event trace for grammar:
.PP
b : C ({;}A|B) // {;} is there to prevent A|B becoming a set | D ;
.PP
The sequence for this rule (with no viable alt in the subrule) for input 'c c' (there are 3 tokens) is:
.PP
commence LT(1) enterRule b location 7 1 enter decision 3 LT(1) exit decision 3 enterAlt1 location 7 5 LT(1) consumeToken [c/<4>,1:0] location 7 7 enterSubRule 2 enter decision 2 LT(1) LT(1) recognitionException NoViableAltException 2 1 2 exit decision 2 exitSubRule 2 beginResync LT(1) consumeToken [c/<4>,1:1] LT(1) endResync LT(-1) exitRule b terminate 
.PP
Referenced by antlr3DebugListenerNew(), and reportError().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::rewind\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBANTLR3_MARKER\fP marker)"
.PP
After an arbitrarily long lookahead as with a cyclic DFA (or with any backtrack), this informs the debugger that stream should be rewound to the position associated with marker. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::rewindLast\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Rewind to the input position of the last marker. 
.PP
Used currently only after a cyclic DFA and just before starting a sem/syn predicate to get the input position back to the start of the decision. Do not 'pop' the marker off the state. mark(i) and rewind(i) should balance still. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::semanticPredicate\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBANTLR3_BOOLEAN\fP result, const char *predicate)"
.PP
A semantic predicate was evaluate with this result and action text. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::setTokenBoundaries\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy, \fBpANTLR3_BASE_TREE\fP t, \fBANTLR3_MARKER\fP tokenStartIndex, \fBANTLR3_MARKER\fP tokenStopIndex)"
.PP
Set the token start/stop token index for a subtree root or node. 
.PP
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID is set. 
.PP
Referenced by antlr3DebugListenerNew(), and dbgSetTokenBoundaries().
.SS "\fBSOCKET\fP \fBANTLR3_DEBUG_EVENT_LISTENER_struct::socket\fP"
.PP
The socket structure we receive after a successful accept on the serverSocket. 
.PP
Referenced by ack(), handshake(), and transmit().
.SS "void(* \fBANTLR3_DEBUG_EVENT_LISTENER_struct::terminate\fP)(\fBpANTLR3_DEBUG_EVENT_LISTENER\fP delboy)"
.PP
Parsing is over; successfully or not. 
.PP
Mostly useful for telling remote debugging listeners that it's time to quit. When the rule invocation level goes to zero at the end of a rule, we are done parsing. 
.PP
Referenced by antlr3DebugListenerNew().
.SS "\fBpANTLR3_STRING\fP \fBANTLR3_DEBUG_EVENT_LISTENER_struct::tokenString\fP"
.PP
Used to serialize the values of any particular token we need to send back to the debugger. 
.PP
Referenced by serializeNode(), and serializeToken().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
