.TH "ANTLR3_COMMON_TOKEN_STREAM_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_COMMON_TOKEN_STREAM_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3tokenstream.h>\fP
.PP
.SH "Detailed Description"
.PP 
Common token stream is an implementation of ANTLR_TOKEN_STREAM for the default parsers and recognizers. 

You may of course build your own implementation if you are so inclined. 
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBchannel\fP"
.br
.ti -1c
.RI "\fBpANTLR3_LIST\fP \fBchannelOverrides\fP"
.br
.RI "\fIOverride map of tokens. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBdiscardOffChannel\fP"
.br
.RI "\fIIf this flag is set to ANTLR3_TRUE, then tokens that the stream sees that are not in the channel that this stream is tuned to, are not tracked in the tokens table. \fP"
.ti -1c
.RI "void(* \fBdiscardOffChannelToks\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_BOOLEAN\fP discard)"
.br
.RI "\fISignal to discard off channel tokens from here on in. \fP"
.ti -1c
.RI "\fBpANTLR3_LIST\fP \fBdiscardSet\fP"
.br
.RI "\fIDiscared set. \fP"
.ti -1c
.RI "void(* \fBdiscardTokenType\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_INT32\fP ttype)"
.br
.RI "\fIAdd a particular token type to the discard set. \fP"
.ti -1c
.RI "void(* \fBfree\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream)"
.br
.RI "\fIFunction that knows how to free an ANTLR3_COMMON_TOKEN_STREAM. \fP"
.ti -1c
.RI "\fBpANTLR3_LIST\fP(* \fBgetTokenRange\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop)"
.br
.RI "\fIFunction that returns all the tokens between a start and a stop index. \fP"
.ti -1c
.RI "\fBpANTLR3_VECTOR\fP(* \fBgetTokens\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream)"
.br
.RI "\fIFunction that returns a pointer to the ANTLR3_LIST of all tokens in the stream (this causes the buffer to fill if we have not get any yet). \fP"
.ti -1c
.RI "\fBpANTLR3_LIST\fP(* \fBgetTokensList\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop, \fBpANTLR3_LIST\fP list)"
.br
.RI "\fIFunction that returns all the tokens indicated by being a member of the supplied List. \fP"
.ti -1c
.RI "\fBpANTLR3_LIST\fP(* \fBgetTokensSet\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop, \fBpANTLR3_BITSET\fP types)"
.br
.RI "\fIFunction that returns all the tokens indicated by the specified bitset, within a range of tokens. \fP"
.ti -1c
.RI "\fBpANTLR3_LIST\fP(* \fBgetTokensType\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop, \fBANTLR3_UINT32\fP type)"
.br
.RI "\fIFunction that returns all tokens of a certain type within a range. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBp\fP"
.br
.RI "\fIThe index into the tokens list of the current token (the next one that will be consumed. \fP"
.ti -1c
.RI "void(* \fBreset\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream)"
.br
.RI "\fIFunction that resets the token stream so that it can be reused, but but that does not free up any resources, such as the token factory the factory pool and so on. \fP"
.ti -1c
.RI "void(* \fBsetTokenTypeChannel\fP )(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP ttype, \fBANTLR3_UINT32\fP \fBchannel\fP)"
.br
.RI "\fIA simple filter mechanism whereby you can tell this token stream to force all tokens of type ttype to be on channel. \fP"
.ti -1c
.RI "void * \fBsuper\fP"
.br
.RI "\fIWhatever is supplying the COMMON_TOKEN_STREAM needs a pointer to itself so that this can be accessed by any of the API functions which it implements. \fP"
.ti -1c
.RI "\fBpANTLR3_VECTOR\fP \fBtokens\fP"
.br
.RI "\fIRecords every single token pulled from the source indexed by the token index. \fP"
.ti -1c
.RI "\fBpANTLR3_TOKEN_STREAM\fP \fBtstream\fP"
.br
.RI "\fIThe ANTLR3_TOKEN_STREAM interface implementation, which also includes the intstream implementation. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::channel\fP"
.PP
Referenced by antlr3CommonTokenStreamSourceNew(), and reset().
.SS "\fBpANTLR3_LIST\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::channelOverrides\fP"
.PP
Override map of tokens. 
.PP
If a token type has an entry in here, then the pointer in the table points to an int, being the override channel number that should always be used for this token type. 
.PP
Referenced by antlr3CommonTokenStreamSourceNew(), antlr3CTSFree(), reset(), and setTokenTypeChannel().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::discardOffChannel\fP"
.PP
If this flag is set to ANTLR3_TRUE, then tokens that the stream sees that are not in the channel that this stream is tuned to, are not tracked in the tokens table. 
.PP
When set to false, ALL tokens are added to the tracking. 
.PP
Referenced by antlr3CommonTokenStreamSourceNew(), discardOffChannel(), and reset().
.SS "void(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::discardOffChannelToks\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_BOOLEAN\fP discard)"
.PP
Signal to discard off channel tokens from here on in. 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "\fBpANTLR3_LIST\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::discardSet\fP"
.PP
Discared set. 
.PP
If a token has an entry in this table, then it is thrown away (data pointer is always NULL). 
.PP
Referenced by antlr3CommonTokenStreamSourceNew(), antlr3CTSFree(), discardTokenType(), and reset().
.SS "void(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::discardTokenType\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_INT32\fP ttype)"
.PP
Add a particular token type to the discard set. 
.PP
If a token is found to belong to this set, then it is skipped/thrown away 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "void(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::free\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream)"
.PP
Function that knows how to free an ANTLR3_COMMON_TOKEN_STREAM. 
.PP
Referenced by antlr3CommonTokenStreamSourceNew().
.SS "\fBpANTLR3_LIST\fP(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::getTokenRange\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop)"
.PP
Function that returns all the tokens between a start and a stop index. 
.PP
TODO: This is a new list (Ack! Maybe this is a reason to have factories for LISTS and HASHTABLES etc :-( come back to this) 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "\fBpANTLR3_VECTOR\fP(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::getTokens\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream)"
.PP
Function that returns a pointer to the ANTLR3_LIST of all tokens in the stream (this causes the buffer to fill if we have not get any yet). 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "\fBpANTLR3_LIST\fP(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::getTokensList\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop, \fBpANTLR3_LIST\fP list)"
.PP
Function that returns all the tokens indicated by being a member of the supplied List. 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "\fBpANTLR3_LIST\fP(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::getTokensSet\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop, \fBpANTLR3_BITSET\fP types)"
.PP
Function that returns all the tokens indicated by the specified bitset, within a range of tokens. 
.PP
Referenced by antlr3CommonTokenStreamNew(), getTokenRange(), getTokensList(), and getTokensType().
.SS "\fBpANTLR3_LIST\fP(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::getTokensType\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP start, \fBANTLR3_UINT32\fP stop, \fBANTLR3_UINT32\fP type)"
.PP
Function that returns all tokens of a certain type within a range. 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "\fBANTLR3_INT32\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::p\fP"
.PP
The index into the tokens list of the current token (the next one that will be consumed. 
.PP
p = -1 indicates that the token list is empty. 
.PP
Referenced by antlr3CommonTokenStreamNew(), consume(), getTokens(), getTokensSet(), LB(), reset(), tokLT(), toString(), and toStringSS().
.SS "void(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::reset\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream)"
.PP
Function that resets the token stream so that it can be reused, but but that does not free up any resources, such as the token factory the factory pool and so on. 
.PP
This prevents the need to keep freeing and reallocating the token pools if the thing you are building is a multi-shot dameon or somethign like that. It is much faster to just reuse all the vectors. 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "void(* \fBANTLR3_COMMON_TOKEN_STREAM_struct::setTokenTypeChannel\fP)(struct \fBANTLR3_COMMON_TOKEN_STREAM_struct\fP *tokenStream, \fBANTLR3_UINT32\fP ttype, \fBANTLR3_UINT32\fP \fBchannel\fP)"
.PP
A simple filter mechanism whereby you can tell this token stream to force all tokens of type ttype to be on channel. 
.PP
For example, when interpreting, we cannot exec actions so we need to tell the stream to force all WS and NEWLINE to be a different, ignored channel. 
.PP
Referenced by antlr3CommonTokenStreamNew().
.SS "void* \fBANTLR3_COMMON_TOKEN_STREAM_struct::super\fP"
.PP
Whatever is supplying the COMMON_TOKEN_STREAM needs a pointer to itself so that this can be accessed by any of the API functions which it implements. 
.PP
.SS "\fBpANTLR3_VECTOR\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::tokens\fP"
.PP
Records every single token pulled from the source indexed by the token index. 
.PP
There might be more efficient ways to do this, such as referencing directly in to the token factory pools, but for now this is convenient and the ANTLR3_LIST is not a huge overhead as it only stores pointers anyway, but allows for iterations and so on. 
.PP
Referenced by antlr3CommonTokenStreamNew(), antlr3CTSFree(), consume(), get(), getTokens(), LB(), reset(), tokLT(), and toStringSS().
.SS "\fBpANTLR3_TOKEN_STREAM\fP \fBANTLR3_COMMON_TOKEN_STREAM_struct::tstream\fP"
.PP
The ANTLR3_TOKEN_STREAM interface implementation, which also includes the intstream implementation. 
.PP
We could duplicate the pANTLR_INT_STREAM in this interface and initialize it to a copy, but this could be confusing it just results in one more level of indirection and I think that with judicial use of 'const' later, the optimizer will do decent job. 
.PP
Referenced by antlr3CommonTokenDebugStreamSourceNew(), antlr3CommonTokenStreamNew(), antlr3CommonTokenStreamSourceNew(), antlr3CTSFree(), antlr3RecognitionExceptionNew(), and getTokensSet().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
