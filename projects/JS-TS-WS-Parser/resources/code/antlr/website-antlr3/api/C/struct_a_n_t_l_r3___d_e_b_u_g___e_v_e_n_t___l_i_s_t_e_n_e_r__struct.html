<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR3C: ANTLR3_DEBUG_EVENT_LISTENER_struct Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ANTLR3_DEBUG_EVENT_LISTENER_struct Struct Reference</h1><!-- doxytag: class="ANTLR3_DEBUG_EVENT_LISTENER_struct" --><code>#include &lt;antlr3debugeventlistener.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for ANTLR3_DEBUG_EVENT_LISTENER_struct:</div>
<div class="dynsection">
<p><center><img src="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct__coll__graph.png" border="0" usemap="#_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct__coll__map" alt="Collaboration graph"></center>
<map name="_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct__coll__map">
<area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html" title="ANTLR3_BASE_TREE_ADAPTOR_struct" alt="" coords="2157,178,2432,204"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html" title="Base string class tracks the allocations and provides simple string tracking functions..." alt="" coords="363,211,536,238"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html" title="Definition of the string factory interface, which creates and tracks strings for..." alt="" coords="727,400,972,427"><area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html" title="The definition of an ANTLR3 common token structure, which all implementations of..." alt="" coords="1439,384,1676,411"><area shape="rect" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html" title="Master context structure for an ANTLR3 C runtime based input stream." alt="" coords="1107,288,1333,315"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html" title="ANTLR3_INT_STREAM_struct" alt="" coords="745,266,953,292"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html" title="ANTLR3_VECTOR_struct" alt="" coords="360,462,539,488"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r___e_l_e_m_e_n_t__struct.html" title="ANTLR3_VECTOR_ELEMENT_struct" alt="" coords="7,462,255,488"><area shape="rect" href="struct_a_n_t_l_r3___t_o_k_e_n___f_a_c_t_o_r_y__struct.html" title="ANTLR3 Token factory interface to create lots of tokens efficiently rather than creating..." alt="" coords="1789,272,2029,299"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The ANTLR3 debugging interface for communicating with ANLTR Works. 
<p>
Function comments mostly taken from the Java version. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#f73fc8d7ab547c2769c44fcced3d91f8">ack</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve acknowledge response from the debugger.  <a href="#f73fc8d7ab547c2769c44fcced3d91f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html">pANTLR3_BASE_TREE_ADAPTOR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#d4f7a3ec200a922978922fb86fb72023">adaptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the debug event system to access the adapter in use by the recognizer, if this is a tree parser of some sort.  <a href="#d4f7a3ec200a922978922fb86fb72023"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#cc676073bc55a9df74ccc4891f8f9ef5">addChild</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> root, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> child)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make childID a child of rootID.  <a href="#cc676073bc55a9df74ccc4891f8f9ef5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4d2a09f0735305b7778615dcbc62073d">becomeRoot</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> newRoot, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> oldRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a node the new root of an existing root.  <a href="#4d2a09f0735305b7778615dcbc62073d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#77996ab10c5e44e69c749153db018864">beginBacktrack</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#0c910c11c19fedc74640fa240ad2bdc4">beginResync</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates the recognizer is about to consume tokens to resynchronize the parser.  <a href="#0c910c11c19fedc74640fa240ad2bdc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#8f0d972dc2a671daaa530c0929fd2dfc">commence</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Announce that parsing has begun.  <a href="#8f0d972dc2a671daaa530c0929fd2dfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#eebd35a1758f4bd8a1ebe87a754181ec">consumeHiddenToken</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An off-channel input token was consumed.  <a href="#eebd35a1758f4bd8a1ebe87a754181ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#b69667e7adf4eb6f3ada9e47a851402b">consumeNode</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input for a tree parser is an AST, but we know nothing for sure about a node except its type and text (obtained from the adaptor).  <a href="#b69667e7adf4eb6f3ada9e47a851402b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#a102c05452b09dc31bde71db7d1cf27b">consumeToken</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An input token was consumed; matched by any kind of element.  <a href="#a102c05452b09dc31bde71db7d1cf27b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#da0ce98f7c626520cc8ea71b2a371482">createNode</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Announce a new node built from token elements such as type etc.  <a href="#da0ce98f7c626520cc8ea71b2a371482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#e524748e0a12e1c82a88892dabb8c1d6">createNodeTok</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> node, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> token)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Announce a new node built from an existing token.  <a href="#e524748e0a12e1c82a88892dabb8c1d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#651d4b204361bb951131408d817a0955">endBacktrack</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int level, <a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> successful)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#669726a9950721d30b320cdd534f1589">endResync</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that the recognizer has finished consuming tokens in order to resynchronize.  <a href="#669726a9950721d30b320cdd534f1589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#7a37a4a27edfab60086ae2c390946322">enterAlt</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int alt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Because rules can have lots of alternatives, it is very useful to know which alt you are entering.  <a href="#7a37a4a27edfab60086ae2c390946322"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#793a0776b6f77f5aea2dc58c9ddddfba">enterDecision</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Every decision, fixed k or arbitrary, has an enter/exit event so that a GUI can easily track what LT/consume events are associated with prediction.  <a href="#793a0776b6f77f5aea2dc58c9ddddfba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#c857f7eb0e3a8ac76119735c2e089961">enterRule</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, const char *<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4f01c6add4000cd36d700e22754e55a8">grammarFileName</a>, const char *ruleName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parser has just entered a rule.  <a href="#c857f7eb0e3a8ac76119735c2e089961"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#1f36733161c1f98cd9876d4e5ac572a2">enterSubRule</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Track entry into any (.  <a href="#1f36733161c1f98cd9876d4e5ac572a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#0713f61fbfbae26d65370d89d4908e5a">errorNode</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If a syntax error occurs, recognizers bracket the error with an error node if they are building ASTs.  <a href="#0713f61fbfbae26d65370d89d4908e5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#d4ffe64fde8fdc9577829f6f6921caaa">exitDecision</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#e8755b1f41540b344fae90a94d3a3ba8">exitRule</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, const char *<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4f01c6add4000cd36d700e22754e55a8">grammarFileName</a>, const char *ruleName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the last thing executed before leaving a rule.  <a href="#e8755b1f41540b344fae90a94d3a3ba8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#29c55fdd3dc6399e0b89303694fac424">exitSubRule</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#72d80e00691f7ab256c5e5603cf8f24c">free</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free up the resources allocated to this structure.  <a href="#72d80e00691f7ab256c5e5603cf8f24c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4f01c6add4000cd36d700e22754e55a8">grammarFileName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name of the grammar file that we are debugging.  <a href="#4f01c6add4000cd36d700e22754e55a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#e03e67490b74ee95bdd2a9e957022e15">handshake</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a connection from the debugger and initiate the debugging session.  <a href="#e03e67490b74ee95bdd2a9e957022e15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#72372c15b77044c33217002180102878">initialized</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether we have already connected or not.  <a href="#72372c15b77044c33217002180102878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4fa291bc4f73722b4a1f40a79a9428f9">location</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int line, int pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To watch a parser move through the grammar, the parser needs to inform the debugger what line/charPos it is passing in the grammar.  <a href="#4fa291bc4f73722b4a1f40a79a9428f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#faf77e7b413b4eb08eac090fc8faf0c0">LT</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int i, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Somebody (anybody) looked ahead.  <a href="#faf77e7b413b4eb08eac090fc8faf0c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#357f77b7235cc77e2a5128d62f7121eb">LTT</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int i, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The tree parser looked ahead.  <a href="#357f77b7235cc77e2a5128d62f7121eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#c3a29f3c8779cc97c9188f45cdc3d2ec">mark</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> marker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parser is going to look arbitrarily ahead; mark this location, the token stream's marker is sent in case you need it.  <a href="#c3a29f3c8779cc97c9188f45cdc3d2ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#2195d2af227afe0b9824781e8f5e64ae">nilNode</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A nil was created (even nil nodes have a unique ID.  <a href="#2195d2af227afe0b9824781e8f5e64ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#84ad67b6e7ee2d8c5cc50a92ef51d16a">port</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The port number which the debug listener should listen on for a connection.  <a href="#84ad67b6e7ee2d8c5cc50a92ef51d16a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#f15ca775d7e1dcb484542fdc30ed63a1">PROTOCOL_VERSION</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The version of the debugging protocol supported by the providing instance of the debug event listener.  <a href="#f15ca775d7e1dcb484542fdc30ed63a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#71f7ad3f972749e585973773a7cfb69d">recognitionException</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___e_x_c_e_p_t_i_o_n__struct.html">pANTLR3_EXCEPTION</a> e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A recognition exception occurred such as NoViableAltException.  <a href="#71f7ad3f972749e585973773a7cfb69d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#75107200ac78d7991c21b1b303144dff">rewind</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> marker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">After an arbitrarily long lookahead as with a cyclic DFA (or with any backtrack), this informs the debugger that stream should be rewound to the position associated with marker.  <a href="#75107200ac78d7991c21b1b303144dff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#bc6b46435d5264bdae6ae7a7cb8996a5">rewindLast</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rewind to the input position of the last marker.  <a href="#bc6b46435d5264bdae6ae7a7cb8996a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#b379ec89e5227d5ee95e0420544f02f7">semanticPredicate</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> result, const char *predicate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A semantic predicate was evaluate with this result and action text.  <a href="#b379ec89e5227d5ee95e0420544f02f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#9b01b22f92c496a1eb48f0d8c1efeae0">setTokenBoundaries</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> tokenStartIndex, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> tokenStopIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the token start/stop token index for a subtree root or node.  <a href="#9b01b22f92c496a1eb48f0d8c1efeae0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#8dc8083897335125630f1af5dafd5831">SOCKET</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#ed6e688364e4ff83067f57e436356a54">socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The socket structure we receive after a successful accept on the serverSocket.  <a href="#ed6e688364e4ff83067f57e436356a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#61c8813b991db07c7a0dc14be8d9bf96">terminate</a> )(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parsing is over; successfully or not.  <a href="#61c8813b991db07c7a0dc14be8d9bf96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#a632f6a33c2a4a7471e2b76baa6264c3">tokenString</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to serialize the values of any particular token we need to send back to the debugger.  <a href="#a632f6a33c2a4a7471e2b76baa6264c3"></a><br></td></tr>
</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="f73fc8d7ab547c2769c44fcced3d91f8"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::ack" ref="f73fc8d7ab547c2769c44fcced3d91f8" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#f73fc8d7ab547c2769c44fcced3d91f8">ANTLR3_DEBUG_EVENT_LISTENER_struct::ack</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve acknowledge response from the debugger. 
<p>
in fact this response is never used at the moment. So we just read whatever is in the socket buffer and throw it away. 
</div>
</div><p>
<a class="anchor" name="d4f7a3ec200a922978922fb86fb72023"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::adaptor" ref="d4f7a3ec200a922978922fb86fb72023" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html">pANTLR3_BASE_TREE_ADAPTOR</a> <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#d4f7a3ec200a922978922fb86fb72023">ANTLR3_DEBUG_EVENT_LISTENER_struct::adaptor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows the debug event system to access the adapter in use by the recognizer, if this is a tree parser of some sort. 
<p>

<p>Referenced by <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00080">antlr3BaseTreeAdaptorInit()</a>, and <a class="el" href="antlr3debughandlers_8c-source.html#l00464">serializeNode()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cc676073bc55a9df74ccc4891f8f9ef5"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::addChild" ref="cc676073bc55a9df74ccc4891f8f9ef5" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE root, pANTLR3_BASE_TREE child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#cc676073bc55a9df74ccc4891f8f9ef5">ANTLR3_DEBUG_EVENT_LISTENER_struct::addChild</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> root, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> child)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make childID a child of rootID. 
<p>
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only IDs are set.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="antlr3basetree_8c.html#b5c4b9d608ad720b8399a1a52e380184">org.antlr.runtime.tree.TreeAdaptor.addChild()</a> </dd></dl>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00556">dbgAddChild()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00575">dbgAddChildToken()</a>, and <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00500">simulateTreeConstruction()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4d2a09f0735305b7778615dcbc62073d"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::becomeRoot" ref="4d2a09f0735305b7778615dcbc62073d" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE newRoot, pANTLR3_BASE_TREE oldRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4d2a09f0735305b7778615dcbc62073d">ANTLR3_DEBUG_EVENT_LISTENER_struct::becomeRoot</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> newRoot, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> oldRoot)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a node the new root of an existing root. 
<p>
See<p>
Note: the newRootID parameter is possibly different than the <a class="el" href="antlr3basetreeadaptor_8c.html#97a0d566a6ba11f71ee85d69ab6f7927" title="If oldRoot is a nil root, just copy or move the children to newRoot.">TreeAdaptor.becomeRoot()</a> newRoot parameter. In our case, it will always be the result of calling <a class="el" href="antlr3basetreeadaptor_8c.html#97a0d566a6ba11f71ee85d69ab6f7927" title="If oldRoot is a nil root, just copy or move the children to newRoot.">TreeAdaptor.becomeRoot()</a> and not root_n or whatever.<p>
The listener should assume that this event occurs only when the current subrule (or rule) subtree is being reset to newRootID.<p>
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only IDs are set.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="antlr3basetreeadaptor_8c.html#97a0d566a6ba11f71ee85d69ab6f7927" title="If oldRoot is a nil root, just copy or move the children to newRoot.">org.antlr.runtime.tree.TreeAdaptor.becomeRoot()</a> </dd></dl>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00691">dbgBecomeRoot()</a>, and <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00745">dbgBecomeRootToken()</a>.</p>

</div>
</div><p>
<a class="anchor" name="77996ab10c5e44e69c749153db018864"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::beginBacktrack" ref="77996ab10c5e44e69c749153db018864" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#77996ab10c5e44e69c749153db018864">ANTLR3_DEBUG_EVENT_LISTENER_struct::beginBacktrack</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int level)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, and <a class="el" href="antlr3baserecognizer_8c-source.html#l00751">beginBacktrack()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0c910c11c19fedc74640fa240ad2bdc4"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::beginResync" ref="0c910c11c19fedc74640fa240ad2bdc4" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#0c910c11c19fedc74640fa240ad2bdc4">ANTLR3_DEBUG_EVENT_LISTENER_struct::beginResync</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates the recognizer is about to consume tokens to resynchronize the parser. 
<p>
Any consume events from here until the recovered event are not part of the parse--they are dead tokens. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00768">beginResync()</a>, and <a class="el" href="antlr3baserecognizer_8c-source.html#l01432">recoverFromMismatchedToken()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8f0d972dc2a671daaa530c0929fd2dfc"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::commence" ref="8f0d972dc2a671daaa530c0929fd2dfc" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#8f0d972dc2a671daaa530c0929fd2dfc">ANTLR3_DEBUG_EVENT_LISTENER_struct::commence</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Announce that parsing has begun. 
<p>
Not technically useful except for sending events over a socket. A GUI for example will launch a thread to connect and communicate with a remote parser. The thread will want to notify the GUI when a connection is made. ANTLR parsers trigger this upon entry to the first rule (the ruleLevel is used to figure this out). 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="eebd35a1758f4bd8a1ebe87a754181ec"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::consumeHiddenToken" ref="eebd35a1758f4bd8a1ebe87a754181ec" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_COMMON_TOKEN t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#eebd35a1758f4bd8a1ebe87a754181ec">ANTLR3_DEBUG_EVENT_LISTENER_struct::consumeHiddenToken</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An off-channel input token was consumed. 
<p>
Trigger after the token was matched by things like <a class="el" href="group__p_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r.html#g06172ef38079026fc3d29bea9a046cc3" title="Match current input symbol against ttype.">match()</a>, <a class="el" href="group__p_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r.html#gc6666b109c5d2fb42e311b0a248e0bb0" title="Consumes the next token, whatever it is, and resets the recognizer state so that...">matchAny()</a>. (unless of course the hidden token is first stuff in the input stream). 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3tokenstream_8c-source.html#l00416">consumeInitialHiddenTokens()</a>, and <a class="el" href="antlr3tokenstream_8c-source.html#l00620">dbgConsume()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b69667e7adf4eb6f3ada9e47a851402b"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::consumeNode" ref="b69667e7adf4eb6f3ada9e47a851402b" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#b69667e7adf4eb6f3ada9e47a851402b">ANTLR3_DEBUG_EVENT_LISTENER_struct::consumeNode</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Input for a tree parser is an AST, but we know nothing for sure about a node except its type and text (obtained from the adaptor). 
<p>
This is the analog of the consumeToken method. The ID is usually the memory address of the node. If the type is UP or DOWN, then the ID is not really meaningful as it's fixed--there is just one UP node and one DOWN navigation node.<p>
Note that unlike the Java version, the node type of the C parsers is always fixed as pANTLR3_BASE_TREE because all such structures contain a super pointer to their parent, which is generally COMMON_TREE and within that there is a super pointer that can point to a user type that encapsulates it. Almost akin to saying that it is an interface pointer except we don't need to know what the interface is in full, just those bits that are the base. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a102c05452b09dc31bde71db7d1cf27b"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::consumeToken" ref="a102c05452b09dc31bde71db7d1cf27b" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_COMMON_TOKEN t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#a102c05452b09dc31bde71db7d1cf27b">ANTLR3_DEBUG_EVENT_LISTENER_struct::consumeToken</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An input token was consumed; matched by any kind of element. 
<p>
Trigger after the token was matched by things like <a class="el" href="group__p_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r.html#g06172ef38079026fc3d29bea9a046cc3" title="Match current input symbol against ttype.">match()</a>, <a class="el" href="group__p_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r.html#gc6666b109c5d2fb42e311b0a248e0bb0" title="Consumes the next token, whatever it is, and resets the recognizer state so that...">matchAny()</a>. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, and <a class="el" href="antlr3tokenstream_8c-source.html#l00620">dbgConsume()</a>.</p>

</div>
</div><p>
<a class="anchor" name="da0ce98f7c626520cc8ea71b2a371482"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::createNode" ref="da0ce98f7c626520cc8ea71b2a371482" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#da0ce98f7c626520cc8ea71b2a371482">ANTLR3_DEBUG_EVENT_LISTENER_struct::createNode</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Announce a new node built from token elements such as type etc. 
<p>
..<p>
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID, type, text are set. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3commontreeadaptor_8c-source.html#l00272">dbgCreate()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00831">dbgCreateTypeText()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00775">dbgCreateTypeToken()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00806">dbgCreateTypeTokenText()</a>, <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00447">dbgNil()</a>, and <a class="el" href="antlr3basetreeadaptor_8c-source.html#l00500">simulateTreeConstruction()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e524748e0a12e1c82a88892dabb8c1d6"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::createNodeTok" ref="e524748e0a12e1c82a88892dabb8c1d6" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE node, pANTLR3_COMMON_TOKEN token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#e524748e0a12e1c82a88892dabb8c1d6">ANTLR3_DEBUG_EVENT_LISTENER_struct::createNodeTok</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> node, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> token)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Announce a new node built from an existing token. 
<p>
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only node.ID and token.tokenIndex are set. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="651d4b204361bb951131408d817a0955"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::endBacktrack" ref="651d4b204361bb951131408d817a0955" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int level, ANTLR3_BOOLEAN successful)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#651d4b204361bb951131408d817a0955">ANTLR3_DEBUG_EVENT_LISTENER_struct::endBacktrack</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int level, <a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> successful)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, and <a class="el" href="antlr3baserecognizer_8c-source.html#l00760">endBacktrack()</a>.</p>

</div>
</div><p>
<a class="anchor" name="669726a9950721d30b320cdd534f1589"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::endResync" ref="669726a9950721d30b320cdd534f1589" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#669726a9950721d30b320cdd534f1589">ANTLR3_DEBUG_EVENT_LISTENER_struct::endResync</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that the recognizer has finished consuming tokens in order to resynchronize. 
<p>
There may be multiple beginResync/endResync pairs before the recognizer comes out of errorRecovery mode (in which multiple errors are suppressed). This will be useful in a gui where you want to probably grey out tokens that are consumed but not matched to anything in grammar. Anything between a beginResync/endResync pair was tossed out by the parser. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00777">endResync()</a>, and <a class="el" href="antlr3baserecognizer_8c-source.html#l01432">recoverFromMismatchedToken()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7a37a4a27edfab60086ae2c390946322"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::enterAlt" ref="7a37a4a27edfab60086ae2c390946322" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int alt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#7a37a4a27edfab60086ae2c390946322">ANTLR3_DEBUG_EVENT_LISTENER_struct::enterAlt</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int alt)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Because rules can have lots of alternatives, it is very useful to know which alt you are entering. 
<p>
This is 1..n for n alts. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="793a0776b6f77f5aea2dc58c9ddddfba"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::enterDecision" ref="793a0776b6f77f5aea2dc58c9ddddfba" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int decisionNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#793a0776b6f77f5aea2dc58c9ddddfba">ANTLR3_DEBUG_EVENT_LISTENER_struct::enterDecision</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Every decision, fixed k or arbitrary, has an enter/exit event so that a GUI can easily track what LT/consume events are associated with prediction. 
<p>
You will see a single enter/exit subrule but multiple enter/exit decision events, one for each loop iteration. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c857f7eb0e3a8ac76119735c2e089961"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::enterRule" ref="c857f7eb0e3a8ac76119735c2e089961" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, const char *grammarFileName, const char *ruleName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#c857f7eb0e3a8ac76119735c2e089961">ANTLR3_DEBUG_EVENT_LISTENER_struct::enterRule</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, const char *<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4f01c6add4000cd36d700e22754e55a8">grammarFileName</a>, const char *ruleName)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The parser has just entered a rule. 
<p>
No decision has been made about which alt is predicted. This is fired AFTER init actions have been executed. Attributes are defined and available etc... 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1f36733161c1f98cd9876d4e5ac572a2"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::enterSubRule" ref="1f36733161c1f98cd9876d4e5ac572a2" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int decisionNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#1f36733161c1f98cd9876d4e5ac572a2">ANTLR3_DEBUG_EVENT_LISTENER_struct::enterSubRule</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Track entry into any (. 
<p>
..) subrule other EBNF construct 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0713f61fbfbae26d65370d89d4908e5a"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::errorNode" ref="0713f61fbfbae26d65370d89d4908e5a" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#0713f61fbfbae26d65370d89d4908e5a">ANTLR3_DEBUG_EVENT_LISTENER_struct::errorNode</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If a syntax error occurs, recognizers bracket the error with an error node if they are building ASTs. 
<p>
This event notifies the listener that this is the case 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d4ffe64fde8fdc9577829f6f6921caaa"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::exitDecision" ref="d4ffe64fde8fdc9577829f6f6921caaa" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int decisionNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#d4ffe64fde8fdc9577829f6f6921caaa">ANTLR3_DEBUG_EVENT_LISTENER_struct::exitDecision</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e8755b1f41540b344fae90a94d3a3ba8"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::exitRule" ref="e8755b1f41540b344fae90a94d3a3ba8" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, const char *grammarFileName, const char *ruleName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#e8755b1f41540b344fae90a94d3a3ba8">ANTLR3_DEBUG_EVENT_LISTENER_struct::exitRule</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, const char *<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4f01c6add4000cd36d700e22754e55a8">grammarFileName</a>, const char *ruleName)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the last thing executed before leaving a rule. 
<p>
It is executed even if an exception is thrown. This is triggered after error reporting and recovery have occurred (unless the exception is not caught in this rule). This implies an "exitAlt" event. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="29c55fdd3dc6399e0b89303694fac424"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::exitSubRule" ref="29c55fdd3dc6399e0b89303694fac424" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int decisionNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#29c55fdd3dc6399e0b89303694fac424">ANTLR3_DEBUG_EVENT_LISTENER_struct::exitSubRule</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int decisionNumber)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="72d80e00691f7ab256c5e5603cf8f24c"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::free" ref="72d80e00691f7ab256c5e5603cf8f24c" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#72d80e00691f7ab256c5e5603cf8f24c">ANTLR3_DEBUG_EVENT_LISTENER_struct::free</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free up the resources allocated to this structure. 
<p>

</div>
</div><p>
<a class="anchor" name="4f01c6add4000cd36d700e22754e55a8"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::grammarFileName" ref="4f01c6add4000cd36d700e22754e55a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a> <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4f01c6add4000cd36d700e22754e55a8">ANTLR3_DEBUG_EVENT_LISTENER_struct::grammarFileName</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The name of the grammar file that we are debugging. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00194">handshake()</a>, <a class="el" href="antlr3debughandlers_8c-source.html#l00464">serializeNode()</a>, and <a class="el" href="antlr3debughandlers_8c-source.html#l00418">serializeToken()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e03e67490b74ee95bdd2a9e957022e15"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::handshake" ref="e03e67490b74ee95bdd2a9e957022e15" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#e03e67490b74ee95bdd2a9e957022e15">ANTLR3_DEBUG_EVENT_LISTENER_struct::handshake</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for a connection from the debugger and initiate the debugging session. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="72372c15b77044c33217002180102878"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::initialized" ref="72372c15b77044c33217002180102878" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#72372c15b77044c33217002180102878">ANTLR3_DEBUG_EVENT_LISTENER_struct::initialized</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether we have already connected or not. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00194">handshake()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4fa291bc4f73722b4a1f40a79a9428f9"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::location" ref="4fa291bc4f73722b4a1f40a79a9428f9" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int line, int pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#4fa291bc4f73722b4a1f40a79a9428f9">ANTLR3_DEBUG_EVENT_LISTENER_struct::location</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int line, int pos)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To watch a parser move through the grammar, the parser needs to inform the debugger what line/charPos it is passing in the grammar. 
<p>
For now, this does not know how to switch from one grammar to the other and back for island grammars etc...<p>
This should also allow breakpoints because the debugger can stop the parser whenever it hits this line/pos. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="faf77e7b413b4eb08eac090fc8faf0c0"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::LT" ref="faf77e7b413b4eb08eac090fc8faf0c0" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int i, pANTLR3_COMMON_TOKEN t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#faf77e7b413b4eb08eac090fc8faf0c0">ANTLR3_DEBUG_EVENT_LISTENER_struct::LT</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int i, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Somebody (anybody) looked ahead. 
<p>
Note that this actually gets triggered by both LA and LT calls. The debugger will want to know which Token object was examined. Like consumeToken, this indicates what token was seen at that depth. A remote debugger cannot look ahead into a file it doesn't have so LT events must pass the token even if the info is redundant. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="357f77b7235cc77e2a5128d62f7121eb"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::LTT" ref="357f77b7235cc77e2a5128d62f7121eb" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, int i, pANTLR3_BASE_TREE t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#357f77b7235cc77e2a5128d62f7121eb">ANTLR3_DEBUG_EVENT_LISTENER_struct::LTT</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, int i, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The tree parser looked ahead. 
<p>
If the type is UP or DOWN, then the ID is not really meaningful as it's fixed--there is just one UP node and one DOWN navigation node. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c3a29f3c8779cc97c9188f45cdc3d2ec"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::mark" ref="c3a29f3c8779cc97c9188f45cdc3d2ec" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, ANTLR3_MARKER marker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#c3a29f3c8779cc97c9188f45cdc3d2ec">ANTLR3_DEBUG_EVENT_LISTENER_struct::mark</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> marker)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The parser is going to look arbitrarily ahead; mark this location, the token stream's marker is sent in case you need it. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2195d2af227afe0b9824781e8f5e64ae"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::nilNode" ref="2195d2af227afe0b9824781e8f5e64ae" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#2195d2af227afe0b9824781e8f5e64ae">ANTLR3_DEBUG_EVENT_LISTENER_struct::nilNode</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A nil was created (even nil nodes have a unique ID. 
<p>
.. they are not "null" per se). As of 4/28/2006, this seems to be uniquely triggered when starting a new subtree such as when entering a subrule in automatic mode and when building a tree in rewrite mode.<p>
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID is set. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="84ad67b6e7ee2d8c5cc50a92ef51d16a"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::port" ref="84ad67b6e7ee2d8c5cc50a92ef51d16a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a> <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#84ad67b6e7ee2d8c5cc50a92ef51d16a">ANTLR3_DEBUG_EVENT_LISTENER_struct::port</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The port number which the debug listener should listen on for a connection. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, <a class="el" href="antlr3debughandlers_8c-source.html#l00147">antlr3DebugListenerNewPort()</a>, and <a class="el" href="antlr3debughandlers_8c-source.html#l00194">handshake()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f15ca775d7e1dcb484542fdc30ed63a1"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::PROTOCOL_VERSION" ref="f15ca775d7e1dcb484542fdc30ed63a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#f15ca775d7e1dcb484542fdc30ed63a1">ANTLR3_DEBUG_EVENT_LISTENER_struct::PROTOCOL_VERSION</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The version of the debugging protocol supported by the providing instance of the debug event listener. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, and <a class="el" href="antlr3debughandlers_8c-source.html#l00194">handshake()</a>.</p>

</div>
</div><p>
<a class="anchor" name="71f7ad3f972749e585973773a7cfb69d"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::recognitionException" ref="71f7ad3f972749e585973773a7cfb69d" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_EXCEPTION e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#71f7ad3f972749e585973773a7cfb69d">ANTLR3_DEBUG_EVENT_LISTENER_struct::recognitionException</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___e_x_c_e_p_t_i_o_n__struct.html">pANTLR3_EXCEPTION</a> e)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A recognition exception occurred such as NoViableAltException. 
<p>
I made this a generic event so that I can alter the exception hierarchy later without having to alter all the debug objects.<p>
Upon error, the stack of enter rule/subrule must be properly unwound. If no viable alt occurs it is within an enter/exit decision, which also must be rewound. Even the rewind for each mark must be unwound. In the Java target this is pretty easy using try/finally, if a bit ugly in the generated code. The rewind is generated in DFA.predict() actually so no code needs to be generated for that. For languages w/o this "finally" feature (C++?), the target implementor will have to build an event stack or something.<p>
Across a socket for remote debugging, only the RecognitionException data fields are transmitted. The token object or whatever that caused the problem was the last object referenced by LT. The immediately preceding LT event should hold the unexpected Token or char.<p>
Here is a sample event trace for grammar:<p>
b : C ({;}A|B) // {;} is there to prevent A|B becoming a set | D ;<p>
The sequence for this rule (with no viable alt in the subrule) for input 'c c' (there are 3 tokens) is:<p>
commence LT(1) enterRule b location 7 1 enter decision 3 LT(1) exit decision 3 enterAlt1 location 7 5 LT(1) consumeToken [c/&lt;4&gt;,1:0] location 7 7 enterSubRule 2 enter decision 2 LT(1) LT(1) recognitionException NoViableAltException 2 1 2 exit decision 2 exitSubRule 2 beginResync LT(1) consumeToken [c/&lt;4&gt;,1:1] LT(1) endResync LT(-1) exitRule b terminate 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, and <a class="el" href="antlr3baserecognizer_8c-source.html#l00721">reportError()</a>.</p>

</div>
</div><p>
<a class="anchor" name="75107200ac78d7991c21b1b303144dff"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::rewind" ref="75107200ac78d7991c21b1b303144dff" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, ANTLR3_MARKER marker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#75107200ac78d7991c21b1b303144dff">ANTLR3_DEBUG_EVENT_LISTENER_struct::rewind</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> marker)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
After an arbitrarily long lookahead as with a cyclic DFA (or with any backtrack), this informs the debugger that stream should be rewound to the position associated with marker. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="bc6b46435d5264bdae6ae7a7cb8996a5"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::rewindLast" ref="bc6b46435d5264bdae6ae7a7cb8996a5" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#bc6b46435d5264bdae6ae7a7cb8996a5">ANTLR3_DEBUG_EVENT_LISTENER_struct::rewindLast</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rewind to the input position of the last marker. 
<p>
Used currently only after a cyclic DFA and just before starting a sem/syn predicate to get the input position back to the start of the decision. Do not "pop" the marker off the state. mark(i) and rewind(i) should balance still. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b379ec89e5227d5ee95e0420544f02f7"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::semanticPredicate" ref="b379ec89e5227d5ee95e0420544f02f7" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, ANTLR3_BOOLEAN result, const char *predicate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#b379ec89e5227d5ee95e0420544f02f7">ANTLR3_DEBUG_EVENT_LISTENER_struct::semanticPredicate</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> result, const char *predicate)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A semantic predicate was evaluate with this result and action text. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b01b22f92c496a1eb48f0d8c1efeae0"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::setTokenBoundaries" ref="9b01b22f92c496a1eb48f0d8c1efeae0" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy, pANTLR3_BASE_TREE t, ANTLR3_MARKER tokenStartIndex, ANTLR3_MARKER tokenStopIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#9b01b22f92c496a1eb48f0d8c1efeae0">ANTLR3_DEBUG_EVENT_LISTENER_struct::setTokenBoundaries</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy, <a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a> t, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> tokenStartIndex, <a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a> tokenStopIndex)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the token start/stop token index for a subtree root or node. 
<p>
If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID is set. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>, and <a class="el" href="antlr3commontreeadaptor_8c-source.html#l00409">dbgSetTokenBoundaries()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ed6e688364e4ff83067f57e436356a54"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::socket" ref="ed6e688364e4ff83067f57e436356a54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#8dc8083897335125630f1af5dafd5831">SOCKET</a> <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#ed6e688364e4ff83067f57e436356a54">ANTLR3_DEBUG_EVENT_LISTENER_struct::socket</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The socket structure we receive after a successful accept on the serverSocket. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00330">ack()</a>, <a class="el" href="antlr3debughandlers_8c-source.html#l00194">handshake()</a>, and <a class="el" href="antlr3debughandlers_8c-source.html#l00323">transmit()</a>.</p>

</div>
</div><p>
<a class="anchor" name="61c8813b991db07c7a0dc14be8d9bf96"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::terminate" ref="61c8813b991db07c7a0dc14be8d9bf96" args=")(pANTLR3_DEBUG_EVENT_LISTENER delboy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#61c8813b991db07c7a0dc14be8d9bf96">ANTLR3_DEBUG_EVENT_LISTENER_struct::terminate</a>)(<a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html">pANTLR3_DEBUG_EVENT_LISTENER</a> delboy)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parsing is over; successfully or not. 
<p>
Mostly useful for telling remote debugging listeners that it's time to quit. When the rule invocation level goes to zero at the end of a rule, we are done parsing. 
<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00093">antlr3DebugListenerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a632f6a33c2a4a7471e2b76baa6264c3"></a><!-- doxytag: member="ANTLR3_DEBUG_EVENT_LISTENER_struct::tokenString" ref="a632f6a33c2a4a7471e2b76baa6264c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a> <a class="el" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html#a632f6a33c2a4a7471e2b76baa6264c3">ANTLR3_DEBUG_EVENT_LISTENER_struct::tokenString</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to serialize the values of any particular token we need to send back to the debugger. 
<p>

<p>Referenced by <a class="el" href="antlr3debughandlers_8c-source.html#l00464">serializeNode()</a>, and <a class="el" href="antlr3debughandlers_8c-source.html#l00418">serializeToken()</a>.</p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="antlr3debugeventlistener_8h.html">antlr3debugeventlistener.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:04 2010 for ANTLR3C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
