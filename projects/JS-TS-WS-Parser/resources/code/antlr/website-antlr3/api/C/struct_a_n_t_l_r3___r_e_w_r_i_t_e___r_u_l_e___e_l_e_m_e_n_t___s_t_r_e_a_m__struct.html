<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR3C: ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct Struct Reference</h1><!-- doxytag: class="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct" --><code>#include &lt;antlr3rewritestreams.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct:</div>
<div class="dynsection">
<p><center><img src="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct__coll__graph.png" border="0" usemap="#_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct__coll__map" alt="Collaboration graph"></center>
<map name="_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct__coll__map">
<area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r__struct.html" title="Base tracking context structure for all types of recognizers." alt="" coords="3844,580,4097,607"><area shape="rect" href="struct_a_n_t_l_r3___s_t_a_c_k__struct.html" title="Structure that represents a Stack collection." alt="" coords="2465,1048,2633,1075"><area shape="rect" href="struct_a_n_t_l_r3___r_e_c_o_g_n_i_z_e_r___s_h_a_r_e_d___s_t_a_t_e__struct.html" title="All the data elements required to track the current state of any recognizer (lexer..." alt="" coords="2880,706,3205,732"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html" title="ANTLR3_VECTOR_struct" alt="" coords="360,894,539,920"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html" title="Definition of the string factory interface, which creates and tracks strings for..." alt="" coords="629,511,875,538"><area shape="rect" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html" title="Master context structure for an ANTLR3 C runtime based input stream." alt="" coords="1632,355,1859,382"><area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html" title="A generic tree implementation with no payload." alt="" coords="2448,1139,2651,1166"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r___e_l_e_m_e_n_t__struct.html" title="ANTLR3_VECTOR_ELEMENT_struct" alt="" coords="7,894,255,920"><area shape="rect" href="struct_a_n_t_l_r3___b_i_t_s_e_t__struct.html" title="ANTLR3_BITSET_struct" alt="" coords="1883,960,2053,987"><area shape="rect" href="struct_a_n_t_l_r3___b_i_t_s_e_t___l_i_s_t__struct.html" title="ANTLR3_BITSET_LIST_struct" alt="" coords="1297,886,1503,912"><area shape="rect" href="struct_a_n_t_l_r3___e_x_c_e_p_t_i_o_n__struct.html" title="Base structure for an ANTLR3 exception tracker." alt="" coords="1645,852,1845,879"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___t_a_b_l_e__struct.html" title="Structure that tracks a hash table." alt="" coords="3483,415,3693,442"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___e_n_t_r_y__struct.html" title="Internal structure representing an element in a hash bucket." alt="" coords="2444,390,2655,416"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___b_u_c_k_e_t__struct.html" title="Internal structure of a hash table bucket, which tracks all keys that hash to the..." alt="" coords="2932,346,3153,372"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___k_e_y__struct.html" title="ANTLR3_HASH_KEY_struct" alt="" coords="2101,383,2293,410"><area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html" title="The definition of an ANTLR3 common token structure, which all implementations of..." alt="" coords="2079,439,2316,466"><area shape="rect" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html" title="Definition of a token source, which has a pointer to a function that returns the..." alt="" coords="2432,647,2667,674"><area shape="rect" href="struct_a_n_t_l_r3___t_o_k_e_n___f_a_c_t_o_r_y__struct.html" title="ANTLR3 Token factory interface to create lots of tokens efficiently rather than creating..." alt="" coords="2429,440,2669,467"><area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html" title="ANTLR3_BASE_TREE_ADAPTOR_struct" alt="" coords="2905,152,3180,179"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html" title="Base string class tracks the allocations and provides simple string tracking functions..." alt="" coords="976,530,1149,556"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html" title="ANTLR3_INT_STREAM_struct" alt="" coords="1296,580,1504,607"><area shape="rect" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html" title="The ANTLR3 debugging interface for communicating with ANLTR Works." alt="" coords="3440,180,3736,207"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___t_r_i_e__struct.html" title="Structure that defines an ANTLR3_INT_TRIE." alt="" coords="2459,778,2640,804"><area shape="rect" href="struct_a_n_t_l_r3___t_r_i_e___e_n_t_r_y__struct.html" title="Structure that holds the payload entry in an ANTLR3_INT_TRIE or ANTLR3_STRING_TRIE..." alt="" coords="1643,762,1848,788"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___t_r_i_e___n_o_d_e__struct.html" title="Structure that defines an element/node in an ANTLR3_INT_TRIE." alt="" coords="2084,778,2311,804"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A generic list of elements tracked in an alternative to be used in a -&gt; rewrite rule. 
<p>
In the C implementation, all tree oriented streams return a pointer to the same type: pANTLR3_BASE_TREE. Anything that has subclassed from this still passes this type, within which there is a super pointer, which points to it's own data and methods. Hence we do not need to implement this as the equivalent of an abstract class, but just fill in the appropriate interface as usual with this model.<p>
Once you start <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49a3d89cea69ba728843b12a5cfd51e3" title="Return the next element in the stream.">next()</a>ing, do not try to add more elements. It will break the cursor tracking I believe.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="antlr3interfaces_8h.html#c687acdf803706344cfbd3f579474274" title="Pointer to an instantiation of &#39;class&#39; ANTLR3_REWRITE_RULE_NODE_STREAM.">pANTLR3_REWRITE_RULE_NODE_STREAM</a> <p>
<a class="el" href="group___a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m.html#ge7733833bf686184837d5eb2cdb5a53a" title="Pointer to an instantiation of &#39;class&#39; ANTLR3_REWRITE_RULE_ELEMENT_STREAM...">pANTLR3_REWRITE_RULE_ELEMENT_STREAM</a> <p>
<a class="el" href="antlr3interfaces_8h.html#5f81a145b3cf4347ec31698e7a14ca49" title="Pointer to an instantiation of &#39;class&#39; ANTLR3_REWRITE_RULE_SUBSTREE_STREAM...">pANTLR3_REWRITE_RULE_SUBTREE_STREAM</a></dd></dl>
TODO: add mechanism to detect/puke on modification after reading from stream <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#69cee716e8e1deb6aa763737c5181544">_next</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html">pANTLR3_BASE_TREE_ADAPTOR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#20b25c06ca3abdbfba72f112142b9833">adaptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the tree adaptor in use for this stream.  <a href="#20b25c06ca3abdbfba72f112142b9833"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#40c0438d249bc834876cdeba57e5c36f">add</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream, void *el, void(ANTLR3_CDECL *freePtr)(void *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new pANTLR3_BASE_TREE to this stream.  <a href="#40c0438d249bc834876cdeba57e5c36f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#26ee5204e3a6fa6ba468478663a46f60">cursor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cursor 0.  <a href="#26ee5204e3a6fa6ba468478663a46f60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#ce76c26ae005d87209376d9aafae6f35">dirty</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Once a node / subtree has been used in a stream, it must be dup'ed from then on.  <a href="#ce76c26ae005d87209376d9aafae6f35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#e843a201581e7ef94e8c50630a76eaf5">dup</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream, void *el)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When constructing trees, sometimes we need to dup a token or AST subtree.  <a href="#e843a201581e7ef94e8c50630a76eaf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#0902e14cb0c4ce49537d9c06176acb8f">elementDescription</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The element or stream description; usually has name of the token or rule reference that this list tracks.  <a href="#0902e14cb0c4ce49537d9c06176acb8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html">pANTLR3_VECTOR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#5f5e056ea19406a056138bb2db3e1396">elements</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of tokens or subtrees we are tracking.  <a href="#5f5e056ea19406a056138bb2db3e1396"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#e77c76a2570b6ef4f40146b33ad4c04a">free</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#00de6f1193fabbd344258e02d7bf6b23">freeElements</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether we should free the vector or it was supplied to us.  <a href="#00de6f1193fabbd344258e02d7bf6b23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#6eb5f2121bfbe1d52e0fbb8f760f4485">getDescription</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the description string if there is one available (check for NULL).  <a href="#6eb5f2121bfbe1d52e0fbb8f760f4485"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#db77b4789ff891dfcafa00b3cccf8f58">hasNext</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns ANTLR3_TRUE if there is a next element available.  <a href="#db77b4789ff891dfcafa00b3cccf8f58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49a3d89cea69ba728843b12a5cfd51e3">next</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next element in the stream.  <a href="#49a3d89cea69ba728843b12a5cfd51e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#ecd854145796216efc9c57b3960abfa4">nextNode</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Treat next element as a single node even if it's a subtree.  <a href="#ecd854145796216efc9c57b3960abfa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#e68722ecc1e063575e357f87959f23a7">nextToken</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#cb290228de319c4cf0a219a0a413069b">nextTree</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r__struct.html">pANTLR3_BASE_RECOGNIZER</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#98e2e50ecddd94ce2b452514627e2b77">rec</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49e313e9d59d347925773e99afbf3d6e">reset</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the condition of this stream so that it appears we have not consumed any of its elements.  <a href="#49e313e9d59d347925773e99afbf3d6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#3d90443fe82f011d5709c84c9add4508">singleElement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Track single elements w/o creating a list.  <a href="#3d90443fe82f011d5709c84c9add4508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#c1c8e6814f647b356c1e1b77e3e589fd">size</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of elements available in the stream.  <a href="#c1c8e6814f647b356c1e1b77e3e589fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#b4e1cbf7d9e92987d53c9f9b835f0eeb">toTree</a> )(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream, void *el)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure stream emits trees; tokens must be converted to AST nodes.  <a href="#b4e1cbf7d9e92987d53c9f9b835f0eeb"></a><br></td></tr>
</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="69cee716e8e1deb6aa763737c5181544"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::_next" ref="69cee716e8e1deb6aa763737c5181544" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#69cee716e8e1deb6aa763737c5181544">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::_next</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00601">next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00788">nextNode()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00773">nextNodeNode()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00767">nextNodeToken()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00592">nextToken()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00568">nextTree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="20b25c06ca3abdbfba72f112142b9833"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::adaptor" ref="20b25c06ca3abdbfba72f112142b9833" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html">pANTLR3_BASE_TREE_ADAPTOR</a> <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#20b25c06ca3abdbfba72f112142b9833">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::adaptor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to the tree adaptor in use for this stream. 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00519">add()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00696">dupTree()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00108">freeNodeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00065">freeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00788">nextNode()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00767">nextNodeToken()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00738">toTreeNode()</a>.</p>

</div>
</div><p>
<a class="anchor" name="40c0438d249bc834876cdeba57e5c36f"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::add" ref="40c0438d249bc834876cdeba57e5c36f" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream, void *el, void(ANTLR3_CDECL *freePtr)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#40c0438d249bc834876cdeba57e5c36f">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::add</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream, void *el, void(ANTLR3_CDECL *freePtr)(void *))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new pANTLR3_BASE_TREE to this stream. 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00257">antlr3RewriteRuleElementStreamNewAEE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="26ee5204e3a6fa6ba468478663a46f60"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::cursor" ref="26ee5204e3a6fa6ba468478663a46f60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a> <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#26ee5204e3a6fa6ba468478663a46f60">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::cursor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cursor 0. 
<p>
.n-1. If singleElement!=NULL, cursor is 0 until you <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49a3d89cea69ba728843b12a5cfd51e3" title="Return the next element in the stream.">next()</a>, which bumps it to 1 meaning no more elements. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00625">_next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00750">hasNext()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00601">next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00788">nextNode()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00568">nextTree()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00510">reset()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ce76c26ae005d87209376d9aafae6f35"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::dirty" ref="ce76c26ae005d87209376d9aafae6f35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#ce76c26ae005d87209376d9aafae6f35">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::dirty</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Once a node / subtree has been used in a stream, it must be dup'ed from then on. 
<p>
Streams are reset after sub rules so that the streams can be reused in future sub rules. So, reset must set a dirty bit. If dirty, then <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49a3d89cea69ba728843b12a5cfd51e3" title="Return the next element in the stream.">next()</a> always returns a dup. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00788">nextNode()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00568">nextTree()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00510">reset()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e843a201581e7ef94e8c50630a76eaf5"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::dup" ref="e843a201581e7ef94e8c50630a76eaf5" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream, void *el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#e843a201581e7ef94e8c50630a76eaf5">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::dup</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream, void *el)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When constructing trees, sometimes we need to dup a token or AST subtree. 
<p>
Dup'ing a token means just creating another AST node around it. For trees, you must call the <a class="el" href="antlr3basetree_8c.html#968076e57330da2c02dc905d1e470a15">adaptor.dupTree()</a>. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00442">antlr3RewriteRuleNODEStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00466">antlr3RewriteRuleNODEStreamNewAEE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00485">antlr3RewriteRuleNODEStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00373">antlr3RewriteRuleSubtreeStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00395">antlr3RewriteRuleSubtreeStreamNewAEE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00418">antlr3RewriteRuleSubtreeStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00309">antlr3RewriteRuleTOKENStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00333">antlr3RewriteRuleTOKENStreamNewAEE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00352">antlr3RewriteRuleTOKENStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00601">next()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00568">nextTree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0902e14cb0c4ce49537d9c06176acb8f"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::elementDescription" ref="0902e14cb0c4ce49537d9c06176acb8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#0902e14cb0c4ce49537d9c06176acb8f">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::elementDescription</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The element or stream description; usually has name of the token or rule reference that this list tracks. 
<p>
Can include rulename too, but the exception would track that info. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00836">getDescription()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5f5e056ea19406a056138bb2db3e1396"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::elements" ref="5f5e056ea19406a056138bb2db3e1396" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html">pANTLR3_VECTOR</a> <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#5f5e056ea19406a056138bb2db3e1396">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::elements</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The list of tokens or subtrees we are tracking. 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00625">_next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00519">add()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00280">antlr3RewriteRuleElementStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00174">expungeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00108">freeNodeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00065">freeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00750">hasNext()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00811">size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e77c76a2570b6ef4f40146b33ad4c04a"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::free" ref="e77c76a2570b6ef4f40146b33ad4c04a" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#e77c76a2570b6ef4f40146b33ad4c04a">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::free</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00442">antlr3RewriteRuleNODEStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00466">antlr3RewriteRuleNODEStreamNewAEE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00485">antlr3RewriteRuleNODEStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00373">antlr3RewriteRuleSubtreeStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00395">antlr3RewriteRuleSubtreeStreamNewAEE()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00418">antlr3RewriteRuleSubtreeStreamNewAEV()</a>.</p>

</div>
</div><p>
<a class="anchor" name="00de6f1193fabbd344258e02d7bf6b23"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::freeElements" ref="00de6f1193fabbd344258e02d7bf6b23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a> <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#00de6f1193fabbd344258e02d7bf6b23">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::freeElements</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether we should free the vector or it was supplied to us. 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00519">add()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00280">antlr3RewriteRuleElementStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00174">expungeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00108">freeNodeRS()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00065">freeRS()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6eb5f2121bfbe1d52e0fbb8f760f4485"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::getDescription" ref="6eb5f2121bfbe1d52e0fbb8f760f4485" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#6eb5f2121bfbe1d52e0fbb8f760f4485">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::getDescription</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the description string if there is one available (check for NULL). 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="db77b4789ff891dfcafa00b3cccf8f58"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::hasNext" ref="db77b4789ff891dfcafa00b3cccf8f58" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#db77b4789ff891dfcafa00b3cccf8f58">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::hasNext</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns ANTLR3_TRUE if there is a next element available. 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="49a3d89cea69ba728843b12a5cfd51e3"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::next" ref="49a3d89cea69ba728843b12a5cfd51e3" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49a3d89cea69ba728843b12a5cfd51e3">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::next</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the next element in the stream. 
<p>
If out of elements, throw an exception unless <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#c1c8e6814f647b356c1e1b77e3e589fd" title="Number of elements available in the stream.">size()</a>==1. If size is 1, then return elements[0]. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ecd854145796216efc9c57b3960abfa4"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::nextNode" ref="ecd854145796216efc9c57b3960abfa4" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#ecd854145796216efc9c57b3960abfa4">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::nextNode</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Treat next element as a single node even if it's a subtree. 
<p>
This is used instead of <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49a3d89cea69ba728843b12a5cfd51e3" title="Return the next element in the stream.">next()</a> when the result has to be a tree root node. Also prevents us from duplicating recently-added children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration must dup the type node, but ID has been added.<p>
Referencing to a rule result twice is ok; dup entire tree as we can't be adding trees; e.g., expr expr. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00442">antlr3RewriteRuleNODEStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00466">antlr3RewriteRuleNODEStreamNewAEE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00485">antlr3RewriteRuleNODEStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00373">antlr3RewriteRuleSubtreeStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00395">antlr3RewriteRuleSubtreeStreamNewAEE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00418">antlr3RewriteRuleSubtreeStreamNewAEV()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00309">antlr3RewriteRuleTOKENStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00333">antlr3RewriteRuleTOKENStreamNewAEE()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00352">antlr3RewriteRuleTOKENStreamNewAEV()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e68722ecc1e063575e357f87959f23a7"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::nextToken" ref="e68722ecc1e063575e357f87959f23a7" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#e68722ecc1e063575e357f87959f23a7">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::nextToken</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb290228de319c4cf0a219a0a413069b"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::nextTree" ref="cb290228de319c4cf0a219a0a413069b" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#cb290228de319c4cf0a219a0a413069b">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::nextTree</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="98e2e50ecddd94ce2b452514627e2b77"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::rec" ref="98e2e50ecddd94ce2b452514627e2b77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r__struct.html">pANTLR3_BASE_RECOGNIZER</a> <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#98e2e50ecddd94ce2b452514627e2b77">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::rec</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00108">freeNodeRS()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00065">freeRS()</a>.</p>

</div>
</div><p>
<a class="anchor" name="49e313e9d59d347925773e99afbf3d6e"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::reset" ref="49e313e9d59d347925773e99afbf3d6e" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#49e313e9d59d347925773e99afbf3d6e">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::reset</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the condition of this stream so that it appears we have not consumed any of its elements. 
<p>
Elements themselves are untouched. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3d90443fe82f011d5709c84c9add4508"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::singleElement" ref="3d90443fe82f011d5709c84c9add4508" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#3d90443fe82f011d5709c84c9add4508">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::singleElement</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Track single elements w/o creating a list. 
<p>
Upon 2nd add, alloc list 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00625">_next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00519">add()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00108">freeNodeRS()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00750">hasNext()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00811">size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c1c8e6814f647b356c1e1b77e3e589fd"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::size" ref="c1c8e6814f647b356c1e1b77e3e589fd" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#c1c8e6814f647b356c1e1b77e3e589fd">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::size</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of elements available in the stream. 
<p>

<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00625">_next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00601">next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00788">nextNode()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00568">nextTree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b4e1cbf7d9e92987d53c9f9b835f0eeb"></a><!-- doxytag: member="ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::toTree" ref="b4e1cbf7d9e92987d53c9f9b835f0eeb" args=")(struct ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct *stream, void *el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e__struct.html">pANTLR3_BASE_TREE</a>(* <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html#b4e1cbf7d9e92987d53c9f9b835f0eeb">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct::toTree</a>)(struct <a class="el" href="struct_a_n_t_l_r3___r_e_w_r_i_t_e___r_u_l_e___e_l_e_m_e_n_t___s_t_r_e_a_m__struct.html">ANTLR3_REWRITE_RULE_ELEMENT_STREAM_struct</a> *stream, void *el)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure stream emits trees; tokens must be converted to AST nodes. 
<p>
AST nodes can be passed through unmolested. 
<p>Referenced by <a class="el" href="antlr3rewritestreams_8c-source.html#l00625">_next()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00187">antlr3RewriteRuleElementStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00442">antlr3RewriteRuleNODEStreamNewAE()</a>, <a class="el" href="antlr3rewritestreams_8c-source.html#l00466">antlr3RewriteRuleNODEStreamNewAEE()</a>, and <a class="el" href="antlr3rewritestreams_8c-source.html#l00485">antlr3RewriteRuleNODEStreamNewAEV()</a>.</p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="antlr3rewritestreams_8h.html">antlr3rewritestreams.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:06 2010 for ANTLR3C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
