.TH "ANTLR3_LEXER_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_LEXER_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3lexer.h>\fP
.PP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "void * \fBctx\fP"
.br
.RI "\fIA generated lexer has an \fBmTokens()\fP function, which needs the context pointer of the generated lexer, not the base lexer interface this is stored here and initialized by the generated code (or manually if this is a manually built lexer. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TOKEN\fP(* \fBemit\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to a function that constructs a new token from the lexer stored information. \fP"
.ti -1c
.RI "void(* \fBemitNew\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBpANTLR3_COMMON_TOKEN\fP token)"
.br
.RI "\fIPointer to a function that emits the supplied token as the next token in the stream. \fP"
.ti -1c
.RI "void(* \fBfree\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to a function that knows how to free the resources of a lexer. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP(* \fBgetCharIndex\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetCharPositionInLine\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetLine\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to function to return the current line number in the input stream. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBgetText\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to function to return the text so far for the current token being generated. \fP"
.ti -1c
.RI "\fBpANTLR3_INPUT_STREAM\fP \fBinput\fP"
.br
.RI "\fIA pointer to the character stream whence this lexer is receiving characters. \fP"
.ti -1c
.RI "void(* \fBmatchAny\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to a function that matches the next token/char in the input stream regardless of what it actaully is. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP(* \fBmatchc\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBANTLR3_UCHAR\fP c)"
.br
.RI "\fIPointer to a function that matches and consumes the specified character from the input stream. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP(* \fBmatchRange\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBANTLR3_UCHAR\fP low, \fBANTLR3_UCHAR\fP high)"
.br
.RI "\fIPointer to a function that matches any character in the supplied range (I suppose it could be a token range too but this would only be useful if the tokens were in tsome guaranteed order which is only going to happen with a hand crafted token set). \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP(* \fBmatchs\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBANTLR3_UCHAR\fP *string)"
.br
.RI "\fIPointer to a function that attempts to match and consume the specified string from the input stream. \fP"
.ti -1c
.RI "void(* \fBmTokens\fP )(void *\fBctx\fP)"
.br
.RI "\fIPointer to the user provided (either manually or through code generation function that causes the lexer rules to run the lexing rules and produce the next token if there iss one. \fP"
.ti -1c
.RI "void(* \fBpopCharStream\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to a function that abandons the current input stream, whether it is empty or not and reverts to the previous stacked input stream. \fP"
.ti -1c
.RI "void(* \fBpushCharStream\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBpANTLR3_INPUT_STREAM\fP \fBinput\fP)"
.br
.RI "\fIPointer to a function that switches the current character input stream to a new one, saving the old one, which we will revert to at the end of this new one. \fP"
.ti -1c
.RI "\fBpANTLR3_BASE_RECOGNIZER\fP \fBrec\fP"
.br
.RI "\fIPointer to the implementation of a base recognizer, which the lexer creates and then overrides with its own lexer oriented functions (the default implementation is parser oriented). \fP"
.ti -1c
.RI "void(* \fBrecover\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.br
.RI "\fIPointer to a function that recovers from an error found in the input stream. \fP"
.ti -1c
.RI "void(* \fBsetCharStream\fP )(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBpANTLR3_INPUT_STREAM\fP \fBinput\fP)"
.br
.RI "\fIPointer to a function that sets the charstream source for the lexer and causes it to be reset. \fP"
.ti -1c
.RI "void * \fBsuper\fP"
.br
.RI "\fIIf there is a super structure that is implementing the lexer, then a pointer to it can be stored here in case implementing functions are overridden by this super structure. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "void* \fBANTLR3_LEXER_struct::ctx\fP"
.PP
A generated lexer has an \fBmTokens()\fP function, which needs the context pointer of the generated lexer, not the base lexer interface this is stored here and initialized by the generated code (or manually if this is a manually built lexer. 
.PP
Referenced by nextTokenStr().
.SS "\fBpANTLR3_COMMON_TOKEN\fP(* \fBANTLR3_LEXER_struct::emit\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to a function that constructs a new token from the lexer stored information. 
.PP
Referenced by antlr3LexerNew().
.SS "void(* \fBANTLR3_LEXER_struct::emitNew\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBpANTLR3_COMMON_TOKEN\fP token)"
.PP
Pointer to a function that emits the supplied token as the next token in the stream. 
.PP
Referenced by antlr3LexerNew().
.SS "void(* \fBANTLR3_LEXER_struct::free\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to a function that knows how to free the resources of a lexer. 
.PP
Referenced by antlr3LexerNew().
.SS "\fBANTLR3_MARKER\fP(* \fBANTLR3_LEXER_struct::getCharIndex\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Referenced by antlr3LexerNew(), emit(), getText(), and nextTokenStr().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_LEXER_struct::getCharPositionInLine\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Referenced by antlr3LexerNew().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_LEXER_struct::getLine\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to function to return the current line number in the input stream. 
.PP
Referenced by antlr3LexerNew(), and nextTokenStr().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_LEXER_struct::getText\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to function to return the text so far for the current token being generated. 
.PP
Referenced by antlr3LexerNew().
.SS "\fBpANTLR3_INPUT_STREAM\fP \fBANTLR3_LEXER_struct::input\fP"
.PP
A pointer to the character stream whence this lexer is receiving characters. 
.PP
TODO: I may come back to this and implement charstream outside the input stream as per the java implementation. 
.PP
Referenced by alreadyParsedRule(), antlr3RecognitionExceptionNew(), displayRecognitionError(), emit(), getCharIndex(), getCharPositionInLine(), getLine(), getText(), matchAny(), matchc(), matchRange(), matchs(), memoize(), nextTokenStr(), popCharStream(), pushCharStream(), recover(), and setCharStream().
.SS "void(* \fBANTLR3_LEXER_struct::matchAny\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to a function that matches the next token/char in the input stream regardless of what it actaully is. 
.PP
Referenced by antlr3LexerNew().
.SS "\fBANTLR3_BOOLEAN\fP(* \fBANTLR3_LEXER_struct::matchc\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBANTLR3_UCHAR\fP c)"
.PP
Pointer to a function that matches and consumes the specified character from the input stream. 
.PP
The input stream is required to provide characters via LA() as UTF32 characters. The default lexer implementation is source encoding agnostic and so input streams do not generally need to override the default implmentation. 
.PP
Referenced by antlr3LexerNew().
.SS "\fBANTLR3_BOOLEAN\fP(* \fBANTLR3_LEXER_struct::matchRange\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBANTLR3_UCHAR\fP low, \fBANTLR3_UCHAR\fP high)"
.PP
Pointer to a function that matches any character in the supplied range (I suppose it could be a token range too but this would only be useful if the tokens were in tsome guaranteed order which is only going to happen with a hand crafted token set). 
.PP
Referenced by antlr3LexerNew().
.SS "\fBANTLR3_BOOLEAN\fP(* \fBANTLR3_LEXER_struct::matchs\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBANTLR3_UCHAR\fP *string)"
.PP
Pointer to a function that attempts to match and consume the specified string from the input stream. 
.PP
Note that strings muse be passed as terminated arrays of ANTLR3_UCHAR. Strings are terminated with 0xFFFFFFFF, which is an invalid UTF32 character 
.PP
Referenced by antlr3LexerNew().
.SS "void(* \fBANTLR3_LEXER_struct::mTokens\fP)(void *\fBctx\fP)"
.PP
Pointer to the user provided (either manually or through code generation function that causes the lexer rules to run the lexing rules and produce the next token if there iss one. 
.PP
This is called from \fBnextToken()\fP in the pANTLR3_TOKEN_SOURCE. Note that the input parameter for this funciton is the generated lexer context (stored in ctx in this interface) it is a generated function and expects the context to be the generated lexer. 
.PP
Referenced by antlr3LexerNew(), and nextTokenStr().
.SS "void(* \fBANTLR3_LEXER_struct::popCharStream\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to a function that abandons the current input stream, whether it is empty or not and reverts to the previous stacked input stream. 
.PP
Referenced by antlr3LexerNew(), and nextToken().
.SS "void(* \fBANTLR3_LEXER_struct::pushCharStream\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBpANTLR3_INPUT_STREAM\fP \fBinput\fP)"
.PP
Pointer to a function that switches the current character input stream to a new one, saving the old one, which we will revert to at the end of this new one. 
.PP
Referenced by antlr3LexerNew().
.SS "\fBpANTLR3_BASE_RECOGNIZER\fP \fBANTLR3_LEXER_struct::rec\fP"
.PP
Pointer to the implementation of a base recognizer, which the lexer creates and then overrides with its own lexer oriented functions (the default implementation is parser oriented). 
.PP
This also contains a token source interface, which the lexer instance will provide to anything that needs it, which is anything else that implements a base recognizer, such as a parser. 
.PP
Referenced by antlr3LexerNew(), displayRecognitionError(), emit(), emitNew(), freeLexer(), getText(), matchc(), matchRange(), matchs(), nextToken(), nextTokenStr(), popCharStream(), pushCharStream(), reset(), and setCharStream().
.SS "void(* \fBANTLR3_LEXER_struct::recover\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer)"
.PP
Pointer to a function that recovers from an error found in the input stream. 
.PP
Generally, this will be a ANTLR3_EXCEPTION_NOVIABLE_ALT but it could also be from a mismatched token that the (*match)() could not recover from. 
.PP
Referenced by antlr3LexerNew(), matchc(), matchRange(), matchs(), and nextTokenStr().
.SS "void(* \fBANTLR3_LEXER_struct::setCharStream\fP)(struct \fBANTLR3_LEXER_struct\fP *lexer, \fBpANTLR3_INPUT_STREAM\fP \fBinput\fP)"
.PP
Pointer to a function that sets the charstream source for the lexer and causes it to be reset. 
.PP
Referenced by antlr3LexerNew(), popCharStream(), and pushCharStream().
.SS "void* \fBANTLR3_LEXER_struct::super\fP"
.PP
If there is a super structure that is implementing the lexer, then a pointer to it can be stored here in case implementing functions are overridden by this super structure. 
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
