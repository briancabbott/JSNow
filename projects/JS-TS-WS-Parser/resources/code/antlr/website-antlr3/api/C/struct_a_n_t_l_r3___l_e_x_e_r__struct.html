<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR3C: ANTLR3_LEXER_struct Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ANTLR3_LEXER_struct Struct Reference</h1><!-- doxytag: class="ANTLR3_LEXER_struct" --><code>#include &lt;antlr3lexer.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for ANTLR3_LEXER_struct:</div>
<div class="dynsection">
<p><center><img src="struct_a_n_t_l_r3___l_e_x_e_r__struct__coll__graph.png" border="0" usemap="#_a_n_t_l_r3___l_e_x_e_r__struct__coll__map" alt="Collaboration graph"></center>
<map name="_a_n_t_l_r3___l_e_x_e_r__struct__coll__map">
<area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html" title="The definition of an ANTLR3 common token structure, which all implementations of..." alt="" coords="2079,543,2316,569"><area shape="rect" href="struct_a_n_t_l_r3___r_e_c_o_g_n_i_z_e_r___s_h_a_r_e_d___s_t_a_t_e__struct.html" title="All the data elements required to track the current state of any recognizer (lexer..." alt="" coords="2880,903,3205,929"><area shape="rect" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html" title="Definition of a token source, which has a pointer to a function that returns the..." alt="" coords="2432,784,2667,811"><area shape="rect" href="struct_a_n_t_l_r3___t_o_k_e_n___f_a_c_t_o_r_y__struct.html" title="ANTLR3 Token factory interface to create lots of tokens efficiently rather than creating..." alt="" coords="2429,484,2669,511"><area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___t_r_e_e___a_d_a_p_t_o_r__struct.html" title="ANTLR3_BASE_TREE_ADAPTOR_struct" alt="" coords="2905,508,3180,535"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html" title="Base string class tracks the allocations and provides simple string tracking functions..." alt="" coords="976,612,1149,639"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html" title="Definition of the string factory interface, which creates and tracks strings for..." alt="" coords="629,469,875,496"><area shape="rect" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html" title="Master context structure for an ANTLR3 C runtime based input stream." alt="" coords="1632,423,1859,449"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html" title="ANTLR3_INT_STREAM_struct" alt="" coords="1296,688,1504,715"><area shape="rect" href="struct_a_n_t_l_r3___e_x_c_e_p_t_i_o_n__struct.html" title="Base structure for an ANTLR3 exception tracker." alt="" coords="1645,803,1845,829"><area shape="rect" href="struct_a_n_t_l_r3___d_e_b_u_g___e_v_e_n_t___l_i_s_t_e_n_e_r__struct.html" title="The ANTLR3 debugging interface for communicating with ANLTR Works." alt="" coords="3440,599,3736,625"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html" title="ANTLR3_VECTOR_struct" alt="" coords="360,949,539,976"><area shape="rect" href="struct_a_n_t_l_r3___s_t_a_c_k__struct.html" title="Structure that represents a Stack collection." alt="" coords="2465,1288,2633,1315"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r___e_l_e_m_e_n_t__struct.html" title="ANTLR3_VECTOR_ELEMENT_struct" alt="" coords="7,949,255,976"><area shape="rect" href="struct_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r__struct.html" title="Base tracking context structure for all types of recognizers." alt="" coords="3844,1005,4097,1032"><area shape="rect" href="struct_a_n_t_l_r3___b_i_t_s_e_t__struct.html" title="ANTLR3_BITSET_struct" alt="" coords="1883,1219,2053,1245"><area shape="rect" href="struct_a_n_t_l_r3___b_i_t_s_e_t___l_i_s_t__struct.html" title="ANTLR3_BITSET_LIST_struct" alt="" coords="1297,1012,1503,1039"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___t_a_b_l_e__struct.html" title="Structure that tracks a hash table." alt="" coords="3483,1111,3693,1137"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___e_n_t_r_y__struct.html" title="Internal structure representing an element in a hash bucket." alt="" coords="2444,1168,2655,1195"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___b_u_c_k_e_t__struct.html" title="Internal structure of a hash table bucket, which tracks all keys that hash to the..." alt="" coords="2932,1172,3153,1199"><area shape="rect" href="struct_a_n_t_l_r3___h_a_s_h___k_e_y__struct.html" title="ANTLR3_HASH_KEY_struct" alt="" coords="2101,1175,2293,1201"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___t_r_i_e__struct.html" title="Structure that defines an ANTLR3_INT_TRIE." alt="" coords="2459,1009,2640,1036"><area shape="rect" href="struct_a_n_t_l_r3___t_r_i_e___e_n_t_r_y__struct.html" title="Structure that holds the payload entry in an ANTLR3_INT_TRIE or ANTLR3_STRING_TRIE..." alt="" coords="1643,1017,1848,1044"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___t_r_i_e___n_o_d_e__struct.html" title="Structure that defines an element/node in an ANTLR3_INT_TRIE." alt="" coords="2084,1009,2311,1036"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#a8c9ab64d60b659c71263c2f2a39779a">ctx</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generated lexer has an <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#f9c91981f78a7d27002934024b024fc0" title="Pointer to the user provided (either manually or through code generation function...">mTokens()</a> function, which needs the context pointer of the generated lexer, not the base lexer interface this is stored here and initialized by the generated code (or manually if this is a manually built lexer.  <a href="#a8c9ab64d60b659c71263c2f2a39779a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#5200cf32fbc130ee638ceee2be66bd4d">emit</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that constructs a new token from the lexer stored information.  <a href="#5200cf32fbc130ee638ceee2be66bd4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#59104ea186b3ad9ce763dc1feee71bd4">emitNew</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> token)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that emits the supplied token as the next token in the stream.  <a href="#59104ea186b3ad9ce763dc1feee71bd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#793226480ca08fbcac7b61578fb2430c">free</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that knows how to free the resources of a lexer.  <a href="#793226480ca08fbcac7b61578fb2430c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#3c09f36c7367d7755563155adcabdcc1">getCharIndex</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#2b5e18cf9d9b55bfcc02d345c5e8f848">getCharPositionInLine</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#151c4767a28ceccf7fb5bd81e30eaeec">getLine</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to function to return the current line number in the input stream.  <a href="#151c4767a28ceccf7fb5bd81e30eaeec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#a916fc721b7c14ee4bb57b1c7fb88e60">getText</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to function to return the text so far for the current token being generated.  <a href="#a916fc721b7c14ee4bb57b1c7fb88e60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html">pANTLR3_INPUT_STREAM</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#63668c0391badeb589243179e93f1a0a">input</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to the character stream whence this lexer is receiving characters.  <a href="#63668c0391badeb589243179e93f1a0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#de2cead2bc3a6d5693b38e77542f8149">matchAny</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that matches the next token/char in the input stream regardless of what it actaully is.  <a href="#de2cead2bc3a6d5693b38e77542f8149"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#e3c5c1856e94f840c9c1872f8617b282">matchc</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that matches and consumes the specified character from the input stream.  <a href="#e3c5c1856e94f840c9c1872f8617b282"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#90cf24b209be2197848b23db2f3fdc06">matchRange</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> low, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> high)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that matches any character in the supplied range (I suppose it could be a token range too but this would only be useful if the tokens were in tsome guaranteed order which is only going to happen with a hand crafted token set).  <a href="#90cf24b209be2197848b23db2f3fdc06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#868ae254b20657e4e8a837bfcf1a4c71">matchs</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that attempts to match and consume the specified string from the input stream.  <a href="#868ae254b20657e4e8a837bfcf1a4c71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#f9c91981f78a7d27002934024b024fc0">mTokens</a> )(void *<a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#a8c9ab64d60b659c71263c2f2a39779a">ctx</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the user provided (either manually or through code generation function that causes the lexer rules to run the lexing rules and produce the next token if there iss one.  <a href="#f9c91981f78a7d27002934024b024fc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#f3f03678a1511675104bc37ada7dcade">popCharStream</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that abandons the current input stream, whether it is empty or not and reverts to the previous stacked input stream.  <a href="#f3f03678a1511675104bc37ada7dcade"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#fa7cff0e582050f15c7c27e17a2e844c">pushCharStream</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html">pANTLR3_INPUT_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#63668c0391badeb589243179e93f1a0a">input</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that switches the current character input stream to a new one, saving the old one, which we will revert to at the end of this new one.  <a href="#fa7cff0e582050f15c7c27e17a2e844c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r__struct.html">pANTLR3_BASE_RECOGNIZER</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#fcb0d60a4a2c829c30cc1e8e3454390f">rec</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the implementation of a base recognizer, which the lexer creates and then overrides with its own lexer oriented functions (the default implementation is parser oriented).  <a href="#fcb0d60a4a2c829c30cc1e8e3454390f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#77fd0b4598ebb28edab46d9aab6e7143">recover</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that recovers from an error found in the input stream.  <a href="#77fd0b4598ebb28edab46d9aab6e7143"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#5c28d84198fa94f172e35887f52c248f">setCharStream</a> )(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html">pANTLR3_INPUT_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#63668c0391badeb589243179e93f1a0a">input</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that sets the charstream source for the lexer and causes it to be reset.  <a href="#5c28d84198fa94f172e35887f52c248f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#e500bd5337a874e4c753b614fafc1eec">super</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a super structure that is implementing the lexer, then a pointer to it can be stored here in case implementing functions are overridden by this super structure.  <a href="#e500bd5337a874e4c753b614fafc1eec"></a><br></td></tr>
</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="a8c9ab64d60b659c71263c2f2a39779a"></a><!-- doxytag: member="ANTLR3_LEXER_struct::ctx" ref="a8c9ab64d60b659c71263c2f2a39779a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#a8c9ab64d60b659c71263c2f2a39779a">ANTLR3_LEXER_struct::ctx</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A generated lexer has an <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#f9c91981f78a7d27002934024b024fc0" title="Pointer to the user provided (either manually or through code generation function...">mTokens()</a> function, which needs the context pointer of the generated lexer, not the base lexer interface this is stored here and initialized by the generated code (or manually if this is a manually built lexer. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5200cf32fbc130ee638ceee2be66bd4d"></a><!-- doxytag: member="ANTLR3_LEXER_struct::emit" ref="5200cf32fbc130ee638ceee2be66bd4d" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#5200cf32fbc130ee638ceee2be66bd4d">ANTLR3_LEXER_struct::emit</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that constructs a new token from the lexer stored information. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="59104ea186b3ad9ce763dc1feee71bd4"></a><!-- doxytag: member="ANTLR3_LEXER_struct::emitNew" ref="59104ea186b3ad9ce763dc1feee71bd4" args=")(struct ANTLR3_LEXER_struct *lexer, pANTLR3_COMMON_TOKEN token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#59104ea186b3ad9ce763dc1feee71bd4">ANTLR3_LEXER_struct::emitNew</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a> token)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that emits the supplied token as the next token in the stream. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="793226480ca08fbcac7b61578fb2430c"></a><!-- doxytag: member="ANTLR3_LEXER_struct::free" ref="793226480ca08fbcac7b61578fb2430c" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#793226480ca08fbcac7b61578fb2430c">ANTLR3_LEXER_struct::free</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that knows how to free the resources of a lexer. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3c09f36c7367d7755563155adcabdcc1"></a><!-- doxytag: member="ANTLR3_LEXER_struct::getCharIndex" ref="3c09f36c7367d7755563155adcabdcc1" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#0361e6bf442e07afe923e4d05e9ebc4f">ANTLR3_MARKER</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#3c09f36c7367d7755563155adcabdcc1">ANTLR3_LEXER_struct::getCharIndex</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00633">emit()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00869">getText()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2b5e18cf9d9b55bfcc02d345c5e8f848"></a><!-- doxytag: member="ANTLR3_LEXER_struct::getCharPositionInLine" ref="2b5e18cf9d9b55bfcc02d345c5e8f848" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#2b5e18cf9d9b55bfcc02d345c5e8f848">ANTLR3_LEXER_struct::getCharPositionInLine</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="151c4767a28ceccf7fb5bd81e30eaeec"></a><!-- doxytag: member="ANTLR3_LEXER_struct::getLine" ref="151c4767a28ceccf7fb5bd81e30eaeec" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#c41f744abd0fd25144b9eb9d11b1dfd1">ANTLR3_UINT32</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#151c4767a28ceccf7fb5bd81e30eaeec">ANTLR3_LEXER_struct::getLine</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to function to return the current line number in the input stream. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a916fc721b7c14ee4bb57b1c7fb88e60"></a><!-- doxytag: member="ANTLR3_LEXER_struct::getText" ref="a916fc721b7c14ee4bb57b1c7fb88e60" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#a916fc721b7c14ee4bb57b1c7fb88e60">ANTLR3_LEXER_struct::getText</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to function to return the text so far for the current token being generated. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="63668c0391badeb589243179e93f1a0a"></a><!-- doxytag: member="ANTLR3_LEXER_struct::input" ref="63668c0391badeb589243179e93f1a0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html">pANTLR3_INPUT_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#63668c0391badeb589243179e93f1a0a">ANTLR3_LEXER_struct::input</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A pointer to the character stream whence this lexer is receiving characters. 
<p>
TODO: I may come back to this and implement charstream outside the input stream as per the java implementation. 
<p>Referenced by <a class="el" href="antlr3baserecognizer_8c-source.html#l01918">alreadyParsedRule()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l00269">antlr3RecognitionExceptionNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00418">displayRecognitionError()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00633">emit()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00863">getCharIndex()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00858">getCharPositionInLine()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00852">getLine()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00869">getText()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00840">matchAny()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00761">matchc()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00801">matchRange()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00718">matchs()</a>, <a class="el" href="antlr3baserecognizer_8c-source.html#l01989">memoize()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00601">popCharStream()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00555">pushCharStream()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00846">recover()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00483">setCharStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="de2cead2bc3a6d5693b38e77542f8149"></a><!-- doxytag: member="ANTLR3_LEXER_struct::matchAny" ref="de2cead2bc3a6d5693b38e77542f8149" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#de2cead2bc3a6d5693b38e77542f8149">ANTLR3_LEXER_struct::matchAny</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that matches the next token/char in the input stream regardless of what it actaully is. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e3c5c1856e94f840c9c1872f8617b282"></a><!-- doxytag: member="ANTLR3_LEXER_struct::matchc" ref="e3c5c1856e94f840c9c1872f8617b282" args=")(struct ANTLR3_LEXER_struct *lexer, ANTLR3_UCHAR c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#e3c5c1856e94f840c9c1872f8617b282">ANTLR3_LEXER_struct::matchc</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> c)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that matches and consumes the specified character from the input stream. 
<p>
The input stream is required to provide characters via LA() as UTF32 characters. The default lexer implementation is source encoding agnostic and so input streams do not generally need to override the default implmentation. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="90cf24b209be2197848b23db2f3fdc06"></a><!-- doxytag: member="ANTLR3_LEXER_struct::matchRange" ref="90cf24b209be2197848b23db2f3fdc06" args=")(struct ANTLR3_LEXER_struct *lexer, ANTLR3_UCHAR low, ANTLR3_UCHAR high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#90cf24b209be2197848b23db2f3fdc06">ANTLR3_LEXER_struct::matchRange</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> low, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> high)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that matches any character in the supplied range (I suppose it could be a token range too but this would only be useful if the tokens were in tsome guaranteed order which is only going to happen with a hand crafted token set). 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="868ae254b20657e4e8a837bfcf1a4c71"></a><!-- doxytag: member="ANTLR3_LEXER_struct::matchs" ref="868ae254b20657e4e8a837bfcf1a4c71" args=")(struct ANTLR3_LEXER_struct *lexer, ANTLR3_UCHAR *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="antlr3defs_8h.html#5b33dccbba3b7212539695e21df4079b">ANTLR3_BOOLEAN</a>(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#868ae254b20657e4e8a837bfcf1a4c71">ANTLR3_LEXER_struct::matchs</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="antlr3defs_8h.html#078eec1343cdbb862af80f352ea701da">ANTLR3_UCHAR</a> *string)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that attempts to match and consume the specified string from the input stream. 
<p>
Note that strings muse be passed as terminated arrays of ANTLR3_UCHAR. Strings are terminated with 0xFFFFFFFF, which is an invalid UTF32 character 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f9c91981f78a7d27002934024b024fc0"></a><!-- doxytag: member="ANTLR3_LEXER_struct::mTokens" ref="f9c91981f78a7d27002934024b024fc0" args=")(void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#f9c91981f78a7d27002934024b024fc0">ANTLR3_LEXER_struct::mTokens</a>)(void *<a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#a8c9ab64d60b659c71263c2f2a39779a">ctx</a>)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to the user provided (either manually or through code generation function that causes the lexer rules to run the lexing rules and produce the next token if there iss one. 
<p>
This is called from <a class="el" href="antlr3lexer_8c.html#c9a1246efbb94ec9e0069b70c3c53502" title="Default implementation of the nextToken() call for a lexer.">nextToken()</a> in the pANTLR3_TOKEN_SOURCE. Note that the input parameter for this funciton is the generated lexer context (stored in ctx in this interface) it is a generated function and expects the context to be the generated lexer. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f3f03678a1511675104bc37ada7dcade"></a><!-- doxytag: member="ANTLR3_LEXER_struct::popCharStream" ref="f3f03678a1511675104bc37ada7dcade" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#f3f03678a1511675104bc37ada7dcade">ANTLR3_LEXER_struct::popCharStream</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that abandons the current input stream, whether it is empty or not and reverts to the previous stacked input stream. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00321">nextToken()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fa7cff0e582050f15c7c27e17a2e844c"></a><!-- doxytag: member="ANTLR3_LEXER_struct::pushCharStream" ref="fa7cff0e582050f15c7c27e17a2e844c" args=")(struct ANTLR3_LEXER_struct *lexer, pANTLR3_INPUT_STREAM input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#fa7cff0e582050f15c7c27e17a2e844c">ANTLR3_LEXER_struct::pushCharStream</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html">pANTLR3_INPUT_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#63668c0391badeb589243179e93f1a0a">input</a>)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that switches the current character input stream to a new one, saving the old one, which we will revert to at the end of this new one. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fcb0d60a4a2c829c30cc1e8e3454390f"></a><!-- doxytag: member="ANTLR3_LEXER_struct::rec" ref="fcb0d60a4a2c829c30cc1e8e3454390f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___b_a_s_e___r_e_c_o_g_n_i_z_e_r__struct.html">pANTLR3_BASE_RECOGNIZER</a> <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#fcb0d60a4a2c829c30cc1e8e3454390f">ANTLR3_LEXER_struct::rec</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to the implementation of a base recognizer, which the lexer creates and then overrides with its own lexer oriented functions (the default implementation is parser oriented). 
<p>
This also contains a token source interface, which the lexer instance will provide to anything that needs it, which is anything else that implements a base recognizer, such as a parser. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00418">displayRecognitionError()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00633">emit()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00627">emitNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00679">freeLexer()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00869">getText()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00761">matchc()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00801">matchRange()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00718">matchs()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00321">nextToken()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00601">popCharStream()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00555">pushCharStream()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00166">reset()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00483">setCharStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="77fd0b4598ebb28edab46d9aab6e7143"></a><!-- doxytag: member="ANTLR3_LEXER_struct::recover" ref="77fd0b4598ebb28edab46d9aab6e7143" args=")(struct ANTLR3_LEXER_struct *lexer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#77fd0b4598ebb28edab46d9aab6e7143">ANTLR3_LEXER_struct::recover</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that recovers from an error found in the input stream. 
<p>
Generally, this will be a ANTLR3_EXCEPTION_NOVIABLE_ALT but it could also be from a mismatched token that the (*match)() could not recover from. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00761">matchc()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00801">matchRange()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00718">matchs()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5c28d84198fa94f172e35887f52c248f"></a><!-- doxytag: member="ANTLR3_LEXER_struct::setCharStream" ref="5c28d84198fa94f172e35887f52c248f" args=")(struct ANTLR3_LEXER_struct *lexer, pANTLR3_INPUT_STREAM input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#5c28d84198fa94f172e35887f52c248f">ANTLR3_LEXER_struct::setCharStream</a>)(struct <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html">ANTLR3_LEXER_struct</a> *lexer, <a class="el" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html">pANTLR3_INPUT_STREAM</a> <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#63668c0391badeb589243179e93f1a0a">input</a>)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that sets the charstream source for the lexer and causes it to be reset. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00601">popCharStream()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00555">pushCharStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e500bd5337a874e4c753b614fafc1eec"></a><!-- doxytag: member="ANTLR3_LEXER_struct::super" ref="e500bd5337a874e4c753b614fafc1eec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="struct_a_n_t_l_r3___l_e_x_e_r__struct.html#e500bd5337a874e4c753b614fafc1eec">ANTLR3_LEXER_struct::super</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If there is a super structure that is implementing the lexer, then a pointer to it can be stored here in case implementing functions are overridden by this super structure. 
<p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="antlr3lexer_8h.html">antlr3lexer.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:05 2010 for ANTLR3C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
