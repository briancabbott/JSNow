.TH "src/antlr3collections.c" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/antlr3collections.c \- 
.SH "Detailed Description"
.PP 
Provides a number of useful functions that are roughly equivalent to java HashTable and List for the purposes of Antlr 3 C runtime. 

Also useable by the C programmer for things like symbol tables pointers and so on. 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3.h>\fP
.br
\fC#include 'antlr3collections.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBaddEdge\fP (\fBpANTLR3_TOPO\fP topo, \fBANTLR3_UINT32\fP edge, \fBANTLR3_UINT32\fP dependency)"
.br
.ti -1c
.RI "static void \fBantlr3EnumFree\fP (\fBpANTLR3_HASH_ENUM\fP en)"
.br
.RI "\fIFrees up the memory structures that represent a hash table enumeration. \fP"
.ti -1c
.RI "\fBpANTLR3_HASH_ENUM\fP \fBantlr3EnumNew\fP (\fBpANTLR3_HASH_TABLE\fP table)"
.br
.RI "\fICreates an enumeration structure to traverse the hash table. \fP"
.ti -1c
.RI "static int \fBantlr3EnumNext\fP (\fBpANTLR3_HASH_ENUM\fP en, \fBpANTLR3_HASH_KEY\fP *key, void **data)"
.br
.RI "\fIReturn the next entry in the hashtable being traversed by the supplied enumeration. \fP"
.ti -1c
.RI "static void \fBantlr3EnumNextEntry\fP (\fBpANTLR3_HASH_ENUM\fP en)"
.br
.RI "\fILocal function to advance the entry pointer of an enumeration structure to the next valid entry (if there is one). \fP"
.ti -1c
.RI "ANTLR3_API \fBANTLR3_UINT32\fP \fBantlr3Hash\fP (void *key, \fBANTLR3_UINT32\fP keylen)"
.br
.RI "\fIGiven an input key of arbitrary length, return a hash value of it. \fP"
.ti -1c
.RI "static void \fBantlr3HashDelete\fP (\fBpANTLR3_HASH_TABLE\fP table, void *key)"
.br
.RI "\fITakes the element with the supplied key out of the list, and deletes the data calling the supplied free() routine if any. \fP"
.ti -1c
.RI "static void \fBantlr3HashDeleteI\fP (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key)"
.br
.RI "\fITakes the element with the supplied key out of the list, and deletes the data calling the supplied free() routine if any. \fP"
.ti -1c
.RI "static void \fBantlr3HashFree\fP (\fBpANTLR3_HASH_TABLE\fP table)"
.br
.ti -1c
.RI "static void * \fBantlr3HashGet\fP (\fBpANTLR3_HASH_TABLE\fP table, void *key)"
.br
.RI "\fIReturn the element pointer in the hash table for a particular key value, or NULL if it don't exist (or was itself NULL). \fP"
.ti -1c
.RI "static void * \fBantlr3HashGetI\fP (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key)"
.br
.RI "\fIReturn the element pointer in the hash table for a particular key value, or NULL if it don't exist (or was itself NULL). \fP"
.ti -1c
.RI "static \fBANTLR3_INT32\fP \fBantlr3HashPut\fP (\fBpANTLR3_HASH_TABLE\fP table, void *key, void *element, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.RI "\fIAdd the element pointer in to the table, based upon the hash of the provided key. \fP"
.ti -1c
.RI "static \fBANTLR3_INT32\fP \fBantlr3HashPutI\fP (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key, void *element, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.RI "\fIAdd the element pointer in to the table, based upon the hash of the provided key. \fP"
.ti -1c
.RI "static \fBpANTLR3_HASH_ENTRY\fP \fBantlr3HashRemove\fP (\fBpANTLR3_HASH_TABLE\fP table, void *key)"
.br
.RI "\fIRemove the element in the hash table for a particular key value, if it exists - no error if it does not. \fP"
.ti -1c
.RI "static \fBpANTLR3_HASH_ENTRY\fP \fBantlr3HashRemoveI\fP (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key)"
.br
.RI "\fIRemove a numeric keyed entry from a hash table if it exists, no error if it does not exist. \fP"
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBantlr3HashSize\fP (\fBpANTLR3_HASH_TABLE\fP table)"
.br
.RI "\fIreturn the current size of the hash table \fP"
.ti -1c
.RI "\fBpANTLR3_HASH_TABLE\fP \fBantlr3HashTableNew\fP (\fBANTLR3_UINT32\fP sizeHint)"
.br
.ti -1c
.RI "\fBpANTLR3_INT_TRIE\fP \fBantlr3IntTrieNew\fP (\fBANTLR3_UINT32\fP depth)"
.br
.ti -1c
.RI "static \fBANTLR3_INT32\fP \fBantlr3ListAdd\fP (\fBpANTLR3_LIST\fP list, void *element, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.RI "\fIAdd the supplied element to the list, at the next available key. \fP"
.ti -1c
.RI "static void \fBantlr3ListDelete\fP (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key)"
.br
.ti -1c
.RI "static void \fBantlr3ListFree\fP (\fBpANTLR3_LIST\fP list)"
.br
.ti -1c
.RI "static void * \fBantlr3ListGet\fP (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key)"
.br
.ti -1c
.RI "ANTLR3_API \fBpANTLR3_LIST\fP \fBantlr3ListNew\fP (\fBANTLR3_UINT32\fP sizeHint)"
.br
.ti -1c
.RI "static \fBANTLR3_INT32\fP \fBantlr3ListPut\fP (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key, void *element, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.ti -1c
.RI "static void * \fBantlr3ListRemove\fP (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key)"
.br
.RI "\fIRemove from the list, but don't free the element, just send it back to the caller. \fP"
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBantlr3ListSize\fP (\fBpANTLR3_LIST\fP list)"
.br
.ti -1c
.RI "ANTLR3_API void \fBantlr3SetVectorApi\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP sizeHint)"
.br
.ti -1c
.RI "static void \fBantlr3StackFree\fP (\fBpANTLR3_STACK\fP stack)"
.br
.ti -1c
.RI "static void * \fBantlr3StackGet\fP (\fBpANTLR3_STACK\fP stack, \fBANTLR3_INTKEY\fP key)"
.br
.ti -1c
.RI "ANTLR3_API \fBpANTLR3_STACK\fP \fBantlr3StackNew\fP (\fBANTLR3_UINT32\fP sizeHint)"
.br
.ti -1c
.RI "static void * \fBantlr3StackPeek\fP (\fBpANTLR3_STACK\fP stack)"
.br
.ti -1c
.RI "static void * \fBantlr3StackPop\fP (\fBpANTLR3_STACK\fP stack)"
.br
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBantlr3StackPush\fP (\fBpANTLR3_STACK\fP stack, void *element, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBantlr3StackSize\fP (\fBpANTLR3_STACK\fP stack)"
.br
.ti -1c
.RI "ANTLR3_API \fBpANTLR3_TOPO\fP \fBantlr3TopoNew\fP ()"
.br
.RI "\fIAllocate and initialize a new ANTLR3 topological sorter, which can be used to define edges that identify numerical node indexes that depend on other numerical node indexes, which can then be sorted topologically such that any node is sorted after all its dependent nodes. \fP"
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBantlr3VectorAdd\fP (\fBpANTLR3_VECTOR\fP vector, void *element, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.RI "\fIAdd the supplied pointer and freeing function pointer to the list, expanding the vector if needed. \fP"
.ti -1c
.RI "static void \fBantlr3VectorClear\fP (\fBpANTLR3_VECTOR\fP vector)"
.br
.ti -1c
.RI "static void \fBantlr3VectorDel\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry)"
.br
.ti -1c
.RI "ANTLR3_API \fBpANTLR3_VECTOR_FACTORY\fP \fBantlr3VectorFactoryNew\fP (\fBANTLR3_UINT32\fP sizeHint)"
.br
.RI "\fIVector factory creation. \fP"
.ti -1c
.RI "static void ANTLR3_CDECL \fBantlr3VectorFree\fP (\fBpANTLR3_VECTOR\fP vector)"
.br
.ti -1c
.RI "static void * \fBantlr3VectorGet\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry)"
.br
.ti -1c
.RI "ANTLR3_API \fBpANTLR3_VECTOR\fP \fBantlr3VectorNew\fP (\fBANTLR3_UINT32\fP sizeHint)"
.br
.ti -1c
.RI "static void \fBantlr3VectorResize\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP hint)"
.br
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBantlr3VectorSet\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry, void *element, void(ANTLR3_CDECL *freeptr)(void *), \fBANTLR3_BOOLEAN\fP freeExisting)"
.br
.RI "\fIReplace the element at the specified entry point with the supplied entry. \fP"
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBantlr3VectorSize\fP (\fBpANTLR3_VECTOR\fP vector)"
.br
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBantlr3VectorSwap\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry1, \fBANTLR3_UINT32\fP entry2)"
.br
.RI "\fIReplace the element at the specified entry point with the supplied entry. \fP"
.ti -1c
.RI "static void * \fBantrl3VectorRemove\fP (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry)"
.br
.RI "\fIRemove the entry from the vector, but do not free any entry, even if it has a free pointer. \fP"
.ti -1c
.RI "static void \fBcloseVectorFactory\fP (\fBpANTLR3_VECTOR_FACTORY\fP factory)"
.br
.ti -1c
.RI "static void \fBDFS\fP (\fBpANTLR3_TOPO\fP topo, \fBANTLR3_UINT32\fP node)"
.br
.RI "\fIGiven a starting node, descend its dependent nodes (ones that it has edges to) until we find one without edges. \fP"
.ti -1c
.RI "static void \fBfreeIntNode\fP (\fBpANTLR3_INT_TRIE_NODE\fP node)"
.br
.RI "\fIRelease memory allocated to this tree. \fP"
.ti -1c
.RI "static void \fBfreeTopo\fP (\fBpANTLR3_TOPO\fP topo)"
.br
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBintTrieAdd\fP (\fBpANTLR3_INT_TRIE\fP trie, \fBANTLR3_INTKEY\fP key, \fBANTLR3_UINT32\fP type, \fBANTLR3_INTKEY\fP intVal, void *data, void(ANTLR3_CDECL *freeptr)(void *))"
.br
.RI "\fIAdd an entry into the INT trie. \fP"
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBintTrieDel\fP (\fBpANTLR3_INT_TRIE\fP trie, \fBANTLR3_INTKEY\fP key)"
.br
.ti -1c
.RI "static void \fBintTrieFree\fP (\fBpANTLR3_INT_TRIE\fP trie)"
.br
.RI "\fICalled to free all nodes and the structure itself. \fP"
.ti -1c
.RI "static \fBpANTLR3_TRIE_ENTRY\fP \fBintTrieGet\fP (\fBpANTLR3_INT_TRIE\fP trie, \fBANTLR3_INTKEY\fP key)"
.br
.RI "\fISearch the int Trie and return a pointer to the first bucket indexed by the key if it is contained in the trie, otherwise NULL. \fP"
.ti -1c
.RI "static void \fBnewPool\fP (\fBpANTLR3_VECTOR_FACTORY\fP factory)"
.br
.ti -1c
.RI "static \fBpANTLR3_VECTOR\fP \fBnewVector\fP (\fBpANTLR3_VECTOR_FACTORY\fP factory)"
.br
.ti -1c
.RI "static void \fBreturnVector\fP (\fBpANTLR3_VECTOR_FACTORY\fP factory, \fBpANTLR3_VECTOR\fP vector)"
.br
.ti -1c
.RI "static \fBpANTLR3_UINT32\fP \fBsortToArray\fP (\fBpANTLR3_TOPO\fP topo)"
.br
.ti -1c
.RI "static void \fBsortVector\fP (\fBpANTLR3_TOPO\fP topo, \fBpANTLR3_VECTOR\fP v)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBANTLR3_UINT8\fP \fBbitIndex\fP [256]"
.br
.RI "\fIArray of left most significant bit positions for an 8 bit element provides an efficient way to find the highest bit that is set in an n byte value (n>0). \fP"
.ti -1c
.RI "static \fBANTLR3_UINT64\fP \fBbitMask\fP [64]"
.br
.RI "\fIRather than use the bit index of a trie node to shift 0x01 left that many times, then & with the result, it is faster to use the bit index as an index into this table which holds precomputed masks for any of the 64 bits we need to mask off singly. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void addEdge (\fBpANTLR3_TOPO\fP topo, \fBANTLR3_UINT32\fP edge, \fBANTLR3_UINT32\fP dependency)\fC [static]\fP"
.PP
References ANTLR3_BITSET_struct::add, ANTLR3_CALLOC, ANTLR3_REALLOC, antlr3BitsetNew(), ANTLR3_TOPO_struct::edges, and ANTLR3_TOPO_struct::limit.
.PP
Referenced by antlr3TopoNew().
.SS "static void antlr3EnumFree (\fBpANTLR3_HASH_ENUM\fP en)\fC [static]\fP"
.PP
Frees up the memory structures that represent a hash table enumeration. 
.PP
\fBParameters:\fP
.RS 4
\fIenum\fP Pointer to ANTLR3 enumeration structure returned by \fBantlr3EnumNew()\fP 
.RE
.PP

.PP
References ANTLR3_FREE.
.PP
Referenced by antlr3EnumNew().
.SS "\fBpANTLR3_HASH_ENUM\fP antlr3EnumNew (\fBpANTLR3_HASH_TABLE\fP table)"
.PP
Creates an enumeration structure to traverse the hash table. 
.PP
\fBParameters:\fP
.RS 4
\fItable\fP Table to enumerate 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to enumeration structure. 
.RE
.PP

.PP
References ANTLR3_ERR_NOMEM, ANTLR3_FUNC_PTR, ANTLR3_MALLOC, antlr3EnumFree(), antlr3EnumNext(), antlr3EnumNextEntry(), ANTLR3_HASH_ENUM_struct::bucket, ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_ENUM_struct::entry, ANTLR3_HASH_ENUM_struct::free, ANTLR3_HASH_ENUM_struct::next, and ANTLR3_HASH_ENUM_struct::table.
.PP
Referenced by antlr3BitsetList().
.SS "static int antlr3EnumNext (\fBpANTLR3_HASH_ENUM\fP en, \fBpANTLR3_HASH_KEY\fP * key, void ** data)\fC [static]\fP"
.PP
Return the next entry in the hashtable being traversed by the supplied enumeration. 
.PP
\fBParameters:\fP
.RS 4
\fIen\fP Pointer to the enumeration tracking structure 
.br
\fIkey\fP Pointer to void pointer, where the key pointer is returned. 
.br
\fIdata\fP Pointer to void pointer where the data pointer is returned. 
.RE
.PP
\fBReturns:\fP
.RS 4
.IP "\(bu" 2
ANTLR3_SUCCESS if there was a next key
.IP "\(bu" 2
ANTLR3_FAIL if there were no more keys
.PP
.RE
.PP
\fBRemarks:\fP
.RS 4
No checking of input structure is performed! 
.RE
.PP

.PP
References ANTLR3_FAIL, ANTLR3_SUCCESS, antlr3EnumNextEntry(), ANTLR3_HASH_ENUM_struct::bucket, ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_ENUM_struct::entry, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, and ANTLR3_HASH_ENUM_struct::table.
.PP
Referenced by antlr3EnumNew().
.SS "static void antlr3EnumNextEntry (\fBpANTLR3_HASH_ENUM\fP en)\fC [static]\fP"
.PP
Local function to advance the entry pointer of an enumeration structure to the next valid entry (if there is one). 
.PP
\fBParameters:\fP
.RS 4
\fIenum\fP Pointer to ANTLR3 enumeration structure returned by \fBantlr3EnumNew()\fP
.RE
.PP
\fBRemarks:\fP
.RS 4
.IP "\(bu" 2
The function always leaves the pointers pointing at a valid entry if there is one, so if the entry pointer is NULL when this function exits, there were no more entries in the table. 
.PP
.RE
.PP

.PP
References ANTLR3_HASH_ENUM_struct::bucket, ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_ENUM_struct::entry, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_ENTRY_struct::nextEntry, and ANTLR3_HASH_ENUM_struct::table.
.PP
Referenced by antlr3EnumNew(), and antlr3EnumNext().
.SS "ANTLR3_API \fBANTLR3_UINT32\fP antlr3Hash (void * key, \fBANTLR3_UINT32\fP keylen)"
.PP
Given an input key of arbitrary length, return a hash value of it. 
.PP
This can then be used (with suitable modulo) to index other structures. 
.PP
Referenced by antlr3HashGet(), antlr3HashPut(), and antlr3HashRemove().
.SS "static void antlr3HashDelete (\fBpANTLR3_HASH_TABLE\fP table, void * key)\fC [static]\fP"
.PP
Takes the element with the supplied key out of the list, and deletes the data calling the supplied free() routine if any. 
.PP
References ANTLR3_FREE, antlr3HashRemove(), and ANTLR3_HASH_ENTRY_struct::data.
.PP
Referenced by antlr3HashTableNew().
.SS "static void antlr3HashDeleteI (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
Takes the element with the supplied key out of the list, and deletes the data calling the supplied free() routine if any. 
.PP
References ANTLR3_FREE, antlr3HashRemoveI(), and ANTLR3_HASH_ENTRY_struct::data.
.PP
Referenced by antlr3HashTableNew().
.SS "static void antlr3HashFree (\fBpANTLR3_HASH_TABLE\fP table)\fC [static]\fP"
.PP
References ANTLR3_FREE, ANTLR3_HASH_TYPE_STR, ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_ENTRY_struct::nextEntry, ANTLR3_HASH_KEY_struct::sKey, and ANTLR3_HASH_KEY_struct::type.
.PP
Referenced by antlr3HashTableNew().
.SS "static void * antlr3HashGet (\fBpANTLR3_HASH_TABLE\fP table, void * key)\fC [static]\fP"
.PP
Return the element pointer in the hash table for a particular key value, or NULL if it don't exist (or was itself NULL). 
.PP
References antlr3Hash(), ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_ENTRY_struct::nextEntry, and ANTLR3_HASH_KEY_struct::sKey.
.PP
Referenced by antlr3HashTableNew().
.SS "static void * antlr3HashGetI (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
Return the element pointer in the hash table for a particular key value, or NULL if it don't exist (or was itself NULL). 
.PP
References ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::iKey, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, and ANTLR3_HASH_ENTRY_struct::nextEntry.
.PP
Referenced by antlr3HashTableNew().
.SS "static \fBANTLR3_INT32\fP antlr3HashPut (\fBpANTLR3_HASH_TABLE\fP table, void * key, void * element, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
Add the element pointer in to the table, based upon the hash of the provided key. 
.PP
References ANTLR3_HASH_TABLE_struct::allowDups, ANTLR3_ERR_HASHDUP, ANTLR3_ERR_NOMEM, ANTLR3_FALSE, ANTLR3_HASH_TYPE_STR, ANTLR3_MALLOC, ANTLR3_STRDUP, ANTLR3_SUCCESS, ANTLR3_TRUE, antlr3Hash(), ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_TABLE_struct::count, ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_TABLE_struct::doStrdup, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_ENTRY_struct::nextEntry, ANTLR3_HASH_KEY_struct::sKey, and ANTLR3_HASH_KEY_struct::type.
.PP
Referenced by antlr3HashTableNew().
.SS "static \fBANTLR3_INT32\fP antlr3HashPutI (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key, void * element, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
Add the element pointer in to the table, based upon the hash of the provided key. 
.PP
References ANTLR3_HASH_TABLE_struct::allowDups, ANTLR3_ERR_HASHDUP, ANTLR3_ERR_NOMEM, ANTLR3_FALSE, ANTLR3_HASH_TYPE_INT, ANTLR3_MALLOC, ANTLR3_SUCCESS, ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_TABLE_struct::count, ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::iKey, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_ENTRY_struct::nextEntry, and ANTLR3_HASH_KEY_struct::type.
.PP
Referenced by antlr3HashTableNew().
.SS "static \fBpANTLR3_HASH_ENTRY\fP antlr3HashRemove (\fBpANTLR3_HASH_TABLE\fP table, void * key)\fC [static]\fP"
.PP
Remove the element in the hash table for a particular key value, if it exists - no error if it does not. 
.PP
References ANTLR3_FREE, ANTLR3_TRUE, antlr3Hash(), ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_TABLE_struct::count, ANTLR3_HASH_TABLE_struct::doStrdup, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_ENTRY_struct::nextEntry, and ANTLR3_HASH_KEY_struct::sKey.
.PP
Referenced by antlr3HashDelete(), and antlr3HashTableNew().
.SS "static \fBpANTLR3_HASH_ENTRY\fP antlr3HashRemoveI (\fBpANTLR3_HASH_TABLE\fP table, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
Remove a numeric keyed entry from a hash table if it exists, no error if it does not exist. 
.PP
References ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_TABLE_struct::count, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_KEY_struct::iKey, ANTLR3_HASH_KEY_struct::key, ANTLR3_HASH_ENTRY_struct::keybase, ANTLR3_HASH_TABLE_struct::modulo, and ANTLR3_HASH_ENTRY_struct::nextEntry.
.PP
Referenced by antlr3HashDeleteI(), and antlr3HashTableNew().
.SS "static \fBANTLR3_UINT32\fP antlr3HashSize (\fBpANTLR3_HASH_TABLE\fP table)\fC [static]\fP"
.PP
return the current size of the hash table 
.PP
References ANTLR3_HASH_TABLE_struct::count.
.PP
Referenced by antlr3HashTableNew().
.SS "\fBpANTLR3_HASH_TABLE\fP antlr3HashTableNew (\fBANTLR3_UINT32\fP sizeHint)"
.PP
References ANTLR3_HASH_TABLE_struct::allowDups, ANTLR3_FALSE, ANTLR3_FREE, ANTLR3_MALLOC, ANTLR3_TRUE, antlr3HashDelete(), antlr3HashDeleteI(), antlr3HashFree(), antlr3HashGet(), antlr3HashGetI(), antlr3HashPut(), antlr3HashPutI(), antlr3HashRemove(), antlr3HashRemoveI(), antlr3HashSize(), ANTLR3_HASH_TABLE_struct::buckets, ANTLR3_HASH_TABLE_struct::count, ANTLR3_HASH_TABLE_struct::del, ANTLR3_HASH_TABLE_struct::delI, ANTLR3_HASH_TABLE_struct::doStrdup, ANTLR3_HASH_BUCKET_struct::entries, ANTLR3_HASH_TABLE_struct::free, ANTLR3_HASH_TABLE_struct::get, ANTLR3_HASH_TABLE_struct::getI, ANTLR3_HASH_TABLE_struct::modulo, ANTLR3_HASH_TABLE_struct::put, ANTLR3_HASH_TABLE_struct::putI, ANTLR3_HASH_TABLE_struct::remove, ANTLR3_HASH_TABLE_struct::removeI, and ANTLR3_HASH_TABLE_struct::size.
.PP
Referenced by antlr3ListNew().
.SS "\fBpANTLR3_INT_TRIE\fP antlr3IntTrieNew (\fBANTLR3_UINT32\fP depth)"
.PP
References ANTLR3_INT_TRIE_struct::add, ANTLR3_CALLOC, ANTLR3_ERR_NOMEM, ANTLR3_FREE, ANTLR3_FUNC_PTR, ANTLR3_INT_TRIE_NODE_struct::bitNum, ANTLR3_INT_TRIE_struct::count, ANTLR3_INT_TRIE_struct::del, ANTLR3_INT_TRIE_struct::free, ANTLR3_INT_TRIE_struct::get, intTrieAdd(), intTrieDel(), intTrieFree(), intTrieGet(), ANTLR3_INT_TRIE_NODE_struct::leftN, ANTLR3_INT_TRIE_NODE_struct::rightN, and ANTLR3_INT_TRIE_struct::root.
.PP
Referenced by getRuleMemoization(), and reset().
.SS "static \fBANTLR3_INT32\fP antlr3ListAdd (\fBpANTLR3_LIST\fP list, void * element, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
Add the supplied element to the list, at the next available key. 
.PP
References ANTLR3_LIST_struct::put, ANTLR3_HASH_TABLE_struct::size, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "static void antlr3ListDelete (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
References ANTLR3_HASH_TABLE_struct::delI, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "static void antlr3ListFree (\fBpANTLR3_LIST\fP list)\fC [static]\fP"
.PP
References ANTLR3_FREE, ANTLR3_HASH_TABLE_struct::free, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "static void * antlr3ListGet (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
References ANTLR3_HASH_TABLE_struct::getI, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "ANTLR3_API \fBpANTLR3_LIST\fP antlr3ListNew (\fBANTLR3_UINT32\fP sizeHint)"
.PP
References ANTLR3_LIST_struct::add, ANTLR3_ERR_NOMEM, ANTLR3_FUNC_PTR, ANTLR3_MALLOC, antlr3HashTableNew(), antlr3ListAdd(), antlr3ListDelete(), antlr3ListFree(), antlr3ListGet(), antlr3ListPut(), antlr3ListRemove(), antlr3ListSize(), ANTLR3_LIST_struct::del, ANTLR3_LIST_struct::free, ANTLR3_LIST_struct::get, ANTLR3_LIST_struct::put, ANTLR3_LIST_struct::remove, ANTLR3_LIST_struct::size, and ANTLR3_LIST_struct::table.
.PP
Referenced by discardTokenType(), getTokensSet(), and setTokenTypeChannel().
.SS "static \fBANTLR3_INT32\fP antlr3ListPut (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key, void * element, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
References ANTLR3_HASH_TABLE_struct::putI, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "static void * antlr3ListRemove (\fBpANTLR3_LIST\fP list, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
Remove from the list, but don't free the element, just send it back to the caller. 
.PP
References ANTLR3_HASH_ENTRY_struct::data, ANTLR3_HASH_TABLE_struct::removeI, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "static \fBANTLR3_UINT32\fP antlr3ListSize (\fBpANTLR3_LIST\fP list)\fC [static]\fP"
.PP
References ANTLR3_HASH_TABLE_struct::size, and ANTLR3_LIST_struct::table.
.PP
Referenced by antlr3ListNew().
.SS "ANTLR3_API void antlr3SetVectorApi (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP sizeHint)"
.PP
References ANTLR3_VECTOR_struct::add, ANTLR3_FALSE, ANTLR3_FREE, ANTLR3_MALLOC, ANTLR3_VECTOR_INTERNAL_SIZE, antlr3VectorAdd(), antlr3VectorClear(), antlr3VectorDel(), antlr3VectorFree(), antlr3VectorGet(), antlr3VectorSet(), antlr3VectorSize(), antlr3VectorSwap(), antrl3VectorRemove(), ANTLR3_VECTOR_struct::clear, ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_struct::del, ANTLR3_VECTOR_struct::elements, ANTLR3_VECTOR_struct::elementsSize, ANTLR3_VECTOR_struct::factoryMade, ANTLR3_VECTOR_struct::get, ANTLR3_VECTOR_struct::internal, ANTLR3_VECTOR_struct::remove, ANTLR3_VECTOR_struct::set, ANTLR3_VECTOR_struct::size, and ANTLR3_VECTOR_struct::swap.
.PP
Referenced by antlr3VectorFactoryNew(), antlr3VectorNew(), and newVector().
.SS "static void antlr3StackFree (\fBpANTLR3_STACK\fP stack)\fC [static]\fP"
.PP
References ANTLR3_FREE, ANTLR3_STACK_struct::top, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3StackNew().
.SS "static void * antlr3StackGet (\fBpANTLR3_STACK\fP stack, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::get, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3StackNew().
.SS "ANTLR3_API \fBpANTLR3_STACK\fP antlr3StackNew (\fBANTLR3_UINT32\fP sizeHint)"
.PP
References ANTLR3_ERR_NOMEM, ANTLR3_FUNC_PTR, ANTLR3_MALLOC, antlr3StackFree(), antlr3StackGet(), antlr3StackPeek(), antlr3StackPop(), antlr3StackPush(), antlr3StackSize(), antlr3VectorNew(), ANTLR3_STACK_struct::free, ANTLR3_STACK_struct::get, ANTLR3_STACK_struct::peek, ANTLR3_STACK_struct::pop, ANTLR3_STACK_struct::push, ANTLR3_STACK_struct::size, ANTLR3_STACK_struct::top, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3ArboretumNew(), antlr3CommonTreeNodeStreamNew(), antlr3VectorFactoryNew(), pushCharStream(), and reset().
.SS "static void * antlr3StackPeek (\fBpANTLR3_STACK\fP stack)\fC [static]\fP"
.PP
References ANTLR3_STACK_struct::top.
.PP
Referenced by antlr3StackNew().
.SS "static void * antlr3StackPop (\fBpANTLR3_STACK\fP stack)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_struct::del, ANTLR3_VECTOR_struct::get, ANTLR3_STACK_struct::top, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3StackNew().
.SS "static \fBANTLR3_BOOLEAN\fP antlr3StackPush (\fBpANTLR3_STACK\fP stack, void * element, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::add, ANTLR3_STACK_struct::top, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3StackNew().
.SS "static \fBANTLR3_UINT32\fP antlr3StackSize (\fBpANTLR3_STACK\fP stack)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::count, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3StackNew().
.SS "ANTLR3_API \fBpANTLR3_TOPO\fP antlr3TopoNew ()"
.PP
Allocate and initialize a new ANTLR3 topological sorter, which can be used to define edges that identify numerical node indexes that depend on other numerical node indexes, which can then be sorted topologically such that any node is sorted after all its dependent nodes. 
.PP
Use:
.PP
/verbatim
.PP
pANTLR3_TOPO topo; topo = antlr3NewTopo();
.PP
if (topo == NULL) { out of memory }
.PP
topo->addEdge(topo, 3, 0); // Node 3 depends on node 0 topo->addEdge(topo, 0, 1); // Node - depends on node 1 topo->sortVector(topo, myVector); // Sort the vector in place (node numbers are the vector entry numbers)
.PP
/verbatim 
.PP
References addEdge(), ANTLR3_TOPO_struct::addEdge, ANTLR3_FALSE, ANTLR3_MALLOC, ANTLR3_TOPO_struct::cycle, ANTLR3_TOPO_struct::cycleMark, ANTLR3_TOPO_struct::edges, ANTLR3_TOPO_struct::free, freeTopo(), ANTLR3_TOPO_struct::hasCycle, ANTLR3_TOPO_struct::limit, ANTLR3_TOPO_struct::sorted, sortToArray(), ANTLR3_TOPO_struct::sortToArray, sortVector(), ANTLR3_TOPO_struct::sortVector, and ANTLR3_TOPO_struct::visited.
.SS "static \fBANTLR3_UINT32\fP antlr3VectorAdd (\fBpANTLR3_VECTOR\fP vector, void * element, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
Add the supplied pointer and freeing function pointer to the list, expanding the vector if needed. 
.PP
References antlr3VectorResize(), ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_ELEMENT_struct::element, ANTLR3_VECTOR_struct::elements, and ANTLR3_VECTOR_struct::elementsSize.
.PP
Referenced by antlr3SetVectorApi().
.SS "static void antlr3VectorClear (\fBpANTLR3_VECTOR\fP vector)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_ELEMENT_struct::element, and ANTLR3_VECTOR_struct::elements.
.PP
Referenced by antlr3SetVectorApi().
.SS "static void antlr3VectorDel (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry)\fC [static]\fP"
.PP
References ANTLR3_MEMMOVE, ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_ELEMENT_struct::element, and ANTLR3_VECTOR_struct::elements.
.PP
Referenced by antlr3SetVectorApi().
.SS "ANTLR3_API \fBpANTLR3_VECTOR_FACTORY\fP antlr3VectorFactoryNew (\fBANTLR3_UINT32\fP sizeHint)"
.PP
Vector factory creation. 
.PP
References ANTLR3_MALLOC, ANTLR3_TRUE, ANTLR3_VECTOR_INTERNAL_SIZE, antlr3SetVectorApi(), antlr3StackNew(), ANTLR3_VECTOR_FACTORY_struct::close, closeVectorFactory(), ANTLR3_VECTOR_struct::factoryMade, ANTLR3_VECTOR_FACTORY_struct::freeStack, newPool(), newVector(), ANTLR3_VECTOR_FACTORY_struct::newVector, ANTLR3_VECTOR_FACTORY_struct::pools, returnVector(), ANTLR3_VECTOR_FACTORY_struct::returnVector, ANTLR3_VECTOR_FACTORY_struct::thisPool, and ANTLR3_VECTOR_FACTORY_struct::unTruc.
.PP
Referenced by antlr3ArboretumNew().
.SS "static void ANTLR3_CDECL antlr3VectorFree (\fBpANTLR3_VECTOR\fP vector)\fC [static]\fP"
.PP
References ANTLR3_FALSE, ANTLR3_FREE, ANTLR3_VECTOR_INTERNAL_SIZE, ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_ELEMENT_struct::element, ANTLR3_VECTOR_struct::elements, ANTLR3_VECTOR_struct::elementsSize, and ANTLR3_VECTOR_struct::factoryMade.
.PP
Referenced by antlr3SetVectorApi().
.SS "static void * antlr3VectorGet (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_ELEMENT_struct::element, and ANTLR3_VECTOR_struct::elements.
.PP
Referenced by antlr3SetVectorApi().
.SS "ANTLR3_API \fBpANTLR3_VECTOR\fP antlr3VectorNew (\fBANTLR3_UINT32\fP sizeHint)"
.PP
References ANTLR3_ERR_NOMEM, ANTLR3_FUNC_PTR, ANTLR3_MALLOC, and antlr3SetVectorApi().
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3CommonTokenStreamNew(), antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), antlr3InputReset(), antlr3StackNew(), antlr3StringFactoryNew(), replaceChildren(), and reset().
.SS "static void antlr3VectorResize (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP hint)\fC [static]\fP"
.PP
References ANTLR3_MALLOC, ANTLR3_MEMCPY, ANTLR3_REALLOC, ANTLR3_VECTOR_INTERNAL_SIZE, ANTLR3_VECTOR_struct::elements, ANTLR3_VECTOR_struct::elementsSize, and ANTLR3_VECTOR_struct::internal.
.PP
Referenced by antlr3VectorAdd(), and antlr3VectorSet().
.SS "static \fBANTLR3_UINT32\fP antlr3VectorSet (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry, void * element, void(ANTLR3_CDECL *freeptr)(void *), \fBANTLR3_BOOLEAN\fP freeExisting)\fC [static]\fP"
.PP
Replace the element at the specified entry point with the supplied entry. 
.PP
References antlr3VectorResize(), ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_ELEMENT_struct::element, ANTLR3_VECTOR_struct::elements, and ANTLR3_VECTOR_struct::elementsSize.
.PP
Referenced by antlr3SetVectorApi().
.SS "static \fBANTLR3_UINT32\fP antlr3VectorSize (\fBpANTLR3_VECTOR\fP vector)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::count.
.PP
Referenced by antlr3SetVectorApi().
.SS "static \fBANTLR3_BOOLEAN\fP antlr3VectorSwap (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry1, \fBANTLR3_UINT32\fP entry2)\fC [static]\fP"
.PP
Replace the element at the specified entry point with the supplied entry. 
.PP
References ANTLR3_CDECL, ANTLR3_FALSE, ANTLR3_TRUE, ANTLR3_VECTOR_ELEMENT_struct::element, ANTLR3_VECTOR_struct::elements, and ANTLR3_VECTOR_struct::elementsSize.
.PP
Referenced by antlr3SetVectorApi().
.SS "static void * antrl3VectorRemove (\fBpANTLR3_VECTOR\fP vector, \fBANTLR3_UINT32\fP entry)\fC [static]\fP"
.PP
Remove the entry from the vector, but do not free any entry, even if it has a free pointer. 
.PP
References ANTLR3_MEMMOVE, ANTLR3_VECTOR_struct::count, ANTLR3_VECTOR_ELEMENT_struct::element, and ANTLR3_VECTOR_struct::elements.
.PP
Referenced by antlr3SetVectorApi().
.SS "static void closeVectorFactory (\fBpANTLR3_VECTOR_FACTORY\fP factory)\fC [static]\fP"
.PP
References ANTLR3_FACTORY_VPOOL_SIZE, ANTLR3_FREE, ANTLR3_TRUE, ANTLR3_VECTOR_INTERNAL_SIZE, ANTLR3_VECTOR_struct::elements, ANTLR3_VECTOR_struct::elementsSize, ANTLR3_VECTOR_struct::factoryMade, ANTLR3_STACK_struct::free, ANTLR3_VECTOR_FACTORY_struct::freeStack, ANTLR3_VECTOR_FACTORY_struct::nextVector, ANTLR3_VECTOR_FACTORY_struct::pools, and ANTLR3_VECTOR_FACTORY_struct::thisPool.
.PP
Referenced by antlr3VectorFactoryNew().
.SS "static void DFS (\fBpANTLR3_TOPO\fP topo, \fBANTLR3_UINT32\fP node)\fC [static]\fP"
.PP
Given a starting node, descend its dependent nodes (ones that it has edges to) until we find one without edges. 
.PP
Having found a node without edges, we have discovered the bottom of a depth first search, which we can then ascend, adding the nodes in order from the bottom, which gives us the dependency order. 
.PP
References ANTLR3_BITSET_struct::add, ANTLR3_FALSE, ANTLR3_TRUE, ANTLR3_TOPO_struct::cycle, ANTLR3_TOPO_struct::cycleMark, ANTLR3_TOPO_struct::edges, ANTLR3_TOPO_struct::hasCycle, ANTLR3_BITSET_struct::isMember, ANTLR3_TOPO_struct::limit, ANTLR3_BITSET_struct::numBits, ANTLR3_BITSET_struct::size, ANTLR3_TOPO_struct::sorted, and ANTLR3_TOPO_struct::visited.
.PP
Referenced by sortToArray().
.SS "static void freeIntNode (\fBpANTLR3_INT_TRIE_NODE\fP node)\fC [static]\fP"
.PP
Release memory allocated to this tree. 
.PP
Basic algorithm is that we do a depth first left descent and free up any nodes that are not backward pointers. 
.PP
References ANTLR3_FREE, ANTLR3_HASH_TYPE_STR, ANTLR3_INT_TRIE_NODE_struct::bitNum, ANTLR3_INT_TRIE_NODE_struct::buckets, ANTLR3_TRIE_ENTRY_struct::data, ANTLR3_INT_TRIE_NODE_struct::leftN, ANTLR3_TRIE_ENTRY_struct::next, ANTLR3_TRIE_ENTRY_struct::ptr, ANTLR3_INT_TRIE_NODE_struct::rightN, and ANTLR3_TRIE_ENTRY_struct::type.
.PP
Referenced by intTrieFree().
.SS "static void freeTopo (\fBpANTLR3_TOPO\fP topo)\fC [static]\fP"
.PP
References ANTLR3_FREE, ANTLR3_TOPO_struct::cycle, ANTLR3_TOPO_struct::edges, ANTLR3_BITSET_struct::free, ANTLR3_TOPO_struct::limit, ANTLR3_TOPO_struct::sorted, and ANTLR3_TOPO_struct::visited.
.PP
Referenced by antlr3TopoNew().
.SS "static \fBANTLR3_BOOLEAN\fP intTrieAdd (\fBpANTLR3_INT_TRIE\fP trie, \fBANTLR3_INTKEY\fP key, \fBANTLR3_UINT32\fP type, \fBANTLR3_INTKEY\fP intVal, void * data, void(ANTLR3_CDECL *freeptr)(void *))\fC [static]\fP"
.PP
Add an entry into the INT trie. 
.PP
Basically we descend the trie as we do when searching it, which will locate the only node in the trie that can be reached by the bit pattern of the key. If the key is actually at that node, then if the trie accepts duplicates we add the supplied data in a new chained bucket to that data node. If it does not accept duplicates then we merely return FALSE in case the caller wants to know whether the key was already in the trie. If the node we locate is not the key we are looking to add, then we insert a new node into the trie with a bit index of the leftmost differing bit and the left or right node pointing to itself or the data node we are inserting 'before'. 
.PP
References ANTLR3_INT_TRIE_struct::allowDups, ANTLR3_CALLOC, ANTLR3_FALSE, ANTLR3_HASH_TYPE_STR, ANTLR3_TRUE, ANTLR3_INT_TRIE_NODE_struct::bitNum, ANTLR3_INT_TRIE_NODE_struct::buckets, ANTLR3_INT_TRIE_struct::count, ANTLR3_TRIE_ENTRY_struct::data, ANTLR3_TRIE_ENTRY_struct::intVal, ANTLR3_INT_TRIE_NODE_struct::key, ANTLR3_INT_TRIE_NODE_struct::leftN, ANTLR3_TRIE_ENTRY_struct::next, nextNode(), ANTLR3_TRIE_ENTRY_struct::ptr, ANTLR3_INT_TRIE_NODE_struct::rightN, ANTLR3_INT_TRIE_struct::root, and ANTLR3_TRIE_ENTRY_struct::type.
.PP
Referenced by antlr3IntTrieNew().
.SS "static \fBANTLR3_BOOLEAN\fP intTrieDel (\fBpANTLR3_INT_TRIE\fP trie, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
References ANTLR3_FALSE, and ANTLR3_INT_TRIE_struct::root.
.PP
Referenced by antlr3IntTrieNew().
.SS "static void intTrieFree (\fBpANTLR3_INT_TRIE\fP trie)\fC [static]\fP"
.PP
Called to free all nodes and the structure itself. 
.PP
References ANTLR3_FREE, freeIntNode(), and ANTLR3_INT_TRIE_struct::root.
.PP
Referenced by antlr3IntTrieNew().
.SS "static \fBpANTLR3_TRIE_ENTRY\fP intTrieGet (\fBpANTLR3_INT_TRIE\fP trie, \fBANTLR3_INTKEY\fP key)\fC [static]\fP"
.PP
Search the int Trie and return a pointer to the first bucket indexed by the key if it is contained in the trie, otherwise NULL. 
.PP
References ANTLR3_INT_TRIE_NODE_struct::bitNum, ANTLR3_INT_TRIE_NODE_struct::buckets, ANTLR3_INT_TRIE_struct::count, ANTLR3_INT_TRIE_NODE_struct::key, ANTLR3_INT_TRIE_NODE_struct::leftN, nextNode(), ANTLR3_INT_TRIE_NODE_struct::rightN, and ANTLR3_INT_TRIE_struct::root.
.PP
Referenced by antlr3IntTrieNew().
.SS "static void newPool (\fBpANTLR3_VECTOR_FACTORY\fP factory)\fC [static]\fP"
.PP
References ANTLR3_FACTORY_VPOOL_SIZE, ANTLR3_MALLOC, ANTLR3_REALLOC, ANTLR3_VECTOR_FACTORY_struct::nextVector, ANTLR3_VECTOR_FACTORY_struct::pools, and ANTLR3_VECTOR_FACTORY_struct::thisPool.
.PP
Referenced by antlr3ArboretumNew(), antlr3TokenFactoryNew(), antlr3VectorFactoryNew(), factoryReset(), newPoolToken(), newPoolTree(), and newVector().
.SS "static \fBpANTLR3_VECTOR\fP newVector (\fBpANTLR3_VECTOR_FACTORY\fP factory)\fC [static]\fP"
.PP
References ANTLR3_FACTORY_VPOOL_SIZE, ANTLR3_TRUE, ANTLR3_VECTOR_INTERNAL_SIZE, antlr3SetVectorApi(), ANTLR3_VECTOR_struct::elements, ANTLR3_VECTOR_struct::factoryMade, ANTLR3_VECTOR_FACTORY_struct::freeStack, ANTLR3_VECTOR_struct::internal, newPool(), ANTLR3_VECTOR_FACTORY_struct::nextVector, ANTLR3_STACK_struct::peek, ANTLR3_VECTOR_FACTORY_struct::pools, ANTLR3_STACK_struct::pop, and ANTLR3_VECTOR_FACTORY_struct::thisPool.
.PP
Referenced by antlr3VectorFactoryNew().
.SS "static void returnVector (\fBpANTLR3_VECTOR_FACTORY\fP factory, \fBpANTLR3_VECTOR\fP vector)\fC [static]\fP"
.PP
References ANTLR3_VECTOR_struct::clear, ANTLR3_VECTOR_FACTORY_struct::freeStack, and ANTLR3_STACK_struct::push.
.PP
Referenced by antlr3VectorFactoryNew().
.SS "static \fBpANTLR3_UINT32\fP sortToArray (\fBpANTLR3_TOPO\fP topo)\fC [static]\fP"
.PP
References ANTLR3_FALSE, ANTLR3_MALLOC, ANTLR3_TRUE, antlr3BitsetNew(), ANTLR3_TOPO_struct::cycle, DFS(), ANTLR3_TOPO_struct::edges, ANTLR3_TOPO_struct::hasCycle, ANTLR3_BITSET_struct::isMember, ANTLR3_TOPO_struct::limit, ANTLR3_TOPO_struct::sorted, and ANTLR3_TOPO_struct::visited.
.PP
Referenced by antlr3TopoNew().
.SS "static void sortVector (\fBpANTLR3_TOPO\fP topo, \fBpANTLR3_VECTOR\fP v)\fC [static]\fP"
.PP
References ANTLR3_FREE, ANTLR3_MALLOC, ANTLR3_TRUE, ANTLR3_VECTOR_struct::count, ANTLR3_TOPO_struct::hasCycle, ANTLR3_TOPO_struct::limit, ANTLR3_TOPO_struct::sorted, ANTLR3_TOPO_struct::sortToArray, and ANTLR3_VECTOR_struct::swap.
.PP
Referenced by antlr3TopoNew().
.SH "Variable Documentation"
.PP 
.SS "\fBANTLR3_UINT8\fP \fBbitIndex\fP[256]\fC [static]\fP"
.PP
\fBInitial value:\fP
.PP
.nf
 
{ 
    0,                                                  
    0,                                                  
    1, 1,                                               
    2, 2, 2, 2,                                         
    3, 3, 3, 3, 3, 3, 3, 3,                             
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,     
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,     
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,     
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
}
.fi
Array of left most significant bit positions for an 8 bit element provides an efficient way to find the highest bit that is set in an n byte value (n>0). 
.PP
Assuming the values will all hit the data cache, coding without conditional elements should allow branch prediction to work well and of course a parallel instruction cache will whip through this. Otherwise we must loop shifting a one bit and masking. The values we tend to be placing in out integer patricia trie are usually a lot lower than the 64 bits we allow for the key allows. Hence there is a lot of redundant looping and shifting in a while loop. Whereas, the lookup table is just a few ands and indirect lookups, while testing for 0. This is likely to be done in parallel on many processors available when I wrote this. If this code survives as long as yacc, then I may already be dead by the time you read this and maybe there is a single machine instruction to perform the operation. What else are you going to do with all those transistors? Jim 2007
.PP
The table is probably obvious but it is just the number 0..7 of the MSB in each integer value 0..256 
.SS "\fBANTLR3_UINT64\fP bitMask[64]\fC [static]\fP"
.PP
\fBInitial value:\fP
.PP
.nf
 
{
    0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL,
    0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL,
    0x0000000000000100ULL, 0x0000000000000200ULL, 0x0000000000000400ULL, 0x0000000000000800ULL,
    0x0000000000001000ULL, 0x0000000000002000ULL, 0x0000000000004000ULL, 0x0000000000008000ULL,
    0x0000000000010000ULL, 0x0000000000020000ULL, 0x0000000000040000ULL, 0x0000000000080000ULL,
    0x0000000000100000ULL, 0x0000000000200000ULL, 0x0000000000400000ULL, 0x0000000000800000ULL,
    0x0000000001000000ULL, 0x0000000002000000ULL, 0x0000000004000000ULL, 0x0000000008000000ULL,
    0x0000000010000000ULL, 0x0000000020000000ULL, 0x0000000040000000ULL, 0x0000000080000000ULL,
    0x0000000100000000ULL, 0x0000000200000000ULL, 0x0000000400000000ULL, 0x0000000800000000ULL,
    0x0000001000000000ULL, 0x0000002000000000ULL, 0x0000004000000000ULL, 0x0000008000000000ULL,
    0x0000010000000000ULL, 0x0000020000000000ULL, 0x0000040000000000ULL, 0x0000080000000000ULL,
    0x0000100000000000ULL, 0x0000200000000000ULL, 0x0000400000000000ULL, 0x0000800000000000ULL,
    0x0001000000000000ULL, 0x0002000000000000ULL, 0x0004000000000000ULL, 0x0008000000000000ULL,
    0x0010000000000000ULL, 0x0020000000000000ULL, 0x0040000000000000ULL, 0x0080000000000000ULL,
    0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL,
    0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL
}
.fi
Rather than use the bit index of a trie node to shift 0x01 left that many times, then & with the result, it is faster to use the bit index as an index into this table which holds precomputed masks for any of the 64 bits we need to mask off singly. 
.PP
The data values will stay in cache while ever a trie is in heavy use, such as in memoization. It is also pretty enough to be ASCII art. 
.PP
Referenced by antlr3BitsetAdd(), antlr3BitsetMember(), and antlr3BitsetRemove().
.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
