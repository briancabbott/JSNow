.TH "ANTLR3_COMMON_TREE_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_COMMON_TREE_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3commontree.h>\fP
.PP
.SH "Detailed Description"
.PP 
Interface for an ANTLR3 common tree which is what gets passed around by the AST producing parser. 
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBANTLR3_BASE_TREE\fP \fBbaseTree\fP"
.br
.RI "\fIAn encapsulated BASE TREE structure (NOT a pointer) that performs a lot of the dirty work of node management To this we add just a few functions that are specific to the payload. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBchildIndex\fP"
.br
.RI "\fIWhat index is this particular node in the child list it belongs to? \fP"
.ti -1c
.RI "\fBpANTLR3_ARBORETUM\fP \fBfactory\fP"
.br
.RI "\fIPointer to the tree factory that manufactured this token. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TREE\fP \fBparent\fP"
.br
.RI "\fIPoints to the node that has this node as a child. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBstartIndex\fP"
.br
.RI "\fIStart token index that encases this tree. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBstopIndex\fP"
.br
.RI "\fIEnd token that encases this tree. \fP"
.ti -1c
.RI "void * \fBsuper\fP"
.br
.RI "\fINot used by ANTLR, but if a super structure is created above this structure, it can be used to point to the start of the super structure, where additional data and function pointers can be stored. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TOKEN\fP \fBtoken\fP"
.br
.RI "\fIA single token, this is the payload for the tree. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBANTLR3_BASE_TREE\fP \fBANTLR3_COMMON_TREE_struct::baseTree\fP"
.PP
An encapsulated BASE TREE structure (NOT a pointer) that performs a lot of the dirty work of node management To this we add just a few functions that are specific to the payload. 
.PP
You can further abstract common tree so long as you always have a baseTree pointer in the top structure and copy it from the next one down. So, lets say we have a structure JIMS_TREE. It needs an ANTLR3_BASE_TREE that will support all the general tree duplication stuff. It needs a ANTLR3_COMMON_TREE structure embedded or completely provides the equivalent interface. It provides it's own methods and data. To create a new one of these, the function provided to the tree adaptor (see comments there) should allocate the memory for a new JIMS_TREE structure, then call antlr3InitCommonTree(<addressofembeddedCOMMON_TREE>) antlr3BaseTreeNew(<addressofBASETREE>) The interfaces for BASE_TREE and COMMON_TREE will then be initialized. You then call and you can override them or just init JIMS_TREE (note that the base tree in common tree will be ignored) just the top level base tree is used). Codegen will take care of the rest. 
.PP
Referenced by antlr3ArboretumNew(), antlr3SetCTAPI(), getMissingSymbol(), LB(), newFromTree(), newPoolTree(), and reuse().
.SS "\fBANTLR3_INT32\fP \fBANTLR3_COMMON_TREE_struct::childIndex\fP"
.PP
What index is this particular node in the child list it belongs to? 
.PP
Referenced by antlr3SetCTAPI().
.SS "\fBpANTLR3_ARBORETUM\fP \fBANTLR3_COMMON_TREE_struct::factory\fP"
.PP
Pointer to the tree factory that manufactured this token. 
.PP
This can be used by duplication methods and so on to manufacture another auto-tracked common tree structure 
.PP
Referenced by antlr3ArboretumNew(), dupNode(), newPoolTree(), and reuse().
.SS "\fBpANTLR3_COMMON_TREE\fP \fBANTLR3_COMMON_TREE_struct::parent\fP"
.PP
Points to the node that has this node as a child. 
.PP
If this is NULL, then this is the root node. 
.PP
Referenced by antlr3SetCTAPI().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_COMMON_TREE_struct::startIndex\fP"
.PP
Start token index that encases this tree. 
.PP
Referenced by antlr3SetCTAPI(), and setTokenBoundaries().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_COMMON_TREE_struct::stopIndex\fP"
.PP
End token that encases this tree. 
.PP
Referenced by antlr3SetCTAPI(), and setTokenBoundaries().
.SS "void* \fBANTLR3_COMMON_TREE_struct::super\fP"
.PP
Not used by ANTLR, but if a super structure is created above this structure, it can be used to point to the start of the super structure, where additional data and function pointers can be stored. 
.PP
.SS "\fBpANTLR3_COMMON_TOKEN\fP \fBANTLR3_COMMON_TREE_struct::token\fP"
.PP
A single token, this is the payload for the tree. 
.PP
Referenced by antlr3CommonTreeNewFromToken(), antlr3CommonTreeNodeStreamFree(), antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), antlr3RecognitionExceptionNew(), antlr3SetCTAPI(), getLine(), getType(), and newFromTree().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
