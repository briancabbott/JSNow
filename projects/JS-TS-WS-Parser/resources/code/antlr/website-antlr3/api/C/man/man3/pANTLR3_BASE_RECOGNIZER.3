.TH "pANTLR3_BASE_RECOGNIZER Base Recognizer Implementation" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pANTLR3_BASE_RECOGNIZER Base Recognizer Implementation \- 
.SH "Detailed Description"
.PP 
The base recognizer interface is implemented by all higher level recognizers such as \fBpANTLR3_PARSER\fP and provides methods common to all recognizers. 
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBalreadyParsedRule\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_MARKER\fP ruleIndex)"
.br
.RI "\fIHas this rule already parsed input at the current index in the input stream? Return ANTLR3_TRUE if we have and ANTLR3_FALSE if we have not. \fP"
.ti -1c
.RI "ANTLR3_API \fBpANTLR3_BASE_RECOGNIZER\fP \fBantlr3BaseRecognizerNew\fP (\fBANTLR3_UINT32\fP type, \fBANTLR3_UINT32\fP sizeHint, \fBpANTLR3_RECOGNIZER_SHARED_STATE\fP state)"
.br
.ti -1c
.RI "ANTLR3_API void \fBantlr3MTExceptionNew\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fICreates a new Mismatched Token Exception and inserts in the recognizer exception stack. \fP"
.ti -1c
.RI "ANTLR3_API void \fBantlr3RecognitionExceptionNew\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.ti -1c
.RI "static void \fBbeginBacktrack\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP level)"
.br
.ti -1c
.RI "static void \fBbeginResync\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.ti -1c
.RI "static \fBpANTLR3_BITSET\fP \fBcombineFollows\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_BOOLEAN\fP exact)"
.br
.RI "\fICompute the current followset for the input stream. \fP"
.ti -1c
.RI "static \fBpANTLR3_BITSET\fP \fBcomputeCSRuleFollow\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fICompute the context-sensitive FOLLOW set for current rule. \fP"
.ti -1c
.RI "static \fBpANTLR3_BITSET\fP \fBcomputeErrorRecoverySet\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fICompute the error recovery set for the current rule. \fP"
.ti -1c
.RI "static void \fBconsumeUntil\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP tokenType)"
.br
.RI "\fIEat tokens from the input stream until we get one of JUST the right type. \fP"
.ti -1c
.RI "static void \fBconsumeUntilSet\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_BITSET\fP set)"
.br
.RI "\fIEat tokens from the input stream until we find one that belongs to the supplied set. \fP"
.ti -1c
.RI "static void \fBdisplayRecognitionError\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_UINT8\fP *tokenNames)"
.br
.RI "\fIStandard/Example error display method. \fP"
.ti -1c
.RI "static void \fBendBacktrack\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP level, \fBANTLR3_BOOLEAN\fP successful)"
.br
.ti -1c
.RI "static void \fBendResync\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.ti -1c
.RI "static void \fBfreeBR\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.ti -1c
.RI "static void ANTLR3_CDECL \fBfreeIntTrie\fP (void *trie)"
.br
.ti -1c
.RI "static void * \fBgetCurrentInputSymbol\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP istream)"
.br
.ti -1c
.RI "static void * \fBgetMissingSymbol\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP istream, \fBpANTLR3_EXCEPTION\fP e, \fBANTLR3_UINT32\fP expectedTokenType, \fBpANTLR3_BITSET_LIST\fP follow)"
.br
.ti -1c
.RI "static \fBANTLR3_UINT32\fP \fBgetNumberOfSyntaxErrors\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fIReturn how many syntax errors were detected by this recognizer. \fP"
.ti -1c
.RI "static \fBpANTLR3_STACK\fP \fBgetRuleInvocationStack\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fIReturn the rule invocation stack (how we got here in the parse. \fP"
.ti -1c
.RI "static \fBpANTLR3_STACK\fP \fBgetRuleInvocationStackNamed\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_UINT8\fP name)"
.br
.ti -1c
.RI "static \fBANTLR3_MARKER\fP \fBgetRuleMemoization\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_INTKEY\fP ruleIndex, \fBANTLR3_MARKER\fP ruleParseStart)"
.br
.RI "\fIPointer to a function to return whether the rule has parsed input starting at the supplied start index before. \fP"
.ti -1c
.RI "static void * \fBmatch\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP ttype, \fBpANTLR3_BITSET_LIST\fP follow)"
.br
.RI "\fIMatch current input symbol against ttype. \fP"
.ti -1c
.RI "static void \fBmatchAny\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fIConsumes the next token, whatever it is, and resets the recognizer state so that it is not in error. \fP"
.ti -1c
.RI "static void \fBmemoize\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_MARKER\fP ruleIndex, \fBANTLR3_MARKER\fP ruleParseStart)"
.br
.RI "\fIRecord whether or not this rule parsed the input at this position successfully. \fP"
.ti -1c
.RI "static void \fBmismatch\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP ttype, \fBpANTLR3_BITSET_LIST\fP follow)"
.br
.RI "\fIFactor out what to do upon token mismatch so tree parsers can behave differently. \fP"
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBmismatchIsMissingToken\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP is, \fBpANTLR3_BITSET_LIST\fP follow)"
.br
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBmismatchIsUnwantedToken\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP is, \fBANTLR3_UINT32\fP ttype)"
.br
.ti -1c
.RI "static void \fBrecover\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fIRecover from an error found on the input stream. \fP"
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBrecoverFromMismatchedElement\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_BITSET_LIST\fP followBits)"
.br
.RI "\fIThis code is factored out from mismatched token and mismatched set recovery. \fP"
.ti -1c
.RI "static void * \fBrecoverFromMismatchedSet\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_BITSET_LIST\fP follow)"
.br
.ti -1c
.RI "static void * \fBrecoverFromMismatchedToken\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP ttype, \fBpANTLR3_BITSET_LIST\fP follow)"
.br
.RI "\fIAttempt to recover from a single missing or extra token. \fP"
.ti -1c
.RI "static void \fBreportError\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.RI "\fIReport a recognition problem. \fP"
.ti -1c
.RI "static void \fBreset\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.br
.ti -1c
.RI "static \fBANTLR3_BOOLEAN\fP \fBsynpred\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, void *ctx, void(*predicate)(void *ctx))"
.br
.RI "\fIA syntactic predicate. \fP"
.ti -1c
.RI "static \fBpANTLR3_HASH_TABLE\fP \fBtoStrings\fP (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_HASH_TABLE\fP tokens)"
.br
.RI "\fIConvenience method for template rewrites - NYI. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "static \fBANTLR3_BOOLEAN\fP alreadyParsedRule (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_MARKER\fP ruleIndex)\fC [static]\fP"
.PP
Has this rule already parsed input at the current index in the input stream? Return ANTLR3_TRUE if we have and ANTLR3_FALSE if we have not. 
.PP
This method has a side-effect: if we have seen this input for this rule and successfully parsed before, then seek ahead to 1 past the stop token matched for this rule last time. 
.PP
References ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TRUE, ANTLR3_TYPE_LEXER, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_BASE_RECOGNIZER_struct::getRuleMemoization, ANTLR3_INT_STREAM_struct::index, ANTLR3_LEXER_struct::input, ANTLR3_INPUT_STREAM_struct::istream, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, MEMO_RULE_FAILED, MEMO_RULE_UNKNOWN, ANTLR3_INT_STREAM_struct::seek, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "ANTLR3_API \fBpANTLR3_BASE_RECOGNIZER\fP antlr3BaseRecognizerNew (\fBANTLR3_UINT32\fP type, \fBANTLR3_UINT32\fP sizeHint, \fBpANTLR3_RECOGNIZER_SHARED_STATE\fP state)"
.PP
References alreadyParsedRule(), ANTLR3_BASE_RECOGNIZER_struct::alreadyParsedRule, ANTLR3_CALLOC, ANTLR3_FALSE, ANTLR3_FREE, ANTLR3_MALLOC, antlr3MTExceptionNew(), antlr3VectorNew(), ANTLR3_RECOGNIZER_SHARED_STATE_struct::backtracking, beginBacktrack(), ANTLR3_BASE_RECOGNIZER_struct::beginBacktrack, beginResync(), ANTLR3_BASE_RECOGNIZER_struct::beginResync, combineFollows(), ANTLR3_BASE_RECOGNIZER_struct::combineFollows, computeCSRuleFollow(), ANTLR3_BASE_RECOGNIZER_struct::computeCSRuleFollow, computeErrorRecoverySet(), ANTLR3_BASE_RECOGNIZER_struct::computeErrorRecoverySet, consumeUntil(), ANTLR3_BASE_RECOGNIZER_struct::consumeUntil, consumeUntilSet(), ANTLR3_BASE_RECOGNIZER_struct::consumeUntilSet, ANTLR3_BASE_RECOGNIZER_struct::debugger, displayRecognitionError(), ANTLR3_BASE_RECOGNIZER_struct::displayRecognitionError, endBacktrack(), ANTLR3_BASE_RECOGNIZER_struct::endBacktrack, endResync(), ANTLR3_BASE_RECOGNIZER_struct::endResync, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorCount, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorRecovery, ANTLR3_BASE_RECOGNIZER_struct::exConstruct, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_RECOGNIZER_SHARED_STATE_struct::following, ANTLR3_BASE_RECOGNIZER_struct::free, freeBR(), getCurrentInputSymbol(), ANTLR3_BASE_RECOGNIZER_struct::getCurrentInputSymbol, getMissingSymbol(), ANTLR3_BASE_RECOGNIZER_struct::getMissingSymbol, getNumberOfSyntaxErrors(), ANTLR3_BASE_RECOGNIZER_struct::getNumberOfSyntaxErrors, getRuleInvocationStack(), ANTLR3_BASE_RECOGNIZER_struct::getRuleInvocationStack, getRuleInvocationStackNamed(), ANTLR3_BASE_RECOGNIZER_struct::getRuleInvocationStackNamed, getRuleMemoization(), ANTLR3_BASE_RECOGNIZER_struct::getRuleMemoization, ANTLR3_RECOGNIZER_SHARED_STATE_struct::lastErrorIndex, match(), ANTLR3_BASE_RECOGNIZER_struct::match, matchAny(), ANTLR3_BASE_RECOGNIZER_struct::matchAny, memoize(), ANTLR3_BASE_RECOGNIZER_struct::memoize, mismatch(), ANTLR3_BASE_RECOGNIZER_struct::mismatch, mismatchIsMissingToken(), ANTLR3_BASE_RECOGNIZER_struct::mismatchIsMissingToken, mismatchIsUnwantedToken(), ANTLR3_BASE_RECOGNIZER_struct::mismatchIsUnwantedToken, recover(), ANTLR3_BASE_RECOGNIZER_struct::recover, recoverFromMismatchedElement(), recoverFromMismatchedSet(), ANTLR3_BASE_RECOGNIZER_struct::recoverFromMismatchedSet, recoverFromMismatchedToken(), ANTLR3_BASE_RECOGNIZER_struct::recoverFromMismatchedToken, reportError(), ANTLR3_BASE_RECOGNIZER_struct::reportError, reset(), ANTLR3_BASE_RECOGNIZER_struct::reset, ANTLR3_RECOGNIZER_SHARED_STATE_struct::rStreams, ANTLR3_RECOGNIZER_SHARED_STATE_struct::ruleMemo, ANTLR3_RECOGNIZER_SHARED_STATE_struct::sizeHint, ANTLR3_BASE_RECOGNIZER_struct::state, synpred(), ANTLR3_BASE_RECOGNIZER_struct::synpred, ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenNames, ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokFactory, ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokSource, toStrings(), ANTLR3_BASE_RECOGNIZER_struct::toStrings, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3LexerNew(), antlr3ParserNew(), and antlr3TreeParserNewStream().
.SS "ANTLR3_API void antlr3MTExceptionNew (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.PP
Creates a new Mismatched Token Exception and inserts in the recognizer exception stack. 
.PP
\fBParameters:\fP
.RS 4
\fIrecognizer\fP Context pointer for this recognizer 
.RE
.PP

.PP
References ANTLR3_MISMATCHED_EX_NAME, ANTLR3_MISMATCHED_TOKEN_EXCEPTION, antlr3RecognitionExceptionNew(), ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_EXCEPTION_struct::name, ANTLR3_BASE_RECOGNIZER_struct::state, and ANTLR3_EXCEPTION_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3ParserNew(), and mismatch().
.SS "ANTLR3_API void antlr3RecognitionExceptionNew (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)"
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_TREE_NODE_STREAM_struct::_LT, ANTLR3_TOKEN_STREAM_struct::_LT, ANTLR3_CHARSTREAM, ANTLR3_COMMONTREENODE, ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_INPUT_MASK, ANTLR3_RECOGNITION_EX_NAME, ANTLR3_RECOGNITION_EXCEPTION, ANTLR3_TOKEN_EOF, ANTLR3_TOKENSTREAM, ANTLR3_TRUE, ANTLR3_TYPE_LEXER, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, antlr3ExceptionNew(), ANTLR3_EXCEPTION_struct::c, ANTLR3_EXCEPTION_struct::charPositionInLine, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::error, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_INPUT_STREAM_struct::fileName, getCharPositionInLine(), ANTLR3_INPUT_STREAM_struct::getCharPositionInLine, getLine(), ANTLR3_INPUT_STREAM_struct::getLine, ANTLR3_INT_STREAM_struct::index, ANTLR3_EXCEPTION_struct::index, ANTLR3_EXCEPTION_struct::input, ANTLR3_COMMON_TOKEN_struct::input, ANTLR3_LEXER_struct::input, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_INPUT_STREAM_struct::istream, ANTLR3_EXCEPTION_struct::line, ANTLR3_EXCEPTION_struct::message, ANTLR3_EXCEPTION_struct::nextException, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_EXCEPTION_struct::streamName, ANTLR3_TOKEN_STREAM_struct::super, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_COMMON_TREE_struct::token, ANTLR3_EXCEPTION_struct::token, ANTLR3_COMMON_TOKEN_STREAM_struct::tstream, ANTLR3_PARSER_struct::tstream, ANTLR3_INT_STREAM_struct::type, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3MTExceptionNew(), antlr3MTNExceptionNew(), mismatch(), recoverFromMismatchedToken(), and setCharStream().
.SS "static void beginBacktrack (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP level)\fC [static]\fP"
.PP
References ANTLR3_DEBUG_EVENT_LISTENER_struct::beginBacktrack, and ANTLR3_BASE_RECOGNIZER_struct::debugger.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3DebugListenerNew().
.SS "static void beginResync (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
References ANTLR3_DEBUG_EVENT_LISTENER_struct::beginResync, and ANTLR3_BASE_RECOGNIZER_struct::debugger.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3DebugListenerNew().
.SS "static \fBpANTLR3_BITSET\fP combineFollows (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_BOOLEAN\fP exact)\fC [static]\fP"
.PP
Compute the current followset for the input stream. 
.PP
References ANTLR3_EOR_TOKEN_TYPE, ANTLR3_FALSE, ANTLR3_TRUE, antlr3BitsetLoad(), antlr3BitsetNew(), ANTLR3_BITSET_struct::borInPlace, ANTLR3_RECOGNIZER_SHARED_STATE_struct::following, ANTLR3_BITSET_struct::free, ANTLR3_STACK_struct::get, ANTLR3_BITSET_struct::isMember, ANTLR3_BITSET_struct::remove, ANTLR3_STACK_struct::size, and ANTLR3_BASE_RECOGNIZER_struct::state.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static \fBpANTLR3_BITSET\fP computeCSRuleFollow (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Compute the context-sensitive FOLLOW set for current rule. 
.PP
Documentation below is from the Java runtime.
.PP
This is the set of token types that can follow a specific rule reference given a specific call chain. You get the set of viable tokens that can possibly come next (look ahead depth 1) given the current call chain. Contrast this with the definition of plain FOLLOW for rule r:
.PP
FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
.PP
where x in T* and alpha, beta in V*; T is set of terminals and V is the set of terminals and non terminals. In other words, FOLLOW(r) is the set of all tokens that can possibly follow references to r in///any* sentential form (context). At runtime, however, we know precisely which context applies as we have the call chain. We may compute the exact (rather than covering superset) set of following tokens.
.PP
For example, consider grammar:
.PP
stat : ID '=' expr ';' // FOLLOW(stat)=={EOF} | 'return' expr '.' ; expr : atom ('+' atom)* ; // FOLLOW(expr)=={';','.',')'} atom : INT // FOLLOW(atom)=={'+',')',';','.'} | '(' expr ')' ;
.PP
The FOLLOW sets are all inclusive whereas context-sensitive FOLLOW sets are precisely what could follow a rule reference. For input input 'i=(3);', here is the derivation:
.PP
stat => ID '=' expr ';' => ID '=' atom ('+' atom)* ';' => ID '=' '(' expr ')' ('+' atom)* ';' => ID '=' '(' atom ')' ('+' atom)* ';' => ID '=' '(' INT ')' ('+' atom)* ';' => ID '=' '(' INT ')' ';'
.PP
At the '3' token, you'd have a call chain of
.PP
stat -> expr -> atom -> expr -> atom
.PP
What can follow that specific nested ref to atom? Exactly ')' as you can see by looking at the derivation of this specific input. Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
.PP
You want the exact viable token set when recovering from a token mismatch. Upon token mismatch, if LA(1) is member of the viable next token set, then you know there is most likely a missing token in the input stream. 'Insert' one by just not throwing an exception. 
.PP
References ANTLR3_FALSE, and ANTLR3_BASE_RECOGNIZER_struct::combineFollows.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static \fBpANTLR3_BITSET\fP computeErrorRecoverySet (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Compute the error recovery set for the current rule. 
.PP
Documentation below is from the Java implementation.
.PP
During rule invocation, the parser pushes the set of tokens that can follow that rule reference on the stack; this amounts to computing FIRST of what follows the rule reference in the enclosing rule. This local follow set only includes tokens from within the rule; i.e., the FIRST computation done by ANTLR stops at the end of a rule. EXAMPLE When you find a 'no viable alt exception', the input is not consistent with any of the alternatives for rule r. The best thing to do is to consume tokens until you see something that can legally follow a call to r *or* any rule that called r. You don't want the exact set of viable next tokens because the input might just be missing a token--you might consume the rest of the input looking for one of the missing tokens.
.PP
Consider grammar:
.PP
a : '[' b ']' | '(' b ')' ; b : c '^' INT ; c : ID | INT ;
.PP
At each rule invocation, the set of tokens that could follow that rule is pushed on a stack. Here are the various 'local' follow sets:
.PP
FOLLOW(b1_in_a) = FIRST(']') = ']' FOLLOW(b2_in_a) = FIRST(')') = ')' FOLLOW(c_in_b) = FIRST('^') = '^'
.PP
Upon erroneous input '[]', the call chain is
.PP
a -> b -> c
.PP
and, hence, the follow context stack is:
.PP
depth local follow set after call to rule 0 <EOF> a (from main()) 1 ']' b 3 '^' c
.PP
Notice that ')' is not included, because b would have to have been called from a different context in rule a for ')' to be included.
.PP
For error recovery, we cannot consider FOLLOW(c) (context-sensitive or otherwise). We need the combined set of all context-sensitive FOLLOW sets--the set of all tokens that could follow any reference in the call chain. We need to resync to one of those tokens. Note that FOLLOW(c)='^' and if we resync'd to that token, we'd consume until EOF. We need to sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}. In this case, for input '[]', LA(1) is in this set so we would not consume anything and after printing an error rule c would return normally. It would not find the required '^' though. At this point, it gets a mismatched token error and throws an exception (since LA(1) is not in the viable following token set). The rule exception handler tries to recover, but finds the same recovery set and doesn't consume anything. Rule b exits normally returning to rule a. Now it finds the ']' (and with the successful match exits errorRecovery mode).
.PP
So, you can see that the parser walks up call chain looking for the token that was a member of the recovery set.
.PP
Errors are not generated in errorRecovery mode.
.PP
ANTLR's error recovery mechanism is based upon original ideas:
.PP
'Algorithms + Data Structures = Programs' by Niklaus Wirth
.PP
and
.PP
'A note on error recovery in recursive descent parsers': http://portal.acm.org/citation.cfm?id=947902.947905
.PP
Later, Josef Grosch had some good ideas:
.PP
'Efficient and Comfortable Error Recovery in Recursive Descent Parsers': ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
.PP
Like Grosch I implemented local FOLLOW sets that are combined at run-time upon error to avoid overhead during parsing. 
.PP
References ANTLR3_FALSE, and ANTLR3_BASE_RECOGNIZER_struct::combineFollows.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void consumeUntil (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP tokenType)\fC [static]\fP"
.PP
Eat tokens from the input stream until we get one of JUST the right type. 
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_FPRINTF, ANTLR3_TOKEN_EOF, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_INT_STREAM_struct::consume, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void consumeUntilSet (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_BITSET\fP set)\fC [static]\fP"
.PP
Eat tokens from the input stream until we find one that belongs to the supplied set. 
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TOKEN_EOF, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_INT_STREAM_struct::consume, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void displayRecognitionError (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_UINT8\fP * tokenNames)\fC [static]\fP"
.PP
Standard/Example error display method. 
.PP
No generic error message display funciton coudl possibly do everything correctly for all possible parsers. Hence you are provided with this example routine, which you should override in your parser/tree parser to do as you will.
.PP
Here we depart somewhat from the Java runtime as that has now split up a lot of the error display routines into spearate units. However, ther is little advantage to this in the C version as you will probably implement all such routines as a separate translation unit, rather than install them all as pointers to functions in the base recognizer. 
.PP
References ANTLR3_EARLY_EXIT_EXCEPTION, ANTLR3_FPRINTF, ANTLR3_MISMATCHED_SET_EXCEPTION, ANTLR3_MISMATCHED_TOKEN_EXCEPTION, ANTLR3_MISSING_TOKEN_EXCEPTION, ANTLR3_NO_VIABLE_ALT_EXCEPTION, ANTLR3_RECOGNITION_EXCEPTION, ANTLR3_TOKEN_EOF, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_UNWANTED_TOKEN_EXCEPTION, antlr3BitsetLoad(), ANTLR3_EXCEPTION_struct::charPositionInLine, ANTLR3_STRING_struct::chars, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_EXCEPTION_struct::expecting, ANTLR3_EXCEPTION_struct::expectingSet, ANTLR3_BASE_TREE_struct::getCharPositionInLine, ANTLR3_BASE_TREE_struct::getToken, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_EXCEPTION_struct::line, ANTLR3_EXCEPTION_struct::message, ANTLR3_BITSET_struct::numBits, ANTLR3_BITSET_struct::size, size(), ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_EXCEPTION_struct::streamName, ANTLR3_BASE_TREE_struct::super, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_STRING_struct::to8, ANTLR3_EXCEPTION_struct::token, ANTLR3_COMMON_TOKEN_struct::toString, ANTLR3_BASE_TREE_struct::toStringTree, ANTLR3_PARSER_struct::tstream, ANTLR3_COMMON_TOKEN_struct::type, ANTLR3_BASE_RECOGNIZER_struct::type, and ANTLR3_EXCEPTION_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3LexerNew().
.SS "static void endBacktrack (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP level, \fBANTLR3_BOOLEAN\fP successful)\fC [static]\fP"
.PP
References ANTLR3_BASE_RECOGNIZER_struct::debugger, and ANTLR3_DEBUG_EVENT_LISTENER_struct::endBacktrack.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3DebugListenerNew().
.SS "static void endResync (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
References ANTLR3_BASE_RECOGNIZER_struct::debugger, and ANTLR3_DEBUG_EVENT_LISTENER_struct::endResync.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3DebugListenerNew().
.SS "static void freeBR (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
References ANTLR3_FREE, ANTLR3_TOKEN_FACTORY_struct::close, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_INT_TRIE_struct::free, ANTLR3_EXCEPTION_struct::freeEx, ANTLR3_RECOGNIZER_SHARED_STATE_struct::rStreams, ANTLR3_RECOGNIZER_SHARED_STATE_struct::ruleMemo, ANTLR3_BASE_RECOGNIZER_struct::state, and ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokFactory.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void ANTLR3_CDECL freeIntTrie (void * trie)\fC [static]\fP"
.PP
Referenced by getRuleMemoization().
.SS "static void * getCurrentInputSymbol (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP istream)\fC [static]\fP"
.PP
References ANTLR3_INT_STREAM_struct::super.
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3LexerNew(), and antlr3TreeParserNewStream().
.SS "static void * getMissingSymbol (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP istream, \fBpANTLR3_EXCEPTION\fP e, \fBANTLR3_UINT32\fP expectedTokenType, \fBpANTLR3_BITSET_LIST\fP follow)\fC [static]\fP"
.PP
References ANTLR3_TOKEN_STREAM_struct::_LT, ANTLR3_TOKEN_DEFAULT_CHANNEL, ANTLR3_TOKEN_EOF, antlr3TokenFactoryNew(), ANTLR3_STRING_struct::append8, ANTLR3_COMMON_TOKEN_struct::custom, ANTLR3_COMMON_TOKEN_struct::getCharPositionInLine, ANTLR3_COMMON_TOKEN_struct::getLine, ANTLR3_COMMON_TOKEN_struct::getText, ANTLR3_COMMON_TOKEN_struct::getType, ANTLR3_COMMON_TOKEN_struct::input, ANTLR3_COMMON_TOKEN_struct::lineStart, ANTLR3_TOKEN_FACTORY_struct::newToken, ANTLR3_COMMON_TOKEN_struct::setChannel, ANTLR3_COMMON_TOKEN_struct::setCharPositionInLine, ANTLR3_COMMON_TOKEN_struct::setLine, ANTLR3_COMMON_TOKEN_struct::setText8, ANTLR3_COMMON_TOKEN_struct::setType, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_TOKEN_STREAM_struct::super, ANTLR3_INT_STREAM_struct::super, ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenNames, ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokFactory, ANTLR3_COMMON_TOKEN_struct::user1, ANTLR3_COMMON_TOKEN_struct::user2, and ANTLR3_COMMON_TOKEN_struct::user3.
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3LexerNew(), and antlr3TreeParserNewStream().
.SS "static \fBANTLR3_UINT32\fP getNumberOfSyntaxErrors (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Return how many syntax errors were detected by this recognizer. 
.PP
References ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorCount, and ANTLR3_BASE_RECOGNIZER_struct::state.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static \fBpANTLR3_STACK\fP getRuleInvocationStack (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Return the rule invocation stack (how we got here in the parse. 
.PP
In the java version Ter just asks the JVM for all the information but in C we don't get this information, so I am going to do nothing right now. 
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static \fBpANTLR3_STACK\fP getRuleInvocationStackNamed (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_UINT8\fP name)\fC [static]\fP"
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static \fBANTLR3_MARKER\fP getRuleMemoization (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_INTKEY\fP ruleIndex, \fBANTLR3_MARKER\fP ruleParseStart)\fC [static]\fP"
.PP
Pointer to a function to return whether the rule has parsed input starting at the supplied start index before. 
.PP
If the rule has not parsed input starting from the supplied start index, then it will return ANTLR3_MEMO_RULE_UNKNOWN. If it has parsed from the suppled start point then it will return the point where it last stopped parsing after that start point.
.PP
\fBRemarks:\fP
.RS 4
The rule memos are an ANTLR3_LIST of ANTLR3_LISTS, however if this becomes any kind of performance issue (it probably won't, the hash tables are pretty quick) then we could make a special int only version of the table. 
.RE
.PP

.PP
References ANTLR3_INT_TRIE_struct::add, ANTLR3_FUNC_PTR, ANTLR3_HASH_TYPE_STR, antlr3IntTrieNew(), ANTLR3_TRIE_ENTRY_struct::data, freeIntTrie(), ANTLR3_INT_TRIE_struct::get, ANTLR3_TRIE_ENTRY_struct::intVal, MEMO_RULE_UNKNOWN, ANTLR3_TRIE_ENTRY_struct::ptr, ANTLR3_RECOGNIZER_SHARED_STATE_struct::ruleMemo, and ANTLR3_BASE_RECOGNIZER_struct::state.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void * match (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP ttype, \fBpANTLR3_BITSET_LIST\fP follow)\fC [static]\fP"
.PP
Match current input symbol against ttype. 
.PP
Upon error, do one token insertion or deletion if possible. To turn off single token insertion or deletion error recovery, override mismatchRecover() and have it call plain \fBmismatch()\fP, which does not recover. Then any error in a rule will cause an exception and immediate exit from rule. Rule would recover by resynchronizing to the set of symbols that can follow rule ref. 
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TRUE, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_RECOGNIZER_SHARED_STATE_struct::backtracking, ANTLR3_INT_STREAM_struct::consume, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorRecovery, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_BASE_RECOGNIZER_struct::getCurrentInputSymbol, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_BASE_RECOGNIZER_struct::recoverFromMismatchedToken, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void matchAny (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Consumes the next token, whatever it is, and resets the recognizer state so that it is not in error. 
.PP
\fBParameters:\fP
.RS 4
\fIrecognizer\fP Recognizer context pointer 
.RE
.PP

.PP
References ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_INT_STREAM_struct::consume, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorRecovery, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3LexerNew().
.SS "static void memoize (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_MARKER\fP ruleIndex, \fBANTLR3_MARKER\fP ruleParseStart)\fC [static]\fP"
.PP
Record whether or not this rule parsed the input at this position successfully. 
.PP
References ANTLR3_INT_TRIE_struct::add, ANTLR3_FPRINTF, ANTLR3_HASH_TYPE_INT, ANTLR3_TRUE, ANTLR3_TYPE_LEXER, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_TRIE_ENTRY_struct::data, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_INT_TRIE_struct::get, ANTLR3_INT_STREAM_struct::index, ANTLR3_LEXER_struct::input, ANTLR3_INPUT_STREAM_struct::istream, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, MEMO_RULE_FAILED, ANTLR3_TRIE_ENTRY_struct::ptr, ANTLR3_RECOGNIZER_SHARED_STATE_struct::ruleMemo, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void mismatch (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP ttype, \fBpANTLR3_BITSET_LIST\fP follow)\fC [static]\fP"
.PP
Factor out what to do upon token mismatch so tree parsers can behave differently. 
.PP
Override and call mismatchRecover(input, ttype, follow) to get single token insertion and deletion. Use this to turn off single token insertion and deletion. Override mismatchRecover to call this instead.
.PP
\fBRemarks:\fP
.RS 4
mismatch only works for parsers and must be overridden for anything else. 
.RE
.PP

.PP
References ANTLR3_FPRINTF, ANTLR3_MISSING_TOKEN_EXCEPTION, ANTLR3_MISSING_TOKEN_EXCEPTION_NAME, ANTLR3_TYPE_PARSER, ANTLR3_UNWANTED_TOKEN_EXCEPTION, ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME, antlr3MTExceptionNew(), antlr3RecognitionExceptionNew(), ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_EXCEPTION_struct::expecting, ANTLR3_TOKEN_STREAM_struct::istream, mismatchIsMissingToken(), mismatchIsUnwantedToken(), ANTLR3_EXCEPTION_struct::name, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_PARSER_struct::tstream, ANTLR3_EXCEPTION_struct::type, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3TreeParserNewStream().
.SS "static \fBANTLR3_BOOLEAN\fP mismatchIsMissingToken (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP is, \fBpANTLR3_BITSET_LIST\fP follow)\fC [static]\fP"
.PP

.PP
if current token is consistent with what could come after set then we know we're missing a token; error recovery is free to 'insert' the missing token
.PP
BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR in follow set to indicate that the fall of the start symbol is in the set (EOF can follow). 
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_EOR_TOKEN_TYPE, ANTLR3_FALSE, ANTLR3_TRUE, antlr3BitsetLoad(), ANTLR3_BITSET_struct::borInPlace, ANTLR3_BASE_RECOGNIZER_struct::computeCSRuleFollow, ANTLR3_VECTOR_struct::count, ANTLR3_RECOGNIZER_SHARED_STATE_struct::following, ANTLR3_BITSET_struct::free, ANTLR3_BITSET_struct::isMember, ANTLR3_BITSET_struct::remove, ANTLR3_BASE_RECOGNIZER_struct::state, and ANTLR3_STACK_struct::vector.
.PP
Referenced by antlr3BaseRecognizerNew(), mismatch(), and recoverFromMismatchedToken().
.SS "static \fBANTLR3_BOOLEAN\fP mismatchIsUnwantedToken (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_INT_STREAM\fP is, \fBANTLR3_UINT32\fP ttype)\fC [static]\fP"
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_FALSE, ANTLR3_TRUE, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_EXCEPTION_struct::expecting, and ANTLR3_BASE_RECOGNIZER_struct::state.
.PP
Referenced by antlr3BaseRecognizerNew(), and mismatch().
.SS "static void recover (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Recover from an error found on the input stream. 
.PP
Mostly this is NoViableAlt exceptions, but could be a mismatched token that the \fBmatch()\fP routine could not recover from. 
.PP
References ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_BASE_RECOGNIZER_struct::beginResync, ANTLR3_BASE_RECOGNIZER_struct::computeErrorRecoverySet, ANTLR3_INT_STREAM_struct::consume, ANTLR3_BASE_RECOGNIZER_struct::consumeUntilSet, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_BASE_RECOGNIZER_struct::endResync, ANTLR3_RECOGNIZER_SHARED_STATE_struct::error, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_BITSET_struct::free, ANTLR3_INT_STREAM_struct::index, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::lastErrorIndex, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3LexerNew().
.SS "static \fBANTLR3_BOOLEAN\fP recoverFromMismatchedElement (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_BITSET_LIST\fP followBits)\fC [static]\fP"
.PP
This code is factored out from mismatched token and mismatched set recovery. 
.PP
It handles 'single token insertion' error recovery for both. No tokens are consumed to recover from insertions. Return true if recovery was possible else return false. 
.PP
References ANTLR3_INT_STREAM_struct::_LA, ANTLR3_EOR_TOKEN_TYPE, ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TRUE, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, antlr3BitsetLoad(), ANTLR3_BASE_RECOGNIZER_struct::computeCSRuleFollow, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::error, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_BITSET_struct::free, ANTLR3_BITSET_struct::isMember, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_BITSET_struct::remove, ANTLR3_BASE_RECOGNIZER_struct::reportError, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void * recoverFromMismatchedSet (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_BITSET_LIST\fP follow)\fC [static]\fP"
.PP
References ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_MISSING_TOKEN_EXCEPTION, ANTLR3_TOKEN_INVALID, ANTLR3_TRUE, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::error, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_BASE_RECOGNIZER_struct::getMissingSymbol, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_BASE_RECOGNIZER_struct::mismatchIsMissingToken, ANTLR3_BASE_RECOGNIZER_struct::reportError, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_EXCEPTION_struct::token, ANTLR3_PARSER_struct::tstream, ANTLR3_EXCEPTION_struct::type, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void * recoverFromMismatchedToken (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBANTLR3_UINT32\fP ttype, \fBpANTLR3_BITSET_LIST\fP follow)\fC [static]\fP"
.PP
Attempt to recover from a single missing or extra token. 
.PP
EXTRA TOKEN
.PP
LA(1) is not what we are looking for. If LA(2) has the right token, however, then assume LA(1) is some extra spurious token. Delete it and LA(2) as if we were doing a normal \fBmatch()\fP, which advances the input.
.PP
MISSING TOKEN
.PP
If current token is consistent with what could come after ttype then it is ok to 'insert' the missing token, else throw exception For example, Input 'i=(3;' is clearly missing the ')'. When the parser returns from the nested call to expr, it will have call chain:
.PP
stat -> expr -> atom
.PP
and it will be trying to match the ')' at this point in the derivation:
.PP
=> ID '=' '(' INT ')' ('+' atom)* ';' ^ \fBmatch()\fP will see that ';' doesn't match ')' and report a mismatched token error. To recover, it sees that LA(1)==';' is in the set of tokens that can follow the ')' token reference in rule atom. It can assume that you forgot the ')'.
.PP
The exception that was passed in, in the java implementation is sorted in the recognizer exception stack in the C version. To 'throw' it we set the error flag and rules cascade back when this is set. 
.PP
References ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_MISSING_TOKEN_EXCEPTION, ANTLR3_MISSING_TOKEN_EXCEPTION_NAME, ANTLR3_TRUE, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_UNWANTED_TOKEN_EXCEPTION, ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME, antlr3RecognitionExceptionNew(), ANTLR3_BASE_RECOGNIZER_struct::beginResync, ANTLR3_DEBUG_EVENT_LISTENER_struct::beginResync, ANTLR3_INT_STREAM_struct::consume, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_BASE_RECOGNIZER_struct::debugger, ANTLR3_DEBUG_EVENT_LISTENER_struct::endResync, ANTLR3_BASE_RECOGNIZER_struct::endResync, ANTLR3_RECOGNIZER_SHARED_STATE_struct::error, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_EXCEPTION_struct::expecting, ANTLR3_BASE_RECOGNIZER_struct::getCurrentInputSymbol, ANTLR3_BASE_RECOGNIZER_struct::getMissingSymbol, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_EXCEPTION_struct::message, mismatchIsMissingToken(), ANTLR3_BASE_RECOGNIZER_struct::mismatchIsUnwantedToken, ANTLR3_BASE_RECOGNIZER_struct::reportError, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_EXCEPTION_struct::token, ANTLR3_PARSER_struct::tstream, ANTLR3_EXCEPTION_struct::type, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static void reportError (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
Report a recognition problem. 
.PP
This method sets errorRecovery to indicate the parser is recovering not parsing. Once in recovery mode, no errors are generated. To get out of recovery mode, the parser must successfully match a token (after a resync). So it will go:
.PP
1. error occurs 2. enter recovery mode, report error 3. consume until token found in resynch set 4. try to resume parsing 5. next \fBmatch()\fP will reset errorRecovery mode
.PP
If you override, make sure to update errorCount if you care about that. 
.PP
References ANTLR3_TRUE, ANTLR3_BASE_RECOGNIZER_struct::debugger, ANTLR3_BASE_RECOGNIZER_struct::displayRecognitionError, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorCount, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorRecovery, ANTLR3_RECOGNIZER_SHARED_STATE_struct::exception, ANTLR3_DEBUG_EVENT_LISTENER_struct::recognitionException, ANTLR3_BASE_RECOGNIZER_struct::state, and ANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenNames.
.PP
Referenced by antlr3BaseRecognizerNew(), and antlr3LexerNew().
.SS "static void reset (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer)\fC [static]\fP"
.PP
References ANTLR3_FALSE, antlr3IntTrieNew(), antlr3StackNew(), ANTLR3_RECOGNIZER_SHARED_STATE_struct::backtracking, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorCount, ANTLR3_RECOGNIZER_SHARED_STATE_struct::errorRecovery, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_RECOGNIZER_SHARED_STATE_struct::following, ANTLR3_INT_TRIE_struct::free, ANTLR3_STACK_struct::free, ANTLR3_RECOGNIZER_SHARED_STATE_struct::lastErrorIndex, ANTLR3_RECOGNIZER_SHARED_STATE_struct::ruleMemo, and ANTLR3_BASE_RECOGNIZER_struct::state.
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3CommonTokenStreamNew(), antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), antlr3LexerNew(), and antlr3RewriteRuleElementStreamNewAE().
.SS "static \fBANTLR3_BOOLEAN\fP synpred (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, void * ctx, void(*)(void *ctx) predicate)\fC [static]\fP"
.PP
A syntactic predicate. 
.PP
Returns true/false depending on whether the specified grammar fragment matches the current input stream. This resets the failed instance var afterwards. 
.PP
References ANTLR3_FALSE, ANTLR3_FPRINTF, ANTLR3_TRUE, ANTLR3_TYPE_PARSER, ANTLR3_TYPE_TREE_PARSER, ANTLR3_RECOGNIZER_SHARED_STATE_struct::backtracking, ANTLR3_TREE_PARSER_struct::ctnstream, ANTLR3_RECOGNIZER_SHARED_STATE_struct::failed, ANTLR3_TREE_NODE_STREAM_struct::istream, ANTLR3_TOKEN_STREAM_struct::istream, ANTLR3_INT_STREAM_struct::mark, ANTLR3_INT_STREAM_struct::rewind, ANTLR3_BASE_RECOGNIZER_struct::state, ANTLR3_BASE_RECOGNIZER_struct::super, ANTLR3_COMMON_TREE_NODE_STREAM_struct::tnstream, ANTLR3_PARSER_struct::tstream, and ANTLR3_BASE_RECOGNIZER_struct::type.
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "static \fBpANTLR3_HASH_TABLE\fP toStrings (\fBpANTLR3_BASE_RECOGNIZER\fP recognizer, \fBpANTLR3_HASH_TABLE\fP tokens)\fC [static]\fP"
.PP
Convenience method for template rewrites - NYI. 
.PP
Referenced by antlr3BaseRecognizerNew().
