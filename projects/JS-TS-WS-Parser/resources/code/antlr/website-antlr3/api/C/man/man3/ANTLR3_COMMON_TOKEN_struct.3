.TH "ANTLR3_COMMON_TOKEN_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_COMMON_TOKEN_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3commontoken.h>\fP
.PP
.SH "Detailed Description"
.PP 
The definition of an ANTLR3 common token structure, which all implementations of a token stream should provide, installing any further structures in the custom pointer element of this structure. 

\fBRemarks:\fP
.RS 4
Token streams are in essence provided by lexers or other programs that serve as lexers. 
.RE
.PP

.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBchannel\fP"
.br
.RI "\fIThe virtual channel that this token exists in. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBcharPosition\fP"
.br
.RI "\fIThe character position in the line that this token was derived from. \fP"
.ti -1c
.RI "void * \fBcustom\fP"
.br
.RI "\fIPointer to a custom element that the ANTLR3 programmer may define and install. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBfactoryMade\fP"
.br
.RI "\fIIndicates that a token was produced from the token factory and therefore the the freeToken() method should not do anything itself because token factory is responsible for deleting it. \fP"
.ti -1c
.RI "void(* \fBfreeCustom\fP )(void *\fBcustom\fP)"
.br
.RI "\fIPointer to a function that knows how to free the custom structure when the token is destroyed. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetChannel\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that gets the channel that this token was placed in (parsers can 'tune' to these channels. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP(* \fBgetCharPositionInLine\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that gets the offset in the line where this token exists. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetLine\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that gets the 'line' number where this token resides. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP(* \fBgetStartIndex\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that gets the start index in the input stream for this token. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP(* \fBgetStopIndex\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that gets the stop index in the input stream for this token. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBgetText\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to function that returns the text pointer of a token, use \fBtoString()\fP if you want a pANTLR3_STRING version of the token. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP(* \fBgetTokenIndex\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that returns an index 0. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetType\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that returns the token type of this token. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBindex\fP"
.br
.RI "\fIWhat the index of this token is, 0, 1, . \fP"
.ti -1c
.RI "\fBpANTLR3_INPUT_STREAM\fP \fBinput\fP"
.br
.RI "\fIPointer to the input stream that this token originated in. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBline\fP"
.br
.RI "\fIThe line number in the input stream where this token was derived from. \fP"
.ti -1c
.RI "void * \fBlineStart\fP"
.br
.RI "\fIThe offset into the input stream that the line in which this token resides starts. \fP"
.ti -1c
.RI "void(* \fBsetChannel\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_UINT32\fP \fBchannel\fP)"
.br
.RI "\fIPointer to a function that sets the channel that this token should belong to. \fP"
.ti -1c
.RI "void(* \fBsetCharPositionInLine\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_INT32\fP pos)"
.br
.RI "\fIPointer to a function that sets the offset in the line where this token exists. \fP"
.ti -1c
.RI "void(* \fBsetLine\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_UINT32\fP \fBline\fP)"
.br
.RI "\fIPointer to a function that sets the 'line' number where this token reside. \fP"
.ti -1c
.RI "void(* \fBsetStartIndex\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_MARKER\fP \fBindex\fP)"
.br
.RI "\fIPointer to a function that sets the start index in the input stream for this token. \fP"
.ti -1c
.RI "void(* \fBsetStopIndex\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_MARKER\fP \fBindex\fP)"
.br
.RI "\fIPointer to a function that sets the stop index in the input stream for this token. \fP"
.ti -1c
.RI "void(* \fBsetText\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBpANTLR3_STRING\fP \fBtext\fP)"
.br
.RI "\fIPointer to a function that 'might' be able to set the text associated with a token. \fP"
.ti -1c
.RI "void(* \fBsetText8\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBpANTLR3_UINT8\fP \fBtext\fP)"
.br
.RI "\fIPointer to a function that 'might' be able to set the text associated with a token. \fP"
.ti -1c
.RI "void(* \fBsetTokenIndex\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_MARKER\fP)"
.br
.RI "\fIPointer to a function that can set the token index of this token in the token input stream. \fP"
.ti -1c
.RI "void(* \fBsetType\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_UINT32\fP ttype)"
.br
.RI "\fIPointer to a function that sets the type of this token. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBstart\fP"
.br
.RI "\fIThe character offset in the input stream where the text for this token starts. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBstop\fP"
.br
.RI "\fIThe character offset in the input stream where the text for this token stops. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING_FACTORY\fP \fBstrFactory\fP"
.br
.RI "\fIA string factory that we can use if we ever need the text of a token and need to manufacture a pANTLR3_STRING. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBtextState\fP"
.br
.RI "\fIIndicates whether this token is carrying:. \fP"
.ti -1c
.RI "union {"
.br
.ti -1c
.RI "   \fBpANTLR3_UCHAR\fP \fBchars\fP"
.br
.RI "\fIPointer that is used when the token just has a pointer to a char *, such as when a rewrite of an imaginary token supplies a string in the grammar. \fP"
.ti -1c
.RI "   \fBpANTLR3_STRING\fP \fBtext\fP"
.br
.RI "\fISome token types actually do carry around their associated text, hence (*getText)() will return this pointer if it is not NULL. \fP"
.ti -1c
.RI "} \fBtokText\fP"
.br
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBtoString\fP )(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.br
.RI "\fIPointer to a function that returns this token as a text representation that can be printed with embedded control codes such as 
.br
 replaced with the printable sequence '\\\\n' This also yields a string structure that can be used more easily than the pointer to the input stream in certain situations. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBtype\fP"
.br
.RI "\fIThe actual type of this token. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBuser1\fP"
.br
.RI "\fIBecause it is a bit more of a hassle to override an ANTLR3_COMMON_TOKEN as the standard structure for a token, a number of user programmable elements are allowed in a token. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBuser2\fP"
.br
.RI "\fIBecause it is a bit more of a hassle to override an ANTLR3_COMMON_TOKEN as the standard structure for a token, a number of user programmable elements are allowed in a token. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBuser3\fP"
.br
.RI "\fIBecause it is a bit more of a hassle to override an ANTLR3_COMMON_TOKEN as the standard structure for a token, a number of user programmable elements are allowed in a token. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::channel\fP"
.PP
The virtual channel that this token exists in. 
.PP
Referenced by emit(), getChannel(), and setChannel().
.SS "\fBANTLR3_INT32\fP \fBANTLR3_COMMON_TOKEN_struct::charPosition\fP"
.PP
The character position in the line that this token was derived from. 
.PP
Referenced by emit(), getCharPositionInLine(), and setCharPositionInLine().
.SS "\fBpANTLR3_UCHAR\fP \fBANTLR3_COMMON_TOKEN_struct::chars\fP"
.PP
Pointer that is used when the token just has a pointer to a char *, such as when a rewrite of an imaginary token supplies a string in the grammar. 
.PP
No sense in constructing a pANTLR3_STRING just for that, as mostly the text will not be accessed - if it is, then we will build a pANTLR3_STRING for it a that point. 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), createToken(), createTokenFromToken(), getText(), and setText8().
.SS "void* \fBANTLR3_COMMON_TOKEN_struct::custom\fP"
.PP
Pointer to a custom element that the ANTLR3 programmer may define and install. 
.PP
Referenced by emit(), factoryClose(), and getMissingSymbol().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_COMMON_TOKEN_struct::factoryMade\fP"
.PP
Indicates that a token was produced from the token factory and therefore the the freeToken() method should not do anything itself because token factory is responsible for deleting it. 
.PP
Referenced by antlr3LexerNew(), antlr3TokenFactoryNew(), newPoolToken(), newToken(), and nextTokenStr().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::freeCustom\fP)(void *\fBcustom\fP)"
.PP
Pointer to a function that knows how to free the custom structure when the token is destroyed. 
.PP
Referenced by factoryClose().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_COMMON_TOKEN_struct::getChannel\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that gets the channel that this token was placed in (parsers can 'tune' to these channels. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), serializeToken(), and toString().
.SS "\fBANTLR3_INT32\fP(* \fBANTLR3_COMMON_TOKEN_struct::getCharPositionInLine\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that gets the offset in the line where this token exists. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), getCharPositionInLine(), getMissingSymbol(), serializeNode(), serializeToken(), and toString().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_COMMON_TOKEN_struct::getLine\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that gets the 'line' number where this token resides. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), getLine(), getMissingSymbol(), serializeNode(), serializeToken(), and toString().
.SS "\fBANTLR3_MARKER\fP(* \fBANTLR3_COMMON_TOKEN_struct::getStartIndex\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that gets the start index in the input stream for this token. 
.PP
Referenced by antlr3SetTokenAPI(), getText(), and toString().
.SS "\fBANTLR3_MARKER\fP(* \fBANTLR3_COMMON_TOKEN_struct::getStopIndex\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that gets the stop index in the input stream for this token. 
.PP
Referenced by antlr3SetTokenAPI(), getText(), and toString().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_COMMON_TOKEN_struct::getText\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to function that returns the text pointer of a token, use \fBtoString()\fP if you want a pANTLR3_STRING version of the token. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), getMissingSymbol(), serializeToken(), toString(), and toStringSS().
.SS "\fBANTLR3_MARKER\fP(* \fBANTLR3_COMMON_TOKEN_struct::getTokenIndex\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that returns an index 0. 
.PP
..n-1 of the token in the token input stream. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), dbgSetTokenBoundaries(), serializeToken(), setTokenBoundaries(), toString(), and toStringTT().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_COMMON_TOKEN_struct::getType\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that returns the token type of this token. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), getMissingSymbol(), getTokensSet(), getType(), and serializeToken().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_COMMON_TOKEN_struct::index\fP"
.PP
What the index of this token is, 0, 1, . 
.PP
., n-2, n-1 tokens 
.PP
Referenced by getTokenIndex(), and setTokenIndex().
.SS "\fBpANTLR3_INPUT_STREAM\fP \fBANTLR3_COMMON_TOKEN_struct::input\fP"
.PP
Pointer to the input stream that this token originated in. 
.PP
Referenced by antlr3RecognitionExceptionNew(), createToken(), getMissingSymbol(), getStartIndex(), getText(), newPoolToken(), and setInputStream().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::line\fP"
.PP
The line number in the input stream where this token was derived from. 
.PP
Referenced by emit(), getLine(), and setLine().
.SS "void* \fBANTLR3_COMMON_TOKEN_struct::lineStart\fP"
.PP
The offset into the input stream that the line in which this token resides starts. 
.PP
Referenced by emit(), and getMissingSymbol().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setChannel\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_UINT32\fP \fBchannel\fP)"
.PP
Pointer to a function that sets the channel that this token should belong to. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), and getMissingSymbol().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setCharPositionInLine\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_INT32\fP pos)"
.PP
Pointer to a function that sets the offset in the line where this token exists. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), and getMissingSymbol().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setLine\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_UINT32\fP \fBline\fP)"
.PP
Pointer to a function that sets the 'line' number where this token reside. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), getMissingSymbol(), and nextTokenStr().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setStartIndex\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_MARKER\fP \fBindex\fP)"
.PP
Pointer to a function that sets the start index in the input stream for this token. 
.PP
Referenced by antlr3SetTokenAPI(), newPoolToken(), nextTokenStr(), and tokLT().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setStopIndex\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_MARKER\fP \fBindex\fP)"
.PP
Pointer to a function that sets the stop index in the input stream for this token. 
.PP
Referenced by antlr3SetTokenAPI(), nextTokenStr(), and tokLT().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setText\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBpANTLR3_STRING\fP \fBtext\fP)"
.PP
Pointer to a function that 'might' be able to set the text associated with a token. 
.PP
Imaginary tokens such as an ANTLR3_CLASSIC_TOKEN may actually do this, however many tokens such as ANTLR3_COMMON_TOKEN do not actaully have strings associated with them but just point into the current input stream. These tokens will implement this function with a function that errors out (probably drastically. 
.PP
Referenced by antlr3SetTokenAPI().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setText8\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBpANTLR3_UINT8\fP \fBtext\fP)"
.PP
Pointer to a function that 'might' be able to set the text associated with a token. 
.PP
Imaginary tokens such as an ANTLR3_CLASSIC_TOKEN may actually do this, however many tokens such as ANTLR3_COMMON_TOKEN do not actully have strings associated with them but just point into the current input stream. These tokens will implement this function with a function that errors out (probably drastically. 
.PP
Referenced by antlr3SetTokenAPI(), createTypeTokenText(), and getMissingSymbol().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setTokenIndex\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_MARKER\fP)"
.PP
Pointer to a function that can set the token index of this token in the token input stream. 
.PP
Referenced by antlr3SetTokenAPI(), and createTokenFromToken().
.SS "void(* \fBANTLR3_COMMON_TOKEN_struct::setType\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token, \fBANTLR3_UINT32\fP ttype)"
.PP
Pointer to a function that sets the type of this token. 
.PP
Referenced by antlr3CommonTokenNew(), antlr3LexerNew(), antlr3SetTokenAPI(), createToken(), createTokenFromToken(), createTypeToken(), createTypeTokenText(), and getMissingSymbol().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_COMMON_TOKEN_struct::start\fP"
.PP
The character offset in the input stream where the text for this token starts. 
.PP
Referenced by emit(), getStartIndex(), and setStartIndex().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_COMMON_TOKEN_struct::stop\fP"
.PP
The character offset in the input stream where the text for this token stops. 
.PP
Referenced by emit(), getStopIndex(), and setStopIndex().
.SS "\fBpANTLR3_STRING_FACTORY\fP \fBANTLR3_COMMON_TOKEN_struct::strFactory\fP"
.PP
A string factory that we can use if we ever need the text of a token and need to manufacture a pANTLR3_STRING. 
.PP
Referenced by ANTLR3_TREE_ADAPTORNew(), antlr3CommonTreeNodeStreamNew(), antlr3CommonTreeNodeStreamNewStream(), antlr3LexerNew(), createToken(), getText(), newPoolToken(), setCharStream(), and setInputStream().
.SS "\fBpANTLR3_STRING\fP \fBANTLR3_COMMON_TOKEN_struct::text\fP"
.PP
Some token types actually do carry around their associated text, hence (*getText)() will return this pointer if it is not NULL. 
.PP
Referenced by createTokenFromToken(), emit(), getText(), setText(), and setText8().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::textState\fP"
.PP
Indicates whether this token is carrying:. 
.PP
State | Meaning ------+-------------------------------------- 0 | Nothing (neither rewrite text, nor setText) 1 | char * to user supplied rewrite text 2 | pANTLR3_STRING because of setText or similar action
.PP
Affects the union structure tokText below (uses 32 bit so alignment is always good) 
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), createToken(), createTokenFromToken(), emit(), getText(), setText(), and setText8().
.SS "union { ... } 
		 \fBANTLR3_COMMON_TOKEN_struct::tokText\fP"
.PP
Referenced by antlr3CommonTreeNodeStreamNew(), createToken(), createTokenFromToken(), emit(), getText(), setText(), and setText8().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_COMMON_TOKEN_struct::toString\fP)(struct \fBANTLR3_COMMON_TOKEN_struct\fP *token)"
.PP
Pointer to a function that returns this token as a text representation that can be printed with embedded control codes such as 
.br
 replaced with the printable sequence '\\\\n' This also yields a string structure that can be used more easily than the pointer to the input stream in certain situations. 
.PP
Referenced by antlr3SetTokenAPI(), createTokenFromToken(), and displayRecognitionError().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::type\fP"
.PP
The actual type of this token. 
.PP
Referenced by displayRecognitionError(), emit(), getText(), getType(), nextToken(), setType(), and toString().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::user1\fP"
.PP
Because it is a bit more of a hassle to override an ANTLR3_COMMON_TOKEN as the standard structure for a token, a number of user programmable elements are allowed in a token. 
.PP
This is one of them. 
.PP
Referenced by emit(), and getMissingSymbol().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::user2\fP"
.PP
Because it is a bit more of a hassle to override an ANTLR3_COMMON_TOKEN as the standard structure for a token, a number of user programmable elements are allowed in a token. 
.PP
This is one of them. 
.PP
Referenced by emit(), and getMissingSymbol().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_COMMON_TOKEN_struct::user3\fP"
.PP
Because it is a bit more of a hassle to override an ANTLR3_COMMON_TOKEN as the standard structure for a token, a number of user programmable elements are allowed in a token. 
.PP
This is one of them. 
.PP
Referenced by emit(), and getMissingSymbol().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
