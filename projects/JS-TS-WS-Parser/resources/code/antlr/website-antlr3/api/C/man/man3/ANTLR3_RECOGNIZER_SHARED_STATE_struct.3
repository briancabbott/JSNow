.TH "ANTLR3_RECOGNIZER_SHARED_STATE_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_RECOGNIZER_SHARED_STATE_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3recognizersharedstate.h>\fP
.PP
.SH "Detailed Description"
.PP 
All the data elements required to track the current state of any recognizer (lexer, parser, tree parser). 

May be share between multiple recognizers such that grammar inheritance is easily supported. 
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBbacktracking\fP"
.br
.RI "\fIIf 0, no backtracking is going on. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBchannel\fP"
.br
.RI "\fIThe channel number for the current token. \fP"
.ti -1c
.RI "void * \fBcustom\fP"
.br
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBerror\fP"
.br
.RI "\fIIf set to ANTLR3_TRUE then the recognizer has an exception condition (this is tested by the generated code for the rules of the grammar). \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBerrorCount\fP"
.br
.RI "\fIWhen the recognizer terminates, the error handling functions will have incremented this value if any error occurred (that was displayed). \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBerrorRecovery\fP"
.br
.RI "\fIThis is true when we see an error and before having successfully matched a token. \fP"
.ti -1c
.RI "\fBpANTLR3_EXCEPTION\fP \fBexception\fP"
.br
.RI "\fIPoints to the first in a possible chain of exceptions that the recognizer has discovered. \fP"
.ti -1c
.RI "\fBANTLR3_BOOLEAN\fP \fBfailed\fP"
.br
.RI "\fIIn lieu of a return value, this indicates that a rule or token has failed to match. \fP"
.ti -1c
.RI "\fBpANTLR3_STACK\fP \fBfollowing\fP"
.br
.RI "\fITrack the set of token types that can follow any rule invocation. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBlastErrorIndex\fP"
.br
.RI "\fIThe index into the input stream where the last error occurred. \fP"
.ti -1c
.RI "\fBpANTLR3_VECTOR\fP \fBrStreams\fP"
.br
.RI "\fIA stack of token/tree rewrite streams that are available for use by a parser or tree parser that is using rewrites to generate an AST. \fP"
.ti -1c
.RI "\fBpANTLR3_INT_TRIE\fP \fBruleMemo\fP"
.br
.RI "\fIANTLR3_VECTOR of ANTLR3_LIST for rule memoizing. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBsizeHint\fP"
.br
.RI "\fITrack around a hint from the creator of the recognizer as to how big this thing is going to get, as the actress said to the bishop. \fP"
.ti -1c
.RI "\fBpANTLR3_STACK\fP \fBstreams\fP"
.br
.RI "\fIInput stream stack, which allows the C programmer to switch input streams easily and allow the standard \fBnextToken()\fP implementation to deal with it as this is a common requirement. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP \fBtext\fP"
.br
.RI "\fIText for the current token. \fP"
.ti -1c
.RI "\fBpANTLR3_COMMON_TOKEN\fP \fBtoken\fP"
.br
.RI "\fIThe goal of all lexer rules/methods is to create a token object. \fP"
.ti -1c
.RI "\fBpANTLR3_UINT8\fP * \fBtokenNames\fP"
.br
.RI "\fIPointer to an array of token names that are generally useful in error reporting. \fP"
.ti -1c
.RI "\fBANTLR3_MARKER\fP \fBtokenStartCharIndex\fP"
.br
.RI "\fIWhat character index in the stream did the current token start at? Needed, for example, to get the text for current token. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBtokenStartCharPositionInLine\fP"
.br
.RI "\fIThe character position of the first character of the current token within the line specified by tokenStartLine. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBtokenStartLine\fP"
.br
.RI "\fIThe input line (where it makes sense) on which the first character of the current token resides. \fP"
.ti -1c
.RI "\fBpANTLR3_TOKEN_FACTORY\fP \fBtokFactory\fP"
.br
.RI "\fIThe goal of all lexer rules being to create a token, then a lexer needs to build a token factory to create them. \fP"
.ti -1c
.RI "\fBpANTLR3_TOKEN_SOURCE\fP \fBtokSource\fP"
.br
.RI "\fIA lexer is a source of tokens, produced by all the generated (or hand crafted if you like) matching rules. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBtype\fP"
.br
.RI "\fIThe token type for the current token. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBuser1\fP"
.br
.RI "\fIUser controlled variables that will be installed in a newly created token. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBuser2\fP"
.br
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBuser3\fP"
.br
.ti -1c
.RI "void * \fBuserp\fP"
.br
.RI "\fIUser programmable pointer that can be used for instance as a place to store some tracking structure specific to the grammar that would not normally be available to the error handling functions. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBANTLR3_INT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::backtracking\fP"
.PP
If 0, no backtracking is going on. 
.PP
Safe to exec actions etc... If >0 then it's the level of backtracking. 
.PP
Referenced by antlr3BaseRecognizerNew(), match(), matchc(), matchRange(), matchs(), noViableAlt(), reset(), and synpred().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::channel\fP"
.PP
The channel number for the current token. 
.PP
Referenced by emit(), nextTokenStr(), and reset().
.SS "void* \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::custom\fP"
.PP
Referenced by emit(), and nextTokenStr().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::error\fP"
.PP
If set to ANTLR3_TRUE then the recognizer has an exception condition (this is tested by the generated code for the rules of the grammar). 
.PP
Referenced by antlr3dfapredict(), antlr3RecognitionExceptionNew(), nextTokenStr(), recover(), recoverFromMismatchedElement(), recoverFromMismatchedSet(), and recoverFromMismatchedToken().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::errorCount\fP"
.PP
When the recognizer terminates, the error handling functions will have incremented this value if any error occurred (that was displayed). 
.PP
It can then be used by the grammar programmer without having to use static globals. 
.PP
Referenced by antlr3BaseRecognizerNew(), getNumberOfSyntaxErrors(), reportError(), and reset().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::errorRecovery\fP"
.PP
This is true when we see an error and before having successfully matched a token. 
.PP
Prevents generation of more than one error message per error. 
.PP
Referenced by antlr3BaseRecognizerNew(), match(), matchAny(), reportError(), and reset().
.SS "\fBpANTLR3_EXCEPTION\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::exception\fP"
.PP
Points to the first in a possible chain of exceptions that the recognizer has discovered. 
.PP
Referenced by antlr3MTExceptionNew(), antlr3MTNExceptionNew(), antlr3RecognitionExceptionNew(), displayRecognitionError(), freeBR(), mismatch(), mismatchIsUnwantedToken(), noViableAlt(), recoverFromMismatchedSet(), recoverFromMismatchedToken(), and reportError().
.SS "\fBANTLR3_BOOLEAN\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::failed\fP"
.PP
In lieu of a return value, this indicates that a rule or token has failed to match. 
.PP
Reset to false upon valid token match. 
.PP
Referenced by alreadyParsedRule(), antlr3BaseRecognizerNew(), match(), matchAny(), matchc(), matchRange(), matchs(), memoize(), nextTokenStr(), noViableAlt(), recover(), recoverFromMismatchedElement(), recoverFromMismatchedSet(), reset(), and synpred().
.SS "\fBpANTLR3_STACK\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::following\fP"
.PP
Track the set of token types that can follow any rule invocation. 
.PP
Stack structure, to support: List<BitSet>. 
.PP
Referenced by antlr3BaseRecognizerNew(), combineFollows(), freeParser(), mismatchIsMissingToken(), and reset().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::lastErrorIndex\fP"
.PP
The index into the input stream where the last error occurred. 
.PP
This is used to prevent infinite loops where an error is found but no token is consumed during recovery...another error is found, ad nauseam. This is a failsafe mechanism to guarantee that at least one token/tree node is consumed for two errors. 
.PP
Referenced by antlr3BaseRecognizerNew(), recover(), and reset().
.SS "\fBpANTLR3_VECTOR\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::rStreams\fP"
.PP
A stack of token/tree rewrite streams that are available for use by a parser or tree parser that is using rewrites to generate an AST. 
.PP
This saves each rule in the recongizer from having to allocate and deallocate rewtire streams on entry and exit. As the parser recurses throgh the rules it will reach a steady state of the maximum number of allocated streams, which instead of deallocating them at rule exit, it will place on this stack for reuse. The streams are then all finally freed when this stack is freed. 
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3RewriteRuleElementStreamNewAE(), freeBR(), freeNodeRS(), and freeRS().
.SS "\fBpANTLR3_INT_TRIE\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::ruleMemo\fP"
.PP
ANTLR3_VECTOR of ANTLR3_LIST for rule memoizing. 
.PP
Tracks the stop token index for each rule. ruleMemo[ruleIndex] is the memoization table for ruleIndex. For key ruleStartIndex, you get back the stop token for associated rule or MEMO_RULE_FAILED.
.PP
This is only used if rule memoization is on. 
.PP
Referenced by antlr3BaseRecognizerNew(), freeBR(), getRuleMemoization(), memoize(), and reset().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::sizeHint\fP"
.PP
Track around a hint from the creator of the recognizer as to how big this thing is going to get, as the actress said to the bishop. 
.PP
This allows us to tune hash tables accordingly. This might not be the best place for this in the end but we will see. 
.PP
Referenced by antlr3BaseRecognizerNew().
.SS "\fBpANTLR3_STACK\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::streams\fP"
.PP
Input stream stack, which allows the C programmer to switch input streams easily and allow the standard \fBnextToken()\fP implementation to deal with it as this is a common requirement. 
.PP
Referenced by freeLexer(), nextToken(), popCharStream(), and pushCharStream().
.SS "\fBpANTLR3_STRING\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::text\fP"
.PP
Text for the current token. 
.PP
This can be overridden by setting this variable directly or by using the SETTEXT() macro (preferred) in your lexer rules. 
.PP
Referenced by emit(), getText(), nextTokenStr(), reset(), and setCharStream().
.SS "\fBpANTLR3_COMMON_TOKEN\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::token\fP"
.PP
The goal of all lexer rules/methods is to create a token object. 
.PP
This is an instance variable as multiple rules may collaborate to create a single token. For example, NUM : INT | FLOAT ; In this case, you want the INT or FLOAT rule to set token and not have it reset to a NUM token in rule NUM. 
.PP
Referenced by emit(), emitNew(), nextTokenStr(), reset(), and setCharStream().
.SS "\fBpANTLR3_UINT8\fP* \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenNames\fP"
.PP
Pointer to an array of token names that are generally useful in error reporting. 
.PP
The generated parsers install this pointer. The table it points to is statically allocated as 8 bit ascii at parser compile time - grammar token names are thus restricted in character sets, which does not seem to terrible. 
.PP
Referenced by antlr3BaseRecognizerNew(), getMissingSymbol(), and reportError().
.SS "\fBANTLR3_MARKER\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenStartCharIndex\fP"
.PP
What character index in the stream did the current token start at? Needed, for example, to get the text for current token. 
.PP
Set at the start of nextToken. 
.PP
Referenced by displayRecognitionError(), emit(), getText(), nextTokenStr(), reset(), and setCharStream().
.SS "\fBANTLR3_INT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenStartCharPositionInLine\fP"
.PP
The character position of the first character of the current token within the line specified by tokenStartLine. 
.PP
Referenced by displayRecognitionError(), emit(), nextTokenStr(), and reset().
.SS "\fBANTLR3_INT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::tokenStartLine\fP"
.PP
The input line (where it makes sense) on which the first character of the current token resides. 
.PP
Referenced by displayRecognitionError(), emit(), nextTokenStr(), and reset().
.SS "\fBpANTLR3_TOKEN_FACTORY\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::tokFactory\fP"
.PP
The goal of all lexer rules being to create a token, then a lexer needs to build a token factory to create them. 
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3LexerNew(), emit(), freeBR(), freeLexer(), getMissingSymbol(), reset(), and setCharStream().
.SS "\fBpANTLR3_TOKEN_SOURCE\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::tokSource\fP"
.PP
A lexer is a source of tokens, produced by all the generated (or hand crafted if you like) matching rules. 
.PP
As such it needs to provide a token source interface implementation. 
.PP
Referenced by antlr3BaseRecognizerNew(), antlr3LexerNew(), freeLexer(), and setCharStream().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::type\fP"
.PP
The token type for the current token. 
.PP
Referenced by emit(), and reset().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::user1\fP"
.PP
User controlled variables that will be installed in a newly created token. 
.PP
Referenced by emit(), and nextTokenStr().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::user2\fP"
.PP
Referenced by emit(), and nextTokenStr().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::user3\fP"
.PP
Referenced by emit(), and nextTokenStr().
.SS "void* \fBANTLR3_RECOGNIZER_SHARED_STATE_struct::userp\fP"
.PP
User programmable pointer that can be used for instance as a place to store some tracking structure specific to the grammar that would not normally be available to the error handling functions. 
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
