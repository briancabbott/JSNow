<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ANTLR3C: ANTLR3_TOKEN_SOURCE_struct Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ANTLR3_TOKEN_SOURCE_struct Struct Reference</h1><!-- doxytag: class="ANTLR3_TOKEN_SOURCE_struct" --><code>#include &lt;antlr3tokenstream.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for ANTLR3_TOKEN_SOURCE_struct:</div>
<div class="dynsection">
<p><center><img src="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct__coll__graph.png" border="0" usemap="#_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct__coll__map" alt="Collaboration graph"></center>
<map name="_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct__coll__map">
<area shape="rect" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html" title="The definition of an ANTLR3 common token structure, which all implementations of..." alt="" coords="350,539,587,565"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html" title="Base string class tracks the allocations and provides simple string tracking functions..." alt="" coords="259,123,432,149"><area shape="rect" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html" title="Definition of the string factory interface, which creates and tracks strings for..." alt="" coords="402,323,647,349"><area shape="rect" href="struct_a_n_t_l_r3___i_n_p_u_t___s_t_r_e_a_m__struct.html" title="Master context structure for an ANTLR3 C runtime based input stream." alt="" coords="250,448,476,475"><area shape="rect" href="struct_a_n_t_l_r3___i_n_t___s_t_r_e_a_m__struct.html" title="ANTLR3_INT_STREAM_struct" alt="" coords="67,323,275,349"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r__struct.html" title="ANTLR3_VECTOR_struct" alt="" coords="583,123,762,149"><area shape="rect" href="struct_a_n_t_l_r3___v_e_c_t_o_r___e_l_e_m_e_n_t__struct.html" title="ANTLR3_VECTOR_ELEMENT_struct" alt="" coords="548,5,796,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Definition of a token source, which has a pointer to a function that returns the next token (using a token factory if it is going to be efficient) and a pointer to an ANTLR3_INPUT_STREAM. 
<p>
This is slightly different to the Java interface because we have no way to implement multiple interfaces without defining them in the interface structure or casting (void *), which is too convoluted. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">ANTLR3_COMMON_TOKEN</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#40b1631371c9aa2872f411c691d7348e">eofToken</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special pre-allocated token, which signifies End Of Tokens.  <a href="#40b1631371c9aa2872f411c691d7348e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#c71607f39f82e74a177e44bcada52343">fileName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When the token source is constructed, it is populated with the file name from whence the tokens were produced by the lexer.  <a href="#c71607f39f82e74a177e44bcada52343"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#c1e745731ff025ccd806f6becfb4c4ea">nextToken</a> )(struct <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html">ANTLR3_TOKEN_SOURCE_struct</a> *tokenSource)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a function that returns the next token in the stream.  <a href="#c1e745731ff025ccd806f6becfb4c4ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">ANTLR3_COMMON_TOKEN</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#417f3d7f340e55046200a8dc20bdf5bd">skipToken</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special pre-allocated token, which is returned by <a class="el" href="antlr3lexer_8c.html#e31c6940c452ca2d98ba1e85e2a091c9">mTokens()</a> if the lexer rule said to just skip the generated token altogether.  <a href="#417f3d7f340e55046200a8dc20bdf5bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html">pANTLR3_STRING_FACTORY</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#b65d5aa5431af0423d02ee9777417bd9">strFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whoever is providing tokens, needs to provide a string factory too.  <a href="#b65d5aa5431af0423d02ee9777417bd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#8ea66f6d566682d41b763ff27f6a0916">super</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whatever is supplying the token source interface, needs a pointer to itself so that this pointer can be passed to it when the nextToken function is called.  <a href="#8ea66f6d566682d41b763ff27f6a0916"></a><br></td></tr>
</table>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="40b1631371c9aa2872f411c691d7348e"></a><!-- doxytag: member="ANTLR3_TOKEN_SOURCE_struct::eofToken" ref="40b1631371c9aa2872f411c691d7348e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">ANTLR3_COMMON_TOKEN</a> <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#40b1631371c9aa2872f411c691d7348e">ANTLR3_TOKEN_SOURCE_struct::eofToken</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A special pre-allocated token, which signifies End Of Tokens. 
<p>
Because this must be set up with the current input index and so on, we embed the structure and return the address of it. It is marked as factoryMade, so that it is never attempted to be freed. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00483">setCharStream()</a>, and <a class="el" href="antlr3tokenstream_8c-source.html#l00352">tokLT()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c71607f39f82e74a177e44bcada52343"></a><!-- doxytag: member="ANTLR3_TOKEN_SOURCE_struct::fileName" ref="c71607f39f82e74a177e44bcada52343" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g__struct.html">pANTLR3_STRING</a> <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#c71607f39f82e74a177e44bcada52343">ANTLR3_TOKEN_SOURCE_struct::fileName</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When the token source is constructed, it is populated with the file name from whence the tokens were produced by the lexer. 
<p>
This pointer is a copy of the one supplied by the CharStream (and may be NULL) so should not be manipulated other than to copy or print it. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00483">setCharStream()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c1e745731ff025ccd806f6becfb4c4ea"></a><!-- doxytag: member="ANTLR3_TOKEN_SOURCE_struct::nextToken" ref="c1e745731ff025ccd806f6becfb4c4ea" args=")(struct ANTLR3_TOKEN_SOURCE_struct *tokenSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">pANTLR3_COMMON_TOKEN</a>(* <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#c1e745731ff025ccd806f6becfb4c4ea">ANTLR3_TOKEN_SOURCE_struct::nextToken</a>)(struct <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html">ANTLR3_TOKEN_SOURCE_struct</a> *tokenSource)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a function that returns the next token in the stream. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>.</p>

</div>
</div><p>
<a class="anchor" name="417f3d7f340e55046200a8dc20bdf5bd"></a><!-- doxytag: member="ANTLR3_TOKEN_SOURCE_struct::skipToken" ref="417f3d7f340e55046200a8dc20bdf5bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___c_o_m_m_o_n___t_o_k_e_n__struct.html">ANTLR3_COMMON_TOKEN</a> <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#417f3d7f340e55046200a8dc20bdf5bd">ANTLR3_TOKEN_SOURCE_struct::skipToken</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A special pre-allocated token, which is returned by <a class="el" href="antlr3lexer_8c.html#e31c6940c452ca2d98ba1e85e2a091c9">mTokens()</a> if the lexer rule said to just skip the generated token altogether. 
<p>
Having this single token stops us wasting memory by have the token factory actually create something that we are going to SKIP(); anyway. 
<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b65d5aa5431af0423d02ee9777417bd9"></a><!-- doxytag: member="ANTLR3_TOKEN_SOURCE_struct::strFactory" ref="b65d5aa5431af0423d02ee9777417bd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_n_t_l_r3___s_t_r_i_n_g___f_a_c_t_o_r_y__struct.html">pANTLR3_STRING_FACTORY</a> <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#b65d5aa5431af0423d02ee9777417bd9">ANTLR3_TOKEN_SOURCE_struct::strFactory</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whoever is providing tokens, needs to provide a string factory too. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00483">setCharStream()</a>, and <a class="el" href="antlr3tokenstream_8c-source.html#l00535">toStringSS()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8ea66f6d566682d41b763ff27f6a0916"></a><!-- doxytag: member="ANTLR3_TOKEN_SOURCE_struct::super" ref="8ea66f6d566682d41b763ff27f6a0916" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="struct_a_n_t_l_r3___t_o_k_e_n___s_o_u_r_c_e__struct.html#8ea66f6d566682d41b763ff27f6a0916">ANTLR3_TOKEN_SOURCE_struct::super</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whatever is supplying the token source interface, needs a pointer to itself so that this pointer can be passed to it when the nextToken function is called. 
<p>

<p>Referenced by <a class="el" href="antlr3lexer_8c-source.html#l00072">antlr3LexerNew()</a>, <a class="el" href="antlr3lexer_8c-source.html#l00321">nextToken()</a>, and <a class="el" href="antlr3lexer_8c-source.html#l00208">nextTokenStr()</a>.</p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="antlr3tokenstream_8h.html">antlr3tokenstream.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 29 17:24:07 2010 for ANTLR3C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
