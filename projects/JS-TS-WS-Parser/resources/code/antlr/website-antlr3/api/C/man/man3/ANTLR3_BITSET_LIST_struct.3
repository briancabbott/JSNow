.TH "ANTLR3_BITSET_LIST_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_BITSET_LIST_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3bitset.h>\fP
.PP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBpANTLR3_BITWORD\fP \fBbits\fP"
.br
.RI "\fIPointer to the allocated array of bits for this bit set, which is an array of 64 bit elements (of the architecture). \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBlength\fP"
.br
.RI "\fILength of the current bit set in ANTLR3_UINT64 units. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "\fBpANTLR3_BITWORD\fP \fBANTLR3_BITSET_LIST_struct::bits\fP"
.PP
Pointer to the allocated array of bits for this bit set, which is an array of 64 bit elements (of the architecture). 
.PP
If we find a machine/C compiler that does not know anything about 64 bit values then it should be easy enough to produce a 32 bit (or less) version of the bitset code. Note that the pointer here may be static if laid down by the code generation, and it must be copied if it is to be manipulated to perform followset calculations. 
.PP
Referenced by antlr3BitsetAdd(), antlr3BitsetClone(), antlr3BitsetCopy(), antlr3BitsetEquals(), antlr3BitsetFree(), antlr3BitsetIsNil(), antlr3BitsetLoad(), antlr3BitsetMember(), antlr3BitsetNew(), antlr3BitsetORInPlace(), antlr3BitsetRemove(), antlr3BitsetSize(), and grow().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_BITSET_LIST_struct::length\fP"
.PP
Length of the current bit set in ANTLR3_UINT64 units. 
.PP
Referenced by antlr3BitsetAdd(), antlr3BitsetClone(), antlr3BitsetCopy(), antlr3BitsetEquals(), antlr3BitsetIsNil(), antlr3BitsetLoad(), antlr3BitsetMember(), antlr3BitsetNew(), antlr3BitsetNumBits(), antlr3BitsetORInPlace(), antlr3BitsetSize(), grow(), and growToInclude().

.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
