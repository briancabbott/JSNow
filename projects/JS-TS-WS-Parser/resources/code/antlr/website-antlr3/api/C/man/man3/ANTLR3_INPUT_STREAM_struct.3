.TH "ANTLR3_INPUT_STREAM_struct" 3 "29 Nov 2010" "Version 3.3" "ANTLR3C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ANTLR3_INPUT_STREAM_struct \- 
.SH SYNOPSIS
.br
.PP
\fC#include <antlr3input.h>\fP
.PP
.SH "Detailed Description"
.PP 
Master context structure for an ANTLR3 C runtime based input stream. 
.SS "Data Fields"

.in +1c
.ti -1c
.RI "void *(* \fB_LT\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_INT32\fP lt)"
.br
.RI "\fIPointer to function to return input stream element at 1 based offset from nextChar. \fP"
.ti -1c
.RI "\fBANTLR3_UINT8\fP \fBcharByteSize\fP"
.br
.RI "\fIIndicates the size, in 8 bit units, of a single character. \fP"
.ti -1c
.RI "\fBANTLR3_INT32\fP \fBcharPositionInLine\fP"
.br
.RI "\fIThe offset within the current line of the current character. \fP"
.ti -1c
.RI "void(* \fBclose\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.RI "\fIPointer to function that closes the input stream. \fP"
.ti -1c
.RI "void * \fBcurrentLine\fP"
.br
.RI "\fIPointer into the input buffer where the current line started. \fP"
.ti -1c
.RI "void * \fBdata\fP"
.br
.RI "\fIPointer the start of the input string, characters may be taken as offsets from here and in original input format encoding. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBencoding\fP"
.br
.RI "\fIIndicates the encoding scheme used in this input stream. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP \fBfileName\fP"
.br
.RI "\fIFile name string, set to pointer to memory if you set it manually as it will be \fBfree()\fPd. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBfileNo\fP"
.br
.RI "\fIFile number, needs to be set manually to some file index of your devising. \fP"
.ti -1c
.RI "void(* \fBfree\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetCharPositionInLine\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.RI "\fIPointer to function to return the current offset in the current input stream line. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBgetLine\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.RI "\fIPointer to function to return the current line number in the input stream. \fP"
.ti -1c
.RI "void *(* \fBgetLineBuf\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.RI "\fIPointer to function to return the current line buffer in the input stream The pointer returned is directly into the input stream so you must copy it if you wish to manipulate it without damaging the input stream. \fP"
.ti -1c
.RI "int \fBisAllocated\fP"
.br
.RI "\fIIndicates if the data pointer was allocated by us, and so should be freed when the stream dies. \fP"
.ti -1c
.RI "\fBpANTLR3_INT_STREAM\fP \fBistream\fP"
.br
.RI "\fIInterfaces that provide streams must all provide a generic ANTLR3_INT_STREAM interface and an ANTLR3_INPUT_STREAM is no different. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBline\fP"
.br
.RI "\fIThe line number we are traversing in the input file. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBmarkDepth\fP"
.br
.RI "\fITracks how deep \fBmark()\fP calls are nested. \fP"
.ti -1c
.RI "\fBpANTLR3_VECTOR\fP \fBmarkers\fP"
.br
.RI "\fIList of \fBmark()\fP points in the input stream. \fP"
.ti -1c
.RI "\fBANTLR3_UCHAR\fP \fBnewlineChar\fP"
.br
.RI "\fICharacter that automatically causes an internal line count increment. \fP"
.ti -1c
.RI "void * \fBnextChar\fP"
.br
.RI "\fIPointer to the next character to be consumed from the input data This is cast to point at the encoding of the original file that was read by the functions installed as pointer in this input stream context instance at file/string/whatever load time. \fP"
.ti -1c
.RI "void(* \fBreset\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.RI "\fIPointer to function that resets the input stream. \fP"
.ti -1c
.RI "void(* \fBreuse\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBpANTLR3_UINT8\fP inString, \fBANTLR3_UINT32\fP \fBsize\fP, \fBpANTLR3_UINT8\fP name)"
.br
.RI "\fIPointer to a function that reuses and resets an input stream by supplying a new 'source'. \fP"
.ti -1c
.RI "void(* \fBsetCharPositionInLine\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_UINT32\fP position)"
.br
.RI "\fIPointer to function to set the current position in the current line. \fP"
.ti -1c
.RI "void(* \fBsetLine\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_UINT32\fP \fBline\fP)"
.br
.RI "\fIPointer to function to set the current line number in the input stream. \fP"
.ti -1c
.RI "void(* \fBSetNewLineChar\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_UINT32\fP \fBnewlineChar\fP)"
.br
.RI "\fIPointer to function to override the default newline character that the input stream looks for to trigger the line/offset and line buffer recording information. \fP"
.ti -1c
.RI "void(* \fBsetUcaseLA\fP )(\fBpANTLR3_INPUT_STREAM\fP input, \fBANTLR3_BOOLEAN\fP flag)"
.br
.RI "\fIPointer to function that installs a version of LA that always returns upper case. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP(* \fBsize\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.br
.RI "\fIPointer to function to return the total size of the input buffer. \fP"
.ti -1c
.RI "\fBANTLR3_UINT32\fP \fBsizeBuf\fP"
.br
.RI "\fINumber of characters that can be consumed at this point in time. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING_FACTORY\fP \fBstrFactory\fP"
.br
.RI "\fIString factory for this input stream. \fP"
.ti -1c
.RI "\fBpANTLR3_STRING\fP(* \fBsubstr\fP )(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_MARKER\fP start, \fBANTLR3_MARKER\fP stop)"
.br
.RI "\fIPointer to function to return a substring of the input stream. \fP"
.ti -1c
.RI "void * \fBsuper\fP"
.br
.RI "\fIWhatever super structure is providing the INPUT stream needs a pointer to itself so that this can be passed back to it whenever the api functions are called back from this interface. \fP"
.in -1c
.SH "Field Documentation"
.PP 
.SS "void*(* \fBANTLR3_INPUT_STREAM_struct::_LT\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_INT32\fP lt)"
.PP
Pointer to function to return input stream element at 1 based offset from nextChar. 
.PP
Same as _LA for char stream, but token streams etc. have one of these that does other stuff of course. 
.PP
Referenced by antlr3GenericSetupStream().
.SS "\fBANTLR3_UINT8\fP \fBANTLR3_INPUT_STREAM_struct::charByteSize\fP"
.PP
Indicates the size, in 8 bit units, of a single character. 
.PP
Note that the C runtime does not deal with surrogates as this would be slow and complicated. If this is a UTF-8 stream then this field will be set to 0. Generally you are best working internally with 32 bit characters as this is the most efficient. 
.PP
Referenced by antlr3EBCDICSetupStream(), antlr3GenericSetupStream(), antlr3UTF16SetupStream(), antlr3UTF32SetupStream(), antlr3UTF8SetupStream(), and getText().
.SS "\fBANTLR3_INT32\fP \fBANTLR3_INPUT_STREAM_struct::charPositionInLine\fP"
.PP
The offset within the current line of the current character. 
.PP
Referenced by antlr38BitConsume(), antlr38BitGetCharPosition(), antlr38BitMark(), antlr38BitRewind(), antlr38BitSetCharPosition(), antlr3InputReset(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF32Consume(), antlr3UTF8Consume(), getCharPositionInLine(), and nextTokenStr().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::close\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Pointer to function that closes the input stream. 
.PP
Referenced by antlr3CreateFileStream(), and antlr3GenericSetupStream().
.SS "void* \fBANTLR3_INPUT_STREAM_struct::currentLine\fP"
.PP
Pointer into the input buffer where the current line started. 
.PP
Referenced by antlr38BitConsume(), antlr38BitGetLineBuf(), antlr38BitMark(), antlr38BitRewind(), antlr3InputReset(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF32Consume(), antlr3UTF8Consume(), and emit().
.SS "void* \fBANTLR3_INPUT_STREAM_struct::data\fP"
.PP
Pointer the start of the input string, characters may be taken as offsets from here and in original input format encoding. 
.PP
Referenced by antlr38BitConsume(), antlr38BitLA(), antlr38BitLA_ucase(), antlr38BitReuse(), antlr3CreateStringStream(), antlr3EBCDICLA(), antlr3InputClose(), antlr3InputReset(), antlr3read8Bit(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF16LA(), antlr3UTF16LABE(), antlr3UTF16LALE(), antlr3UTF32Consume(), antlr3UTF32LA(), antlr3UTF32LABE(), antlr3UTF32LALE(), antlr3UTF8Consume(), antlr3UTF8LA(), displayRecognitionError(), and getStartIndex().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_INPUT_STREAM_struct::encoding\fP"
.PP
Indicates the encoding scheme used in this input stream. 
.PP
Referenced by antlr38BitSetupStream(), antlr3EBCDICSetupStream(), antlr3FileStreamNew(), antlr3StringStreamNew(), antlr3UTF16SetupStream(), antlr3UTF32SetupStream(), antlr3UTF8SetupStream(), and setupInputStream().
.SS "\fBpANTLR3_STRING\fP \fBANTLR3_INPUT_STREAM_struct::fileName\fP"
.PP
File name string, set to pointer to memory if you set it manually as it will be \fBfree()\fPd. 
.PP
Referenced by antlr38BitReuse(), antlr3FileStreamNew(), antlr3RecognitionExceptionNew(), antlr3StringStreamNew(), and setCharStream().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_INPUT_STREAM_struct::fileNo\fP"
.PP
File number, needs to be set manually to some file index of your devising. 
.PP
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::free\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Referenced by antlr3GenericSetupStream().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_INPUT_STREAM_struct::getCharPositionInLine\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Pointer to function to return the current offset in the current input stream line. 
.PP
Referenced by antlr3GenericSetupStream(), and antlr3RecognitionExceptionNew().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_INPUT_STREAM_struct::getLine\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Pointer to function to return the current line number in the input stream. 
.PP
Referenced by antlr3GenericSetupStream(), antlr3RecognitionExceptionNew(), and getLine().
.SS "void*(* \fBANTLR3_INPUT_STREAM_struct::getLineBuf\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Pointer to function to return the current line buffer in the input stream The pointer returned is directly into the input stream so you must copy it if you wish to manipulate it without damaging the input stream. 
.PP
Encoding is obviously in the same form as the input stream. 
.PP
\fBRemarks:\fP
.RS 4

.IP "\(bu" 2
Note taht this function wil lbe inaccurate if setLine is called as there is no way at the moment to position the input stream at a particular line number offset. 
.PP
.RE
.PP

.PP
Referenced by antlr3GenericSetupStream().
.SS "int \fBANTLR3_INPUT_STREAM_struct::isAllocated\fP"
.PP
Indicates if the data pointer was allocated by us, and so should be freed when the stream dies. 
.PP
Referenced by antlr38BitReuse(), antlr3CreateStringStream(), antlr3InputClose(), and antlr3read8Bit().
.SS "\fBpANTLR3_INT_STREAM\fP \fBANTLR3_INPUT_STREAM_struct::istream\fP"
.PP
Interfaces that provide streams must all provide a generic ANTLR3_INT_STREAM interface and an ANTLR3_INPUT_STREAM is no different. 
.PP
Referenced by alreadyParsedRule(), antlr38BitLT(), antlr38BitReuse(), antlr38BitRewind(), antlr38BitSetUcaseLA(), antlr3EBCDICSetupStream(), antlr3FileStreamNew(), antlr3GenericSetupStream(), antlr3InputClose(), antlr3RecognitionExceptionNew(), antlr3StringStreamNew(), antlr3UTF16SetupStream(), antlr3UTF32SetupStream(), antlr3UTF8SetupStream(), getCharIndex(), matchAny(), matchc(), matchRange(), matchs(), memoize(), nextTokenStr(), popCharStream(), pushCharStream(), and recover().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_INPUT_STREAM_struct::line\fP"
.PP
The line number we are traversing in the input file. 
.PP
This gets incremented by a newline() call in the lexer grammar actions. 
.PP
Referenced by antlr38BitConsume(), antlr38BitGetLine(), antlr38BitMark(), antlr38BitRewind(), antlr38BitSetLine(), antlr3InputReset(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF32Consume(), antlr3UTF8Consume(), and nextTokenStr().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_INPUT_STREAM_struct::markDepth\fP"
.PP
Tracks how deep \fBmark()\fP calls are nested. 
.PP
Referenced by antlr38BitMark(), antlr38BitRelease(), and antlr3InputReset().
.SS "\fBpANTLR3_VECTOR\fP \fBANTLR3_INPUT_STREAM_struct::markers\fP"
.PP
List of \fBmark()\fP points in the input stream. 
.PP
Referenced by antlr38BitMark(), antlr38BitRewind(), antlr3GenericSetupStream(), antlr3InputClose(), and antlr3InputReset().
.SS "\fBANTLR3_UCHAR\fP \fBANTLR3_INPUT_STREAM_struct::newlineChar\fP"
.PP
Character that automatically causes an internal line count increment. 
.PP
Referenced by antlr38BitConsume(), antlr38BitSetNewLineChar(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF32Consume(), and antlr3UTF8Consume().
.SS "void* \fBANTLR3_INPUT_STREAM_struct::nextChar\fP"
.PP
Pointer to the next character to be consumed from the input data This is cast to point at the encoding of the original file that was read by the functions installed as pointer in this input stream context instance at file/string/whatever load time. 
.PP
Referenced by antlr38BitConsume(), antlr38BitIndex(), antlr38BitLA(), antlr38BitLA_ucase(), antlr38BitMark(), antlr38BitRewind(), antlr38BitSeek(), antlr3EBCDICLA(), antlr3InputReset(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF16Index(), antlr3UTF16LA(), antlr3UTF16LABE(), antlr3UTF16LALE(), antlr3UTF16Seek(), antlr3UTF32Consume(), antlr3UTF32Index(), antlr3UTF32LA(), antlr3UTF32LABE(), antlr3UTF32LALE(), antlr3UTF32Seek(), antlr3UTF8Consume(), antlr3UTF8LA(), nextTokenStr(), and setupInputStream().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::reset\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Pointer to function that resets the input stream. 
.PP
Referenced by antlr38BitReuse(), and antlr3GenericSetupStream().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::reuse\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBpANTLR3_UINT8\fP inString, \fBANTLR3_UINT32\fP \fBsize\fP, \fBpANTLR3_UINT8\fP name)"
.PP
Pointer to a function that reuses and resets an input stream by supplying a new 'source'. 
.PP
Referenced by antlr3GenericSetupStream().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::setCharPositionInLine\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_UINT32\fP position)"
.PP
Pointer to function to set the current position in the current line. 
.PP
Referenced by antlr3GenericSetupStream().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::setLine\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_UINT32\fP \fBline\fP)"
.PP
Pointer to function to set the current line number in the input stream. 
.PP
Referenced by antlr3GenericSetupStream().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::SetNewLineChar\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_UINT32\fP \fBnewlineChar\fP)"
.PP
Pointer to function to override the default newline character that the input stream looks for to trigger the line/offset and line buffer recording information. 
.PP
\fBRemarks:\fP
.RS 4
.IP "\(bu" 2
By default the chracter '
.br
' will be installed as the newline trigger character. When this character is seen by the \fBconsume()\fP function then the current line number is incremented and the current line offset is reset to 0. The Pointer for the line of input we are consuming is updated to point to the next character after this one in the input stream (which means it may become invalid if the last newline character in the file is seen (so watch out).
.IP "\(bu" 2
If for some reason you do not want the counters and pointers to be restee, you can set the chracter to some impossible character such as '' or whatever.
.IP "\(bu" 2
This is a single character only, so choose the last character in a sequence of two or more.
.IP "\(bu" 2
This is only a simple aid to error reporting - if you have a complicated binary input structure it may not be adequate, but you can always override every function in the input stream with your own of course, and can even write your own complete input stream set if you like.
.IP "\(bu" 2
It is your responsiblity to set a valid character for the input stream type. There is no point setting this to 0xFFFFFFFF if the input stream is 8 bit ASCII, as this will just be truncated and never trigger as the comparison will be (INT32)0xFF == (INT32)0xFFFFFFFF 
.PP
.RE
.PP

.PP
Referenced by antlr3GenericSetupStream().
.SS "void(* \fBANTLR3_INPUT_STREAM_struct::setUcaseLA\fP)(\fBpANTLR3_INPUT_STREAM\fP input, \fBANTLR3_BOOLEAN\fP flag)"
.PP
Pointer to function that installs a version of LA that always returns upper case. 
.PP
Only valid for character streams and creates a case insensitive lexer if the lexer tokens are described in upper case. The tokens will preserve case in the token text. 
.PP
Referenced by antlr3GenericSetupStream().
.SS "\fBANTLR3_UINT32\fP(* \fBANTLR3_INPUT_STREAM_struct::size\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input)"
.PP
Pointer to function to return the total size of the input buffer. 
.PP
For streams this may be just the total we have available so far. This means of course that the input stream must be careful to accumulate enough input so that any backtracking can be satisfied. 
.PP
Referenced by antlr3GenericSetupStream(), and displayRecognitionError().
.SS "\fBANTLR3_UINT32\fP \fBANTLR3_INPUT_STREAM_struct::sizeBuf\fP"
.PP
Number of characters that can be consumed at this point in time. 
.PP
Mostly this is just what is left in the pre-read buffer, but if the input source is a stream such as a socket or something then we may call special read code to wait for more input. 
.PP
Referenced by antlr38BitConsume(), antlr38BitLA(), antlr38BitLA_ucase(), antlr38BitReuse(), antlr38BitSize(), antlr3EBCDICLA(), antlr3read8Bit(), antlr3StringStreamNew(), antlr3UTF16Consume(), antlr3UTF16ConsumeBE(), antlr3UTF16ConsumeLE(), antlr3UTF16LA(), antlr3UTF16LABE(), antlr3UTF16LALE(), antlr3UTF32Consume(), antlr3UTF32LA(), antlr3UTF32LABE(), antlr3UTF32LALE(), antlr3UTF8Consume(), and antlr3UTF8LA().
.SS "\fBpANTLR3_STRING_FACTORY\fP \fBANTLR3_INPUT_STREAM_struct::strFactory\fP"
.PP
String factory for this input stream. 
.PP
Referenced by antlr38BitReuse(), antlr38BitSetupStream(), antlr38BitSubstr(), antlr3EBCDICSetupStream(), antlr3FileStreamNew(), antlr3InputClose(), antlr3StringStreamNew(), antlr3UTF16SetupStream(), antlr3UTF16Substr(), antlr3UTF32SetupStream(), antlr3UTF32Substr(), antlr3UTF8SetupStream(), newPoolToken(), setCharStream(), and setInputStream().
.SS "\fBpANTLR3_STRING\fP(* \fBANTLR3_INPUT_STREAM_struct::substr\fP)(struct \fBANTLR3_INPUT_STREAM_struct\fP *input, \fBANTLR3_MARKER\fP start, \fBANTLR3_MARKER\fP stop)"
.PP
Pointer to function to return a substring of the input stream. 
.PP
String is returned in allocated memory and is in same encoding as the input stream itself, NOT internal ANTLR3_UCHAR form. 
.PP
Referenced by antlr3GenericSetupStream(), antlr3UTF16SetupStream(), antlr3UTF32SetupStream(), and getText().
.SS "void* \fBANTLR3_INPUT_STREAM_struct::super\fP"
.PP
Whatever super structure is providing the INPUT stream needs a pointer to itself so that this can be passed back to it whenever the api functions are called back from this interface. 
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for ANTLR3C from the source code.
