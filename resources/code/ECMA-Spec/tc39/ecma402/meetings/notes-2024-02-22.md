# 2024-02-22 ECMA-402 Meeting

## Logistics

### Attendees

- Shane Carr - Google i18n (SFC), Co-Moderator
- Ben Allen - Igalia (BAN)
- Chris de Almeida - IBM (CDA)
- Frank Yung-Fong Tang - Google i18n, V8 (FYT)
- Eemeli Aro - Mozilla (EAO)
- Henri Sivonen - Mozilla (HJS)
- J. S. Choi – Invited Expert (JSC)
- Jesse Alama - Igalia (JMN)
- Louis-Aimé de Fouquières - Invited Expert (LAF)
- Richard Gibson - Agoric / OpenJS Foundation (RGN)
- Ujjwal Sharma - Igalia (USA), Co-Moderator
- Yusuke Suzuki - Apple (YSZ)

### Standing items

- [Discussion Board](https://github.com/tc39/ecma402/projects/2)
- [Status Wiki](https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking) -- please update!
- [Abbreviations](https://github.com/tc39/notes/blob/master/delegates.txt)
- [MDN Tracking](https://github.com/tc39/ecma402-mdn)
- [Meeting Calendar](https://calendar.google.com/calendar/embed?src=unicode.org_nubvqveeeol570uuu7kri513vc%40group.calendar.google.com)
- [Matrix](https://matrix.to/#/#tc39-ecma402:matrix.org)

## Status Updates

### Updates from the Editors

USA: Entering the period for the next edition of ECMA-402. CDA switched the repo from the antiquated “master” branch to the modern “main” branch. Please rebase any PRs

Merged PRs: Meta-update: 867 Replace old references and documentation, meeting notes. Regularized language in the spec for table iteration in DateTimeFormat. 848. Removed unnecessary part of spec that converts keys to lowercase. Several open editorial PRs that are massive improvements to the spec, but may be difficult to review – they are very big. We are working on reviewing them now, but any help on review would be appreciated. That’s it for ECMA-402. Another thing that I can quickly mention is that there are two PRs #863 Add license, #854 publish biblio, likewise in need of reviews. 

RGN: That’s pretty good coverage. We are, or should be, in the opt-out period for the 2024 release. Editorial changes are still allowed; we might be more judicious but we will still accept them. No normative changes included. 

FYT: Will this change how we work on the spec? For example, if we needed to add an additional reference to 262, is there something we need to change in terms of process for future spec writers or PR writers

RGN: I don’t think so. What we’re going to get from this change is automatic inclusion of the 262 bibliography – any 262 reference will automatically be there.

FYT: but also we automatically include our bibliography. 

RGN: That’s the goal.

EAO: One detail about rebasing PRs – that should not be necessary. Github automation should have taken care of all of that.

CDA: EAO is right – none of the PRs from forks need to rebase. Other PR for publishing biblio – the action looks good, but still need to look into shell script. License needs to be updated for that – you can merge the other license – but we still need to update to match 262. I will create a PR to that branch, or create it directly there in order to avoid a merge conflict later.

SFC: Very pleased with the editors for the tooling. Let’s keep it up! Any additional questions for editors?

### Updates from the MessageFormat Working Group

EAO: We spent all of last week working on MessageFormat, calls from Mondays to Thursdays in order to cram in last deliberations in order to get the spec into a shape to get into LDML 45 or CLDR 45 that will come out in April. We are this week cramming in all the changes we’ve agreed upon so that we can include them in the changes. I heartily welcome anyone and everyone to look into the current state of the spec, because many of these are getting locked down over the course of the next week. Now is effectively the latest time to say anything.

Some changes involve dropping `:plural` and instead including just `:number`. We include `:integer` for number with maximum fractional digits set to 0. One change that we made was leaving out for now effectively some of the formatting options from the default number and date/time that are about supporting compound values – a number together with a currency code, or a number together with a unit, or a date/time together with a time zone. Can be implemented, not in the default required set. Will have conversations in MessageFormat WG, but here as well. How do we feel about compound settings that require a unit of a currency coming in as one of the option values. That’s it for the really high-level bits. 

LAF: How will you manage to make this work for date/time in terms of our work with the international format? Nobody, if you just change date and time information, if you change between computers you can use the ISO specifications, which is a good way to change things, but if we do other things it would not be a good idea to fork, if I may say so.

EAO: Effectively by initially supporting an identified subset of the possible literal ways a date/time can be expressed, so that we can be sure not to jump on that. There’s an issue I just linked to here where Addison Philips, chair of the working group, literally today discussing the format for date/time literals, which we need to include, and whether we should base that on [?] or RFC 3339, or the overlap that’s supported by both effectively, and making sure that we don’t make a wrong decision here that would for instance add a requirement for being able to parse a time without a date in JavaScript before Temporal lands.

HJS: Was the HTML syntax for this stuff on the list, when raising XML schema? The HTML spec has syntax for dates, times, and date/times, which are closer to the Web platform than XML schema, and I was wondering if that was discussed as an option, and why XML schema was picked?

EAO: Addison said that the decision was semi-arbitrary on his part. Commenting on the issue would be invaluable for getting us on the right track.

SFC: Thanks. We’ll loop back to MessageFormat later in this call, so if we have more questions for EAO we can save them for that time, or you can reach out to EAO outside this meeting. It’s been a long time coming for MessageFormat to reach this point, so I’m excited to see this progressing.

### Updates from Implementers

https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking

FYT: There is a PR that didn’t get tracked but should be tracked, PR 846. What happened is we all agreed. BAN needs to land the revert of the revert. We need to track it on the track page. Normative PR, we need to track it as 846. 

SFC: BAN should push revert of revert.  We should also make sure we’re not missing any open PRs on this list. It looks like it’s eben a while since there’s been updates on SM and on MDN, so this is a reminder to update the MDN. SM also doesn’t have any updates in this spreadsheet since PR 647, so if that’s something that someone from Mozilla can add, that would be great so that we can all stay in sync. Thank you YSZ for staying on top of JSC, and we need to make sure that all the other PRs need to be tracked.

FYT: Still need test coverage for 846. To be clear, I changed the formatting of this page – used to have a very large table – and now I’m breaking it every ten rows so that at least we know we’re adding, so that we can at least see it without scrolling too much. The recent PR, on the V8 side, I haven’t really changed the implementation to reflect that yet – planning to, but not yet. 

FYT: One particular concern: 788, I think people have special concerns about implementing that one. I think there’s an issue – wait, never mind, this should be another issue.

### Updates from the W3C i18n Group

EAO: Nothing to report

## Proposals and Discussion Topics

https://github.com/tc39/ecma402/projects/2

### DurationFormat Update

https://github.com/tc39/proposal-intl-duration-format/pull/188

BAN: I've completed an extensive refactor of DurationFormat as discussed in TG1. It pulls out handling of numeric types from other types. This simplifies PartitionDurationFormatPattern. I welcome additional reviews. This is my biggest change so far so please be strict. I'm also working on tests which are not ready yet but they should be done by the end of the week. AFAIK that is all that we need on DurationFormat.

USA: I reviewed the PR and thank BAN for the patience. I think FYT's review will be highly valuable given feedback you've left in the past. I wrote the original AO but in hindsight a monolithic AO was not a good approach. Feedback from implementers on how this compares to the previous version would be valuable.

SFC: We also have a Google Summer of Code project approved for DurationFormat in ICU4X. This is a project run by the Google open source team that hosts thousands of contributors to open-source projects, with mentors from open-source organizations. If you’re a student or a mentor to be paired to make progress on open source. 

USA: Quick clarification: it’s no longer limited to just students, though it is mostly students. You likely won’t have difficulty finding students, but I will also share information on it with student organizations I know.

### MessageFormat: Drop string source support #47

https://github.com/tc39/proposal-intl-messageformat/pull/47

(start time = 10:45 PST)

SFC: We have updates and feedback from TG1. 

EAO: Last time we discussed this at this meeting and we went on to present slides https://docs.google.com/presentation/d/1c_6VoCMJdSP59LNYEUTjCNZi8nKEw_GvMQMlvEmD91s/edit?usp=sharing

Currently it’s well-specified and could advance to stage 2, but there are concerns from people in TG1 about introducing a parser, since it is essentially a novel DSL, and significant experience needs to be gained by people and organizations to be able to advance even to stage 2 if it were to continue including the MessageFormat syntax parser. One possibility I mentioned briefly is that the MessageFormat proposal is stacked in a way such that it is possible for us to leave out the MessageFormat 2 message parser, so in order to format a message, you must give it to the constructor as a data structure. A key factor of the data structure as compared to the syntax is that it involves many of the details of how the syntax is formed, and it is decently capable of representing all messages in all current message formatting syntaxes. In this example (from slide) we have a MessageFormat 2 message, a Fluent message, and a [?] message all represented the same. The scope of the data model fits into two slides in the presentation. The specific question I ended up asking after resolving this with the syntax part not able to advance for years, my sense is that if we were to leave it out, there’s preliminary support in TG1 for advancing a first proposal with just a data model. We here need to discuss whether this is something we want to do, or whether some other approach is the best next step here.

USA: My point of view in this group is that it is not completely fair, but I appreciate your doing this job to avoid delaying the work.

EAO: PR  I prepared removing the syntax from the proposal.

SFC: My concern I raised in TG1 which I’ll raise again here is that the proposal with the string syntax is fairly clear in its motivation, since it helps align the Web platform around a message syntax, which is a topic we’ve been working on for time. Without the string syntax it does work toward aligning the Web process to a data model. I don’t think we’ll be successful if our proposal is only motivated if things b and c happen in the future – it should still be motivated in itself. That’s the benchmark I’d like to reach – it’s motivated enough that if we never add anything again, it’s still motivated in itself. This isn’t the outcome I want, but it’s the bar we should be crossing if we make the change to the proposal. I was hoping you’d be able to vocalize what the motivation is, and if the proposal meets the bar without the syntax.

EAO: There are in my view multiple different rationalizations for why this makes sense and how it makes sense even if we aren't able to add additional things to the language on MessageFormatting.

1. I do think that being able to provide a focus point for the runtime and custom functions and other structures this is enabling is really significant, and the specific message of message formatting, is addressed by how we are working through MessageFormat 2, in many many places better than the start of the art in libraries. There are some subtleties around bidirectional handling, and a parts representation for messages that is a very powerful building block going further. These are important.

2. Beyond those, one significant part of this is advancing other localization proposals from around the Web stack. I’m working / trying to work on HTML and DOM localization to advance, and those proposals, should they be able to go forward, will also require some not just declarative and reactive interface, but also an imperative one, and that means that this proposal and the Intl.MessageFormat that it proposes, becomes a requirement for further work on localization for the Web platform. 

Those are the main benefits this proposal brings. Some are achievable by library solutions, but not all of them, and the market penetration for what’s available to everyone is much better through the language. I wanted to add that the cost of stripping out the parser – it’s about 2 kb zipped that is the tax that is added for having the functionality that is removed here.

FYT: Here's my concern. Let's look at the motivation and the benefit it brings to us and the problems it may create. For a message formatter that had the whole functionality compared to whatever remove the syntax thing, in the whole functionality is that the whole thing is in a serialized form, one string representing everything. A lot of time, software can store that string in a database in a condensed form as a string type, and that could be transmitted from an RPC. You transmit through a string to represent the message format, and you send some data to be formatted with that string. What happened with this particular one is that we don’t have that. If we ship a version without that, what would happen to the original one asking for that message format, they will try to find a way to serialize that. If I’m the person, I’ll say I’ll put whatever you have into a JSON format serializer, store it in a database, deserialize it with a JSON parser. What I really need is a seriallized form, but you can’t give it to me, so I use JSON because it’s everywhere. One you’ve shipped the half-baked one people are going to creatively do something like that, because they need serialized form to store the data concisely. Five years later you will have two or three different versions you have to deal with every time. You’re essentially creating a competitor for yourself.  So that's what I worry about: if we push a half-baked solution, some people will find their own solution to solve the other half, therefore reducing the motivation for solving the bigger picture and creating a problem that doesn't exist today.

EAO: I think I understand. 

SFC: Let’s keep the queue. I definitely see where FYT is coming from here. Also, I would like to add that the data model – KGN concerns with having syntax is that syntax is a big DST that’s not proven, and we don’t want to bet a language on an AST that’s not proven. I feel the same way about the data model – it’s very big, and has a lot of nooks and crannies. If we’re okay saying the DST is not proven, why are we okay with saying the data model isn’t proven? I don’t feel comfortable decoupling these things, because they’re both not proven. All I’m saying is that if the bar we have to cross with the rest of the committee is that we need to add something with industry experience, well, the date model doesn’t satisfy either. And I think we can all agree that the motivation is decreased without including the syntax. We still have the problem, but the motivation is lower. That changes the equation.

USA: I just wanted to point out that another potential issue that I can see as a stumbling block that we could hit down the road is a similar kind of discussion that happened when we wanted to do more capabilities in Segmenter. An important point was that while it was well motivated and designed, it wasn’t the right level of abstraction for that technology. I think similar concerns can be raised for MessageFormat without the syntax. The DOM localization work could change all of that. 

EAO: So I recognize absolutely that removing the syntax lowers the value that is presented here, but it also a way to allow for this to advance, and it may be that it will still take time, as we discussed with DurationFormat, proposals take a while. The syntax may be added back in at a later stage of this proposal before it goes to 2.7. I at least would be very, very interested in having at least some steps forward rather than the probably years to get the syntax parser in the shape that it can be advanced. Having heard the concerns here, are we still comfortable advancing this, or are the concerns high enough that we should say that we should not be doing message formatting for the next couple of years?

FYT: Let’s look at one of your examples. (slide 16) We have a message that currently we don’t want to parse, so we’re sending out the following thing. My understanding with MessageFormat is that the developer will have something like the first string, We may need to reorder things, my original assumption that what MessageFormat was. With this change, my question is what you’re going to send to a translator?

EAO: To answer that directly, probably something very much like the MessageFormat v2 syntax that you see at the top. Could be cases where the original price and the placeholder is replaced by whatever is required by the translator tooling or by the translators themselves. One of the key factors with MF v2 work and the data model is that this is defining a data structure that is entirely effective about translated messages between formats. If the developer’s source is a MFv2 string, but they need to be dealing with translators that only include [refer to slides during break]

The data model usage here is specifically only something that would need to happen during the formatting runtime, because the data model itself is making translations between the representations thereof.

SFC: I guess I want to leave actionable feedback here. 

1: There is room for improvement. I appreciate EAO’s comment that the parser is 2.5 kb compressed, that’s nice to have. If we were try to have a MessageFormat data format, what is the size there? That is useful information to have, which could add additional motivation. If we try to build a minified formatter and despite it all the formatter is very big, that could be another piece of motivation. 

Point 2: I’m almost more concerned about stabliizing a non-proven data model than a non-proven syntax. By stabliizing the data model you reduce the amount of flexibility you have with the string. I know that the proposal at stage 1 has both, and I think that’s something we should be thinking about.
My overall conclusion is that we don’t have enough information right now at this call to answer EAO’s question, but we have raised some good points and good food for thought. Perhaps we could bring this conversation back up next month, when we all have additional information.

USA: I completely agree with EAO’s position of dropping the string support if the alternative is delaying everything. If it is possible at all we should try to convince others that they have incorrect notions about this effort, and the lack of decision that we’re demonstrating here is creating exactly the problem that they predict.

RGN: Thinking about the maturity of the data model is valuable, but also it’s not very different from the data model implied by ICU message format, and it’s probably worth highlighting what the differences are and how significant they are. We’re looking at something that’s more similar than it is different.

EAO: You mentioned briefly the minified implementation. An implementation of MessageFormat 2 is about 4kb. No additional data because that’s in the rest of the spec.

SFC: What I’d really like to see in terms of the Web platform is this idea of a message bundle, which is something that ZB put on the table. I was wondering if – Addison came to us several cycles ago saying that there’s this cool long-term vision in W3C that requires this little thing that you guys can push as a dependency. Fully illustrating what the big picture is is useful here.

FYT: ECMAScript has some built-in data types that other languages don’t: BigInt, eight different Temporal types. Is MessageFormat able to support those data types.

EAO: I guess we’re going to continue talking about this a month from now. I hope everyone takes a look at this presentation and the proposal itself, its shape, and we can continue this discussion, hopefully being able to advance by dropping the syntax and getting this proposal somewhere.

SFC: In order to help us more, it would be productive if the people on the call today came back next month with team positions. I’ll work with FYT to align on that, as well as others. If Mozilla and Apple and everyone else can come back with an initial position, that can help us move forward.

### Stable Formatting: Choose between general and specific solutions #17

https://github.com/tc39/proposal-stable-formatting/issues/17

 (start time = 11:16 PST)

EAO: Here is a presentation from TG1. https://docs.google.com/presentation/d/1p1Xgywv1qfY54gnfHUM6PXQafqgf7wY98znxbolmP2c/edit?usp=sharing

Stable Formatting is trying to prevent bad uses of Intl formatters, where users misuse localization output in ways that don’t relate to localization. For example, selecting locales to get ISO 8461 date formatting to happen, to have these side effects effectively of the specific locales we’re supporting for Intl. This proposal was accepted for stage 1. We are trying to figure out what direction we should take the solution in, which is something I’m hoping to discuss here. One is to look for these thific places where we are providing functionality through Intl formatters and other tooling that are useful for non-Intl, non-localization use cases, and finding ways to introduce this functionality in the non-Intl parts of JavaScript, so that there is a better alternative that we can point users toward. This is one direction we can take.

Another possibility here to is define and establish a “null” locale. No new methods, just accept null, provides functionality. We iterated on this in many ways in both this group and TG1 on how to advance this.

That, I feel, will much more closely follow the actual use cases or misuse cases that we’re looking to address here, although it does extend the scope of what ECMA-402 is doing to this non-localized output, hence raising this question here, and wanting to get feedback and opinions on how we could or should be advancing, in order to get the proposal to stage 2 or further.

SFC: I think there’s two directions: 1) the null locale, 2) add actual solutions for all the problems that would bring people to use Stable Formatting. We should identify when we do proposals what are the reasons people might want to use this in a strange way, and then add other APIs to those.I still like the `null` locale, personally, because I think helping developers not do the wrong thing is one of the numerous use cases for this proposal. Implementing an ECMAScript API without having to carry CLDR data is big. For example, XS and those types that don’t embed Intl can start embedding it through this new `null` locale without pulling in l10n. The use case of making it harder for to do the wrong thing and easier to do the right thing, it’s much easier for me to make a PR against their repo to say “change this one line from sv to null” is a much more acceptable change than “I’ll rewrite the whole function to use Temporal.” Even if using Temporal is the right solution, the null locale is better than doing nothing. 

YSZ: My comment is that I think this is kind of like a required feature. We can’t see using NumberFormat to implement a grouping feature for chats or something like that. We can’t direct users to these use cases. One comment I’d like to have is that the output syntax doesn’t just involve the localles, even in English or ‘en’ locales, some of the output is different in MacOS and Android. This means that the output is not just spending on locale, but also depending on the platforms. If we want to define this neutral,  we should determine what is allowed in this output. I don’t think we should just say that [?]

FYT: I think the null locale idea basically means that if people really want to use the right usage, if they want to use the right usage it still depends on the Intl package. But that excludes in the future – if you have a different solution in 262 rather than 402, it’s better to do that again. In reality, we need to move peoples’ code to do the right approach, regardless of Temporal. Web compatibility reality is that websites may need to support browsers that don’t have that yet, so it’s not a simple switch in reality.

SFC: One compelling option for the zxx locale is that it works even today, and would fall back to und-type behavior. I think that that would be reason that when we design the separate proposal we should think about it in a way such that we could have that type of backward compatibility that they have here. One thing we could do to make it web-compatible right now is to say that the zxx locale should have the same information as undefined. This is a big problem we need to solve, but it’s a solvable problem. 
FYT: Currently if you put in a locale that’s not there, the fallback is the default locale, which is not going to be the same locale everywhere. 

EAO: Indeed, if we don’t recognize a locale we end up falling back to the system of und locale. In firefox and chrome, the und locale isn’t available in most cases. This is an aspect of this space that we could perform separate from this proposal. What was mentioned during a call, I think it was in December, which this item was discussed, talking about the formatting of compact numbers using surprising aspects, different from the SI system. 

EAO: Then there are other uses where having the und locale or null or zxx would enable quite powerful usage that requires something like the null locale, emoji collation is only available from the root locale. There are segmenter concerns as well, where having a specific way of accessing the locale implementation would be seriously useful for making the actions of the system predictable.

SFC: To reply to the comment about zxx fallback, the way to follow that is to just, for older browsers, just a one-liner saying “if zxx is available, use that, else use something else.” I think that solves the compatibility problem – it’d just be a one-liner.

LAF: Maybe we instead of letting people find a Swedish or English or invent a new locale, we should make some our tools really international. For example, the ISO calendar should be really international, the way it is standardized here, that would be a big solution.

HSI: In these cases, we have some definition that is international in some sense, for example in collation we have the root collation, for segmentation we have the Annex 29, that’s in its untailored form, but the API doesn’t yet have a way to request the untailored thing. Not having a locale parameter at all falls to host locale, so we need some string that says “I don’t want a locale, I just want the non-tailored thing”

SFC: To respond to LAF on ISO format, CLDR is working on adding ISO calendar as option – that might happen, I hope it does. That does solve that problem, but it falls into “bucket 1” – the problems that we have will have solutions elsewhere in the Web platform. But I think there’s still motivation for this proposal – we can have both. HSI’s point is also well-taken.

EAO: So the sense of the discussion that I’m hearing here is that there is interest in exploring a little but further what a null locale could look like, and what would really be the definitions and behavior of tools with null,, rather than leaving that approach out of consideration. Further work exploring this would be warranted. 

SFC: The read I get – we don’t have ZB, who had concerns last september – but ZB has concerns that it’s not an Intl proposal, so why are we solving it in ECMA-402. The motivation you’re putting forth are good, but one reason we’re not aligned is that people say “there’s a better solution over there! No, it’s over there!” We need a clear statement of why option 2 is good. HSI on tailorings, my points on implementing 402 without carrying ICU, the point that it’s a small change to change existing call points. Maybe we should have a clear statement so that we as a group can align around a clear goal.

EAO: I kind of agree with SFC that it sounds like this proposal as it is is more about the null locale, which is where it started from, and the alternative to this is to keep doing what we’re currently doing, but not necessarily providing a solution for segmenter  or collator where those do have functionality that are locale-independent.

SFC: I’ll be in Europe from March 5 through 20, so that would be a good time to dive deeper into some of these proposals if I could help with that. 

### Decimal integration #856

https://github.com/tc39/ecma402/issues/856

- [Proposal](https://github.com/tc39/proposal-decimal/)

JMN: The idea with Decimal numbers is a thing that has been discussed in the JS community for some time, even back in the 1990s. Right now there’s a proposal, I’m one of the co-champions of this, is to add a new kind of number to JS meant to represent decimal numbers exactly. As we know we’re using decimal notation to write them, but they’re not stored in decimal format. The purpose of the decimal proposal is to add support out of the box for decimal numbers – 0.1 represented exactly, arithmetic operations carried out have exact answers. 0.1 + 0.2 should be exactly 0.3, which would be the case if we do decimal numbers. There've been discussions in the last year at TC39-TG1 about Decimal and got great feedback from a lot of people interested in numbers. One of the great sources of feedback I got was from SFC, who put a lot of time and attention in. If decimal is a new kind of number for JS, then, this will have impact on what we’re doing in internationalization. One question I have for people in this room is what kinds of things should we do. One thing I can tell you is about the data model for decimals. There was discussion of the underlying semantics – should they just be a notation for mathematical values, or do we think of them as digit strings, where all the digits written are significant and we don’t cut them off, not treat 1.0 the same as 1. So those are some discussions we had last year. I'm happy that we settled on the idea of using IEEE Decimal128 after quite a lot of research and development. The most recent version is IEEE 754-2019. This is something that's been around for a while. The idea is 128 bits to represent the decimal value. And that gives us up to 34 significant digits – we don’t care how they’re encoded, the takeaway is there’s a fixed bit width, and if you want to think about it in terms of digits, you have 34. We have here a new kind of number, and when I was familiarizing myself with what was going on with i18n there are a lot of places where numbers come up, notably NumberFormat.

One of the questions I have for you here is are there other places in the 402 world that I should pay attention to? NumberFormat stands out the most, but it may be that I’m overlooking something. Another thing on my mind in terms of writing the spec, restricting the discussion to NumberFormat to keep things concise and focused, if we think about that functionality I can think about a couple of ways I could go.

1. A thin approach. Take decimal values, convert to strings, keep working down the pipeline. There’s already some work there for strings, do we just lean on that?
2. A thick approach. Try to add this as a new kind of value, and work with it systematically throughout. 

Those are my main questions. 1: should we add Decimal to 402, should we take a thick or thin approach, are there places beside NumberFormat where it will be important. Another technical puzzle: we already have 402, and if we were to write spec text, it should be against current 402, or do we write against in-progress NumberFormatv3? These are some questions that I have in my mind – it’s a bit open-ended, I’m curious to hear what your feedback is.

EAO: One small thing to keep in mind in addition to NumberFormat is PluralRules. There’s already a mismatch, BigInts work with NumberFormat but not with PluralRules.

JMN: Thank you, I was not thinking about PluralRules.

SFC: I think the one thing that we should be doing which is a bit novel for us is that the Decimal128 is capable of representing numbers not just as mathematical values but also with their precision, which decimal brings to the table that we weren’t previously able to. Intl.NumberFormat should take the precision that comes from the decimal 128 and bring it through the whole pipeline, including the output. If you’re formatting a scientific value, precision should come from decimal throughout, likewise non-scientific values. For all non-lossy values we should take the precision always through the spec. (minimum/maximum significant and fractional digits). In the absence of a specified precision in the formatting options we should try to take the precision from the input, much like we infer the calendar numbering or system from the locale. 

LAF: +1

FYT: In Intl you may need to change another one, RelativeTimeFormat. “Three days from now”, “three thousand hundred whatever”, but usually an integer number, so probably not a big deal. Definitely from a spec-work point of view it may not need to be there, but I don’t think that’s too important. Just wanted to clarify one thing: NumberFormatv3 is merged, so it’s not a proposal in progress – it’s already in ECMA-402.

JMN: It sounds like if I understood you correctly, SFC, there’s really a good opportunity here to bring decimal in in a thorough or thick way here, because it offers so much data with decimal 128. This dissuades me from the path of just converting it to a string and pumping it down the pipeline, bail out from the decimal world right away. Is that what you’re thinking, a robust, thoroughgoing integration?

SFC: The short answer is "yes." What you’re thinking in terms of a thorough implementation is not rewriting the whole specification, just making sure that what’s called intl mathematical value is capable of carrying the additional information that decimal 128 brings to the table, and to use it whenever available. There may be some things like options handling to consider. You’re not doing a huge refactoring of the spec, you just need to make sure that this additional info flows through the pipeline correctly. 

SFC: My comment regarding PluralRules, I’ve said this before, one of the biggest bug reports we’ve ever received year after year is that in order to PluralRules selection to happen correctly, PluralRules must be run with the same formatting rules as NumberFormat. One of the common places this changes is in the precision handling, because different precision of numbers have different resolved plural rules. At least for the things that are capable of representing this, it’s definitely a big improvement to prevent one of the most common Intl mistakes. 

FYT: This isn’t tied to the proposal, but: since browser engines are implemented in C and C++, it would be nice for us to understand that is there a data type or a library you’d recommend that we may need to go back to ICU to help us in the future a proposal in the side to adapt some data type to have a better native support. 

JMN: There are a couple of C++ libraries (IBM has one called Decarith, Bloomberg has BBe (open source)), and depending on your compiler you may have support for these things out of the box. Gcc has had decimal support as a compiler option for a while now, I think it was recently added to C++, these things slowly move in favor of the developer experiences. There’s libraries I can recommend; they’re part of the proposal. C++ added decimal support last year, I think at their last meeting, and the C people added it a few years ago but I think compilers might be behind. 

FYT: Second part is my opinion about the question with the ECMA-402. I would suggest we take an easier route to try to just make those our ECMA-402 to take this data type without worrying too much so long as most of the refactoring can be done editorial. If we can make this proposal take an easy route to get in, then we can refactor that for editorial changes that might make things easier for you. Some are quite complicated internally – is it better to change everything at once? This could be too complicated.

JMN: Not quite sure I understand – you’re offering an easier path here, and I appreciate that, but I don’t understand what you mean when you say it’s just an editorial change that we can fix up later. 

FYT: Stepping back: those operations can be very complicated.

JMN: I think this might be what SFC has in mind, extending the definition of an Intl decimal.

SFC: Two steps: an editorial refactor where we can plug in this information through the stack, and the decimal proposal should be a small thing. We don’t need to use TG2 time to discuss.

USA: I just want to second that; I think we already have the structure we need to format decimals, with the only caveat being that instead of an ultimate binary storage it is a string, but apart from that I see no difference from an intl mathematical value, aside from the mathematical value having a larger range.

JMN: Sounds great, thanks!

### Era Display: Data-driven approach #9

https://github.com/tc39/proposal-intl-eradisplay/issues/9

SFC: WE have a bug – see issue. There are various issues with this that we found throughout working on the proposal. I brought this to the CLDR committee a couple of weeks ago, and they suggested an approach for moving forward. Luis’s approach was that “if era is current era, hide era field.” Another approach we can take is basically a data-driven approach: where CLDR gives us data that says “by default suppress the era field only between these dates”, the change would be “calendars and eras can specify the range of dates you want to suppress the era for.” This is a strawman for the gregorian calendar – perhaps we want to suppress 1500 to 10000 we want to suppress the era, but for dates outside that range we don’t want to suppress it. Every calendar system can suppress its own range. Common to not suppress BE for Buddhist era, simply to distinguish from Gregorian. 

LAF: A concern is to make things readable to the user. Today it’s hidden; you try to write a date in gregorian calendar, you don’t have the era, you try to write the same date in the buddhist calendar. If you’re in france and you express a date in the buddhist calendar it’s good to distinguish it from the gregorian calendar. The problem we have is to give more possibilities to the author to challenge or monitor the way the data is displayed. Even if you are dealing with dates (christmas before common era) you don’t need to express BC, because you’re in the context of ancient history. In short, yes, we should have an expressed options in CLDR, but we will still have the need for an option for the [?]

FYT: Should this be part of the locale data?

SFC: Currently proposed as supplemental data. Possibly this should be locale-specific too. 

FYT: You express that as a value, but what does “1500” mean? If Japanese era it could be 2. We’re not talking about the year in a gregorian calendar but a year in that particular calendar and also that particular era. 

SFC: What’s shown on the screen is not something going into an ECMAScript standard; this is CLDR, and our job is not to bikeshed this. I’m just saying that this is the type of data that could be added, and reflected in era display auto. LAF, what you said about additional use cases, you brought an update in December, also you should push an update to the proposal based on this new information so we can discuss this next month. 

FYT: So all we’re trying to determine is what happens when the display is “auto”. We can force it to turn on, we can force it to turn off, but this is unrelated to that.

SFC: This is behavior for era display: auto

LAF: Last month I tried to open two more values to the option, make it possible to say “I want the era even though no one would display it” or “I don’t want the era even if you should display it.” There could be ways to make things visible within CLDR that could help the implementation of the option. 

### Brief User Locale Preferences update

BAN: The proposal has evolved dramatically since we last spoke. We cut some of it to go to a version that YSZ had discussed a few months ago. We were focused on identifying 1-10 variants per locale that couldn't individually identify the user. We are at a crossroads. We could first start by deciding which level of surprisal/entropy is acceptable. We could instead gather the data to set our sense of what is or is not acceptable. It seems CLDR is the place to do that.

SFC: Both HSI and YSZ are on this call, and I want to make sure that the direction we move is productive. I’ve had discussion with many people on this call about the motivation here. Most especially HSI has concerns whether this motivation rises to the appropriate level. Data gathering could address this issue, making sure that HSI and YSZ will stay in the loop, making sure that any additional data-gathering measure could lead to a potentially productive solution. 

YSZ: I want to be direct that our main focus is privacy of this thing; We already agree that this is useful, but from a privacy/security perspective… There's a high chance that without carefully crafting this, there's a high chance that we could hit privacy issues.

### Editorial: Rename _dataLocaleData_ aliases to the more accurate _resolvedLocaleData_ #849

https://github.com/tc39/ecma402/pull/849

RGN: The idea here is to resolve something that’s a bit confusing in the current spec. A representative example is in CreateDateTimeFormat  is that we:

_localeData_ is stored in a slot inaccessible to user code.
_localeData_ is used essentially as a dictionary from localeIdntifier to the dictionary we actually care about.

Right now _localeData_ refers to the big dictionary. where the key is the locale data, and the dictionary that is associated with each of these keys is _dataLocaleData_. _dataLocaleData_ doesn’t really mean anything; the proposal is to call it _resolvedLocaleData_, i.e. data about the resolved local. If we’re tracking the flow, we have use of the ReolveLocale AO to get _r_, the result of ResolveLocale, [[DataLocale]] is a field on this, the locale that ResolveLocale came out with, this is used as the key in this resolved data map. This is purely editorial, doesn’t alter the status of any steps, simply we’re using an alias that better reflects what it is. 

FYT: Why discuss it here?

RGN: There’s some discussion on the PR itself: BAN is in favor, SFC is not strongly in any direction, and Anba proposed a more comprehensible change removing _dataLocale_ entirely.

SFC: I think that anba’s direction (853) is more the direction to go here. The current name _dataLocaleData_ is more correctly representative, since we have a variable called _dataLocale_. I agree that resolvedLocale makes sense than dataLocale, so I agree that we can just rename it to resolvedLocale. Perhaps Anba went a little too far, but I think overall that Anba’s approach is probably the base that we should be using here. 

FYT: Quick question: those are all local variables?

SFC: Yeah.

RGN: in the name of forward progress, can we agree on landing the smaller one while digesting Anba’s version. 

SFC: I do have concerns because I think _dataLocaleData_ is better than _resolvedLocaleData_, unless we change both _dataLocale_ and _dataLocaleData_. 

RGN: So there’s two different uses of _dataLocale_: a field name, and also an alias name. 

SFC: Ideally we change the resolved name, but if we’re not changing the resolved name then at least changing the local alias names. I would support the PR even if we just changed the local alias names. I think it’s better to just do the full change, all at once, like Anba’s proposal, but if you really must split them, I’m comfortable changing the alias names in one PR and the field names in another.

RGN: I’m comfortable with that. Everywhere ResolveLocale is invoked, I’m seeing the same kind of pattern. Willing to check more aliases. There are likely not a lot of uses referencing the field name, more than I thought though. The extra ones are just describing slots that exist, which aren’t even the same thing. Maybe I will just rename it to avoid having miniscule/majiscule D being the only thing distinguishing a field name from a slot name. 
