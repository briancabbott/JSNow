---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4334,"creation_ts":"2015-04-24 13:39:00 -0700","short_desc":"Abrupt completion discarded in native collection constructors","delta_ts":"2015-05-19 15:59:34 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 38: April 14, 2015 Final Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":"mike","assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":14325,"comment_count":0,"who":"mike","bug_when":"2015-04-24 13:39:20 -0700","thetext":"The constructors for Map, Set, WeakMap, and WeakSet all accept an optional\n`iterable` parameter. This is used to create an iterator, and each of the\niterator's values is inserted into the collection's internal data structure\nusing the appropriate instance method (`add` in the case of Set and WeakSet,\n`set` in the case of Map and WeakMap), aliased as `adder`.\n\nAll implementations have a provision for behavior when the `adder` returns an\nabrupt completion: they close the iterator and return the result of that\noperation. For example, from Set [1]:\n\n> 23.2.1.1 Set ( [ iterable ] )\n> ...\n> 6. If iterable is either undefined or null, let iter be undefined.\n> 7. Else,\n>    a. Let adder be Get(set, \"add\").\n>    b. ReturnIfAbrupt(adder).\n>    c. If IsCallable(adder) is false, throw a TypeError exception.\n>    d. Let iter be GetIterator(iterable).\n>    e. ReturnIfAbrupt(iter).\n> 8. If iter is undefined, return set.\n> 9. Repeat\n>    ...\n>    f. Let status be Call(adder, set, «nextValue.[[value]]»).\n>    g. If status is an abrupt completion, return IteratorClose(iter, status).\n\nThis sequence means if `Set.prototype.add` throws an error, the constructor\ninvocation may execute without throwing. In code:\n\n    var s;\n    Set.prototype.add = function() { throw new Error(); };\n    s = new Set([1]);  // No error thrown here\n    s.size === 0;      // true\n\nIt seems wise to close the iterator regardless of \"status\", but I think that if\nstatus is an abrupt completion, this should be forwarded.\n\n> 9. Repeat\n>    ...\n>    f. Let status be Call(adder, set, «nextValue.[[value]]»).\n>    g. If status is an abrupt completion, then\n>       i. IteratorClose(iter, status).\n>       ii. return status\n\nThis pattern demonstrates the same behavior (an abrupt completion from\nIteratorClose is ignored), but it only does so in cases where an abrupt\ncompletion is already positioned to be returned."},{"commentid":14326,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-04-24 14:40:34 -0700","thetext":"(In reply to mike from comment #0)\n...\n> 9. Repeat\n>    ...\n>    f. Let status be Call(adder, set, «nextValue.[[value]]»).\n>    g. If status is an abrupt completion, return IteratorClose(iter, status).\n...\n> \n>     var s;\n>     Set.prototype.add = function() { throw new Error(); };\n>     s = new Set([1]);  // No error thrown here\n>     s.size === 0;      // true\n> \n> It seems wise to close the iterator regardless of \"status\", but I think that\n> if\n> status is an abrupt completion, this should be forwarded.\n\nNo, that's not the iterator protocol WRT 'return'.  'Return' is only called if a iterator driven loop terminates early.  It is not called on iterator exhaustion. See http://people.mozilla.org/~jorendorff/es6-draft.html#table-54 and also the for-of evaluation semantics.\n\nIf status is an abrupt completion, it will indeed normally the the value that is returned in 9.g, because:\n\n> \n> > 9. Repeat\n> >    ...\n> >    f. Let status be Call(adder, set, «nextValue.[[value]]»).\n> >    g. If status is an abrupt completion, then\n> >       i. IteratorClose(iter, status).\n> >       ii. return status\n\nreturn IteratorClose(iter, status)\n\nessentially does the same as your steps g.i-ii above.  See http://people.mozilla.org/~jorendorff/es6-draft.html#sec-iteratorclose \n\nIf iter does not have a 'return' method, IteratorClose returns status. It also returns status if the 'return' method is called, regardless of whether 'return' has a normal or abrupt completion. The only cases where it doesn't return status is if an internal protocol violation is detected. \n\n> \n> This pattern demonstrates the same behavior (an abrupt completion from\n> IteratorClose is ignored), but it only does so in cases where an abrupt\n> completion is already positioned to be returned."},{"commentid":14327,"comment_count":2,"who":"mike","bug_when":"2015-04-24 15:35:39 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #1)\n> (In reply to mike from comment #0)\n> > > 9. Repeat\n> > >    ...\n> > >    f. Let status be Call(adder, set, «nextValue.[[value]]»).\n> > >    g. If status is an abrupt completion, then\n> > >       i. IteratorClose(iter, status).\n> > >       ii. return status\n> \n> return IteratorClose(iter, status)\n> \n> essentially does the same as your steps g.i-ii above.  See\n> http://people.mozilla.org/~jorendorff/es6-draft.html#sec-iteratorclose \n> \n> If iter does not have a 'return' method, IteratorClose returns status. It\n> also returns status if the 'return' method is called, regardless of whether\n> 'return' has a normal or abrupt completion. The only cases where it doesn't\n> return status is if an internal protocol violation is detected. \n\nIt's not the behavior of the `return` method that I am concerned about. It is\nwhen the \"adder\" function (Set.prototype.add in the running example) itself\nthrows an error. Under these conditions, the abrupt completion is referenced\nto decide whether IteratorClose should be called. But after that, it is\ndiscarded--the constructor returns the completion of IteratorClose instead.\n\nThis means that it is possible for a normal completion to be returned from the\nconstructor even when Call(adder, set, «nextValue.[[value]]») returns an\nabrupt completion."},{"commentid":14328,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-04-24 18:12:45 -0700","thetext":"(In reply to mike from comment #2)\n\n> \n> It's not the behavior of the `return` method that I am concerned about. It is\n> when the \"adder\" function (Set.prototype.add in the running example) itself\n> throws an error. Under these conditions, the abrupt completion is referenced\n> to decide whether IteratorClose should be called. But after that, it is\n> discarded--the constructor returns the completion of IteratorClose instead.\n\nNope, the abnormal completion from the add call ('status') is passed as the second argument into IteratorClose and that completion record is what is returned usually returned as the conpletion value of IteratorClose and then returned as the completion value of the Set function.\n\n> \n> This means that it is possible for a normal completion to be returned from\n> the\n> constructor even when Call(adder, set, «nextValue.[[value]]») returns an\n> abrupt completion.\n\nNope, see http://people.mozilla.org/~jorendorff/es6-draft.html#sec-iteratorclose .\n\nIf the value passed ;as the second argument to IteratorClose is an abrupt completion (and it always is) there is no path through IteratorClose that returns a normal completion.\n\nWhat about the expression of IteratorClose or the Set/etc. algorithms mades this difficult for you to see? What would make it clearer for you? Would it be clearer if step g said:\n  g. If status is an abrupt completion, return Completion(IteratorClose(iter, status))."},{"commentid":14329,"comment_count":4,"who":"mike","bug_when":"2015-04-25 10:27:46 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #3)\n> Nope, the abnormal completion from the add call ('status') is passed as the\n> second argument into IteratorClose and that completion record is what is\n> returned usually returned as the conpletion value of IteratorClose and then\n> returned as the completion value of the Set function.\n\nAh, now I understand.\n\n> What about the expression of IteratorClose or the Set/etc. algorithms mades\n> this difficult for you to see? What would make it clearer for you? Would it\n> be clearer if step g said:\n>   g. If status is an abrupt completion, return\n> Completion(IteratorClose(iter, status)).\n\nThanks for offering an alternative, but I don't think that version would\nhave helped me in this case. It was/is very clear to me that the completion\nfrom IteratorClose is being returned in 9.g. The piece I was missing was how\nIteratorClose accepts status and returns it again. I don't have any\nsuggestions on how to make this detail clearer; in this case, the problem\ncomes down to a careless reading. I appreciate your patience (as always) and\napologize for the noise!"}]}}
---
