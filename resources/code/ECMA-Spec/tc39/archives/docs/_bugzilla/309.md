---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":309,"creation_ts":"2012-03-15 12:15:00 -0700","short_desc":"Community Feedback on Harmony Math functions proposal","delta_ts":"2015-10-02 14:36:15 -0700","product":"Harmony","component":"proposals","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","see_also":["https://bugs.ecmascript.org/show_bug.cgi?id=262","https://bugs.ecmascript.org/show_bug.cgi?id=314"],"priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"allen","name":"Allen Wirfs-Brock"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["alex","jens","lukeh","roger.andrews","utatane.tea"],"long_desc":[{"commentid":766,"comment_count":0,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-03-15 12:15:21 -0700","thetext":"This item is for tracking community feedback and feature requests relating to the the Harmony Math related proposals (http://wiki.ecmascript.org/doku.php?id=harmony:more_math_functions and others ).\n\nAnybody with such feedback should record it as a comment on this bug."},{"commentid":767,"comment_count":1,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-15 13:08:50 -0700","thetext":"\n> This item is for tracking community feedback and feature requests relating to\n> the the Harmony Math related proposals\n> (http://wiki.ecmascript.org/doku.php?id=harmony:more_math_functions and others\n> ).\n> \n> Anybody with such feedback should record it as a comment on this bug.\n\nHas anyone considered setting limits for the maximum error of different functions?\n\nMost of the added functions in that proposal are quite a bit less useful unless the results are guaranteed to be better than just implementing them in JS. Accuracy currently varies a bit between browsers (and platforms) which is a bit annoying."},{"commentid":773,"comment_count":2,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-16 14:36:04 -0700","thetext":"(In reply to comment #1)\n> Has anyone considered setting limits for the maximum error of different\n> functions?\n> \n> Most of the added functions in that proposal are quite a bit less useful unless\n> the results are guaranteed to be better than just implementing them in JS.\n> Accuracy currently varies a bit between browsers (and platforms) which is a bit\n> annoying.\n\nAgreed.\n\nThe whole point of Math.log2, Math.log10, Math.log1p, Math.expm1 is to be more accurate than the user could achieve with a simplistic approach.\nMath.hypot too should accurately control cancellation errors (as well as avoiding overflow and managing Infinity).\nMath.cbrt (if it comes to pass) also manages accuracy.\n\nIt should be possible to make a 1 ULP guarantee to most (all?) Math functions, though the exact nature of this issue is assumed to be a \"hard problem\" in computer science.\n\nSee also the Table Maker's Dilemma:\nhttp://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma"},{"commentid":775,"comment_count":3,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-16 14:55:53 -0700","thetext":"(In reply to comment #2)\n> (In reply to comment #1)\n> > Has anyone considered setting limits for the maximum error of different\n> > functions?\n> > \n> > Most of the added functions in that proposal are quite a bit less useful unless\n> > the results are guaranteed to be better than just implementing them in JS.\n> > Accuracy currently varies a bit between browsers (and platforms) which is a bit\n> > annoying.\n> \n> Agreed.\n> \n> The whole point of Math.log2, Math.log10, Math.log1p, Math.expm1 is to be more\n> accurate than the user could achieve with a simplistic approach.\n> Math.hypot too should accurately control cancellation errors (as well as\n> avoiding overflow and managing Infinity).\n> Math.cbrt (if it comes to pass) also manages accuracy.\n> \n> It should be possible to make a 1 ULP guarantee to most (all?) Math functions,\n> though the exact nature of this issue is assumed to be a \"hard problem\" in\n> computer science.\n> \n> See also the Table Maker's Dilemma:\n> http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma\n\nWhile it is correct that the \"Table Maker's Dilemma\" is a problem for general transcendental functions, I think that the ones currently proposed could be correctly rounded; I did a quick check through the IEEE 754-2008 standard and most (if not all) functions are on 'Recommended correctly rounded functions 9.2.0' list."},{"commentid":781,"comment_count":4,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-16 16:13:26 -0700","thetext":"Re: Special Values in the es6libraryextensions.pdf document\n\nNote that sometimes the text has \"if x is +0 or -0\" other times both cases are enumerated even if the result is the same.  Maybe choose one style or the other for consistency.\n\nThis document has a couple of issues in the Special Values of new Math functions:\n\nMath.acosh\n   add new line \"If x is -Inf, the result is +Inf\"\nMath.expm1(−Inf)  -> −1\n   as already noted in Harmony bug 262\nMath.hypot\n   the statement \"the result is y\" is incorrect, result should be abs(y);\n   also, the check for infinite x or y should be done before the check for NaN\n   for IEEE754 conformance (see below)\n\n\nIEEE754 has hypot of +/-Infinity with anything (even NaN) as +Infinity:\n    hypot(Infinity,NaN) == hypot(NaN,-Infinity) == ... == Infinity\n\nThis is similar to the existing Math.pow which conforms to IEEE754 handling of the indefinite number NaN:\n    Math.pow(NaN,0)  -> 1\n(which is correct since pow(x,0)==1 for all x)."},{"commentid":782,"comment_count":5,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-16 17:29:46 -0700","thetext":"Re: Math.hypot\n\nThere seems to be agreement on making Math.hypot variadic: Math.hypot(x,y,z,...)\n\nThe use cases in 3D geometry etc are obvious.\n\nProbably the function's arity should remain 2 (Math.hypot.length==2).  If given no arguments the return value should probably be 0 (not NaN), although what meaning does the Euclidean distance have in a 0-dimensional space?\n\n\nThe documentation of Math.hypot should point out that hypot avoids overflow\nand minimises rounding errors.  Otherwise people might be tempted to naively use Math.sqrt on the sum of the squares.  This is easily implemented by dividing through by the largest argument then multiplying back at the end (see pseudocode below).\n\nAs noted in comment 4 above, the hypot of +/-Infinity with anything (even NaN) should be +Infinity.\n\nPseudocode implementation:\n   scan the arguments noting the maximum absolute value, maxabs;\n   if (maxabs is infinite)  return Infinity;\n   if (any of the arguments was NaN)  return NaN;\n   if (maxabs == 0)  return 0;\n   divide each argument by maxabs;\n   take the sqrt of the sum of the squares of the arguments, r;\n   return r * maxabs;\n\nThere are a couple of speedups possible, such as the early detection of arguments.length being 0 or 1.  Otherwise take care of the value of maxabs if there are no arguments.  You might also want to sum the squared arguments from smallest to largest in an attempt to squeeze a little extra precision."},{"commentid":783,"comment_count":6,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-16 18:19:18 -0700","thetext":"Re: proposed new function Math.cbrt\n\nSeveral math libraries have the cube-root elementary function: cbrt.\nThe proposal is for JavaScript to follow suit.\n\ncbrt is more accurate than pow(x,1/3) and does not have a domain error for x<0.\nUnlike pow() it has the special values:\n    Math.cbrt(-0)  -> -0\n    Math.cbrt(-Infinity)  -> -Infinity\nbecause it is an odd function and therefore has rotational symmetry about the Origin (like sin(), tan(), etc).\n\nSpecific use cases were not given, but observe that cbrt is arguably almost as generally useful as sqrt.  cbrt handles a negative domain (x<0) with no nasty drama, unlike pow which returns NaN - forcing the user to check and correct before invoking.\n\n\nComparing against Math.pow:\n1) cbrt is more explicit about -0 and -Infinity, whereas pow deals with the\n   general case.  (Note that sqrt is also explicit about -0.)\n2) cbrt correctly handles a negative domain (x<0) with no nasty drama,\n   whereas pow returns NaN.\n3) Obviously, cbrt is more accurate than pow since 1/3 is not exact in\n   floating-point, and the error compounds internally.\n\n\nI offer the following implementation of Math.cbrt ...\n\nMath.cbrt = function (x)\n{\n  x = +x;    // guard against non-numeric\n\n  // handle NaN, infinities, zeroes -- thus avoid Inf/Inf and 0/0\n\n  if (isNaN( x/x ))  return x;\n\n  // estimate the cube root well;\n  // then improve by Halley's Method (more accurate ULP than Newton's!)\n\n  var r = Math.pow( Math.abs(x), 1/3 );\n  var t = x/r/r;    // safe!\n  return r + (r * (t-r) / (2*r + t));\n};"},{"commentid":784,"comment_count":7,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-17 02:32:43 -0700","thetext":"Re: rename Math.sign to Math.signum\n\nThere isn't overwhelming precedent in either direction here.  To the extent there is precedent, it seems slightly in favor of 'sign', and it's slightly less cryptic. \n\nOne could argue that it's an advantage to be slightly more cryptic while remaining within well-accepted norms, see point 2 below.\n\nThe sign function complements the abs (magnitude) function.\n\n\nThe case for 'signum':\n\n1) Clearly the word \"sign\" has meaning on the Real line, but think of the Complex plane where the range of the \"sign\" function is the union of a circle of Unit Magnitude (note: UM) and the zeroes.  A complex number, z, in polar coordinates has a magnitude/modulus/amplitude, r, and an argument/phase, theta; where r=abs(z) and theta=sign[um](z).\n\n2) Also, the so-called \"sign\" function actually returns information about the magnitude as well as the +/- sign when the magnitude is a 0, and always implicitly returns the zero/nonzero status of the magnitude:\n      Math.sign[um](-0)  -> -0\n      Math.sign[um](0)  -> 0\n\n3) JavaScript often seems to follow Java's philosophy, and Java has 'signum'.\n\n4) Wikipedia says 'signum' is to avoid confusion with the sine function, (but maybe it isn't sufficiently confusing!):\nhttp://en.wikipedia.org/wiki/Sign_function\n\n\nThe case for 'sign':\n\n5) It is the actual mathematical name for the function.\n\n6) The function is already currently called 'sign', just stick with that.\n\n7) Fewer characters to type.\n\n8) Less cryptic.\n\n\nThis is pretty vague, but 'signum' just feels to me better than 'sign', in the light of the above.  (But it is a 50-50 call!)\n\n\nPS:\nHere is an implementation that works with +0 and -0 and NaN and non-numerics ...\n\n    function(x) { return (x>0)? 1 : (x<0)? -1 : +x; }"},{"commentid":785,"comment_count":8,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-17 02:49:05 -0700","thetext":"(In reply to comment #5)\n> Re: Math.hypot\n> \n> There seems to be agreement on making Math.hypot variadic:\n> Math.hypot(x,y,z,...)\n> \n> The use cases in 3D geometry etc are obvious.\n> \n> Probably the function's arity should remain 2 (Math.hypot.length==2).  If given\n> no arguments the return value should probably be 0 (not NaN), although what\n> meaning does the Euclidean distance have in a 0-dimensional space?\n> \n> \n> The documentation of Math.hypot should point out that hypot avoids overflow\n> and minimises rounding errors.  Otherwise people might be tempted to naively\n> use Math.sqrt on the sum of the squares.  This is easily implemented by\n> dividing through by the largest argument then multiplying back at the end (see\n> pseudocode below).\n> \n> As noted in comment 4 above, the hypot of +/-Infinity with anything (even NaN)\n> should be +Infinity.\n> \n> Pseudocode implementation:\n>    scan the arguments noting the maximum absolute value, maxabs;\n>    if (maxabs is infinite)  return Infinity;\n>    if (any of the arguments was NaN)  return NaN;\n>    if (maxabs == 0)  return 0;\n>    divide each argument by maxabs;\n>    take the sqrt of the sum of the squares of the arguments, r;\n>    return r * maxabs;\n> \n> There are a couple of speedups possible, such as the early detection of\n> arguments.length being 0 or 1.  Otherwise take care of the value of maxabs if\n> there are no arguments.  You might also want to sum the squared arguments from\n> smallest to largest in an attempt to squeeze a little extra precision.\n\nI am still against it, mildly, only because the name does no longer make sense in my opinion. It does no longer calculate the hypotenuse of a right-angled triangle. Why not add both hypot (2-arity) and norm2 with an array argument?\n\nPossibly adding at the same time, add some more vector functions from BLAS L1. They have fast implementations on all platforms and many of them are quite obviously useful for games."},{"commentid":792,"comment_count":9,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-17 07:51:06 -0700","thetext":"Re: variadic Math.hypot\n\n> I am still against it, mildly, only because the name does no longer make sense\n> in my opinion. It does no longer calculate the hypotenuse of a right-angled\n> triangle. Why not add both hypot (2-arity) and norm2 with an array argument?\n> \n> Possibly adding at the same time, add some more vector functions from BLAS L1.\n> They have fast implementations on all platforms and many of them are quite\n> obviously useful for games.\n\nThe Math library contains the elementary mathematical functions (plus a couple of numeric functions that sneaked in).\n\nI would love to see a BLAS library, and LAPACK, taking array-like vectors & matrices as arguments.  But not in the 'Math' namespace.  (If you know of a BLAS lib please private-email me.)\n\n3-adic 'hypot' (or whatever it's called) is useful in basic 3D geometry for those who don't want to go the whole Linear Algebra route.  Not least in converting rectangular x-y-z coordinates into spherical lat-lng-alt -- [this is nice for dealing with other 3D spaces such as colorspace, map grid conversion, astronomy (especially heliocentric coordinates), others?].\n\nI'd be happy with a 'hypot' that is restricted to have either 2 or 3 arguments.\n\n\nThe name \"hypot\" is well-established in 2D and could easily be extended to 3D, but what would you call it?\n\nThe word \"norm2\" invites people to think of general vectors not coordinates (i.e. position vectors).  And it sounds a bit funny when it takes 3 arguments (cf. 'atan2').  It also invites the question: if you've got 2-norms why not 1-norms and Inf-norms and ...\n\nOther words could be based on \"Euclidean distance\" or \"radius vector\" or even \"proper length\".  But nothing really jumps out as very pleasant or better than boring old standard \"hypot\".\n\nI've seen 3-adic 'hypot' called \"hypot3\" in places.  But why invent a new name when JavaScript easily copes with variable arguments?\n\nWould you really want a different name for the 3D version of the simple 2D sqrt(x*x+y*y) concept?"},{"commentid":793,"comment_count":10,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-17 07:57:45 -0700","thetext":"(In reply to comment #4)\n> Re: Special Values in the es6libraryextensions.pdf document\n> \n> Math.acosh\n>    add new line \"If x is -Inf, the result is +Inf\"\n\nWhoops, that line should not be added (I was thinking of cosh).\nacosh(-Inf) is of course a domain error (x<1)."},{"commentid":794,"comment_count":11,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-17 08:07:35 -0700","thetext":"(In reply to comment #9)\n> Re: variadic Math.hypot\n> \n> The Math library contains the elementary mathematical functions (plus a couple\n> of numeric functions that sneaked in).\n> \n> I would love to see a BLAS library, and LAPACK, taking array-like vectors &\n> matrices as arguments.  But not in the 'Math' namespace.  (If you know of a\n> BLAS lib please private-email me.)\n\nI agree, vectors should not be stuck in Math. (And probably would depend on something like Typed Arrays)\n\n> 3-adic 'hypot' (or whatever it's called) is useful in basic 3D geometry for\n> those who don't want to go the whole Linear Algebra route.  Not least in\n> converting rectangular x-y-z coordinates into spherical lat-lng-alt -- [this is\n> nice for dealing with other 3D spaces such as colorspace, map grid conversion,\n> astronomy (especially heliocentric coordinates), others?].\n> \n> I'd be happy with a 'hypot' that is restricted to have either 2 or 3 arguments.\n\nIt is definitely a useful operation.\n\n> The name \"hypot\" is well-established in 2D and could easily be extended to 3D,\n> but what would you call it?\n> \n> The word \"norm2\" invites people to think of general vectors not coordinates\n> (i.e. position vectors).  And it sounds a bit funny when it takes 3 arguments\n> (cf. 'atan2').  It also invites the question: if you've got 2-norms why not\n> 1-norms and Inf-norms and ...\n\nThat was the intention and was just something I was throwing around together with L1 BLAS, which would add those other norms etc.\n\n> Other words could be based on \"Euclidean distance\" or \"radius vector\" or even\n> \"proper length\".  But nothing really jumps out as very pleasant or better than\n> boring old standard \"hypot\".\n\nI agree, if there is nothing significantly better than that, then 'hypot' is a good compromise.\n\n> I've seen 3-adic 'hypot' called \"hypot3\" in places.  But why invent a new name\n> when JavaScript easily copes with variable arguments?\n> \n> Would you really want a different name for the 3D version of the simple 2D\n> sqrt(x*x+y*y) concept?\n\nI agree that there is no point in creating an additional 'hypot3' because then  we just create a confusing variadic 'hypot' with a weird implementation."},{"commentid":797,"comment_count":12,"who":{"uid":"alex","name":"Alexander Zeilmann"},"bug_when":"2012-03-17 11:20:41 -0700","thetext":"> The name \"hypot\" is well-established in 2D and could easily be extended to 3D,\n> but what would you call it?\nThe hypot function is sometimes also called Pythagorean sum/addition.\n(http://en.wikipedia.org/wiki/Pythagorean_addition)\nMoler and Morrison (They found an algorithm for hypot without taking square roots, link to their paper in the Wikipedia article) call this function \"pythag\". But I don't like this name very much, I'd stick with hypot and make it variadic (even if hypotenuse isn't making sense for three or more arguments).\n\n> I'd be happy with a 'hypot' that is restricted to have either 2 or 3 arguments.\nMoler and Morrison made an other interesting point in their paper; they calculate the hypot function with more than two arguments recursively\n   hypot(a, b, c) = hypot(a, hypot(b, c))\nand discuss the advantages of doing it this way.\nSo if we have a good implementation of hypot(a, b), it should be no problem to support 3 or more arguments. Therefore I see no reason of being restricted to 2 or 3 arguments.\nOf course one problem with this approach is speed, because we have to call hypot n-1 times for n arguments."},{"commentid":798,"comment_count":13,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-17 18:54:47 -0700","thetext":"(In reply to comment #12)\nRe: Math.hypot implementation technique\n> Moler and Morrison (They found an algorithm for hypot without taking square\n> roots, link to their paper in the Wikipedia article) call this function\n> \"pythag\".\n\nNice find.\n\nHowever Moler & Morrison's pythag is less accurate than the sqrt technique:\n    pythag(3,4) == 5.000000000000001  == 5 + 2^-50\n    4*sqrt(1+3/4*3/4) == 5    == sqrt(3*3+4*4)  // not just because 4 is 2^2\n\nPresumably this is because sqrt is well-implemented to better than 1 ULP and then suffers from a single multiply; whereas pythag accumulates several rounding errors in the \"p\" variable, significantly worse than 1 ULP.\n\nAlso note that sqrt is typically a basic function of hardware floating-point units.  Hence fast (and internally calculated to extended precision too) on decent systems with a hardware FPU.\n\nIn 1983 Moler & Morrison were only concerned with avoiding \"excessive\" rounding errors, not achieving 1 ULP within the confines of machine precision.\n\n\n> Moler and Morrison made an other interesting point in their paper; they\n> calculate the hypot function with more than two arguments recursively\n>    hypot(a, b, c) = hypot(a, hypot(b, c))\n> and discuss the advantages of doing it this way.\n> So if we have a good implementation of hypot(a, b), it should be no problem to\n> support 3 or more arguments. Therefore I see no reason of being restricted to > 2 or 3 arguments.\n> Of course one problem with this approach is speed, because we have to call\n> hypot n-1 times for n arguments.\n\nThe rounding error accumulates quite badly as the number of arguments increases.  In 1983 Moler & Morrison didn't consider this \"excessive\", but we can do better now."},{"commentid":799,"comment_count":14,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-17 23:39:44 -0700","thetext":"(In reply to comment #13)\n\n> However Moler & Morrison's pythag is less accurate than the sqrt technique:\n>     pythag(3,4) == 5.000000000000001  == 5 + 2^-50\n>     4*sqrt(1+3/4*3/4) == 5    == sqrt(3*3+4*4)  // not just because 4 is 2^2\n> \n> Presumably this is because sqrt is well-implemented to better than 1 ULP and\n> then suffers from a single multiply; whereas pythag accumulates several\n> rounding errors in the \"p\" variable, significantly worse than 1 ULP.\n>\n> …\n>\n> In 1983 Moler & Morrison were only concerned with avoiding \"excessive\" rounding\n> errors, not achieving 1 ULP within the confines of machine precision.\n\nThe number 1 here seems magic, if the specification should demand anything, it should probably follow the IEEE 754-2008 recommendation that the hypot function (for arguments of length 2) should be correctly rounded.\n\n> The rounding error accumulates quite badly as the number of arguments\n> increases.  In 1983 Moler & Morrison didn't consider this \"excessive\", but we\n> can do better now.\n\nA recommendation that it should use an algorithm that provides a good trade-off between accuracy, performance and over-/underflow (for arguments of longer length than 2) should be enough. I doubt that most BLAS NRM2 implementations are accurate for especially evil inputs."},{"commentid":804,"comment_count":15,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-21 06:35:12 -0700","thetext":"Re: summary of variadic Math.hypot\n\nThis is hopefully a summary of the recent interesting Math.hypot discussion.\n\nMath.hypot should take either 2 or 3 arguments, rather than being fully variadic.  2 is normal, 3 is a straightforward extension to 3D geometry.  (Otherwise we get into over-complicated issues with vector 2-norms, etc.)\n\nMath.hypot's arity should be 2 (the normal case), i.e. Math.hypot.length==2.\n\nIt should remain named \"hypot\", which has become standard terminology, even though the diagonal of a cuboid is not really a \"hypotenuse\".\n\nMath.hypot of +/-Infinity with anything (even NaN) is +Infinity:\n    hypot(Infinity,NaN) == hypot(NaN,-Infinity,NaN) == ... == Infinity\n\nThe documentation should point out that Math.hypot:\n1) always avoids underflow,\n2) avoids overflow if possible,\n3) minimises rounding errors.\n\nIn the documentation: the incorrect statement \"the result is y\" should be fixed."},{"commentid":805,"comment_count":16,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-21 16:33:01 -0700","thetext":"Re: implementation of 'log1p' and 'expm1'\n\nThere are a couple of simple implementations of 'log1p' -- has anyone analysed their accuracy considering the hard work in a polynomial approximation (to better than 1ULP)?\n(http://en.wikipedia.org/wiki/Approximation_theory#Remez.27_algorithm)\n\nlog1p(x) = function(x) {\n    if (isNaN( x ) || x == Infinity || x == 0)  return x;\n    var xp1 = x+1;\n    return (xp1 == 0)? -Infinity : Math.log(xp1) - ((xp1-1)-x)/xp1;    // (1)\n    return (xp1 == 1)? x         : Math.log(xp1) * (x/(xp1-1));        // (2)\n};\n\nVersion (2) is believed accurate to a few ULP.  Version (1) seems better.\nThey both seem suspiciously simple.\n\n\nFor 'expm1', is it necessary to find a polynomial approximation, or is evaluating the 'exp' power series without the first term good enough?\n\n\n(With a good 'expm1' the hyperbolic functions can be good;\nwith a good 'log1p' the inverse hyperbolic functions can be good.)"},{"commentid":809,"comment_count":17,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-23 05:52:41 -0700","thetext":"Re: Number.isNaN & Number.isFinite\n\nIf 'isNaN' and 'isFinite' are being carried over from the global namespace into\n'Number', then we could take the opportunity likewise to carry 'parseFloat' and\n'parseInt' for completeness:\n     isNaN       -> Number.isNaN\n     isFinite    -> Number.isFinite\n     parseInt    -> Number.parseInt\n     parseFloat  -> Number.parse\n\nSee Bug 314's 6th comment for more on the possible improvements to parseFloat."},{"commentid":825,"comment_count":18,"who":{"uid":"lukeh","name":"Luke Hoban"},"bug_when":"2012-03-28 08:13:08 -0700","thetext":"I've uploaded a new draft of proposed ES6 library extensions spec\n(http://wiki.ecmascript.org/doku.php?do=show&id=harmony%3Amore_math_functions).\n\nThis so far addresses the following asks from this thread:\n- Support for 2- and 3- arg variants of hypot\n- Adds hypot2 which computes sum of squares\n- Adds cbrt\n- Addresses bugs and editorial inconsistency in description of special values\n\nOther topics raised here, including specification of accuracy and under/overflow requirements, will be discussed at TC39 f2f this week."},{"commentid":826,"comment_count":19,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-28 08:18:23 -0700","thetext":"I have quite a few times been annoyed by the lack of a fused multiply-add function in ES, and wondered if anyone have any arguments against adding it? It is available in the C99 standard, and most non-x86 hardware has support for it.\n\nIt is useful for a lot of things, but mainly when implementing high-precision double-double arithmetic, to increase accuracy when calculating dot products, matrix operations, evaluating polynomials or when trying to implement other transcendental functions.\n\nThe current solution of faking it is a bit suboptimal performance-wise."},{"commentid":829,"comment_count":20,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 09:04:13 -0700","thetext":"(In reply to comment #19)\n> I have quite a few times been annoyed by the lack of a fused multiply-add\n> function in ES, and wondered if anyone have any arguments against adding it? It\n> is available in the C99 standard, and most non-x86 hardware has support for it.\n> \n> It is useful for a lot of things, but mainly when implementing high-precision\n> double-double arithmetic, to increase accuracy when calculating dot products,\n> matrix operations, evaluating polynomials or when trying to implement other\n> transcendental functions.\n> \n> The current solution of faking it is a bit suboptimal performance-wise.\n\n+1.\nA fused multiply-add (FMA) facility would improve IEEE754 conformance, but it needn't be a named function.\n\nFor comments about FMA (\"a mixed blessing\") see page 5 of William Kahan's 1997 lecture notes on IEEE754:\n http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n\nHe suggests using parentheses to decide when to use FMA in arithmetic:\n   (a*b+c)        // FMA\n   (a*b+c*d)      // no FMA\n   (a*b+(c*d))    // FMA\n   ((a*b)+c*d)    // FMA\n\nFMA should be available in a conforming hardware FPU."},{"commentid":830,"comment_count":21,"who":{"uid":"jens","name":"Jens Nockert"},"bug_when":"2012-03-28 09:14:35 -0700","thetext":"> A fused multiply-add (FMA) facility would improve IEEE754 conformance, but it\n> needn't be a named function.\n> \n> For comments about FMA (\"a mixed blessing\") see page 5 of William Kahan's 1997\n> lecture notes on IEEE754:\n>  http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n> \n> He suggests using parentheses to decide when to use FMA in arithmetic:\n>    (a*b+c)        // FMA\n>    (a*b+c*d)      // no FMA\n>    (a*b+(c*d))    // FMA\n>    ((a*b)+c*d)    // FMA\n\nThis changes the semantics of existing programs, so in my opinion it is a _really_ bad idea. A function allows us to stay backwards compatible with older applications that depend on the current version of the language.\n\nIn addition, performance would probably suffer since the most common platform (x86) does generally _not_ have hardware FMA (but you can do it easily in software, and AMD Bulldozer and Intel's upcoming Haswell provide competing FMA implementations.)"},{"commentid":831,"comment_count":22,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 09:36:40 -0700","thetext":"(In reply to comment #18)\n> I've uploaded a new draft of proposed ES6 library extensions spec\n> (http://wiki.ecmascript.org/doku.php?do=show&id=harmony%3Amore_math_functions).\n> \n> This so far addresses the following asks from this thread:\n> - Adds hypot2 which computes sum of squares\n>[snip]\n\nThanks for the feedback.  A couple of questions on the new spec.\n\nWhat's the point of Math.hypot2?\nThe sum of squares is easily computed arithmetically, and there is no chance of avoiding overflow (unlike plain hypot).  The name looks funny when the '2' means 'squared' not 'takes 2 arguments' (cf. Math.atan2).\n\nWhy Number.parseFloat not Number.parse?\nJust thinking of Date.parse which parses a Date, so Number.parse would parse a Number, and Foo.parse parse a Foo.  Whereas Number.parseInt parses a special sort of Number."},{"commentid":832,"comment_count":23,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 09:59:37 -0700","thetext":"(In reply to comment #21)\n> > He suggests using parentheses to decide when to use FMA in arithmetic:\n> \n> This changes the semantics of existing programs, so in my opinion it is a\n> _really_ bad idea. A function allows us to stay backwards compatible with older\n> applications that depend on the current version of the language.\n> \n> In addition, performance would probably suffer since the most common platform\n> (x86) does generally _not_ have hardware FMA (but you can do it easily in\n> software, and AMD Bulldozer and Intel's upcoming Haswell provide competing FMA\n> implementations.)\n\nFair enough.\n\nMay I suggest it is called Number.muladd or Number.FMA -- in the Number namespace since it is arithmetic:\n    Number.muladd(a,b,c)   // returns a+(b*c)"},{"commentid":833,"comment_count":24,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 10:43:03 -0700","thetext":"Re: String.prototype.repeat\n\nShould String.prototype.repeat limit the repetition count, to avoid >8 gigabyte string results?\nWhat if the count is negative?\n\n\nRe: String.prototype.reverse\n\nThe steps are numbered from 8 not 1.\nThe description refers to an Array not a String.\n\n\nSince a String.prototype.reverse function is being carried over from Array, do you want to invent String.prototype.splice too?"},{"commentid":834,"comment_count":25,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 10:45:23 -0700","thetext":"Re: String.prototype.endsWith\n\nThe description for String.prototype.endsWith has a typo: \"endPoisition\""},{"commentid":835,"comment_count":26,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 11:27:35 -0700","thetext":"Re: String.prototype.contains\n\n    obj.contains( searchString, position )\nis equivalent to\n    (obj.indexOf( searchString, position ) >= 0)\n\nWhy define a new function for this simple procedure?"},{"commentid":836,"comment_count":27,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 11:49:35 -0700","thetext":"Re: String.prototype.toArray\n\n    str.toArray()\nis equivalent to\n    str.split('')\n\nWhy define a new function for this simple procedure?"},{"commentid":837,"comment_count":28,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 12:10:52 -0700","thetext":"Re: Number.EPSILON & Number.MAX_INTEGER\n\nThe descriptions of these refer to Number.MAX_VALUE not these properties."},{"commentid":838,"comment_count":29,"who":{"uid":"lukeh","name":"Luke Hoban"},"bug_when":"2012-03-28 12:47:19 -0700","thetext":"Thanks for great feedback.  I've updated the draft.\n\nRe: String.prototype.repeat\nI've updated the spec text to use ToUInt32.  This matches spec convention for things like new Array(len).\n\nRe: String.prototype.reverse\nThis was actually intended to be removed, based on previous TC39 feedback about issues with reversing surrogate pairs.\n\nRe: String.prototype.endsWith\nTypo corrected.\n\nRe: String.prototype.contains\nRe: String.prototype.toArray\nThese are developer conveniences based on frequent requests and expectations from other programming languages and developer platforms.\n\nRe: Number.EPSILON & Number.MAX_INTEGER\nType fixed."},{"commentid":847,"comment_count":30,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-29 01:23:53 -0700","thetext":"(In reply to comment #29)\n> Thanks for great feedback.  I've updated the draft.\n\nLooking at es6libraryextensions-3-28-12.2.pdf ...\n\n\nRe: Number.MAX_INTEGER\n\nIn the PDF there is a large space between \"MAX_INTEGER    is the largest\".\n\n\nRe: String.prototype.repeat\n\nMuch nicer.\nBut still allows the programmers to easily specify enormous strings with length len*count.  Maybe that's OK, after all they can easily shoot themselves in the foot in other ways e.g. an infinite loop like 'for i=1 to 2^54 step 1'.\n\nWhat happens to \"longstring\".repeat(0xFFFFFFFF) -- do they wait a long time until memory runs out?  Maybe that's better than imposing an arbitrary limit.\n\n\nRe: Math.hypot2\n\nRepeating comment 22.\nWhat's the point of Math.hypot2?\nThe sum of squares is easily computed arithmetically, and there is no chance of\navoiding overflow (unlike plain hypot).  The name looks funny when the '2'\nmeans 'squared' not 'takes 2 arguments' (cf. Math.atan2).\n\n\nRe: Number.parseFloat\n\nRephrasing comment 22.\nWhy Number.parseFloat not Number.parse?  (ala Date.parse)\n\nWill there be a new Number.parse which can parse fractions/infinity in any base [2-36]?  Then the parser would be able to decode any format that the formatters can produce, just like Date.parse can.  And Number.parseFloat would really mean parseDecimal."},{"commentid":854,"comment_count":31,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-04-03 04:00:42 -0700","thetext":"Re: Number.isNaN description\n\nThe note after Number.isNaN says the function is equivalent to X!==X,\nthis is not quite correct:\n          x = new Number(NaN)\n          isNaN(x)         // is true\n          Number.isNaN(x)  // is true\n          x!==x            // is false\nhowever:\n          +x!==x           // is true\n\nAlso:\n          x = \"123\"\n          isNaN(x)         // is false\n          Number.isNaN(x)  // is true\n          x!==x            // is false\n          +x!==x           // is true\nAnd:\n          x = \"abc\"\n          isNaN(x)         // is true\n          Number.isNaN(x)  // is true\n          x!==x            // is false\n          +x!==x           // is true\n\nThe global isNaN(x) is equivalent to (+x!=x).\nNumber.isNaN(x) is equivalent to (+x!==x)."},{"commentid":867,"comment_count":32,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-04-19 04:04:00 -0700","thetext":"Re: Unicode surrogates and String.prototype.toArray, also ~.reverse;\n    introducing new StringError\n\nAs described, String.prototype.toArray splits Unicode surrogate pairs; the reason given for not doing ~.reverse is that it would break surrogates if implemented naively.\n\nSooner or later a programmer is going to reverse a string by using 'toArray' followed by an Array reverse, thus hurting themselves when it doesn't work on surrogate pairs.\n\nWe can avoid these problems by making 'toArray' split the string into Unicode codepoints not UTF-16 codeunits -- normal chars would become single array elements, surrogate pairs would become single array elements (of 2 UTF-16 codeunits).\n\nWhat to do with unpaired surrogates in an ill-formed string?  I suggest throwing an exception, just like encodeURI & encodeURIComponent do.  (It is not 'toArray's job to undertake surrogate corrective descisions/actions.)\n\nFollowing this pattern, String.prototype.reverse could also work on well-formed strings, treating surrogate pairs as Unicode codepoints too.  Implemented natively this would be faster than converting to an array, reversing, and joining.\n\nThe exception could be a new Error type: say 'StringError'.\nThis would be used in other cases where a surrogate problem is detected and rejected aborting further processing.\nIt would be sensible to use this new Error in encodeURI & encodeURIComponent too (currently they throw URIError).\n\n... to be continued with new String.prototype.repair ..."},{"commentid":868,"comment_count":33,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-04-19 04:23:25 -0700","thetext":"Re: new String.prototype.repair\n\nFollowing on from comment 32, it would be nice to have a function that repairs ill-formed strings.  Then the programmer could either 1) preemptively force strings to be well-formed, or 2) catch a StringError exception and decide to repair & retry or simply abandon further processing.\n\nSuggested API:  String.prototype.repair( replacechar_opt )\nwhere unpaired surrogates in this string are replaced by 'replacechar_opt' if its given or otherwise U+FFFD (the Unicode replacement character).\nIf 'replacechar_opt' is the empty string then unpaired surrogates are simply deleted.\n\nI believe the following implementation using RegExps would work (the RegExp is split over 2 lines for readability):\n\n\nvar re_badsurrogate = /[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])\n                      |([^\\uD800-\\uDBFF])[\\uDC00-\\uDFFF]|^[\\uDC00-\\uDFFF]/g;\n\nString.prototype.repair(replchar)\n{\n    if (arguments.length == 0)  replchar = \"\\uFFFD\";\n\n    return this.replace( re_badsurrogate, \"$1\"+replchar );\n};"},{"commentid":894,"comment_count":34,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-05-04 14:57:05 -0700","thetext":"(In reply to comment #31)\n> Re: Number.isNaN description\n> \n> The note after Number.isNaN says the function is equivalent to X!==X,\n> this is not quite correct:\n\nthe note was removed in the May 4, 2012 drafrt"},{"commentid":895,"comment_count":35,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-05-04 15:04:41 -0700","thetext":"(In reply to comment #30)\n> (In reply to comment #29)\n> > Thanks for great feedback.  I've updated the draft.\n> \n> Looking at es6libraryextensions-3-28-12.2.pdf ...\n> \n> \n> Re: Number.MAX_INTEGER\n> \n> In the PDF there is a large space between \"MAX_INTEGER    is the largest\".\n> \nFixed in May 4 2012 draft\n\n\n> \n> Re: String.prototype.repeat\n> \n> Much nicer.\n> But still allows the programmers to easily specify enormous strings with length\n> len*count.  Maybe that's OK, after all they can easily shoot themselves in the\n> foot in other ways e.g. an infinite loop like 'for i=1 to 2^54 step 1'.\n> \n> What happens to \"longstring\".repeat(0xFFFFFFFF) -- do they wait a long time\n> until memory runs out?  Maybe that's better than imposing an arbitrary limit.\n> \n\nIn general the ES spec. does place arbitrary limits to try to prevent resource exhaustion errors.  that is left to implementations \n\n\n\n\n> \n> Re: Math.hypot2\n> \n\nIt's now gone.  Killed at March TC39 meeting"},{"commentid":14743,"comment_count":36,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-10-02 14:36:15 -0700","thetext":"Bulk closing all Harmony bugs. Proposals should be tracked on GitHub. The ES wiki is completely defunct at this point."}]}}
---
