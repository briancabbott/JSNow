---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1633,"creation_ts":"2013-07-30 13:40:00 -0700","short_desc":"13.4.1.1: Error recovery in delegating yield incomplete","delta_ts":"2013-11-08 13:08:43 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 16: July 15, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["jorendorff","wingo"],"long_desc":[{"commentid":4607,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-07-30 13:40:54 -0700","thetext":"Runtime Semantics: Evaluation for \"YieldExpression : yield YieldDelegator opt AssignmentExpression\", step 4.d.viii. In case of an error, the \"throw\" handler is called (4.d.viii.1), but then the original error is still propagated, cf. step 4.d.viii.2. \n\nThe original delegating yield proposal included error recovery, but this isn't currently spec'ed (http://wiki.ecmascript.org/doku.php?id=harmony:generators#delegating_yield). Is this an oversight or an intended change?\n\n\ntest case\n---\nfunction* gen(){ print(\"start\"); yield 1; print(\"stop\") }\ngen.prototype.throw = function(e){ print(\"caught: \" + e); return {done: false} }\nlet g = function*(){ yield*gen(); }();\ng.next(); g.throw(\"Stop!\"); g.next();\n---\n\nexpected output with error recovery:\n---\nstart\ncaught: Stop!\nstop\n---\n\ncurrent output:\n---\nstart\ncaught: Stop!\nuncaught exception: Stop!\n---"},{"commentid":5306,"comment_count":1,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2013-09-03 15:53:09 -0700","thetext":"Yep, I just independently found the same issue.\n\nMaybe the spec text we want is like this:\n\n  ...\n  4. ...\n      c. Let status be NormalCompletion(undefined).\n      d. Repeat\n          i. Let delegateResult be IteratorDelegate(iterator, status).\n         ii. If delegateResult.[[type]] is return, then\n              1. Return NormalCompletion(delegateResult.[[value]]).\n        iii. ReturnIfAbrupt(delegateResult).\n         iv. Let status be GeneratorYield(delegateResult).\n\nemphasizing that we're just passing Completion values back and forth between the caller and the delegate iterator. The abstract operation IteratorDelegate(iterator, status) can be defined like this:\n\n  1. If status.[[type]] is normal, then\n      a. Let result be IteratorNext(iterator, status.[[value]]).\n      b. ReturnIfAbrupt(methodCompletion).\n  2. Else,\n      a. Assert: status.[[type]] is throw.\n      b. If HasProperty(iterator, \"throw\") is true, then\n          i. Let result = Invoke(iterator, \"throw\", received).\n         ii. ReturnIfAbrupt(result).\n        iii. If Type(result.[[value]]) is not Object, throw a\n             TypeError exception.\n      c. Else,\n          i. Return status.\n  3. Let done = IteratorComplete(result).\n  4. ReturnIfAbrupt(done).\n  5. Let value = IteratorValue(result).\n  6. ReturnIfAbrupt(value).\n  7. If done is true, then\n      a. Return {[[type]]: return, [[value]]: value, [[target]]: empty}.\n  8. Return NormalCompletion(result)."},{"commentid":5402,"comment_count":2,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2013-09-19 00:50:54 -0700","thetext":"(In reply to comment #1)\n> Yep, I just independently found the same issue.\n\nMe too.  Would be great to fix this soon."},{"commentid":6419,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-11-03 14:50:16 -0800","thetext":"fixed in rev21 editor's draft\napproximately like Jason's suggestion but with IteratorDelegate inlined.\n\nBTW, you guys should feel free to set the importance field appropriately high on any bugs you need a quick response to.\n\n1.   Let exprRef be the result of evaluating AssignmentExpression.\n2.   Let value be GetValue(exprRef).\n3.   ReturnIfAbrupt(value).\n4.   Let iterator be the result of GetIterator(value).\n5.   ReturnIfAbrupt(iterator).\n6.   Let received be NormalCompletion(undefined).\n7.\tRepeat \n  a.\tIf received.[[type]] is normal, then\n     i.\tLet innerResult be the result of IteratorNext(iterator, received.[[value]]).\n     ii.    ReturnIfAbrupt(innerResult).\n  b.\tElse\n     i.\t    Asssert: received.[[type]] is throw.\n     ii.    If HasProperty(iterator, \"throw\") is true, then\n         1.\tLet innerResult be the result of Invoke(iterator, \"throw\", (received.[[value]])).\n         2.\tReturnIfAbrupt(innerResult).\n         3.\tIf Type(innerResult) is not Object, then throw a TypeError exception.\n     iii.   Else, return received.\n  c.\tLet done be IteratorComplete(innerResult).\n  d.\tReturnIfAbrupt(done).\n  e.\tIf done is true, then\n     i.\t    Return IteratorValue (innerResult).\n  f.\tLet received  be the result of GeneratorYield(innerResult)."},{"commentid":6505,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-11-08 13:08:43 -0800","thetext":"fixed in rev21 draft"}]}}
---
