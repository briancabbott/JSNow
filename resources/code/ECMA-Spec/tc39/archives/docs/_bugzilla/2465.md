---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2465,"creation_ts":"2014-01-27 09:47:00 -0800","short_desc":"Missing step in ToNumber / Redundancy in definition of Number.prototype.clz.","delta_ts":"2014-02-14 08:16:20 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 22: January 20, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"ecmascript","name":"C. Scott Ananian"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"mathias","long_desc":[{"commentid":7036,"comment_count":0,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-01-27 09:47:33 -0800","thetext":"The steps in the definition of Number.prototype.clz begin:\n\n1. Let x be thisNumberValue(this value).\n2. Let n be ToUint32(x).\n\nThe definition of ToUint32 begins:\n\n1. Let number be the result of calling ToNumber on the input argument.\n\nIt seems like it would be preferable, for consistency, to omit step 1 of Number.prototype.clz (and similar methods) and have the first step be \"Let n by ToUint32(this value)\".\n\nThis implies that `ToNumber` should return the same result as `thisNumberValue`, that is, the following steps should be performed by `ToNumber`:\n\n\"If Type(value) is Object and value has a [[NumberData]] internal slot, then\nLet n be the value of valueâ€™s [[NumberData]] internal slot.\nIf n is not undefined, then return n.\"\n\nThat could either be folded directly into the definition of `ToNumber`, or else added to `ToPrimitive` when the \"number\" hint is given (or even pushed down into the definition of @@toPrimitive for classes which define the [[NumberData]] internal slot).\n\nThese changes would make the first two steps exactly equivalent to \"var n = this >>> 0\" instead of requiring an additional step: \"var n = Number.prototype.valueOf.call(this) >>> 0\".  It would also make the ToNumber internal operation more consistent with the methods defined on Number.prototype.\n\nSee https://github.com/paulmillr/es6-shim/pull/196 for some related discussion."},{"commentid":7039,"comment_count":1,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-01-27 09:58:16 -0800","thetext":"A closer reading reveals that thisNumberValue also has the side-effect of throwing a TypeError if this value is not sufficiently numeric.  So I would recommend changing step 1 to a simple type check (perhaps using a new \"checkNumberValue\" helper).  IMO it would still be useful to ensure that the numeric results of `ToUint32(n)` and `n >>> 0` are identical; that is, the `ToNumber` operation should include the check of the `[[NumberData]]` internal slot."},{"commentid":7299,"comment_count":2,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-13 17:21:40 -0800","thetext":"Apparently Number.prototype.clz() is going to become Math.clz32(n).\n\nSince all of the Math.* functions perform ToNumber on the arguments, again it seems that the ToNumber algorithm ought to look at the [[NumberData]] internal slot.\n\nAnd presumably the type-check and TypeError of thisNumberValue would be replaced by returning NaN to be consistent with the rest of the Math.* functions."},{"commentid":7301,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-14 08:16:20 -0800","thetext":"both ToNumber and ToUnit32 date to the earliest days of ES and are widely used in the ES spec. Changing, there semantics, for example by not calling valueOf on Number wrapper objects, could break existing code.\n\nHowever, implementations are free to optimize algorithms in any manner that has no observable effect.\n\nFor example,  Math.clz32(x) implicitly does:\n     ToUint32(ToNumber(x))\n\nI would expect implementations to note that the ToNumber operation in step 1 of ToUint32 has no observable effect and can be skipped.\n\nES operation upon [U]int32 values consistently treat NaN as 0 rather than throwing.  The current spec. for Math.clr32 is consistent with that behavior just like Math.imul."}]}}
---
