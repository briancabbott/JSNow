---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3294,"creation_ts":"2014-10-19 12:41:00 -0700","short_desc":"Mixed declarative and dynamic linking no longer supported","delta_ts":"2015-02-19 19:11:08 -0800","product":"Draft for 6th Edition","component":"Modules","version":"Rev 28: October 14, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"guybedford","name":"Guy Bedford"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["dherman","jorendorff","samth"],"long_desc":[{"commentid":10526,"comment_count":0,"who":{"uid":"guybedford","name":"Guy Bedford"},"bug_when":"2014-10-19 12:41:35 -0700","thetext":"In the previous module loader implementation, significant effort was put into enabling ES6 to load legacy modules, which could in turn load ES6. \n\nThis is an important feature as it allows ES6 interop with CommonJS inside an ecosystem like npm. We can't automate conversion of modules to ES6 as circular references in CommonJS will break, so there isn't another way around this interop scenario that I can see.\n\nOne other proposal currently being suggested by some to enable this is the ability to write ES6 and CommonJS together using a CommonJS require for CommonJS and ES6 syntax for ES6:\n\nrequire('cjs-module');\nimport 'es6-module';\n\nI find this idea incredibly worrying, because there is no way to progressively move out of this scenario without rewriting all dependencies. We collectively progress into a hole where we're using two module systems, which I believe will leave everyone worse off.\n\nPerhaps it is out of the scope of ES6 to consider the dynamics of progressive adoption at this level, in which case I concede, but the solution previously provided separating the legacy and ES6 layers and linking these layers alternately supporting circular references in both systems together, through the dynamic instantiation hook, was an incredibly general and elegant solution to this issue.\n\nI'd ask that we consider bringing this back through a more general HostGetSource hook (HostGetModule perhaps) that supports the previous dynamic instantiate hook properties (deps and execute)."},{"commentid":10528,"comment_count":1,"who":{"uid":"guybedford","name":"Guy Bedford"},"bug_when":"2014-10-19 15:23:44 -0700","thetext":"There may be a middle ground here by allowing loading CommonJS from ES6 but not vice-versa. This is effectively supported by the current HostGetSource implementation anyway.\n\nWhile not perfect, compiling ES6 to CommonJS is generally less error-prone than the reverse (circular references don't break as easily) so that we do allow legacy compilation scenarios when using ES6:\n\nnpm package:\nes6/app.js\ncjs/app.js\n\nWhere cjs/app.js is generated from es6/app.js.\n\nIn this way, one can add an ES6 loader to Node, which would load from the es6 sources, in turn potentially loading CJS, while the package still supports being loaded without an ES6 loader through the CJS sources. But we do have to keep this compiled CJS folder around in npm for a little longer, which the reverse interop support scenario of allowing loading ES6 from CommonJS through an ES6 loader might help us progress past sooner."},{"commentid":12855,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-17 17:30:51 -0800","thetext":"fixed in rev34 editor's draft"},{"commentid":13138,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-19 19:11:08 -0800","thetext":"fixed in rev34"}]}}
---
