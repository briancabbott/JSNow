---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2437,"creation_ts":"2014-01-27 06:17:00 -0800","short_desc":"6.1.7.3 Invariants of the Essential Internal Methods: Prototype chain may have infinite length","delta_ts":"2015-02-27 13:46:06 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 22: January 20, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["claude.pache","dslomov","erights","rossberg","tomvc.be"],"long_desc":[{"commentid":7006,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-01-27 06:17:42 -0800","thetext":"6.1.7.3 Invariants of the Essential Internal Methods, [[GetPrototypeOf]] ( ):\n\n> An object’s prototype chain must have finite length [...]\n\nThis assumption does not hold for proxy objects. \n\n\nExample 1:\nvar o = {}, p = new Proxy(o, {});\nObject.setPrototypeOf(o, p);\nObject.getPrototypeOf(p) === p; // yields true\n\nExample 2:\nfunction infiniteProxy() {\n  return new Proxy({}, {\n    getPrototypeOf() {\n      return new infiniteProxy();\n    }\n  });\n}"},{"commentid":7376,"comment_count":1,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2014-02-20 08:07:47 -0800","thetext":"Good catch.\n\nI would be OK with dropping the invariant from the spec. It’s not one we can easily enforce.\n\nMoreover, I don’t see what extra risks we take by removing the invariant. I don’t think implementations deliberately climb prototype chains to optimize things, or if they do, they probably already have limits on how high they want to climb. Even without proxies one can easily construct extremely deep prototype chains.\n\nFinally, with setPrototypeOf in the spec it even becomes possible to define cyclic prototype chains, as far as I can see."},{"commentid":7379,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-20 08:51:25 -0800","thetext":"(In reply to comment #1)\n> \n> \n> Finally, with setPrototypeOf in the spec it even becomes possible to define\n> cyclic prototype chains, as far as I can see.\n\nNot for prototype chains consisting only of ordinary objects.  See step 6, http://people.mozilla.org/~jorendorff/es6-draft.html#sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v \n\nBut as soon as an exotic object is involved, the reliability of the check can be compromised by an exotic [[GetPrototypeOf]].\n\nAbout the only fix I can imagine would be requiring that an observed [[GetPrototypeOf]] result for an object must not change unless there is an intervening [[SetPrototypeOf]] call for the same object.\n\nProbably the real concern here is that a circular prototype chain would throw many implementation into a deep and perhaps non-interruptible infinite loop.  \n\nAllen"},{"commentid":7382,"comment_count":3,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2014-02-20 10:56:55 -0800","thetext":"(In reply to comment #2)\n> Probably the real concern here is that a circular prototype chain would throw\n> many implementation into a deep and perhaps non-interruptible infinite loop.  \n\nPossibly, but when dealing with proxies, virtually any operation called upon a proxy can go into an infinite loop.\n\nAlso note that if a proxy is found in a prototype-chain during property lookup, the lookup stops right there and should call the proxy's \"get\" trap. I don't think an implementation should ever call [[GetPrototypeOf]] on a proxy during critical operations such as property lookup. Indeed, we redesigned the entire [[Get]] and [[Set]] algorithms so that this would no longer be necessary.\n\nNevertheless, it would be good to get some advice from implementors on the importance of this invariant."},{"commentid":7384,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-20 12:36:54 -0800","thetext":"(In reply to comment #3)\n> (In reply to comment #2)\n> > Probably the real concern here is that a circular prototype chain would throw\n> > many implementation into a deep and perhaps non-interruptible infinite loop.  \n> \n> Possibly, but when dealing with proxies, virtually any operation called upon a\n> proxy can go into an infinite loop.\n\nI'm really only concerned about loops that don't have call backs into JS code.\n\n> \n> Also note that if a proxy is found in a prototype-chain during property lookup,\n> the lookup stops right there and should call the proxy's \"get\" trap.\n\nRight! So, no worry here!\n\n> I don't\n> think an implementation should ever call [[GetPrototypeOf]] on a proxy during\n> critical operations such as property lookup. Indeed, we redesigned the entire\n> [[Get]] and [[Set]] algorithms so that this would no longer be necessary.\n\nHow do [[Get]]/[[Set]] help.  They are also defined to perform [[GetPrototypeOf]] calls to walk the proto chain."},{"commentid":7387,"comment_count":5,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2014-02-21 08:50:39 -0800","thetext":"(In reply to comment #4)\n> How do [[Get]]/[[Set]] help.  They are also defined to perform\n> [[GetPrototypeOf]] calls to walk the proto chain.\n\nOnly for non-exotic objects. [[Get]] calls [[GetPrototypeOf]] to retrieve the prototype, then does a tail-call to prototype.[[Get]]. If the prototype is a proxy, the proxy takes over from there, and the external prototype-climbing stops. Same for [[Set]], [[HasProperty]] and [[Enumerate]].\n\nI searched the spec for calls to [[GetPrototypeOf]] that climb the proto chain. Seems like these are the external loops you're worried about:\n\n- 9.1.2 [[SetPrototypeOf]] climbs the proto chain, to check for non-circularity\n- 7.3.15 OrdinaryHasInstance (triggered by instanceof operator and Function.prototype[@@hasInstance] )\n- 19.1.3.3 Object.prototype.isPrototypeOf"},{"commentid":7427,"comment_count":6,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-03-07 06:41:54 -0800","thetext":"Here's a test case to show how to construct a circular prototype chain which involves only ordinary objects. The proxy is only needed for the initial set-up:\n---\nvar obj1 = {};\nvar obj2 = {};\nvar obj3 = {};\n\nvar count = 0;\nvar p3 = new Proxy(obj3, {\n  getPrototypeOf(t) {\n    print(\"getPrototypeOf called\");\n    if (count++ === 1) {\n      Object.setPrototypeOf(obj2, obj1);\n    }\n    return Reflect.getPrototypeOf(t);\n  }\n});\n\nObject.setPrototypeOf(obj2, p3);\nObject.setPrototypeOf(obj1, obj2);\n\nprint(`Object.getPrototypeOf(obj1) === obj2? ${Object.getPrototypeOf(obj1) === obj2}`);\nprint(`Object.getPrototypeOf(obj2) === obj1? ${Object.getPrototypeOf(obj2) === obj1}`);\n---"},{"commentid":10996,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-10 18:50:45 -0800","thetext":"Fixed in rev30 editor's draft.\n\nRemoved the Chapter 6 invariant for [[GetPrototypeOf]] regarding infinite legth prototype chains. Replaced it with a NOTE pointing out the possibility"},{"commentid":11013,"comment_count":8,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-12-11 11:12:13 -0800","thetext":"I'm sorry, I have to push back on this resolution. We are not going to allow for the possibility of cyclic prototype chains between ordinary objects in V8. If the spec actually prescribes that Andre's example succeeds (I haven't checked) then the spec needs fixing."},{"commentid":11014,"comment_count":9,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-12-11 11:19:01 -0800","thetext":"(In reply to Andreas Rossberg from comment #8)\n> I'm sorry, I have to push back on this resolution. We are not going to allow\n> for the possibility of cyclic prototype chains between ordinary objects in\n> V8. If the spec actually prescribes that Andre's example succeeds (I haven't\n> checked) then the spec needs fixing.\n\nOne idea that did come up in discussion is a structural invariant, but without a corresponding behavioral invariant. The structural invariant is in terms of a proxy's effective instantaneous [[Prototype]] being its target's [[Prototype]] at the same moment. The invariant is that you can't have a structural cycle at any moment.\n\nIIRC, we decided to drop this because it did not prevent a behavioral infinite cycle. But perhaps it is useful anyway, in order to account for the plain-object constraint in a proxy compat manner."},{"commentid":11018,"comment_count":10,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-11 12:46:35 -0800","thetext":"(In reply to Andreas Rossberg from comment #8)\n> I'm sorry, I have to push back on this resolution. We are not going to allow\n> for the possibility of cyclic prototype chains between ordinary objects in\n> V8. If the spec actually prescribes that Andre's example succeeds (I haven't\n> checked) then the spec needs fixing.\n\nThen please propose a spec. level fix. How do you currently disallow this?\n\nI can imagine doing so via a check in ordinary object [[SetPrototypeOf]] but that would be check that is specific to it and not an invariant that applies to all implementations of [[SetPrototypeOf]]."},{"commentid":11019,"comment_count":11,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-12-11 13:02:04 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #10)\n> (In reply to Andreas Rossberg from comment #8)\n> > I'm sorry, I have to push back on this resolution. We are not going to allow\n> > for the possibility of cyclic prototype chains between ordinary objects in\n> > V8. If the spec actually prescribes that Andre's example succeeds (I haven't\n> > checked) then the spec needs fixing.\n> \n> Then please propose a spec. level fix. How do you currently disallow this?\n> \n> I can imagine doing so via a check in ordinary object [[SetPrototypeOf]] but\n> that would be check that is specific to it and not an invariant that applies\n> to all implementations of [[SetPrototypeOf]].\n\nFor the structural invariant, the strange part is that the instantaneous cycle check needs to look at imputed structure without causing traps to user code. For this purpose alone, it would reach through a proxy to its target without trapping to the handler."},{"commentid":11020,"comment_count":12,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-12-11 23:59:50 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #10)\n> (In reply to Andreas Rossberg from comment #8)\n> > I'm sorry, I have to push back on this resolution. We are not going to allow\n> > for the possibility of cyclic prototype chains between ordinary objects in\n> > V8. If the spec actually prescribes that Andre's example succeeds (I haven't\n> > checked) then the spec needs fixing.\n> \n> Then please propose a spec. level fix. How do you currently disallow this?\n> \n> I can imagine doing so via a check in ordinary object [[SetPrototypeOf]] but\n> that would be check that is specific to it and not an invariant that applies\n> to all implementations of [[SetPrototypeOf]].\n\nWe don't currently have to do anything, because we still implement the old proxy proposal that couldn't intercept prototype access.\n\nI see three possibilities:\n\n1. We drop mutable prototypes from the spec. Then implementations can continue to support it as a legacy feature in whatever hacky way they see fit, even if it doesn't work with proxies.\n\n2. We at least remove the ability for proxies to intercept prototype access.\n\n3. The champions for including mutable prototypes find a better way for fixing its semantics.\n\nI'm sorry if this sounds unconstructive, but I'm actually somewhat serious here. I only very reluctantly accepted the idea of blessing prototype mutation because I was willing to believe that it can't be worse than what we already implement. Now, cyclic prototype chains is much worse, and I would never have agreed to that. I suggest that the burden for coming up with a fix now lies with the champions (if they still champion it under this changed premise)."},{"commentid":11025,"comment_count":13,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-12-12 11:03:22 -0800","thetext":"The example of Comment #6 works as follows: While the prototype chain of obj2 is visited in order to check for potential cycle, the proxy p3 alters the prototype of an already visited object, making the test for prototype cycle unreliable. A standard solution to that sort of problem is to use locks. In our case:\n\n* While a prototype chain is visited in the process of checking for potential cycle, a temporary lock is put on every visited object. These locks are released at the end of the algorithm.\n\n* Any attempt to alter the prototype on a locked object shall fail.\n\nThat will at least prevent prototype cycles for prototype chains consisting only of ordinary objects (or, more generally, of objects verifying the invariant mentioned in Comment #2)."},{"commentid":11026,"comment_count":14,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-12-12 11:08:25 -0800","thetext":"(In reply to Andreas Rossberg from comment #12)\n> (In reply to Allen Wirfs-Brock from comment #10)\n> > (In reply to Andreas Rossberg from comment #8)\n> > > I'm sorry, I have to push back on this resolution. We are not going to allow\n> > > for the possibility of cyclic prototype chains between ordinary objects in\n> > > V8. If the spec actually prescribes that Andre's example succeeds (I haven't\n> > > checked) then the spec needs fixing.\n> > \n> > Then please propose a spec. level fix. How do you currently disallow this?\n> > \n> > I can imagine doing so via a check in ordinary object [[SetPrototypeOf]] but\n> > that would be check that is specific to it and not an invariant that applies\n> > to all implementations of [[SetPrototypeOf]].\n> \n> We don't currently have to do anything, because we still implement the old\n> proxy proposal that couldn't intercept prototype access.\n> \n> I see three possibilities:\n> \n> 1. We drop mutable prototypes from the spec. Then implementations can\n> continue to support it as a legacy feature in whatever hacky way they see\n> fit, even if it doesn't work with proxies.\n\nNo. If it is everywhere, then it is part of the de facto std anyway and membranes must support it. Therefore proxies must.\n\n> \n> 2. We at least remove the ability for proxies to intercept prototype access.\n\nNo. Makes it impossible to build a membrane.\n\n\n> \n> 3. The champions for including mutable prototypes find a better way for\n> fixing its semantics.\n\nSee comments #9 and #11. Did you somehow miss these?\n\n\n> \n> I'm sorry if this sounds unconstructive, but I'm actually somewhat serious\n> here. I only very reluctantly accepted the idea of blessing prototype\n> mutation because I was willing to believe that it can't be worse than what\n> we already implement. Now, cyclic prototype chains is much worse, and I\n> would never have agreed to that. I suggest that the burden for coming up\n> with a fix now lies with the champions (if they still champion it under this\n> changed premise)."},{"commentid":11027,"comment_count":15,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-12 11:09:31 -0800","thetext":"(In reply to Andreas Rossberg from comment #12)\n> \n> \n> I see three possibilities:\n> \n> 1. We drop mutable prototypes from the spec. Then implementations can\n> continue to support it as a legacy feature in whatever hacky way they see\n> fit, even if it doesn't work with proxies.\n> \n\nOne is never going to fly.  Mutable prototypes are a reality and the job of a standard is to ensure that such realities have a good specification.\n\n> 2. We at least remove the ability for proxies to intercept prototype access.\n> \n\nToo big a change and it significantly reduces what can be expressed using proxies.\n\n> 3. The champions for including mutable prototypes find a better way for\n> fixing its semantics.\n> \n\nThe fix is easy enough, and is essentially Mark's structural check.  However, it's not an invariant of [[GetPrototypeOf]], instead it is a specified part of ordinary object's [[SetPrototypeOf]].  It works as follows:\n\n1) Note that it is not possible to create an ordinary object whose [[Prototype]] is that same object.\n\n2)Ordinary Object [[SetPrototypeOf]] performs this check:\n     If this object uses  the ordinary object [[GetPrototypeOf]] and the arguemnet object's (ie, the new [[Prototype]] value) is an object whose [[GetPrototypeOf]] is also the ordinary object [[GetPrototypeOf]]  then fail if  the argument object's [[Prototype]] is the original ordinary object. Otherwise, recursive apply this test to the [[Prototype]] of the argument object. If null or an object that does not use the ordinary object [[GetPrototypeOf]] ls reached, set the original object's [[Prototype]] to the original argument value and succeed.\n\nIn other words, you can never construct a circular prototype chain consisting only of object's that implement the ordinary object [[GetPrototuypeOf]].\n\nYou can have a circular prototype chain using proxies but, using Mark's terminology, that's a behavioral circularity, not a structural circularity."},{"commentid":11028,"comment_count":16,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-12-12 11:15:55 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #15)\n> (In reply to Andreas Rossberg from comment #12)\n> > \n> > \n> > I see three possibilities:\n> > \n> > 1. We drop mutable prototypes from the spec. Then implementations can\n> > continue to support it as a legacy feature in whatever hacky way they see\n> > fit, even if it doesn't work with proxies.\n> > \n> \n> One is never going to fly.  Mutable prototypes are a reality and the job of\n> a standard is to ensure that such realities have a good specification.\n> \n> > 2. We at least remove the ability for proxies to intercept prototype access.\n> > \n> \n> Too big a change and it significantly reduces what can be expressed using\n> proxies.\n> \n> > 3. The champions for including mutable prototypes find a better way for\n> > fixing its semantics.\n> > \n> \n> The fix is easy enough, and is essentially Mark's structural check. \n> However, it's not an invariant of [[GetPrototypeOf]], instead it is a\n> specified part of ordinary object's [[SetPrototypeOf]].  It works as follows:\n> \n> 1) Note that it is not possible to create an ordinary object whose\n> [[Prototype]] is that same object.\n> \n> 2)Ordinary Object [[SetPrototypeOf]] performs this check:\n>      If this object uses  the ordinary object [[GetPrototypeOf]] and the\n> arguemnet object's (ie, the new [[Prototype]] value) is an object whose\n> [[GetPrototypeOf]] is also the ordinary object [[GetPrototypeOf]]  then fail\n> if  the argument object's [[Prototype]] is the original ordinary object.\n> Otherwise, recursive apply this test to the [[Prototype]] of the argument\n> object. If null or an object that does not use the ordinary object\n> [[GetPrototypeOf]] ls reached, set the original object's [[Prototype]] to\n> the original argument value and succeed.\n> \n> In other words, you can never construct a circular prototype chain\n> consisting only of object's that implement the ordinary object\n> [[GetPrototuypeOf]].\n> \n> You can have a circular prototype chain using proxies but, using Mark's\n> terminology, that's a behavioral circularity, not a structural circularity.\n\nIt is not quite the same. My suggestion is that, if a proxy is encountered during the structural check, that the structural check (and only the structural check) reach through the proxy to the target's [[Prototype]] without trapping.\n\nEither with or without this additional amendment, yes, I believe your text does it. I don't currently see a strong need for this amendment, and so can probably live without it."},{"commentid":11033,"comment_count":17,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-12-13 00:06:58 -0800","thetext":"(In reply to Mark Miller from comment #14)\n> (In reply to Andreas Rossberg from comment #12)\n> > I see three possibilities:\n> > \n> > 1. We drop mutable prototypes from the spec. Then implementations can\n> > continue to support it as a legacy feature in whatever hacky way they see\n> > fit, even if it doesn't work with proxies.\n> \n> No. If it is everywhere, then it is part of the de facto std anyway and\n> membranes must support it. Therefore proxies must.\n> \n> > 2. We at least remove the ability for proxies to intercept prototype access.\n> \n> No. Makes it impossible to build a membrane.\n\nI understand, but the declared resolution of this bug freaked me out a little and I felt the need to clarify the priorities: I would not be willing to sacrifice the non-cyclicity invariant, neither for the sake of prototype mutation nor proxies. It trumps the desire for both.\n\nI was also positive that it can be fixed with less drastic measures.\n\n> > 3. The champions for including mutable prototypes find a better way for\n> > fixing its semantics.\n> \n> See comments #9 and #11. Did you somehow miss these?\n\nI saw it, but it wasn't entirely clear to me at first if that is good enough. I think I'm convinced now. Thanks.\n\nRegarding the difference between your and Allen's version, I strongly prefer yours. If we want to be able to handle proxies efficiently, especially those that do not have customised getPrototypeOf or any other prototype-walking handlers, then it would be vital to maintain structural non-cyclicity for their targets as well. We want to be able to guarantee termination by construction as long as we do not call into user code, for the reasons Allen brought up in #2 and #4."},{"commentid":11217,"comment_count":18,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-23 20:23:33 -0800","thetext":"fixed in rev30"},{"commentid":12177,"comment_count":19,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-05 20:29:01 -0800","thetext":"reopenning, because it everything starting with comment 8 hasn't actually been resolved"},{"commentid":12196,"comment_count":20,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-06 13:18:32 -0800","thetext":"Fixed in Rev33 editor's draft\n\nI updated Ordinary Object [[SetPrototypeOf]] to do the check I described in Comment 15.  This guarantees that prototype chains consisting only of objects that use the ordinary [[GetPrototypeOf]]/[[SetPrototypeOf]] definitions can't be circular.\n\nIn the future we may want to explore switching to Mark's deeper check.  But, I think there may be some corner cases with that (for example, proxies on proxies) approach that I don't have time to explore right now.\n\nI think with this change the solution is good enough for Es6."},{"commentid":12239,"comment_count":21,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2015-02-09 04:56:02 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #20)\n> Fixed in Rev33 editor's draft\n> \n> I updated Ordinary Object [[SetPrototypeOf]] to do the check I described in\n> Comment 15.  This guarantees that prototype chains consisting only of\n> objects that use the ordinary [[GetPrototypeOf]]/[[SetPrototypeOf]]\n> definitions can't be circular.\n> \n> In the future we may want to explore switching to Mark's deeper check.  But,\n> I think there may be some corner cases with that (for example, proxies on\n> proxies) approach that I don't have time to explore right now.\n> \n> I think with this change the solution is good enough for Es6.\n\nHm, can you elaborate? It seems to me that once we spec it this way, we have to start supporting cycles through proxies, and going to Mark's solution would be a breaking change."},{"commentid":12423,"comment_count":22,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-12 12:17:38 -0800","thetext":"fixed in rev33"},{"commentid":13181,"comment_count":23,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2015-02-20 04:32:48 -0800","thetext":"Okay, so the change in rev33 still is only a partial fix.\n\nIt is not clear to me what the implications of having cyclic prototype chains through proxies are for implementations, and I don't think we have sufficient evidence that they don't cause problems.\n\nI'm fine with keeping it like that for the ES6 spec, as long as we agree to reserve the possibility of flagging this as a spec bug later. For example, for the time being, test262 should not test for this."},{"commentid":13425,"comment_count":24,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-27 13:46:06 -0800","thetext":"(In reply to Andreas Rossberg from comment #23)\n> Okay, so the change in rev33 still is only a partial fix.\n> \n> It is not clear to me what the implications of having cyclic prototype\n> chains through proxies are for implementations, and I don't think we have\n> sufficient evidence that they don't cause problems.\n\nSee Tom's Comment 5\n\nBecause of the Rev33 change, the only possible way you could encounter a circular prototype chain is via an Proxy (any other sort of exotic object that exposed a circularity would be self inflicted by the implementation) that has traps for one or more of getPrototypeOf/get/set/hasProperty/enumerate.  \n\nBut, if you encounter such a trap, you have to break out of whatever sort of proto chain climbing internal loop you might be running so you can enter user provided code. Once you're in userland, you shouldn't care what happens."}]}}
---
