---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2297,"creation_ts":"2013-11-15 04:36:00 -0800","short_desc":"9.5.6: No TypeError thrown in step 21b if [[Configurable]] field not present","delta_ts":"2014-07-16 17:03:28 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 21: November 8, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"tomvc.be","long_desc":[{"commentid":6793,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-11-15 04:36:05 -0800","thetext":"9.5.6  [[DefineOwnProperty]] (P, Desc), step 21.b:\n\n> b.  If settingConfigFalse is true, then throw a TypeError exception.\n\nThis condition is not correct, instead it needs to be:\n\n> b.  If Desc does not have a [[Configurable]] field or settingConfigFalse is true, then throw a TypeError exception.\n\n\nTest case:\n---\nObject.defineProperty(Proxy({}, {defineProperty(){return true}}), \"p\", {})\n---"},{"commentid":7360,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-17 17:33:53 -0800","thetext":"That can't be right either.\n\nAssume that proxy P is maintaining a side table of virtual configurable propertie and that  property \"p\" is already in that table.  \"p\" need not exist as a property of P's target object.  In that case, it would be perfect reasonable to say:\n\nObject.defineProperty(P,\"p\", {value:42}); //or even just { } as the PD.\n\nbut I believe that your proposed change would throw in that case.\n\nIt seems like the root issue is that simply by looking at the argument Desc and the boolean trap result we don't know anything about what the handler actually did including how it interpreted the absence of various fields.  It isn't clear that we can actually check the desired invariants without call [[GetOwnProperty]] on the Prozy to see what it claims to have done."},{"commentid":7370,"comment_count":2,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-02-18 13:39:01 -0800","thetext":"From http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies#invariant_enforcement\n> on success, if argument descriptor is non-configurable, check if \n> the property exists on the target and is also non-configurable\n\nIf the argument descriptor does not have a configurable field, is it considered to be a non-configurable or configurable property descriptor?"},{"commentid":7381,"comment_count":3,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2014-02-20 10:51:01 -0800","thetext":"(In reply to comment #2)\n> From\n> http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies#invariant_enforcement\n> > on success, if argument descriptor is non-configurable, check if \n> > the property exists on the target and is also non-configurable\n> \n> If the argument descriptor does not have a configurable field, is it considered\n> to be a non-configurable or configurable property descriptor?\n\nI think my intent was that an argument descriptor is only considered non-configurable if it explicitly has a configurable:false attribute.\n\nIf the configurable: attribute is missing, then for ordinary (non-exotic) objects it depends on whether the property being set already exists or not. If it exists, and configurable is not specified, the attribute remains untouched. If the property being defined is new, it will be configurable:false.\n\nSo imagine performing Object.defineProperty(o, \"p\", {}) on an object you don't know anything about. Then you can't tell at this time whether \"p\" will be configurable or not. So I think it's fine if this case doesn't throw a TypeError for proxies. IOW I think your test case outlined above should just work."},{"commentid":7383,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-20 12:12:34 -0800","thetext":"(In reply to comment #3)\n\nGoing back to the original bug bug report, the spec (at least currently) only sets 'settingConfigFalse' to true if the Desc actually has a [[Configurable]] field, so the original test case wouldn't throw.\n\nSo, I guess I now don't see a problem in the current spec. language. Does anybody else see one?\n\nA handler might decide to treat a missing Configurable property as meaning non-configurable for a virtual property as long as it didn't also create a corresponding configurable property on the target object.  A configurable target property would case the invariant checks for [[GetOwnProperty]] to fail if it tried to claim the virtual property was non-configurable. \n\n> \n> So imagine performing Object.defineProperty(o, \"p\", {}) on an object you don't\n> know anything about. Then you can't tell at this time whether \"p\" will be\n> configurable or not. So I think it's fine if this case doesn't throw a\n> TypeError for proxies. IOW I think your test case outlined above should just\n> work.\n\nPresumably, somebody making a call like this know their intent and would make an explicit Object.hasOwnProperty check if they wanted the result to be dependent upon the actual existence of the property.\n\nA different approach that would still be ES5 compatible would be to move the missing attribute defaulting out of ordinary [[DefineOwnProperty]] and instead do it in Object.definePropery.  That way no Object.defineProperty originated  [[DefineOwnProperty]] would ever get an partial descriptor for a non-existent property.  However, that would probably be undesirable for Proxy handlers that wanted do support virtual properties with new attributes or different defaulting rules."},{"commentid":7386,"comment_count":5,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2014-02-21 08:38:29 -0800","thetext":"(In reply to comment #4)\n> However, that would probably be undesirable for Proxy handlers that\n> wanted do support virtual properties with new attributes or different\n> defaulting rules.\n\nExactly. We didn't discuss different defaulting rules before, but I remember that we aimed for the defineProperty trap to be able to process non-standard attributes on the argument descriptor.\n\nWe could still attempt to \"complete\" the argument descriptor by filling in missing standard attributes, but I think that would be a can of worms (e.g. if it's an empty descriptor, would we turn it into a data or accessor descriptor?)\n\nIn any case, I'm not sure anything is wrong with the current spec text either.\n\nAndré, can you perhaps elaborate on the problem you identified?"},{"commentid":7391,"comment_count":6,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-02-21 11:34:35 -0800","thetext":"(In reply to comment #5)\n> André, can you perhaps elaborate on the problem you identified?\n\nI don't recall if there was a specific issue which required to throw in that case or if throwing a TypeError was just the expected result from some Mozilla Proxy test. I suspect it was the latter, but I'd need to inspect the individual test cases to be sure. (Or maybe just I wrongly assumed that Object.defineProperty() with an empty property descriptor works the same for ordinary objects and proxies.)"},{"commentid":7424,"comment_count":7,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-03-07 03:02:58 -0800","thetext":"(In reply to comment #6)\n> I suspect it was the latter, but I'd need to inspect the individual\n> test cases to be sure. \n\nI tried to reproduce any failures with the rev21 implementation from last November, but to no avail. So from point of you view, this bug report can be closed as invalid..."}]}}
---
