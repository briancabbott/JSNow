---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3626,"creation_ts":"2015-01-23 14:27:00 -0800","short_desc":"14.4.12 EvaluateBody: Allow \"new function*\" to reference `this`","delta_ts":"2015-02-14 08:08:34 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 31: January 15, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":11637,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-23 14:27:29 -0800","thetext":"14.4.12 Runtime Semantics: EvaluateBody\n\nAdd BindThisValue when a generator function is new'ed, so the following example works again.\n\n---\nfunction* g() { print(this) }\nvar it = new g();\nit.next();\n---"},{"commentid":12611,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-13 16:58:46 -0800","thetext":"The note in 14.4.12 says:\nNOTE\tIf the generator was invoked using [[Call]], the this binding will have already been initialized in the normal manner. If the generator was invoked using [[Construct]], the this bind is not initialized and any references to this within the FunctionBody will produce a ReferenceError exception.\n\n\nThere are two reasons for this behavior:\n\n1) generator methods need 'this' to refer to the object the method was invoked upon, not the resulting generator instance.  for example:\n\n   class Foo {\n       *ownName() {\n           yield* Object.getOwnPropertyNames(this);\n        }\n    }\n\nIt would be confusing if  generator methods bound 'this' one way and generator function declarations did something difference. \n\n2) Within the body of a generator function (or anything called from the generator body you can't do anything interesting with the generator object the body is operating upon. In particular, invoking 'next', 'return', or 'throw' on the active generator from within the body throws (see 25.3.3.2) and those are really the only useful things you can do with a generator object. Making 'this' be a reference to the active generator object would just be an invitation to try to do things that can't be done.\n\nFinally, if you really want to print or otherwise get access to the active generator object, it's easy enough to accomplish:\n\nfunction; g() {\n  let thisGenerator = function*() { print(thisGenerator) }();\n  return thisGenerator\n}"},{"commentid":12628,"comment_count":2,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-02-14 07:02:38 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #1)\n> There are two reasons for this behavior:\n> \n> 1) generator methods need 'this' to refer to the object the method was\n> invoked upon, not the resulting generator instance.  for example:\n> \n> [...]\n> \n> It would be confusing if  generator methods bound 'this' one way and\n> generator function declarations did something difference. \n> \n\nAccessing `this` in new'ed generator methods and generator function declarations currently results in a ReferenceError. So I don't understand what you mean be \"did something different\". \n\n\n> 2) Within the body of a generator function (or anything called from the\n> generator body you can't do anything interesting with the generator object\n> the body is operating upon. In particular, invoking 'next', 'return', or\n> 'throw' on the active generator from within the body throws (see 25.3.3.2)\n> and those are really the only useful things you can do with a generator\n> object. Making 'this' be a reference to the active generator object would\n> just be an invitation to try to do things that can't be done.\n> \n> Finally, if you really want to print or otherwise get access to the active\n> generator object, it's easy enough to accomplish:\n> \n> function; g() {\n>   let thisGenerator = function*() { print(thisGenerator) }();\n>   return thisGenerator\n> }\n\nFWIW, this use case was once mentioned in [1]. If `this` stays to be non-functional in new'ed generator functions, I'd almost like to propose to forbid `new` on generators. But then we're back to bug 1489 which I don't want to re-open right now. \n\n[1] https://esdiscuss.org/topic/retrieving-generator-references"},{"commentid":12649,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-14 08:08:34 -0800","thetext":"(In reply to André Bargull from comment #2)\n> (In reply to Allen Wirfs-Brock from comment #1)\n\n> > \n> > It would be confusing if  generator methods bound 'this' one way and\n> > generator function declarations did something difference. \n> > \n> \n> Accessing `this` in new'ed generator methods and generator function\n> declarations currently results in a ReferenceError. So I don't understand\n> what you mean be \"did something different\". \n\nI meant have different non-error behavior.  \n\n> \n> ...\n\n> FWIW, this use case was once mentioned in [1]. If `this` stays to be\n> non-functional in new'ed generator functions, I'd almost like to propose to\n> forbid `new` on generators. But then we're back to bug 1489 which I don't\n> want to re-open right now. \n\nI agree, on both points.\n\nI think meta properties may be a solution to some of the issues that have been raised:\n\nfunction.startValue  value passed into a generator by first nest\nfunction.generator   the current generator object instance"}]}}
---
