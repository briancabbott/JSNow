---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1590,"creation_ts":"2013-07-17 13:36:00 -0700","short_desc":"11.2.3, 15.1.2.1.1: Direct Eval detection broken after EvaluateCall/EvaluateMethodCall changes","delta_ts":"2013-08-23 08:22:42 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 15: May 14, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"major","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"tomvc.be","long_desc":[{"commentid":4546,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-07-17 13:36:08 -0700","thetext":"The rev16 changes to EvaluateCall (11.2.3) seem to have broken (backwards compatible) direct eval detection. \n\nThis is visible when using the Withstatement. In short, code like:\n---\nwith (obj) { eval(s) }\n---\n\nis per the latest changes equivalent to:\n---\nobj.eval(s)\n---\n\nThe first code sample is a (possible) direct eval per 15.1.2.1.1, whereas the latter code sample is never a direct eval call. \n\nI don't see how it is possible to perform backwards compatible direct eval detection and support EvaluateMethodCall / [[Invoke]] at the same time. Unless EvaluateMethodCall is restricted to pure property references, that means without automatic property reference conversion per EvaluateCall, step 1.b.ii.\n\n\nFull test case:\n---\n(function(global) {\n  var x = 1;\n  var p = new Proxy({}, {\n    has: (_, pk) => {\n      print(\"has: \" + pk);\n      return (pk == \"eval\");\n    },\n    get: (_, pk) => {\n      print(\"get: \" + pk);\n      return global.eval;\n    },\n    invoke: (_, pk, args) => {\n      print(\"invoke: \" + pk);\n    }\n  });\n  with(p) {\n    eval(\"eval('var x = 0')\");\n  }\n  return x;\n})(this);\n---\n\nOutput with rev15:\n---\nhas: eval\nhas: eval\nget: eval\nhas: eval\nhas: eval\nget: eval\nhas: x\n0\n---\n\nOutput with rev16: unspecified"},{"commentid":4550,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-07-17 16:31:14 -0700","thetext":"(In reply to comment #0)\n> The rev16 changes to EvaluateCall (11.2.3) seem to have broken (backwards\n> compatible) direct eval detection. \n> \n> This is visible when using the Withstatement. In short, code like:\n> ---\n> with (obj) { eval(s) }\n> ---\n> \n> is per the latest changes equivalent to:\n> ---\n> obj.eval(s)\n> ---\n> \n\nThis equivalence (for actual call purposes) was also the case in ES5, it's just that the direct eval test needs to be made considering the actual binding model before making that transformation.\n\n> The first code sample is a (possible) direct eval per 15.1.2.1.1, whereas the\n> latter code sample is never a direct eval call. \n\nIf written that way, but we are actually talking about evals that are written like your first example. It wasn't intended that you could treat this as a simple desugaring.\n\n> \n> I don't see how it is possible to perform backwards compatible direct eval\n> detection and support EvaluateMethodCall / [[Invoke]] at the same time. Unless\n> EvaluateMethodCall is restricted to pure property references, that means\n> without automatic property reference conversion per EvaluateCall, step 1.b.ii.\n\nAs your test shows, this is primarily an issue in that direct eval determination requires doing a getValue on the function reference which will do a [[Get]] on the with object.  Ordinary [[Invoke]] also does a [[Get]] for that same property.  Prior to the introduction of [[Invoke]] the result of a  single [[Get]] calls could be used both for the the direct eval test and to supply the this value for the call.  The extra [[Get]] call may be observable if the with object is a Proxy or if its 'eval' property is an accessor.\n\nI think the most straight forward fix is to add another clause to the definition of direct eval that says that this case is not a direct eval when the with object is a proxy.  In that case you can unobservably inline expand the [[Invoke]] for the potentially direct eval case in a manner that avoids the possibility of the extra [[Get]] tripping over an 'eval' accessor.\n\nMessy, but direct eval is inherently a messy hack."},{"commentid":4553,"comment_count":2,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2013-07-18 07:14:40 -0700","thetext":"Hi Allen,\n\nAs a more general point, I would be very careful with introducing spec language that explicitly calls out exceptions for proxies.\n\nThis is because proxies are just one kind of exotic object, and any exception made only for proxies does not necessarily cover other exotics.\n\nHence, rather than adding a clause that says that \"this case is not a direct eval when\nthe with object is a proxy\", would it not be better to state \"this case is not a direct eval when the with object is anything other than a normal ECMAScript object\"?\n\nThat way you cover host objects too (because in general we cannot know whether the inlining is safe for such objects)"},{"commentid":4554,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-07-18 08:37:56 -0700","thetext":"(In reply to comment #2)\n> Hi Allen,\n> \n> As a more general point, I would be very careful with introducing spec language\n> that explicitly calls out exceptions for proxies.\n> \n> This is because proxies are just one kind of exotic object, and any exception\n> made only for proxies does not necessarily cover other exotics.\n> \n> Hence, rather than adding a clause that says that \"this case is not a direct\n> eval when\n> the with object is a proxy\", would it not be better to state \"this case is not\n> a direct eval when the with object is anything other than a normal ECMAScript\n> object\"?\n> \n> That way you cover host objects too (because in general we cannot know whether\n> the inlining is safe for such objects)\n\nI known...I did consider saying \"exotic object\" instead of Proxy but array instances are exotic objects and I can imagine somebody using an array as a with object. It is very unlike that there would be an 'eval' property, but not impossible.\n\nSince what I'm trying to enable is the logical inlining of the ordinary [[Invoke]] for this one special case, I guess I could says it isn't a direct eval when the with object is an exotic object that does not use the ordinary [[Invoke]] internal method."},{"commentid":4555,"comment_count":4,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-07-18 09:31:50 -0700","thetext":"(mid-air collision with Allen, planned to say the same objection w.r.t exotic objects and Arrays/Strings/...)\n\nNevertheless, with the proposed changes I'm now getting the following output with my test implementation (https://github.com/anba/es6draft). So the [[Invoke]] trap is called on the Proxy and no direct eval call takes place. Does this sound right?\n---\nhas: eval\ninvoke: eval\n1\n---"},{"commentid":4556,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-07-18 10:59:30 -0700","thetext":"(In reply to comment #4)\n> Does this sound right?\n> ---\n> has: eval\n> invoke: eval\n> 1\n> ---\n\nyes it does.\n\nBTW, I really like you're tests with the MOP level trace results. These essentially provide a \"fingerprint\" as to whether side-effects occur in the correct order.  We should probably push to get some tests like this into Test262."},{"commentid":4559,"comment_count":6,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2013-07-19 01:28:59 -0700","thetext":"(In reply to comment #3)\n> Since what I'm trying to enable is the logical inlining of the ordinary\n> [[Invoke]] for this one special case, I guess I could says it isn't a direct\n> eval when the with object is an exotic object that does not use the ordinary\n> [[Invoke]] internal method.\n\n+1"},{"commentid":4980,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-08-19 17:55:32 -0700","thetext":"fixed in rev17 editor's draft"},{"commentid":5096,"comment_count":8,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-08-23 08:22:42 -0700","thetext":"fixed in rev17, August 23, 2013 draft"}]}}
---
