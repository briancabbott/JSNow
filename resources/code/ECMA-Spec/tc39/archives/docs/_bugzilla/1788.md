---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1788,"creation_ts":"2013-08-16 08:59:00 -0700","short_desc":"15.1.2.1: Lexical declarations should always get into a new declarative environment","delta_ts":"2014-10-14 15:18:02 -0700","product":"Draft for 6th Edition","component":"normative change from ES5.x","version":"Rev 16: July 15, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":4927,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-08-16 08:59:45 -0700","thetext":"\"10.5.5 Eval Declaration Instantiation\" is not yet specified, so it's hard to tell how lexical declarations interact with eval'ed code, but I'd still like to suggest to change 15.1.2.1, step 14 to add an else-branch which creates a new declarative environment:\n\n14.  If strictScript is true or if direct is true and strictCaller is true, then\n  a.  Let strictVarEnv be the result of calling NewDeclarativeEnvironment passing lexEnv as the argument.\n  b.  Let lexEnv be strictVarEnv.\n  c.  Let varEnv be strictVarEnv.\n15.  Else\n  a.  Let newLexEnv be the result of calling NewDeclarativeEnvironment passing lexEnv as the argument.\n  b.  Let lexEnv be newLexEnv.\n\n\nWith this change lexical declarations in the eval'ed code are always created within a new declarative environment. That means the following code does not add a let-bound variable to the block scope:\n---\nlet x = 0;\n{ /* block scope */\n  eval(\"let x = 1\");\n}\n---\n\nIt also ensures lexical declarations are true lexical declarations. Without a new lexical environment, this code would create a data property \"x\" in the object \"o\" with value `1`:\n---\nlet o = {};\nwith(o) eval(\"let x = 1\");\n---\n\nAnd obviously this approach is also beneficial for VMs, because they can give block scopes static shapes. \n\n\n\nSpiderMonkey handles this a bit different, basically \"let <id> = <expression>\" is rewritten to \"var <id>; <id> = <expression>;\". This also gives block scopes static shapes, but lexical declarations can still degenerate into other declaration forms as the following test case shows:\n---\nlet o = {x: 0};\nwith(o) eval(\"let x=1\");\nassertEq(o.x, 1);\nassertEq('x' in this, true);\n---"},{"commentid":5008,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-08-22 11:16:37 -0700","thetext":"sounds like a good idea.  Probably need to discuss it on es-discuss or at  TC39 meeting"},{"commentid":10316,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-10-11 16:45:27 -0700","thetext":"fixed in rev28 editor's draft"},{"commentid":10484,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-10-14 15:18:02 -0700","thetext":"fixed in rev28"}]}}
---
