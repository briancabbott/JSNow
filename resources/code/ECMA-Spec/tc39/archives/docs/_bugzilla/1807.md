---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1807,"creation_ts":"2013-08-23 15:21:00 -0700","short_desc":"better wording for Math.roundFloat32","delta_ts":"2013-09-27 14:47:19 -0700","product":"Draft for 6th Edition","component":"editorial issue","version":"Rev 17: August 23, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"dherman","name":"Dave Herman"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":5207,"comment_count":0,"who":{"uid":"dherman","name":"Dave Herman"},"bug_when":"2013-08-23 15:21:24 -0700","thetext":"The spec for Math.roundFloat32 refers to IEEE-868-2005 which I've never heard of, and I can't find any evidence of its existence on Google or the IEEE web site. :) I assume you meant IEEE-754-2008. But the rest of the spec simply refers to it as IEEE 754, so for consistency I'd use that wording.\n\nHere's how I would write the steps:\n\n* If x is NaN, return NaN.\n* If x is one of -0, 0, +∞, -∞, the return x.\n* Let x32 be the result of converting x to a value in IEEE 754 single-precision 32-bit binary format using roundTiesToEven.\n* Let x64 be the result of converting x32 to a value in IEEE 754 double-precision 64-bit binary format.\n* Return the ECMAScript number corresponding to x64.\n\nDave"},{"commentid":5378,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-09-10 15:03:12 -0700","thetext":"fixed in rev19 editor's draft"},{"commentid":5531,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-09-27 14:47:19 -0700","thetext":"fixed in rev19"}]}}
---
