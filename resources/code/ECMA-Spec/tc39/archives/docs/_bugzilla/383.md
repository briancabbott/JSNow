---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":383,"creation_ts":"2012-06-11 06:42:00 -0700","short_desc":"Array.from (15.4.3.3) additional note describes Array.of","delta_ts":"2012-06-14 22:44:46 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 7: May 4, 2012 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"waldron.rick","name":"Rick Waldron"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"waldron.rick","long_desc":[{"commentid":974,"comment_count":0,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2012-06-11 06:42:23 -0700","thetext":"Currently, the NOTE reads \n\n\n  NOTE\tThe from function is an intentionally generic factory method; it does   not require that its this value be the Array constructor. Therefore it can be transferred to or herited by any other constructors that may be called with a single numeric argument.\n\n\nIt should be updated to:\n\n\n\n  NOTE\tThe from function is an intentionally generic factory method; it does not require that its this value be the Array constructor. Therefore it can be transferred to or inherited by any other constructors that may be called with a single arrayLike argument.\n\n\n\nThe difference is in the type of argument (single numeric => arrayLike) it should accept and a minor typo fix."},{"commentid":980,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-06-14 17:29:52 -0700","thetext":"No, numeric is actually correct.  If this method is going to be invoked as a method of a constructor named Collection, eg: \n\n   let c = Collection.of(1,2,3)\n\nthen the dependency is upon being able to say:\n\n     new Collection(3)  /* allocate a Collection with 3 elements */\n\nThat is because the semantics is roughly:\n\nfunction of(...items) {\n   let result = new this(items.length);\n   for (i=0; i<item.length; ++i) result[i]=items[i];\n   return result;\n}\n\nI did fix the type..."},{"commentid":983,"comment_count":2,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2012-06-14 18:42:41 -0700","thetext":"I'm not disputing that for Array.of, I'm pointing out that it says the same thing under Array.from"},{"commentid":984,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-06-14 19:33:34 -0700","thetext":"It applies to both of them.  The only real difference is that |of| works with a rest parameter while |from| works with a caller supplied array-like object.  But they are both processed in exactly the same way. \n\nThey both do the equivalent of\n   new this(len)\n\nThe NOTE is referring to the fact that the this value (the constructor that |from| or |of| is invoked on needs to support a |new| call like above."},{"commentid":985,"comment_count":4,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2012-06-14 21:35:48 -0700","thetext":"I've read through both of them, and I wrote the original document that David Herman linked to in the strawman proposal, I dont understand why there is a note referring to a call like this:\n\nArray.from( 1 )\n\nWhat would this produce?"},{"commentid":986,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-06-14 22:39:10 -0700","thetext":"(In reply to comment #4)\n> I've read through both of them, and I wrote the original document that David\n> Herman linked to in the strawman proposal, I dont understand why there is a\n> note referring to a call like this:\n> \n> Array.from( 1 )\n\nthat's not what the note is referring to it is referring to a call like:\n  new Array(0)\nwhich the function makes internally in step 7.a\n> \n> What would this produce?\n\nAn empty Array, essentially the same as:\n\n      Array.from([])\n\nArray.from takes one argument.  Step 1 coerces the argument to an object by calling ToObject.  ToObject(1) produces a Number wrapper objects.  Step 3 accesses the value of the wrapper objects \"length\" property.  It doesn't have one so, lenValue is undefined. ToInteger(undefined) returns 0, so len is 0 after step 4.  Step 7.a performs essentially new Array(len) and produces a length array.  Step 11 does nothing because len is 0. Step 12 (redundantly in this case) updates the length of the array to 0 and finally step 14 returns the 0-length array as the value of Array.from.\n\nThis is all  normal procedure for processing \"array-like\" objects in the built-ins.  Because ToInteger(undefined) always yields 0 any object is effectively a 0-length array-like object.\n\nFor example:\n   [].forEach.call(1, function() {console.log('called')});\n\noutput nothing because 1 is converted into an array-like object of length 0."},{"commentid":987,"comment_count":6,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2012-06-14 22:44:46 -0700","thetext":"Thanks - I understand the steps in the specification, but it's clear now that I misunderstood the \"NOTE: ...\" section, where it said \"may be called with a single numeric argument.\"\n\nSorry for the noise"}]}}
---
