---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3550,"creation_ts":"2015-01-16 04:41:00 -0800","short_desc":"new Object(value), for value != null, is no longer equivalent to ToObject(value)","delta_ts":"2015-07-10 08:35:04 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 31: January 15, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"claude.pache","name":"Claude Pache"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["andrebargull","erik.arvidsson"],"long_desc":[{"commentid":11473,"comment_count":0,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2015-01-16 04:41:04 -0800","thetext":"+++ This bug was initially created as a clone of Bug #3544 +++\n\n[removing noise of Bug #3544]\n\n19.1.1.1 Object([ value ])\n\nAs specced in Rev 31, `new Object(foo)`, for foo != null, is now just equivalent to `new Object()` instead of ToObject(foo).\n\nOne should revert to the definition of Rev 30, that is removing the newly added step 1."},{"commentid":11475,"comment_count":1,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2015-01-16 04:41:45 -0800","thetext":"*** Bug 3544 has been marked as a duplicate of this bug. ***"},{"commentid":11493,"comment_count":2,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2015-01-16 08:59:33 -0800","thetext":"Better fix: modify step 1 the following way:\n\n1. If NewTarget is neither null nor the active function object, then,\n    a. Return etc."},{"commentid":11510,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-16 10:33:15 -0800","thetext":"fixed in rev32 editor's draft"},{"commentid":11773,"comment_count":4,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-31 06:45:32 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #3)\n> fixed in rev32 editor's draft\n\nI assume this was changed in the following way. Correct?\n\n---\n1. If NewTarget is null, let newTarget be the active function object, else let newTarget be NewTarget.\n2. If value is null, undefined or not supplied, return OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\" ).\n3. Return ToObject(value).\n---"},{"commentid":11795,"comment_count":5,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2015-01-31 08:43:54 -0800","thetext":"(In reply to André Bargull from comment #4)\n\nConsider:\n\n    class Foo extends Object { }\n    new Foo(3)\n\nWith your algorithm you obtain a Number object. I think that the spec intent is to produce an instance of Foo."},{"commentid":11796,"comment_count":6,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-31 09:02:09 -0800","thetext":"(In reply to Claude Pache from comment #5)\n> (In reply to André Bargull from comment #4)\n> \n> Consider:\n> \n>     class Foo extends Object { }\n>     new Foo(3)\n> \n> With your algorithm you obtain a Number object. I think that the spec intent\n> is to produce an instance of Foo.\n\nAh I see. What about this solution? Step 3 should handle the Object called from sub-class constructor issue.\n\n---\n1. Let activeF be the active function object.\n2. If NewTarget is null, let newTarget be activeF, else let newTarget be NewTarget.\n3. If SameValue(activeF, newTarget) is false, return OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n4. If value is null, undefined or not supplied, return OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n5. Return ToObject(value).\n---"},{"commentid":11815,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-31 14:43:34 -0800","thetext":"Here is the algorithm I actually used for Comment 3\n\n1.\tIf NewTarget is neither undefined nor the active function, then,\n   a.\t   Return OrdinaryCreateFromConstructor(NewTarget, \"%ObjectPrototype%\").\n2.\tIf value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).\n3.\tReturn ToObject(value).\n\n(note the [[call]] state of NewTarget has now been changed from null to undefined)\n\nnote that by step 2 we know that NewTarget is either undefined or a Object constructor function, so we can use ObjectCreate instead of OrdinaryCreate..."},{"commentid":11853,"comment_count":8,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-02-01 04:53:14 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #7)\n> note that by step 2 we know that NewTarget is either undefined or a Object\n> constructor function, so we can use ObjectCreate instead of OrdinaryCreate...\n\nThat means I have to re-open bug 3136. Here's another test case for bug 3136:\n---\nfunction cloneWithProto(constructor, prototype) {\n  return Object.defineProperty(constructor.toMethod({}), \"prototype\", {value: prototype});\n}\n\nfor (var constructor of [Object, Array, Date, Error, TypeError, RegExp, String, Boolean, Number]) {\n  var clone = cloneWithProto(constructor, {});\n  var obj = new clone();\n  print(Object.getPrototypeOf(obj) === clone.prototype);\n}\n---\n\nThe above program prints \"true\" for every constructor function except for `Object`. Changing ObjectCreate to ObjectCreateFromConstructor will align `Object`'s behaviour to be in line with the other built-in constructor functions."},{"commentid":11868,"comment_count":9,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-02 08:24:14 -0800","thetext":"(In reply to Claude Pache from comment #5)\n> (In reply to André Bargull from comment #4)\n> \n> Consider:\n> \n>     class Foo extends Object { }\n>     new Foo(3)\n> \n> With your algorithm you obtain a Number object. I think that the spec intent\n> is to produce an instance of Foo.\n\nI actually think this should create an `[object Number]` exotic object. The prototype chain will still have Foo.prototype on it.\n\nThat would be much more consistent with the rest of the semantics.\n\n  class C extends Object {}\n\nis very different from\n\n  class C {}\n\nThe former has class side inheritance and the instance object is created by calling [[Construct]] on Object with NewTarget passed along.\n\nA similar case would be if I have a base class that might create a typed array in some cases and a plain array in other cases."},{"commentid":11870,"comment_count":10,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2015-02-02 09:18:48 -0800","thetext":"(In reply to Erik Arvidsson from comment #9)\n> (In reply to Claude Pache from comment #5)\n> > (In reply to André Bargull from comment #4)\n> > \n> > Consider:\n> > \n> >     class Foo extends Object { }\n> >     new Foo(3)\n> > \n> > With your algorithm you obtain a Number object. I think that the spec intent\n> > is to produce an instance of Foo.\n> \n> I actually think this should create an `[object Number]` exotic object. The\n> prototype chain will still have Foo.prototype on it.\n> \n\nMaybe, but I doubt that anyone would willfully construct a Number object without `Number.prototype` in its prototype chain using that syntax. DDWIDM."},{"commentid":12027,"comment_count":11,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-02 18:39:02 -0800","thetext":"fixed in rev32 draft"}]}}
---
