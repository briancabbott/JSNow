---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4019,"creation_ts":"2015-02-20 04:14:00 -0800","short_desc":"WeakMap/Set.get/has should throw TypeError","delta_ts":"2015-07-10 08:35:00 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 33: February 12, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"rossberg","name":"Andreas Rossberg"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["erights","erik.arvidsson","gilles.lepretre","julien.sanchez"],"long_desc":[{"commentid":13180,"comment_count":0,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2015-02-20 04:14:13 -0800","thetext":"The .get and .has methods on weak collections return undefined when a key is not an object. That is inconsistent with .set, which throws.\n\nI'm not sure if this is a recent change (the V8 implementation always throws, and I assume we were following the spec draft at the time). Either way, it doesn't make sense to consider non-objects valid keys in some operations but not others."},{"commentid":13182,"comment_count":1,"who":{"uid":"gilles.lepretre","name":"Gilles Lepretre"},"bug_when":"2015-02-20 05:51:36 -0800","thetext":"Related Mozilla issue (Resolved fixed): https://bugzilla.mozilla.org/show_bug.cgi?id=1127827\n\nRelated Chromium issue: https://code.google.com/p/chromium/issues/detail?id=460083"},{"commentid":13183,"comment_count":2,"who":{"uid":"julien.sanchez","name":"Julien Sanchez"},"bug_when":"2015-02-20 06:18:53 -0800","thetext":"For reference, the behavior about handling of non-object values in WeakMap has been updated in rev20 draft, Oct. 28, 2013:\n\nhttps://bugs.ecmascript.org/show_bug.cgi?id=1938\n\nhttp://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#october_28_2013_draft_rev_20"},{"commentid":13184,"comment_count":3,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2015-02-20 06:36:15 -0800","thetext":"Thanks for the reference, I obviously missed that change. Sorry or being late on this.\n\nI agree with the implication requested in comment #2 on that bug. However, Mark's suggestion \"fixed\" it the wrong way. Having all methods throw consistently on non-object keys would achieve the same implication, and in addition, provide a consistent behaviour for invalid keys.\n\nThat is, in addition to Andre's implication, the following equivalences should also hold:\n\n  m.set(k,v) throws  <=>  m.get(k) throws  <=>  m.has(k) throws  <=>  m.delete(k) throws\n\nand similarly for sets."},{"commentid":13330,"comment_count":4,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-24 16:05:56 -0800","thetext":"Hi Andreas, we seem to disagree about which inconsistency is greater. The way I see it, WeakMap.set must satisfy only a subset of Map.set's contract, by rejecting all non-object keys. But, given that it does so, then the mapping cannot contain any non-object keys.\n\nWeakMap.has, .get, and .delete can then fulfill the full Map.has, .get, and .delete contract, as they would on a map whose mapping did not contain any non-object keys -- whether or not they could.\n\nPut another way, .set has the specialized job of admission control. .has, .get, and .delete need only deal with what was admitted.\n\n----\n\nWe can also look at it from the side of multiplying special cases in the clients of these abstractions. A client of a mapping abstraction that might be given a Map or a WeakMap, and that does a .set, must be prepared for .set(primValue) to throw, or must avoid that case. Likewise, it must not use any of the Map api that is absent from WeakMap. But a client who is only given a mapping that is populated by others, and only does a .get, .has, and .delete on it should not need to care about the difference, since both mapping abstractions can satisfy the same contract for these."},{"commentid":13413,"comment_count":5,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2015-02-27 06:12:11 -0800","thetext":"(In reply to Mark Miller from comment #4)\n> Hi Andreas, we seem to disagree about which inconsistency is greater. The\n> way I see it, WeakMap.set must satisfy only a subset of Map.set's contract,\n> by rejecting all non-object keys. But, given that it does so, then the\n> mapping cannot contain any non-object keys.\n> \n> WeakMap.has, .get, and .delete can then fulfill the full Map.has, .get, and\n> .delete contract, as they would on a map whose mapping did not contain any\n> non-object keys -- whether or not they could.\n> \n> Put another way, .set has the specialized job of admission control. .has,\n> .get, and .delete need only deal with what was admitted.\n> \n> ----\n> \n> We can also look at it from the side of multiplying special cases in the\n> clients of these abstractions. A client of a mapping abstraction that might\n> be given a Map or a WeakMap, and that does a .set, must be prepared for\n> .set(primValue) to throw, or must avoid that case. Likewise, it must not use\n> any of the Map api that is absent from WeakMap. But a client who is only\n> given a mapping that is populated by others, and only does a .get, .has, and\n> .delete on it should not need to care about the difference, since both\n> mapping abstractions can satisfy the same contract for these.\n\nI see. This is presuming that weak collections are a useful drop-in replacement for a general ones. Not sure they ever are, though. Their contracts are far more restrictive, and consequently, they're _not_ in a semantic subclass relation. I'm not convinced it's particularly useful to maintain that illusion for a tiny subset of their interface.\n\nA context that would work correctly with both weak and non-weak collections but falls over with the semantics I'm proposing would have rather rare properties: (1) it doesn't iterate the collection, (2) it wants to check the collection for keys that are not objects, but (3) it is guaranteed to never store non-objects.\n\nWeighing this against an internally consistent treatment of key types in weak collections, I find the latter more relevant."},{"commentid":13414,"comment_count":6,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-27 07:54:29 -0800","thetext":"Another vote in support for type checking in get/has.\n\nLets do an analogy. If I implement a StringMap where the keys have to be strings, I could let `get` take any type and always return undefined if not a string. But I find it more useful to throw in that case to show that the caller passed in something non meaningful."},{"commentid":13415,"comment_count":7,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-27 08:28:43 -0800","thetext":"(In reply to Erik Arvidsson from comment #6)\n> Another vote in support for type checking in get/has.\n> \n> Lets do an analogy. If I implement a StringMap where the keys have to be\n> strings, I could let `get` take any type and always return undefined if not\n> a string. But I find it more useful to throw in that case to show that the\n> caller passed in something non meaningful.\n\nInteresting. When I first started reading your analogy, I expected exactly the opposite conclusion.\n\nPerhaps \"delete\" is confusing the picture. If we omit it from the discussion for a moment, then my answer to Andreas'\n\n> A context that would work correctly with both weak and non-weak collections \n> but falls over with the semantics I'm proposing would have rather rare \n> properties: \n> (1) it doesn't iterate the collection, \n> (2) it wants to check the collection for keys that are not objects, but \n> (3) it is guaranteed to never store non-objects.\n\nIs that it is frequent to separate updating contexts from pure querying contexts. A pure querying context is guaranteed never to store non-objects because it never stores anything. That is up to the producer of the mappings it consumes. To a consumer, it hardly matters whether the producer did not store an X vs could not store an X. Precedent:\n\n> \"abc\".indexOf({})\n-1\n\nWould you rather have that throw?\n\n\nHad we specified that deleting a key that doesn't exist throws, then \"delete\" would not be such an oddball. OTOH, if we consider consuming consumers (e.g. linear consumers) in addition to side-effect-free consumers, then considering \"delete\" to be part of the more lenient consuming type makes some sense."},{"commentid":13416,"comment_count":8,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-27 08:59:33 -0800","thetext":"(In reply to Mark Miller from comment #7)\n> > \"abc\".indexOf({})\n> -1\n> \n> Would you rather have that throw?\n\nIf there was a do-over? Yes."},{"commentid":13417,"comment_count":9,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2015-02-27 09:22:59 -0800","thetext":"(In reply to Mark Miller from comment #7)\n> (In reply to Erik Arvidsson from comment #6)\n> > Another vote in support for type checking in get/has.\n> > \n> > Lets do an analogy. If I implement a StringMap where the keys have to be\n> > strings, I could let `get` take any type and always return undefined if not\n> > a string. But I find it more useful to throw in that case to show that the\n> > caller passed in something non meaningful.\n> \n> Interesting. When I first started reading your analogy, I expected exactly\n> the opposite conclusion.\n> \n> Perhaps \"delete\" is confusing the picture. If we omit it from the discussion\n> for a moment, then my answer to Andreas'\n> \n> > A context that would work correctly with both weak and non-weak collections \n> > but falls over with the semantics I'm proposing would have rather rare \n> > properties: \n> > (1) it doesn't iterate the collection, \n> > (2) it wants to check the collection for keys that are not objects, but \n> > (3) it is guaranteed to never store non-objects.\n> \n> Is that it is frequent to separate updating contexts from pure querying\n> contexts. A pure querying context is guaranteed never to store non-objects\n> because it never stores anything. That is up to the producer of the mappings\n> it consumes.\n\nYes, but that is ignoring the other two conditions. It would have to be a pure consumer that does not iterate. And one that somehow expects to be able to ask for non-object keys in a context where there can't possibly be any. I'm too uncreative to imagine a scenario for that.\n\n> To a consumer, it hardly matters whether the producer did not\n> store an X vs could not store an X. Precedent:\n> \n> > \"abc\".indexOf({})\n> -1\n> \n> Would you rather have that throw?\n\nMost definitely. The likelihood of this not being the symptom of a bug seems close to 0."},{"commentid":13423,"comment_count":10,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-27 13:18:37 -0800","thetext":"so, we either need to resolve this as \"works as intended\" or decided to make a change.\n\nMy default response is likely to be the former as Mark is the champion of this feature and the spec. reflects his position and also the result of past discussions on this matter. \n\nHowever, I will point out that throwing an exception is behavior that could be relaxed in the future if it proves to be a bad choice, while there isn't really any backwards compatible way to reverse the decision if we keep  the no exception alternative."},{"commentid":13426,"comment_count":11,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-27 14:09:38 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #10)\n> so, we either need to resolve this as \"works as intended\" or decided to make\n> a change.\n> \n> My default response is likely to be the former as Mark is the champion of\n> this feature and the spec. reflects his position and also the result of past\n> discussions on this matter. \n> \n> However, I will point out that throwing an exception is behavior that could\n> be relaxed in the future if it proves to be a bad choice, while there isn't\n> really any backwards compatible way to reverse the decision if we keep  the\n> no exception alternative.\n\na) I agree with that last point. When it is not clear what the right decision is, if there's a way to safely and compatibly postpone the decision, I've generally been in favor of that.\n\nb) I also agree that it is not clear in this case what the right decision is. My intuition remains that the current behavior is better. But my rationale for that is not strong enough to be confident I can't be convinced otherwise.\n\nc) I do understand that, in terms of committee dynamics, consenting to this change now makes it unlikely that I'll get it the \"right\" way in the future. Today, if we don't get consensus to change, then the \"right\" status quo wins. If we make it throw in ES6, then if we don't get consensus to change later, the \"wrong\" status quo wins. However, given #a and #b, I think I need to concede to this change.\n\n\nOne more time though, here's a further explanation of my intuition here:\n\nIn a statically typed world, it makes sense to see abstractions as partial functions of the set of all possible inputs -- the type system prevents most inputs from even being tried at runtime. In a dynamic system, for many purposes we still think of abstractions as partial, but the situation is more mixed. If we consider throw to be among the responses, then abstractions are total -- they may be given any first class value at runtime. In response to, let's say, a boolean query, if the answer to the question being asked is true, I expect the query to respond \"true\". If the answer to the question being asked false, I expect the query to respond \"false\". If the response is throw, I expect this indicates that the query is ill formed or meaningless, or at least something for which neither \"true\" nor \"false\" is a logically sound response to the query's meaning.\n\nmap.has(88)\n\nasks whether the map has 88 as a key. If it does not, it should tell me that. Throwing is basically saying: \"I refuse to tell you whether I have 88 as a key, even though I know, because I don't think you should have asked.\"\n\nGood API design for a dynamic language is different than good API for a dynamic language.\n\nHave I convinced anyone?\n\n\nAllen, independent of the historical, scheduling, and committee issues, as a dynamic language design person, I am curious what you think. Care to weigh in?"},{"commentid":13427,"comment_count":12,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-27 14:12:17 -0800","thetext":"> Good API design for a dynamic language is different than good API for a \n> dynamic language.\n\nOops. Not what I meant ;)."},{"commentid":13428,"comment_count":13,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-27 14:41:37 -0800","thetext":"(In reply to Mark Miller from comment #11)\n\n> \n> \n> Allen, independent of the historical, scheduling, and committee issues, as a\n> dynamic language design person, I am curious what you think. Care to weigh\n> in?\n\nI'm fine with the current behavior.  My preference is to allow programs to continue making forward progress until it reaches a point where that is impossible. If, upon the basis of  map.has returning false, a program tries to do something that is impossible to do such as set a non-object key in a WeakMap, then the point of the set is probably where the exception should occur."},{"commentid":13732,"comment_count":14,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-15 11:47:29 -0700","thetext":"I plan closing this as WONTFIX (really \"Works as intended\") unless somebody intends to bring this up at the March TC39 meeting as a ES6 approval blocker."}]}}
---
