---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4419,"creation_ts":"2015-07-08 14:28:00 -0700","short_desc":"14.1.18 Wrong scoping of non-strict direct evals in ComputedPropertyNames in parameters","delta_ts":"2015-11-02 14:56:44 -0800","product":"ECMA-262 Edition 6","component":"technical issues","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"allen","name":"Allen Wirfs-Brock"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["bakkot","brterlso","bugs.ecmascript"],"long_desc":[{"commentid":14534,"comment_count":0,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-07-08 14:28:39 -0700","thetext":"On Jul 8, 2015, at 12:25 PM, Kevin Gibbons wrote:\n\nIn the final ECMAScript 2015 spec, each function for which ContainsExpression of that function's [[FormalParameters]] internal slot is true has a scope object for its parameters. Additionally, these functions have a separate scope object under this one for each parameter that has an initializer. See 14.1.18 for the production \"FormalParameter : BindingElement\". The last sentence of this section states\n\nThe new Environment Record created in step 6 is only used if the BindElementâ€™s Initializer contains a direct eval.\n\nThis is shown to be incorrect (aside from the \"BindElement\" typo) with the following program.\n\nvar x = \"outer\";\nfunction f({ [eval('var x=\"inner\"; \"a\";')]: y } = null) {\n  console.log(x);\n}\nf({a: \"z\"});\n\nBecause the presence of an initializer causes a new scope to be created, in which the entire BindingElement is evaluated, this should print \"outer\". Therefore, the scope is used any time there is a direct eval in BindingElement.\n\nThe intent, per the last sentence of 14.1.18 and bug 3383, is that direct evals in the parameter list cannot introduce new variables in the function's parameters scope mentioned earlier. However, non-strict direct evals can also occur in computed property names in parameters which do not have initializers\n\nvar x = \"outer\";\nfunction f({ [eval(\"var x='inner'; 'a';\")]: y }) {\n  console.log(x);\n}\nf({a: \"z\"});\n\nBecause the separate scope is not created if no initializer is present, this should print \"inner\".\n\nIntroducing an initializer, even an initializer which is just a simple value, causes a separate scope to be created. This is non-intuitive, and appears to be unintentional.\n\nThere are multiple ways that this behavior can be fixed\n\nCreate a new scope for each parameter, unconditionally\nCreate a new scope for parameters for which ContainsExpression is true, instead of just those that have an initializer\nDefine code in computed property names as strict code\n\nThe erroneous sentence at the end of section 14.1.18 may be fixed by replacing it with \"The new Environment Record created in step 6 is only used if the BindElement contains a direct eval.\"."},{"commentid":14535,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-07-08 14:31:23 -0700","thetext":"This is an oversight, I forget about the possibility of computer property name expressions in a parameter position.\n\nThe appropriate fix is: Create a new scope for parameters for which ContainsExpression is true, instead of just those that have an initializer\n\nthis reflects what we originally intended.\n\nFinally the sentence at the end should be converted to a NOTE in addition to the suggested change"},{"commentid":14879,"comment_count":2,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-11-02 14:56:44 -0800","thetext":"Fixed in ES2016 Draft."}]}}
---
