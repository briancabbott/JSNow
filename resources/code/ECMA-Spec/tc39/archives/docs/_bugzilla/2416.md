---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2416,"creation_ts":"2014-01-15 23:01:00 -0800","short_desc":"22.1.2.1 usingIterator=true when Array.from's arg is an Array","delta_ts":"2014-07-15 13:23:18 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 21: November 8, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"ecmascript","name":"C. Scott Ananian"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["andrebargull","mathias","medikoo+ecmascript.org"],"long_desc":[{"commentid":6970,"comment_count":0,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-01-15 23:01:47 -0800","thetext":"Since 22.1.3.30 specifies that Array.prototype.@@iterator exists, the test in step 6 of Array.from (22.1.2.1) will set usingIterator to true when the \"arrayLike\" is an actual Array.  This doesn't seem correct, it means that the length information in the passed array will be ignored, the result can't be preallocated to the correct length, and sparse elements skipped:\n\nvar a = [];\na[1] = 'a';\na[9] = 'b';\nArray.from(a) // ['a','b']?\n\nI suggest that step 6a ought to read something like, \"If Array.isArray(items) is true, the set usingIterator to false.\" (or \"If items is an exotic Array object...\").  Since typed arrays also have iterators, you might also want to include a step 6b, \"If items is a typed array...\", so that the following works as expected:\n\nvar a = new Uint8Array(2);\nvar b = Array.from.call(Uint8Array, a); // 0-length array?\n\nAs the algorithm is currently written, the Uint8Array constructor would be called with no arguments and the result of Array.from() would be a zero-length array.\n\nIf the behavior in the spec as it is currently written is desired, the author could pass the iterator explicitly:\n\nArray.from(a.values()) // collapses sparse array\nArray.from.call(Uint8Array, a.values()) // makes zero-length Uint8Array\n\nSo no functionality is lost by making Array and TypedArray *not* use the usingIterator path.\n\nThe algorithm in 22.2.2.1 (%TypedArray%.from) should also be similarly updated to match the fixes to Array.from."},{"commentid":6971,"comment_count":1,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-01-16 06:38:03 -0800","thetext":"It is not possible to apply Array.from() on TypedArray constructors, regardless of whether the @@iterator or .length path is taken. Either CreateDataPropertyOrThrow() or the final Put() will throw a TypeError when `A` is TypedArray object.\n\nAnd array iterators don't skip holes, that means `0 in Array.from([,])` yields true.\n\nRelated:\nhttp://esdiscuss.org/topic/overly-complicated-array-from\nhttp://esdiscuss.org/topic/why-does-array-from-accept-non-iterable-arraylikes"},{"commentid":6972,"comment_count":2,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-01-16 07:42:25 -0800","thetext":"Sorry about the sparse thing, I was looking at es6-shim's implementation, which had a hole-skipping ArrayIterator that must be left over from some earlier version of the spec.  I'll submit a patch to es6-shim.\n\nI think the TypedArray case is still significant.\n\nu = Uint8Array(8)\nu[\"1\"] = 2\nu.length = 8\n\ndoesn't currently throw an exception, why would Array.from() do so?  It seems like Array.from should work with TypedArray if it is to be properly generic.  (Or a @TypedArray@.from() method could be added, but -- ugh.)\n\nAnd it seems like there are still significant performance gains to be had by preallocating arrays.  That holds even for custom classes:\n\nArray.from.call(MyClass, [1, 2, 3])\n\nThe MyClass constructor might be also able to benefit from knowing the length of the array up-front."},{"commentid":6973,"comment_count":3,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-01-16 09:50:52 -0800","thetext":"(In reply to comment #2)\n> I think the TypedArray case is still significant.\n> \n> u = Uint8Array(8)\n> u[\"1\"] = 2\n> u.length = 8\n> \n> doesn't currently throw an exception, why would Array.from() do so?\n\nIt does not throw an exception, because the JavaScript implementation you're using does not comply to the current ES6 draft. ;-)\n\nV8 bleeding edge (rev18548, version 3.24.15):\n---\nd8> \"use strict\"; var u = new Uint8Array(8); u.length = 8\n(d8):1: TypeError: Cannot set property length of #<Uint8Array> which has only a getter\n\"use strict\"; var u = new Uint8Array(8); u.length = 8\n                                                  ^\nTypeError: Cannot set property length of #<Uint8Array> which has only a getter\n    at (d8):1:51\n---\n\nThe \"use strict\" directive is important to get the same semantics as in `Put(A, \"length\", len, true)`, the last parameter defines the strictness of the Put() operation.\n\n\n> And it seems like there are still significant performance gains to be had by\n> preallocating arrays.  That holds even for custom classes:\n> \n> Array.from.call(MyClass, [1, 2, 3])\n> \n> The MyClass constructor might be also able to benefit from knowing the length\n> of the array up-front.\n\nFor the standard Array it's actually not too import which path is preferred, as long as there are no funny properties (read: accessor properties) which introduce arbitrary side effects. Changes like https://bugzil.la/952891 will further improve array iteration. And custom classes can use the TypedArray.from() function if it's necessary or helpful to know the expected length in the constructor invocation.\n\n(Note: I'm not strictly in favour of one or the other approach, I'm merely providing some input for this discussion.)"},{"commentid":7374,"comment_count":4,"who":{"uid":"medikoo+ecmascript.org","name":"Mariusz Nowak"},"bug_when":"2014-02-19 13:36:37 -0800","thetext":"I'd like to go back to sparse array's case, as I think it's still not right.\n\nIndeed result array's length will match length of input array, but it won't be perfect copy of it.\n\nvar input = [1,,2];\nvar result = Array.from(input); // [1,undefined,2];\n\ninput.hasOwnProperty(1); // false\nresult.hasOwnProperty(1); // true\ninput.forEach(x => console.log(x)); // 1, 2\nresult.forEach(x => console.log(x)); // 1, undefined, 2\n\nIt seems not consistent, especially that there are cases for which Array.from will produce sparse arrays:\n\nArray.from({0: 1, 2: 2, length: 2 }); // 1,,2 (sparse array)\n\nI thik as C. Scott Ananian propopsed, arrays should go through logic specified for `usingIterator = true`.\n\nIf it stays as it is it makes this function not viable to produce array copies, which is very common use case, currently addressed with `arr.slice()`, and as `arr.slice()` will now create objects of input type it's no longer safe for creation of plain arrays, it'll be great if Array.from could be used for that."},{"commentid":7375,"comment_count":5,"who":{"uid":"medikoo+ecmascript.org","name":"Mariusz Nowak"},"bug_when":"2014-02-19 23:45:59 -0800","thetext":"Sorry, of course I meant:\n\n====\n(...)\nArray.from({0: 1, 2: 2, length: 3 }); // 1,,2 (sparse array)\n\nI think as C. Scott Ananian propopsed, arrays should *not* go through logic specified for `usingIterator = true`.\n(...)\n===="},{"commentid":7378,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-20 08:35:25 -0800","thetext":"Array.from was discussed at the last TC39 meeting.  See https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-01/jan-28.md#arrayfrom \n\nI don't think those notes capture the entire discussion, but the conclusion is clear: \"Keep as spec'ed.\"\n\nHowever, I don't think the points brought up here were fully explored at the meeting.\n\nIn particular, I don't think it was clear to everybody that:\n\nArray.from([1,,3,,5])\n\nreturns [1,3,5] rather than [1,undefined,3,undefined,5].\n\nI think an appropriate next step would be for Scott to start a new es-discuss thread that specifically addresses that concern and references this bug.\n\nAllen"},{"commentid":7390,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-21 10:13:15 -0800","thetext":"(In reply to comment #6)\n\n> \n> In particular, I don't think it was clear to everybody that:\n> \n> Array.from([1,,3,,5])\n> \n> returns [1,3,5] rather than [1,undefined,3,undefined,5].\n> \n\nI'm not sure where my head was sutick when I wrote the above, but it's wrong.\n\nAs currently specified,\n   Array.from([1,,3,,5])\nreturns [1,undefined,3,undefined,5]\n\nArray Array.from uses @@interator which for Array.prototype is the same as Array.prototype.values.  the values iterator for arrays returns undefined as the value of sparse holes."},{"commentid":7392,"comment_count":8,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-21 13:20:33 -0800","thetext":"Let's open a new bug for whether Array.from({0: 1, 2: 2, length: 3 }) should result in a sparse array.\n\nThis bug is *not* about behavior changes, just whether ArrayIterator should be involved in Array.from([ ... ]).  This is purely an efficiency issue: since the invocation of Array.@@iterator is potentially observable, are we foreclosing optimization opportunities by forcing Array.from() to go through the iterator path.\n\nInput from implementors is probably called for."},{"commentid":7398,"comment_count":9,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-21 13:29:21 -0800","thetext":"Bug 2562 is for the \"sparse arrays from array-like\" issue."},{"commentid":9127,"comment_count":10,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-03 16:59:31 -0700","thetext":"You are essentially talking about enabling an implementation to inline the IsIterable (now called CheckIterable) check. This  check is potentially observable via a proxy or if @@iterator is an accessor property.\n\nHowever, this type of observability is possible for pretty much every potential inline site so an implementation that is going to do inlining is going to have to have a mechanism for determining whether or not any specific inlining can be done unobservably.\n\nSo, this seems like a general issue that optimizing implementation have to take into account and something that we shouldn't try to special case just for this one specific instance of the problem."}]}}
---
