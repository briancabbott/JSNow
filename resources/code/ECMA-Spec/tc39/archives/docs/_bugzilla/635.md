---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":635,"creation_ts":"2012-08-30 02:01:00 -0700","short_desc":"11.1: \"[Lexical goal InputElementRegExp]\" circularity","delta_ts":"2015-02-19 19:11:06 -0800","product":"Draft for 6th Edition","component":"editorial issue","version":"Rev 33: February 12, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"jmdyck","name":"Michael Dyck"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":1541,"comment_count":0,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2012-08-30 02:01:48 -0700","thetext":"In 11.1 \"Primary Expressions\",\nunder \"Syntax\",\nin the production for PrimaryExpression,\none of the many alternatives is:\n    [Lexical goal InputElementRegExp] RegularExpressionLiteral\n\nAccording to 5.1.6, this means that the RegularExpressionLiteral token must be lexically recognized using the goal symbol InputElementRegExp. Everywhere else in the production, the absence of such a phrase indicates that the default lexical goal symbol (i.e., InputElementDiv) is used.\n\nBut this is circular. In order to know which lexical goal symbol to use to get the next token, you need to already know whether the next token is a RegularExpressionLiteral.\n\nFormerly, the choice of lexical goal symbol was determined by \"syntactic grammar context\" (specifically, whether it permitted a leading division or division-assignment operator). So, in the context of \"ready to parse a PrimaryExpression\", the division operators would not be permitted, and so the next token would be obtained via the InputElementRegExp goal symbol. Note that this goal symbol would be chosen based solely on the (left-)context, with no knowledge of any input to the right of the current position. I don't think there's any reason to depart from that."},{"commentid":1542,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-08-30 12:52:22 -0700","thetext":"corrected in editor's draft.\n\nmoved lexical goal annotation to \n   MemberExpression : PrimaryExpression\n\nAlso tweaked use of lexical goal annotation for in specification of TemplateStrings."},{"commentid":1551,"comment_count":2,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2012-08-30 13:30:04 -0700","thetext":"On a related note, section 7 says:\n    \"The InputElementDiv goal symbol is the default goal symbol and is used\n    in those syntactic grammar contexts where a leading division (/) or\n    division-assignment (/=) operator is permitted.\"\nBut this is not entirely true any more. It is used in *some* of those contexts, but not all, since now InputElementQuasiTail must be used in some of those contexts.\n\nFor instance, consider the context after having processed this much input:\n    x = `foo${ a \nCertainly, division and division-assignment operators are permitted in that context (e.g.\n    x = `foo${ a / 2 }`\nis a valid continuation of the given prefix), but InputElementDiv should not be used, because if the continuation happens to be:\n    x = `foo${ a }`\nInputElementDiv would recognize the '}' as RightBracePunctuator, which is not syntactically valid. Instead, InputElementQuasiTail should be used."},{"commentid":1553,"comment_count":3,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2012-08-30 13:30:48 -0700","thetext":"To address the above points, I think you should:\n(a) drop the \"[Lexical goal]\" notation, and\n(b) change the paragraph in section 7 to (something like):\n    \n    If the context allows RegularExpressionLiteral, use InputElementRegExp.\n\n    If the context allows QuasiMiddle or QuasiTail, use InputElementQuasiTail.\n\n    Otherwise, use InputElementDiv.\n\n(And you can note that the first two possibilities are [or should be] mutually exclusive.)"},{"commentid":1557,"comment_count":4,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2012-08-30 13:39:38 -0700","thetext":"(In reply to comment #1)\n> moved lexical goal annotation to \n>    MemberExpression : PrimaryExpression\n\nThis doesn't eliminate the circularity, merely relocates it. (In order to know which lexical goal symbol to use to get the next token, you'd have to already know whether the following input is a PrimaryExpression [vs a FunctionExpression or MemberExpression].)"},{"commentid":1559,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-08-30 14:55:51 -0700","thetext":"(In reply to comment #4)\n> (In reply to comment #1)\n> > moved lexical goal annotation to \n> >    MemberExpression : PrimaryExpression\n> \n> This doesn't eliminate the circularity, merely relocates it. (In order to know\n> which lexical goal symbol to use to get the next token, you'd have to already\n> know whether the following input is a PrimaryExpression [vs a\n> FunctionExpression or MemberExpression].)\n\nI don't think there is actually a circularity problem.  It's probably because we have different understandings of the meaning of alternative lexical goal symbols. Let look at your example:\n   x = `foo${ a / 2 }`\nIf the current context is\n   x = `foo${ a \nthen we must be deep into the expression grammar (we've just recognized \"a\" as a PrimaryExpression) and we used InputElementDiv to tokenize the next character which would have been / recognized as a DevPunctuator.  The expression parse would continue as expected popping back to MultiplicativeExpression.  But lets say that instead the next token was RightBracePunctuator.  That token doesn't appear in the expression grammar at this position, so we have a complete Expression and the parse would pop all the way back out of Expression to the production:\nTemplateLiteral : TemplateHead Expression [Lexical goal InputElementTemplateTail] TemplateSpans\n\n(note the StringTemplate grammar has changed in various ways since the last release draft)\n\nThis production says that to proceed past the Expression we need to look at the next token using the InputElementTemplateTail lexical goal symbol. So we retokenize starting at the current accepted input point (even though we had already tokenized using InputElementDiv).  This time we get the TemplateTail }` as the next token and that will successfully match within TemplateSpans.\n\nDo you seen any issues with this interpretation.  What would need to be said in 5.1.6 to make this interpretation clearer?\n\nI like the [Lexical goal] annotation because it explicitly identifies the contexts where alternative lexical goals must be used.  Previous, that was left to the reader to figure out for them selves."},{"commentid":1573,"comment_count":6,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2012-08-30 17:17:29 -0700","thetext":"(In reply to comment #5)\n> \n> I don't think there is actually a circularity problem.\n> ...\n> But lets say that instead the next token was RightBracePunctuator.\n> That token doesn't appear in the expression grammar at this position,\n> so we have a complete Expression\n\nIf the lookahead token isn't valid in the current context, a conventional parser would report a syntax error.\n\n> and the parse would pop all the way back out of Expression to the\n> production:\n> TemplateLiteral : TemplateHead Expression [Lexical goal\n> InputElementTemplateTail] TemplateSpans\n\n(Your wording (\"pop back out to a production\") suggests that you're imagining an LL(k) or recursive-descent parser, which isn't appropriate to the ECMAScript grammar.)\n\n> This production says that to proceed past the Expression we need to look at\n> the next token using the InputElementTemplateTail lexical goal symbol. So we\n> retokenize starting at the current accepted input point (even though we had\n> already tokenized using InputElementDiv).\n\nAh, well, retokenizing is certainly an odd thing to expect of a parser/lexer. And unnecessary, since you could have done the correct tokenization in the first place (i.e., using InputElementTemplateTail).\n\n> This time we get the TemplateTail }` as the next token and that will\n> successfully match within TemplateSpans.\n> \n> Do you seen any issues with this interpretation.\n\nIn addition to the ones given above, there's the fact that the model of parsing/lexing that you have in mind is different from what's described in previous drafts/editions.\n\nMoreover, you didn't actually address my claim of circularity. (My example wasn't there to show circularity, but to show the no-longer-correctness of a statement in clause 7.) Circularity arises when different right-hand-sides of a production begin with different (explicit or implicit)\"lexical goals\" (as happens for PrimaryExpression): the correct choice of lexical goal symbol depends on what's next, but you can't know what's next until you tokenize it. Here, you can't \"pop back to a production\" where there's only one \"next\" lexical goal.\n\n(At this point, you might suggest trying them both and going with whatever's valid. But that's another complication, and another step away from a conventional parsng model.)\n\nAnd it's all unnecessary, when you could simply adopt my suggestion in comment #3.\n\n> What would need to be said in 5.1.6 to make this interpretation clearer?\n\nWell, you'd probably have to describe your parser/lexer model in more detail. Of course, I'm not suggesting you do so, I'm suggesting that you not use that model.\n\n> I like the [Lexical goal] annotation because it explicitly identifies the\n> contexts where alternative lexical goals must be used.\n\nI can understand the attraction, but I think it's misguided. You appear to be equating \"a syntactic context\" with \"a point in a production\", but in general, a syntactic context corresponds to many points in many productions. (Think of a state in the LR automaton.)\n\n> Previous, that was left to the reader to figure out for them selves.\n\nI think it would suffice to add Notes in a couple Syntax sections. E.g., in 11.1, remind the reader that in any context where RegularExpressionLiteral is allowed (and thus, where PrimaryExpression is allowed, etc), the next token must be found using InputElementRegExp as the lexical goal symbol.\n\nIn summary, I believe that the introduction of \"[Lexical goal]\" notations unnecesarily complicates the parsing model needed to support/use them, and thus actually makes it harder for the reader to figure out."},{"commentid":1731,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-09-28 12:24:27 -0700","thetext":"fixed in rev10, Sept. 27 2012 draft"},{"commentid":12891,"comment_count":8,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2015-02-17 22:01:51 -0800","thetext":"(Maybe it was fixed in rev10, but it isn't fixed in rev33.)\n\n(A)\nIn 12.3 \"Left-Hand-Side Expressions\", the production for MemberExpression\nhas a lexical goal of InputElementRegExp at the start of its first RHS,\nand (implicitly, according to 5.1.5) a lexical goal of InputElementDiv at the start of all its other RHSs. Clearly, this is a conflict as to which lexical goal to use in this context (the start of a MemberExpression).\n\nAnd in 14.4 \"Generator Function Definitions\", consider the production for YieldExpression. After a 'yield' keyword, what lexical goal should be used to get the next token? RHS #2 says InputElementRegExp, RHS #1 says nothing, so presumably the default InputElementDiv should be used. Again, a conflict.\n\n(Please note that I'm not saying there's something ambiguous or unparsable about the grammar itself. I'm just saying that the \"Lexical goal\" annotations don't make sense.)\n\n\n(B)\nIn 11 \"ECMAScript Language: Lexical Grammar\", this sentence still appears:\n    The InputElementDiv goal symbol is the default goal symbol and is used\n    in those syntactic grammar contexts where a leading division (/) or\n    division-assignment (/=) operator is permitted.\n\nThis sentence is not true: there are contexts permitting division and\ndivision-assignment in which InputElementDiv should not be used and\nInputElementTemplateTail *must* be used.\n\n\nMy proposed solution to both of the above is still comment #3 (changing \"Quasi\" to \"Template\", of course)."},{"commentid":12915,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-18 10:31:53 -0800","thetext":"sold, go rid of [lexical goal] annotation and updated clause 11 language as suggest.\n\nfixed in rev34 editor's draft"},{"commentid":12917,"comment_count":10,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2015-02-18 11:47:40 -0800","thetext":"Thanks!\n\nBut mulling over the YieldExpression example, I think I've found a deeper problem, which I'll raise separately."},{"commentid":13126,"comment_count":11,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-19 19:11:06 -0800","thetext":"fixed in rev34"}]}}
---
