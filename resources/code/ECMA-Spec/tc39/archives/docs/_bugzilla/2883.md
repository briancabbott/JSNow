---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2883,"creation_ts":"2014-05-22 06:44:00 -0700","short_desc":"Array.from still not quite polyfillable using for-of","delta_ts":"2014-07-15 10:07:17 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 23: April 5, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"jorendorff","name":"Jason Orendorff"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":8575,"comment_count":0,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-05-22 06:44:08 -0700","thetext":"Follow-up to bug 2083.\n\nThat bug is about being able to polyfill Array.from using a for-of loop for iteration. From my implementation:\n\n    ...\n    // Steps 6-8.\n    if (items[std_Symbol_iterator] !== undefined) {\n        // Steps 8.a-c.\n        var A = IsConstructor(C) ? new C() : [];\n\n        // Step 8.f.\n        var k = 0;\n\n        // Steps 8.d-e and 8.g.i-vi.\n        for (var nextValue of items) {\n            ...\n        }\n    ...\n\nThis is not quite what the spec says, because items.[[Get]](@@iterator) happens twice rather than once. What do you think--should we do the [[Get]] once to detect, and again for the loop? Or is that too much?"},{"commentid":8577,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-05-22 09:41:59 -0700","thetext":"Hmm..\n\nI added the second argument to GetIterator specifically to avoid that second [[Get]] which I assumed native implementations would not want to perform. I could eliminate it (at least in this call) which would make the two [[get]]'s normative. But is that really desirable?\n\nWouldn't this be a more faithful translation of the spec. steps:\n\n     ...\n    // Steps 6-8.\n    let usingIterator = items[std_Symbol_iterator];\n    if (usingIterator !== undefined) {\n        // Steps 8.a-c.\n        var A = IsConstructor(C) ? new C() : [];\n\n        // Step 8.f.\n        var k = 0;\n\n        // Steps 8.d-e and 8.g.i-vi.\n        let itr = usingIterator.call(items)\n        for (var nextValue of itr) {\n            ...\n        }\n    ..."},{"commentid":8579,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-05-22 10:00:58 -0700","thetext":"On second thought, I guess that doesn't quite do it either because\n  for(var nextValue of itr)\n\nis still going to do:\n   itr[Symbol.iterator]]()\n\n..."},{"commentid":8580,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-05-22 10:21:02 -0700","thetext":"...so, \n\nyou could use a while loop and explicitly check the IteratorResult objects. However, I suspect (in the long run) that doesn't optimize as easily as for-of\n\nor, \n\nI wonder if the best approach isn't to not try to eliminate the extra [[Get]] in the spec. and leave it up to implementations to try to decide (if they are so inclined) when eliminating the second access would be non-observable."},{"commentid":8662,"comment_count":4,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-05-28 04:23:53 -0700","thetext":"(In reply to comment #3)\n> I wonder if the best approach isn't to not try to eliminate the extra [[Get]]\n> in the spec. and leave it up to implementations to try to decide (if they are\n> so inclined) when eliminating the second access would be non-observable.\n\nI'll write a while loop. We'll just have to make sure our optimizations are generic enough that we can make the while loop as fast as the for-of loop."}]}}
---
