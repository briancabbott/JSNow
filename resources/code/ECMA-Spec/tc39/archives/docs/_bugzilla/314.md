---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":314,"creation_ts":"2012-03-16 14:44:00 -0700","short_desc":"Community Feedback on Harmony numerics","delta_ts":"2015-10-02 14:36:15 -0700","product":"Harmony","component":"Suggestions","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","see_also":"https://bugs.ecmascript.org/show_bug.cgi?id=309","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"roger.andrews","name":"Roger Andrews"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["jens","lukeh","roger.andrews","utatane.tea"],"long_desc":[{"commentid":774,"comment_count":0,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-16 14:44:19 -0700","thetext":"This item is for tracking community feedback and feature requests relating to\nthe Harmony numerics, primarily Number with some crossover into Math issues (but not new Math functions -- see bug 309 for new functions)\n\nAnybody with such feedback should record it as a comment on this bug."},{"commentid":800,"comment_count":1,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-18 06:15:49 -0700","thetext":"Re: more constants on Number, especially EPSILON\n\nSeveral additional constants are useful when dealing with IEEE binary64 floating-point numbers like JavaScript's Number.  Most of them are special powers-of-two.\n\nRecall that binary64 numbers have:\n  1  sign bit\n  53 significand bits (including 1 unstored \"hidden\" bit which is assumed '1')\n  11 exponent bits (held biased)\nand special values in the exponent field encode NaNs, Infinities, Zeroes.\nAlso a special value in the exponent field allows \"subnormal\" numbers with reduced precision in the significand and the \"hidden\" bit is made '0', allowing graceful underflow.\n\n\nSummary Proposals:\n\nNumber.EPSILON == 2^-52\nThe difference between 1 and the smallest value >1 that is representable as \na floating-point number.\n(See below for terminology.)\n\nNumber.MAX_INTEGER == 2^53 - 1\nThe maximum integer value that can be stored in a number without losing \nprecision.\n(Technically 2^53 can be stored, but that's an anomaly, see below.)\n\nNumber.MIN_NORMAL == 2^-1022\nThe minimum positive value that can be stored as an IEEE \"normal\" number.\n(The existing Number.MIN_VALUE is a \"subnormal\".)\n\nNumber.MAX_POWTWO == 2^1023\nThe maximum power-of-two that can be stored in a number.\n\n\nNote there is some confusion in the definition of \"machine epsilon\" and \"unit roundoff\" - the definition of EPSILON above is the one we want and the one used in the C library.  More detail later.\n\nNote that it is conventional to have (2^n)-1 as the maximum for a n-bit integer.  Binary64 numbers have 53 bits of precision, so MAX_INTEGER = 2^53-1 = 9007199254740991.  Brendan Eich agrees.\n\n\nJustifications:\n\nEPSILON (defined as 2^-52) is the least-significant bit of the significand\nof a binary64 floating-point number.  Loosely speaking, all the exact value's bits below EPSILON are rounded in the significand to form the EPSILON bit.\n\nThis makes it easy to find the next larger or smaller representable number, and is generally useful.  One specific use is when comparing for approximate equality (despite rounding errors) by ignoring low order significand bits.\n\nMAX_INTEGER is useful when working with integers e.g. prime numbers, factorials, fibonacci numbers - just as MAX_VALUE is useful for full numbers.  If an integer calculation step goes over MAX_INTEGER then the final result is not exact (ignoring power-of-two factors).\n\nMIN_NORMAL is the smallest floating-point number that retains full precision.  If a calculation step goes below this number then the final result is known not to be fully significant but has underflowed (gracefully).  (If a calculation step overflows then we know about it like a punch in the face because the final result is Infinity.)  Numeric functions like ulp, nextUp, nextDown need to handle numbers below MIN_NORMAL carefully.\n\nAlso, MIN_NORMAL is useful for long-range downward scaling.  MIN_VALUE could be used for a slightly longer range, but denormalised numbers can be slower than \"normals\" on some (many?) systems.  See the scaling example below.\n\nMAX_POWTWO is the most significant bit possible in a Number.  This is useful for long-range upward scaling.  It is also useful when taking the ulp of a very large number which cannot be calculated with the usual trick due to overflow (admittedly very few people will get excited by this).\n\n\nHere's an example of scaling using MAX_POWTWO and MIN_NORMAL (many speedups are possible, this simply illustrates the technique):\n\n  // multiply x by 2^n, first taking care for large |n|\n  if (isFinite( n )) {\n    while (n > 1023  &&  1/x != 0) {\n      x *= MAX_POWTWO;\n      n -= 1023;\n    }\n    while (n < -1022  &&  x != 0) {\n      x *= MIN_NORMAL;\n      n += 1022;\n    }\n  }\n  result = x * Math.pow( 2, n );\n\n\nIf these four constants are not present you can roll your own:\n  EPSILON     = 1 / 0x10000000000000;\n  MAX_INTEGER = 0x1FFFFFFFFFFFFF;\n  MIN_NORMAL  = Number.MIN_VALUE * 0x10000000000000;\n  MAX_POWTWO  = 2 / MIN_NORMAL;"},{"commentid":802,"comment_count":2,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-20 02:23:12 -0700","thetext":"Re: string representation of -0\n\nThe usefulness of -0 is well-accepted, for those applications which require symmetry about an axis.  (-0 selects the side of a Branch Cut in the Complex plane, and preserves symmetry generally.)  Rightfully -0==0 for those applications which don't care.\n\nJavaScript's arithmetic and mathematical functions handle -0 perfectly.\nFor example:\n    1/-0  -> -Infinity\n    Math.sin(-0)  -> -0\n\nHowever the string representation of -0 is broken due to the definition of the 'ToString' internal function and the string representation methods Number.prototype.toString, Number.prototype.toPrecision, etc, etc.  Thus ES5 does not conform to IEEE754.  See section 9.8.1 of the ES5 Standard: \"ToString Applied to the Number Type\".\n\nOne major consequence of 'ToString' behaviour is that -0 is not preserved in a JSON string, even though the JSON syntax allows it.  Thus simply by transferring data in JSON (without any funny business) one risks a numerical error:\n    JSON.stringify( {x: -0} )  -> '{\"x\":0}'     naughty!\n    JSON.parse( '{\"x\":0}' )    -> {x: 0}\n\nAnother consequence is in the numerical conversion of a single-element Array (bizarrely):\n    +[-0]  -> 0\nbut\n    +[-N]  -> -N   for all N except 0\nOf course\n    +(-0)  -> -0\n\nThe String constructor uses 'ToString', thus:\n    String(-0)  -> \"0\"\n\nThe definitions of the Number.prototype.toString family imply in ES5 that they do not honour -0.  Why?  Implementations have conformed.\nPicking 'toFixed' as one example, thus we have the strangeness:\n    (-0).toFixed(0)  -> \"0\"\nbut\n    (-Number.MIN_VALUE).toFixed(0)  -> \"-0\"\n\n\nFor the set of Number and a suitable codomain in String,\nnote the broken symmetry:\n  'ToString' is surjective but not injective;\n  'ToNumber' is both surjective and injective.\n'ToString' and 'ToNumber' are not inverses:\n    ToNumber(\"-0\")  -> -0\nbut\n    ToString(-0)  -> \"0\"\n\n\nWould it hurt to do the string conversion of -0 right?\nWhen JavaScript's arithmetic and Math handling of -0 is perfect, why go off the rails when it comes to string conversion?"},{"commentid":803,"comment_count":3,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-21 05:15:16 -0700","thetext":"Re: hexadecimal exponential literals\n\nThe proposal is to allow literals in the hexadecimal exponential form, just like decimal literals, and following the C99 standard.\n\nIn ES5, hexadecimal literals (e.g. 0x123ABC) can only express moderately small integers, whereas decimal literals can express any Number (e.g. 123.456e78).  Why do hex literals discriminate against big numbers and fractions?\n\nAllowing hexadecimal exponential literals would extend the JavaScript syntax slightly and unambiguously (it would be handled as a lexeme).\n\n\nC99 introduced hexadecimal floating-point literals, see:\nhttp://publib.boulder.ibm.com/infocenter/zos/v1r12/topic/com.ibm.zos.r12.cbclx01/lit_fltpt.htm#lit_fltpt__hex_float_constants\n\nof the general form:\n   [sign]  \"0x\"  [hexdigits]  [\".\" hexdigits]  [\"p\" [sign] decdigits]\n(with the proviso that at least one significant hexdigit must appear).\n\nThe letter 'p' means \"times 2 to the power of\"; and the exponent digits are \ndecimal.  Case is ignored.  The leading sign is not actually part of the literal, but is a unary operator.\n\n(In C the exponent field must appear in order to disambiguate a trailing \n'f' = float flag, but this would not be necessary in JavaScript.)\n\n\nAdvantages of hexadecimal exponential form:\n\n1)  It brings hexadecimal literals into line with decimal literals.\n\n2)  It allows hexadecimal literals to encompass all the *finite* Numbers, just as decimal literals can.  (Hexadecimal 0x1p1024 overflows to Infinity, just like decimal 1e310.)\n\n3)  It enables numeric literals in a well-understood programmer-friendly form (i.e. hexadecimal).  And it supports those of us who think of numbers in their sign-significand-exponent form.\n\n4)  Various useful constants are easily expressed in hexadecimal exponential form.  For example:\n        EPSILON = 0x1p-52\n        MAX_POWTWO = 0x1p1023\ninstead of the messy:\n        EPSILON = 1 / 0x10000000000000\n        MAX_POWTWO = 1 / (Number.MIN_VALUE * 0x8000000000000)\nor the confusing decimal:\n        EPSILON = 2.220446049250313e-16\n        MAX_POWTWO = 8.98846567431158e+307\n\n\nNote that this is not about allowing programmers to create arbitrary bit patterns in a Number; it is simply about beefing up hexadecimal literals to the same grade as decimal literals."},{"commentid":806,"comment_count":4,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-23 04:55:43 -0700","thetext":"Re: new toEngineering format\n\nThe proposal is for a new numeric format:\n    Number.prototype.toEngineering( numdigits )\n\nThis is similar to the normalised 'toExponential', but the exponent is a multiple of 3 and there are 1, 2, or 3 digits before the decimal point.\nThe 'numdigits' parameter indicates the number of digits after the decimal point.\n\nThe format makes it visually and orally easy to relate a string representation of a number to SI scaling prefixes (\"mega\", \"giga\", \"nano\", etc).\nSee http://en.wikipedia.org/wiki/Scientific_notation#Engineering_notation .\n\n\nMany newer pocket calculators provide this format and it seems to be gaining \nground in formatters generally.  It is useful in engineering, say if one is \nworking with nanoseconds, milliwatts, megaohms, picofarads, etc.\n\nThe objective is to catch up with the trends in data formatting."},{"commentid":807,"comment_count":5,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-23 05:07:20 -0700","thetext":"Re: new toHexExponential format\n\nThe proposal is for a new numeric format:\n    Number.prototype.toHexExponential( numdigits )\n\nThe 'numdigits' parameter indicates the number of digits after the radix point.\n\nThis is similar to 'toExponential' but is in the normalised hexadecimal form instead of decimal.  See comment 3 above.\nE.g.  1.4A2p+4\nThe letter 'p' corresponds to decimal's 'e', and means \"times 2 to the power of\".\nThe *binary* exponent is represented in signed *decimal*.\nThe hex representation should probably be in lowercase to match that of 'toString(16)'.\n\nSee http://en.wikipedia.org/wiki/Hexadecimal#Hexadecimal_exponential_notation .\n\n\nGNU's printf provides this format with its %a and %A conversions.  The format represents a binary64 value in a common programmer-friendly hexadecimal form.  Note the natural match with binary64's sign-significand-exponent parts."},{"commentid":808,"comment_count":6,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-23 05:47:44 -0700","thetext":"Re: new Number.parseInt, and Number.parse (ala Date.parse)\n\nIf 'isNaN' and 'isFinite' are being carried over from the global namespace into 'Number', then we could take the opportunity likewise to carry 'parseFloat' and 'parseInt' for completeness:\n     isNaN       -> Number.isNaN\n     isFinite    -> Number.isFinite\n     parseInt    -> Number.parseInt\n     parseFloat  -> Number.parse\n\nThe new Number.parse should be improved to handle fractions in any base [2-36] and the hexadecimal exponential format (see comment 5 above).\nThus Number.parse would match Date.parse in parsing any string that its formatters can produce:\n     Number.parse( string, [base] )\n\nThe new Number.parse should ignore a leading \"0x\" before a hexadecimal string's digits, just like 'parseInt' does now.  E.g. \"-0x123.B4p+12\".\n\nThe new Number.parse should accept \"Inf\" as a synonym for Infinity (I believe this is recommended by IEEE 754-2008)."},{"commentid":810,"comment_count":7,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-23 06:03:08 -0700","thetext":"Re: hexadecimal fractions/exponentials in 'ToNumber' converter\n\nTo round out the hexadecimal facilities described in several comments above:\nthe 'ToNumber' internal function could also handle hexadecimal fractions and exponentials.  Currently 'ToNumber' only handles integers:\n      Number(\"0x12\")    -> 18\nbut   Number(\"0x12.3\")  -> NaN     // should be 18.1875"},{"commentid":824,"comment_count":8,"who":{"uid":"lukeh","name":"Luke Hoban"},"bug_when":"2012-03-28 08:07:28 -0700","thetext":"I've uploaded a new draft of proposed ES6 library extensions spec (http://wiki.ecmascript.org/doku.php?do=show&id=harmony%3Amore_math_functions).  This so far addresses the following asks from this thread:\n- Adds Number.EPSILON and Number.MAX_INTEGER\n- Adds Number.parseInt and Number.parseFloat\n\nOther topics raised here will be discussed at TC39 f2f this week."},{"commentid":846,"comment_count":9,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-28 17:04:07 -0700","thetext":"Re: breaking Numbers into sign-significand-exponent values\n\nNumerically, floating-point numbers are formed of a sign (s), significand (m), exponent (e), and radix (b):\n     (-1)^s * m * b^e\nwhere 1 <= m < b for a finite non-zero value.\n\nOften we want to access the s-m-e values directly: for argument reduction, or comparing for approximate equality by ignoring low order rounding error, etc.\nIn ES5 this is painful.\n\nAs an example of argument reduction, say we have an algorithm that works well in the interval [0.5,1.5], then we apply this algorithm on m/2 and fix up for the exponent e+1 to obtain best precision.\n\nNote that it is the _values_ of s-m-e that interest us, not the binary bits of whatever representation they have.\n\nHere is a table of the values of s-m-e for the five FP classes:\n  FP Class     s      m        e\n  normal:      0, 1   [ 1 , 2 )   [ −1022 , 1023 ]\n  subnormal:   0, 1   [ 1 , 2 )   [ −1074 , −1023 ]\n  zero:        0, 1   +0       −Inf\n  infinity:    0, 1   +Inf     +Inf\n  NaN:         0     NaN      NaN\n\nThe ancient C functions frexp(3) & ldexp(3) are great for getting & setting s-m-e (see also modf(3)).\n\nC's frexp/ldexp were created before 1980 -- before IEEE754.  So they are not quite the same as IEEE's logB/scaleB and split/join-type functions.\nfrexp delivers a signed significand in the interval [0.5,1) not [1,2) union 0.\nldexp is almost perfect as scaleB, if you already know e.\n\n\nTo get & set the s-m-e of a number we would like methods something like:\n   Number.prototype.getSign()   ~.getSignif()   ~.getExponent()\n   Number.prototype.setSign(s)  ~.setSignif(m)  ~.setExponent(e)\nor read-write properties on Number something like:\n   sign  signif   exponent\n\nOn setSign(s)      s must be 0 (falsy) or 1 (truthy)\nOn setExponent(e)  e must be an integer\n\nThis is similar to the Date getters & setters, which set part of a Date without affecting its other parts.  (Date being a composite of y-m-d-hh-mm-ss-fff, just as Number is a composite of s-m-e.)\n\n\nThen logB(x)    is  x.getExponent()                     or  x.exponent\nand scaleB(x,n) is  x.setExponent( x.getExponent()+n )  or  x.exponent+=n"},{"commentid":848,"comment_count":10,"who":{"uid":"roger.andrews","name":"Roger Andrews"},"bug_when":"2012-03-29 03:43:00 -0700","thetext":"(In reply to comment #9)\n> Re: breaking Numbers into sign-significand-exponent values\n\nIf the access to the sign-significand-exponent (s-m-e) of a number is not provided then we can do it ourselves, but it is lengthy, slow, and expensive.  We have to estimate the exponent and carefully fix up deviant cases.  Whereas the implementation environment has easy access to these desirable values.\n\nHere for example are logB/scaleB implemented in JavaScript with the constants MAX_POWTWO and MIN_NORMAL.\n\n++++code follows++++\n\nIEEE.logB = function (x)\n{\n  x = +x;         // guard against non-numerics\n\n  var m, e;\n  var abs = (x >= 0)? x : -x;             // don't care about -0!\n\n  // calculate the approx exponent;\n  // then fix the exponent estimate by computing the significand\n  // (also works for pow() overflow/underflow!)\n\n  e = Math.floor( Math.log( abs ) / Math.LN2 );\n\n  m = abs / Math.pow( 2, e );           // don't care about NaNs!\n  if (m >= 2)  e += 1;\n  if (m <  1)  e -= 1;\n\n  return e;\n};\n\nIEEE.scaleB = function (x,n)\n{\n  x = +x,  n = +n;     // guard against non-numerics\n\n  // handle NaN, infinities, zeroes\n\n  if (isNaN( x/x ))  return x;\n\n  // multiply x by 2^n, first taking care for large |n|\n\n  if (isFinite( n )) {\n    while (n > 1023  &&  1/x != 0) {\n      x *= MAX_POWTWO;\n      n -= 1023;\n    }\n    while (n < -1022  &&  x != 0) {\n      x *= MIN_NORMAL;\n      n += 1022;\n    }\n  }\n  return x * Math.pow( 2, n );\n};"},{"commentid":14744,"comment_count":11,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-10-02 14:36:15 -0700","thetext":"Bulk closing all Harmony bugs. Proposals should be tracked on GitHub. The ES wiki is completely defunct at this point."}]}}
---
