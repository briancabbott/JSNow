---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3206,"creation_ts":"2014-09-01 11:43:00 -0700","short_desc":"Unscopables should use HasProperty and not Get","delta_ts":"2015-07-10 08:34:19 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 27: August 24, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"arv","name":"Erik Arvidsson"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["claude.pache","erik.arvidsson"],"long_desc":[{"commentid":10112,"comment_count":0,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-09-01 11:43:36 -0700","thetext":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-environment-records-hasbinding-n\n\nStep 9.a should be HasBinding and not Get. We do not care about getter side effects here and we do not care about the value."},{"commentid":10114,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-01 12:04:22 -0700","thetext":"The reason for doing a [[Get]] is so a subclass can over-ride a unscopables item of a super class: \n\nSubArray.prototype[Symbol.unscopables] = {\n   __proto__: Array.prototype[Symbol.unscopables],\n   values: undefined,   //remove 'values' from unscopable set of SubArray\n};"},{"commentid":10120,"comment_count":2,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-09-02 16:04:06 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #1)\n> The reason for doing a [[Get]] is so a subclass can over-ride a unscopables\n> item of a super class: \n> \n> SubArray.prototype[Symbol.unscopables] = {\n>    __proto__: Array.prototype[Symbol.unscopables],\n>    values: undefined,   //remove 'values' from unscopable set of SubArray\n> };\n\nWhat is the use case for that?\n\nIf we are doing Get, should we not do a ToBoolean on the value?"},{"commentid":10168,"comment_count":3,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-09-09 09:13:54 -0700","thetext":"I think it is good to have a general uniform rule for interpreting properties whose sole purpose of is to provide a yes/no answer. There are various possibilities:\n\n1. HasProperty(obj, prop)\n2. Get(obj, prop) !== undefined\n3. ToBoolean(Get(obj, prop))\n4. etc. \n\nOption 1 is not good (as a general rule), because of impossibility to override a \"yes\" answer found on the prototype. Option 3 is imho the best one, because it is more intuitive  to have `false` meaning \"no\". \n\nCurrently, Option 3 is chosen for @@isConcatSpreadable and @@isRegExp, and a variant of it for @@hasInstance -- namely (oversimplifying a bit): \nToBoolean(Invoke(obj, @@hasInstance, (C))\n\nI think that ToBoolean(Get(...)) should also be chosen here for uniformity, unless there is a good reason against it."},{"commentid":10518,"comment_count":4,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-10-17 06:55:07 -0700","thetext":"After thinking more about this, I prefer using `undefined` instead of ToBoolean() === false. The main reason is that there are less chances of unexpected side effects."},{"commentid":10520,"comment_count":5,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-10-18 06:48:05 -0700","thetext":"(In reply to Erik Arvidsson from comment #4)\n> After thinking more about this, I prefer using `undefined` instead of\n> ToBoolean() === false. The main reason is that there are less chances of\n> unexpected side effects.\n\nI don't understand your point, since ToBoolean() itself is side-effect free (recall that all objects are truthy without computation). In fact, regarding potential side-effects, one must choose between those of HasProperty() and those of Get(). Or I missed something?"},{"commentid":11556,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-19 17:11:32 -0800","thetext":"I did a quick review over the spec. and the most common way handle situations like this is treat both undefined and null as meaning not there.\n\nBasically, undefined covers the non-existent property case and null is a nice value some people like to use (rather than an explicit undefined) as a \"not here\" marker.\n\nso I'm changed step 9.c. to:\n  c.\tIf blocked is neither undefined nor null, return false.\n\nwhich is the usual formulation we use for such tests\n\nfixed in rev32 editor's draft"},{"commentid":11560,"comment_count":7,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-01-20 06:40:33 -0800","thetext":"I'm not happy with this. I think we should either stick to just *undefined* or do ToBoolean and compare the result with false. Having something in between just leads to more cases to remember."},{"commentid":11563,"comment_count":8,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-20 10:43:26 -0800","thetext":"(In reply to Erik Arvidsson from comment #7)\n> I'm not happy with this. I think we should either stick to just *undefined*\n> or do ToBoolean and compare the result with false. Having something in\n> between just leads to more cases to remember.\n\nI've reconsidered, and think it should be ToBoolean.\n\nThe reason is that when we defined an unscopables array we use 'true' as the value of the properties.  While we don't explicitly say do, that strongly suggests 'false' would mean the opposite of 'true'.  Or, in otherwords we expect the values of these properties to be treated as ToBoolean values.\n\nSo, step 9.c becomes:\n\nc.\tIf ToBoolean(blocked) is true, return false."},{"commentid":11944,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-02 18:38:51 -0800","thetext":"fixed in rev32 draft"}]}}
---
