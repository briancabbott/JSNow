---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4159,"creation_ts":"2015-03-12 15:57:00 -0700","short_desc":"21.2.5.* RegExp algorithm: in several places, in case of unicode-matching, index should be conditionally incremented by more than 1","delta_ts":"2015-03-17 16:57:06 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 35: March 4, 2015 Release Candidate 2","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"claude.pache","name":"Claude Pache"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":13717,"comment_count":0,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2015-03-12 15:57:10 -0700","thetext":"Let's take for example 21.5.2.2 RegExpBuiltinExec, step 15.c.ii:\n\n    ii. Let lastIndex = lastIndex + 1.\n\nIf fullUnicode (step 13) is true, one should test whether the current code unit is a high surrogate and the following one a low surrogate, in which case one should advance by 2 instead of 1.\n\nThis is correctly implemented in 21.2.5.11 RegExp.prototype[@@split], steps 24.e.i-ii and 24.f.iii.1-2, but not in others algorithms of section 21.2.5.\n\nHere is a proposed patch:\n\n\n\nNextStringIndex(string, index, unicode)\n------------------------------------\nThis abstract operation returns index + 1, or index + 2 if unicode is true and there is a matching pair of surrogates in `string` at position `index`.\n\n1.  Assert `string` is a String.\n2.  Assert `index` is an integer between 0 and 2^53-1.\n3.  Assert `unicode` is a Boolean.\n4.  Let `length` be the number of code units in `string`.\n5.  If `boolean` is false, return `index` + 1.\n6.  If `index` + 1 >= `length`, return `index` + 1.\n7.  Let `first` be the code unit value at index `index` in `string`.\n8.  If `first` < 0xD800 or `first` > 0xDBFF, return `index` + 1.\n9.  Let `second` be the code unit value at index `index` + 1 in `string`.\n10. If `second` < 0xDC00 or `second` > 0xDFFF, return `index` + 1.\n11. Return `index` + 2.\n\n\n\n\n21.2.5.2.2 RegExpBuiltinExec\n----------------------------\nReplace step 15.c.ii with:\n\n   ii.  Let lastIndex be NextStringIndex(S, lastIndex, fullUnicode).\n\n\n\n21.2.5.6 RegExp.prototype[@@match]\n----------------------------------\nCurrent step 8 becomes:\n\n    8.  Else, global is true,\n        a.  Let unicodeMatching be ToBoolean(Get(rx, \"unicode\")).\n        b.  ReturnIfAbrupt(unicodeMatching).\n        c.  (proceed with current step a)\n\nCurrent steps 8.e.iv.5.c-d become:\n\n    c.  Let nextIndex be NextStringIndex(S, thisIndex, unicodeMatching).\n    d.  Let setStatus be Set(rx, \"lastIndex\", nextIndex, true).\n    e.  ReturnIfAbrupt(setStatus).\n\n\n21.2.5.6 RegExp.prototype[@@replace]\n----------------------------------\nCurrent step 10 becomes:\n\n    10.  If global is true,\n        a.  Let unicodeMatching be ToBoolean(Get(rx, \"unicode\")).\n        b.  ReturnIfAbrupt(unicodeMatching).\n        c.  (proceed with current step a)\n\nCurrent steps 13.d.iii.3.c-d become:\n\n    c.  Let nextIndex be NextStringIndex(S, thisIndex, unicodeMatching).\n    d.  Let setStatus be Set(rx, \"lastIndex\", nextIndex, true).\n    e.  ReturnIfAbrupt(setStatus).\n\n    \n\n21.2.5.11 RegExp.prototype [@@split]\n------------------------------------\nUsing the NextStringIndex abstract operations, step 24.e can be rewritten:\n\n    e.  If z is null, let q be NextStringIndex(S, q, unicodeMatching).\n\nand step 24.f.iii:\n\n    iii. If e = p, let q be NextStringIndex(S, q, unicodeMatching)."},{"commentid":13719,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-13 09:07:24 -0700","thetext":"fixed in rev36 editor's draft"},{"commentid":13824,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-17 16:57:06 -0700","thetext":"in rev36"}]}}
---
