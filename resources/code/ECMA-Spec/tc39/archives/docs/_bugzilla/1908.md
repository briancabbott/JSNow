---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1908,"creation_ts":"2013-09-25 16:09:00 -0700","short_desc":"Need to respecify @@unscopable binding","delta_ts":"2015-07-10 08:35:05 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 18: September 5, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"allen","name":"Allen Wirfs-Brock"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["andrebargull","brterlso","erik.arvidsson"],"long_desc":[{"commentid":5424,"comment_count":0,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-09-25 16:09:15 -0700","thetext":"Declarative Environment Record needs to be update to reflect @@unscopable approach discussed at Sept 2013 TC39 meeting \n\n\nhttps://github.com/rwaldron/tc39-notes/blob/master/es6/2013-09/sept-17.md#53-unscopeable"},{"commentid":6622,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-11-09 10:51:58 -0800","thetext":"fixed in rev22 editor's draft\n\nNote that an ordinary object is now used as the object containing the unscopable property names. they are the own property names of the unscopable object."},{"commentid":6657,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-11-11 12:12:34 -0800","thetext":"Here are the main spec. updates (to Rev21)\n\n8.1.1.2.1\tHasBinding(N)\nThe concrete Environment Record method HasBinding for object environment records determines if its associated binding object has a property whose name is the value of the argument N:\n1.\tLet envRec be the object environment record for which the method was invoked.\n2.\tLet bindings be the binding object for envRec.\n3.\tIf the withEnvironment flag of newEnv is true, then\n   a.\tLet unscopables be Get(bindings, @@unscopables).\n   b.\tReturnIfAbrupt(unscopables).\n   c.\tIf Type(unscopables) is Object, then\n      i.\tLet found be HasOwnProperty(unscopables, N).\n      ii.\tReturnIfAbrupt(found).\n      iii.\tIf found is true, then return false.\n4.\tReturn the result of HasProperty(bindings, N).\n\n22.1.3.31\tArray.prototype [ @@unscopables ]\nThe initial value of the @@unscopables data property is an object created by the following steps:\n1.\tLet blackList be the result of calling ObjectCreate(%ObjectPrototype%).\n2.\tCall CreateDataProperty(blackList, \"find\", true).\n3.\tCall CreateDataProperty(blackList, \"findIndex\", true).\n4.\tCall CreateDataProperty(blackList, \"fill\", true).\n5.\tCall CreateDataProperty(blackList, \"copyWithin\", true).\n6.\tCall CreateDataProperty(blackList, \"entries\", true).\n7.\tCall CreateDataProperty(blackList, \"keys\", true).\n8.\tCall CreateDataProperty(blackList, \"values\", true).\n9.\tAssert: Each of the above calls will return true.\n10.\tReturn blackList."},{"commentid":7108,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-01-27 10:05:47 -0800","thetext":"fixed in Rev22 (January 20, 2013) release"},{"commentid":8041,"comment_count":4,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-04-30 15:08:38 -0700","thetext":"Reopening since this is not in rev 24\n\nThe algorithms in #2 do not use an array. The discussion on es-discuss was using an array. I find using any Object and doing HasOwnProperty cleaner."},{"commentid":8047,"comment_count":5,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-04-30 15:36:42 -0700","thetext":"Another reason why using has property is better is that we do not need to invoke any getters or any toString methods."},{"commentid":8048,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-30 18:24:54 -0700","thetext":"The correct code was in rev21, but somehow got lost in rev22 and later.  What is currently in the spec. is essentially what was in rev20."},{"commentid":8084,"comment_count":7,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-05-01 09:14:45 -0700","thetext":"(In reply to comment #6)\n> The correct code was in rev21, but somehow got lost in rev22 and later.  What\n> is currently in the spec. is essentially what was in rev20.\n\nI looked through rev 20, 21, 22 and the unscopables are never extracted in those revs either."},{"commentid":8085,"comment_count":8,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-05-01 09:26:04 -0700","thetext":"unscopables extraction was added in rev17 and then later removed in rev19."},{"commentid":8088,"comment_count":9,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-05-01 11:01:55 -0700","thetext":"(In reply to comment #8)\n> unscopables extraction was added in rev17 and then later removed in rev19.\n\nJust double checked and there is more spec text here but it has issues. (unscopables is never set, probably just a typo)"},{"commentid":8861,"comment_count":10,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2014-06-04 12:44:38 -0700","thetext":"Upping the priority of this as discussed.\n\nI would also appreciate the rationale for why @@unscopable cannot be an object.\n\nIf @@unscopable must be an array, please consider looking up entries in the @@unscopable array using GetOwn rather than Get as it's simpler."},{"commentid":9046,"comment_count":11,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-06-20 13:41:59 -0700","thetext":"Here is a gist with an update spec algorithm for 8.1.1.2.1 HasBinding(N)\n\nhttps://gist.github.com/arv/f820c7c02a8119eb27a3\n\nWith this we can remove the notion that an ObjectEnvironment has an unscopables list since this is all localized to HasBinding."},{"commentid":9047,"comment_count":12,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-06-21 06:33:41 -0700","thetext":"The HasBinding algorithm in the gist retrieves @@unscopables even if `hasProperty` is false. Is this on purpose?"},{"commentid":9070,"comment_count":13,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-06-23 07:22:49 -0700","thetext":"(In reply to comment #12)\n> The HasBinding algorithm in the gist retrieves @@unscopables even if\n> `hasProperty` is false. Is this on purpose?\n\nYou are right, this can be optimized to do one less HasOwnProperty call.\n\nFixed."},{"commentid":9084,"comment_count":14,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-06-23 16:11:38 -0700","thetext":"(In reply to comment #11)\n> Here is a gist with an update spec algorithm for 8.1.1.2.1 HasBinding(N)\n> \n> https://gist.github.com/arv/f820c7c02a8119eb27a3\n\nI see a problem with this design.  Consider this ES5ish code snippet:\n\nwindow.values = 100;\nArray.prototype.__proto__ = {values: 42};\nvar obj = [ ];\nwith (obj) console.log(value);  //should be 42;\n\nIn ES5, the HasBinding call on the with environment would find the property with the value 42. But, with Erik's changes we would we would log \"100\" because his HasBinding look up would stop when it saw an @@unscopable 'values' property on Array.prototype. This causes the with environment to be by passed and lexical lookup would climb the environment until it came to the global environment and finds 'values' with the value 100.\n\nThis issue might or might not be observable if 'values' was added to Object.prototype instead of splicing in a new prototype object.  It would depend upon whether the global object also had a 'values' own property.\n\nIn practice we may never see this, but we're already adding a fair amount of complexity to maintain backwards compatability while adding these new methods.  To fix it in HasBinding we would have to continue looking up the prototype chain even when isBlocked is true. Worse, we will also have to add a similar @@unscopable lookup algorithm to Object Environment Record's GetBindingValue.\n\nI think we have to do it?  Any other thoughts?"},{"commentid":9091,"comment_count":15,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-06-24 07:13:17 -0700","thetext":"(In reply to comment #14)\n> (In reply to comment #11)\n> > Here is a gist with an update spec algorithm for 8.1.1.2.1 HasBinding(N)\n> > \n> > https://gist.github.com/arv/f820c7c02a8119eb27a3\n> \n> I see a problem with this design.  Consider this ES5ish code snippet:\n> \n> window.values = 100;\n> Array.prototype.__proto__ = {values: 42};\n> var obj = [ ];\n> with (obj) console.log(value);  //should be 42;\n> \n> In ES5, the HasBinding call on the with environment would find the property\n> with the value 42. But, with Erik's changes we would we would log \"100\" because\n> his HasBinding look up would stop when it saw an @@unscopable 'values' property\n> on Array.prototype. This causes the with environment to be by passed and\n> lexical lookup would climb the environment until it came to the global\n> environment and finds 'values' with the value 100.\n> \n> This issue might or might not be observable if 'values' was added to\n> Object.prototype instead of splicing in a new prototype object.  It would\n> depend upon whether the global object also had a 'values' own property.\n> \n> In practice we may never see this, but we're already adding a fair amount of\n> complexity to maintain backwards compatability while adding these new methods. \n> To fix it in HasBinding we would have to continue looking up the prototype\n> chain even when isBlocked is true. Worse, we will also have to add a similar\n> @@unscopable lookup algorithm to Object Environment Record's GetBindingValue.\n> \n> I think we have to do it?  Any other thoughts?\n\nIt is unfortunate that we have to do this dance in both HasBinding and GetBindingValue but I don't see any other way.\n\nLet me think about it a bit more."},{"commentid":9158,"comment_count":16,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-07-11 14:26:14 -0700","thetext":"Do we need to update SetMutableBinding too? If not we get very strange results when the object has blacklisted a property that is then set.\n\n(function TestSetterOnBlacklisted() {\n  var proto = {\n    set x(x) {\n      assertTrue(false);\n    },\n    get x() {\n      return 'proto';\n    }\n  };\n  var object = {\n    __proto__: proto,\n    get x() {\n      return this.x_;\n    },\n    set x(x) {\n      this.x_ = x;\n    },\n    x_: 1\n  };\n\n  with (object) {\n    x = 2;\n    assertEquals(x, 2);\n  }\n\n  assertEquals(object.x, 2);\n\n  object[Symbol.unscopables] = {x: true};\n\n  with (object) {\n    x = 3;\n    assertEquals(x, 'proto');\n  }\n\n  assertEquals(object.x, 3);\n})();"},{"commentid":9160,"comment_count":17,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-11 15:34:52 -0700","thetext":"(In reply to comment #16)\n> Do we need to update SetMutableBinding too? If not we get very strange results\n> when the object has blacklisted a property that is then set.\n> \n\nugh!!  The swamp just keeps getting deeper and deeper...\n\nI think we probably have to do it, if we continue down this path. We would also have to consider the interaction  with data property assignments when there is an inherited non-writable property that is @@unscoped \n\nAnd this whole approach completely ignores that fact that the with object or any of its prototypes could be Proxy object that has redefined [[Get]] or [[Set]] and we may be imposing the a wrong lookup semantics on them."},{"commentid":9646,"comment_count":18,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-07-29 22:16:46 -0700","thetext":"At the F2F today we decided to back track this to plan a. This means that we do a HasProperty for name, if found we do a Get for @@unscopables and if found we do a HasProperty on the unscopables object.\n\nhttps://gist.github.com/arv/f820c7c02a8119eb27a3\n\nAllen, as far as I can tell we do not need to update SetMutableBinding anymore, since before the assignment, we will have already determined whether the property name has been black listed or not. Also, with plan a we always do a Get/Put on the object being the receiver so we do not get into the strange edge cases we got to before where a property on the instance was blocked but accepted further down the prototype type chain.\n\n(sorry for not making the SetMtableBinding case clear today with the plan b approach)"},{"commentid":9841,"comment_count":19,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-21 17:05:22 -0700","thetext":"fixed in rev27 editor's draft"},{"commentid":9973,"comment_count":20,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-25 08:29:32 -0700","thetext":"fixed in rev27 draft"}]}}
---
