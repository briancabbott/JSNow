---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3694,"creation_ts":"2015-01-30 16:07:00 -0800","short_desc":"22.2.3.22.2%TypedArray%.prototype.set: Special case same element to allow memmove?","delta_ts":"2015-02-19 19:11:01 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 31: January 15, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"erights","long_desc":[{"commentid":11763,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-30 16:07:53 -0800","thetext":"22.2.3.22.2%TypedArray%.prototype.set(typedArray [, offset ] )\n\nImplementors like their memmoves, but the loop in step 28 makes it impossible to use memmove for Float32/64 because of NaN canonicalization in GetValueFromBuffer."},{"commentid":12199,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-06 15:32:42 -0800","thetext":"Looking at ArrayBuffer SetValueInBuffer, it seems that the only things that prevents using memmove is that fact the SetValueInBuffer says that NaNs must be stored as non-signaling value.  So, if somebody had placed placed signaling NaN bit patterns into the source buffer, the current language requires that an implementation transform them.\n\nI'm think I probably originally inserted the \"non-signaling\" language into the spec and now it isn't clear to me that it has any value given that any possible bit value can be placed into an ArrayBuffer by attaching an appropiate view to it.\nI'm inclined to simply delete the words \"non-signaling\" from the SetValueInBuffer spec.\n\nTo you think this is reasonable and sufficient?\n\nI'm also inclined to put a statement somewhere in the TypedArray section that says that a bit level transfer must occur anytime an algorithm  retrieves a value from a typed array using [[Get]] and immediately stores it back into a typed array, of the same type, using [[Set]].  It seem this would have to be stated as a mandatory requirement, in order to avoid interop hazards."},{"commentid":12610,"comment_count":2,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-13 16:45:11 -0800","thetext":"> anytime an algorithm  retrieves a value from a typed array using [[Get]] and\n> immediately stores it back into a typed array, of the same type, using [[Set]].\n\nI don't think this is viable. How would you define \"immediately\"? When doing a [[Set]] of a NaN, I agree we don't need to say \"non-signaling\", but we still need to allow any NaN bit pattern."},{"commentid":12612,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-13 17:11:33 -0800","thetext":"(In reply to Mark Miller from comment #2)\n> > anytime an algorithm  retrieves a value from a typed array using [[Get]] and\n> > immediately stores it back into a typed array, of the same type, using [[Set]].\n> \n> I don't think this is viable. How would you define \"immediately\"? When doing\n> a [[Set]] of a NaN, I agree we don't need to say \"non-signaling\", but we\n> still need to allow any NaN bit pattern.\n\nBy immediately I mean equivalently to doing a [[Get]] immediately followed by a [[Set]] with no interesting operations between them.  The language can be tweaked, as necessary to make that precise enough.\n\nI'm not sure what you're trying to say in your last sentence. Are you saying that it is important that an implementation is allowed  (but not required) to change NaN patterns on any such [[Get]]/[[Set]] sequence.  If so, then there may be observable difference between implementations and it might even revealing of implementation details such as its preferred.\n\nfinally, I assume that implementations already do memmove where ever they think they can.  What we are trying to do here is make sure that we don't unintentionally have spec. languages that says they can't do that."},{"commentid":12613,"comment_count":4,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-13 17:21:45 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #3)\n> (In reply to Mark Miller from comment #2)\n> > > anytime an algorithm  retrieves a value from a typed array using [[Get]] and\n> > > immediately stores it back into a typed array, of the same type, using [[Set]].\n> > \n> > I don't think this is viable. How would you define \"immediately\"? When doing\n> > a [[Set]] of a NaN, I agree we don't need to say \"non-signaling\", but we\n> > still need to allow any NaN bit pattern.\n> \n> By immediately I mean equivalently to doing a [[Get]] immediately followed\n> by a [[Set]] with no interesting operations between them.  The language can\n> be tweaked, as necessary to make that precise enough.\n\nPerhaps, depending on what you mean by \"interesting\". But I don't understand what you'd be accomplishing. It seems weird to me that\n\nconst x = ta[i];\nta[j] = x;\n\nmeans something different than\n\nconst x = ta[i];\nnoop();\nta[j] = x;\n\nThis non-equivalence breaks what are otherwise algebraic properties of the language that code transformation tools (including transpilers) depend on. This non-equivalence would, AFAICT, be an unprecedented special case in the language semantics.\n\n\n> I'm not sure what you're trying to say in your last sentence. Are you saying\n> that it is important that an implementation is allowed  (but not required)\n> to change NaN patterns on any such [[Get]]/[[Set]] sequence.\n\nWhen they are being gotten as floating point numbers, yes.\n\n\n>  If so, then\n> there may be observable difference between implementations and it might even\n> revealing of implementation details such as its preferred.\n\nIn for a penny....\n\nWe already paid this cost when we allowed storing a NaN to store any NaN bit pattern. Since we only have one abstract NaN value at the JavaScript level, and we decided we can't afford to canonicalize the bit pattern, I don't see that we have any other choice.\n\n\n> finally, I assume that implementations already do memmove where ever they\n> think they can.  What we are trying to do here is make sure that we don't\n> unintentionally have spec. languages that says they can't do that.\n\nHaving the spec allow the implementation more freedom does not threaten this."},{"commentid":12614,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-13 17:40:49 -0800","thetext":"(In reply to Mark Miller from comment #4)\n> \n> Perhaps, depending on what you mean by \"interesting\". But I don't understand\n> what you'd be accomplishing. It seems weird to me that\n> \n> const x = ta[i];\n> ta[j] = x;\n> \n> means something different than\n> \n> const x = ta[i];\n> noop();\n> ta[j] = x;\n> \n\nI'm not talking about JS level code. I'm talking about spec. algorithms like the substeps on step 28 of http://people.mozilla.org/~jorendorff/es6-draft.html#sec-%typedarray%.prototype.set-typedarray-offset which looks like: \n\n28.\tRepeat, while targetByteIndex < limit\n   a.\t   Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).\n   b.\t   Let status be SetValueInBuffer (targetBuffer, targetByteIndex, targetType, value).\n   c.\t   Set srcByteIndex to srcByteIndex + srcElementSize.\n   d.\tSet targetByteIndex to targetByteIndex + targetElementSize.\n\nThese aren't even actual [[Get]] or [[Set]] mop operations but the direct buffer access that are used to implemented [[Get]] and [[Set]].\n\n\n\n\n\n\n\n\n\n> This non-equivalence breaks what are otherwise algebraic properties of the\n> language that code transformation tools (including transpilers) depend on.\n> This non-equivalence would, AFAICT, be an unprecedented special case in the\n> language semantics.\n> \n> \n> > I'm not sure what you're trying to say in your last sentence. Are you saying\n> > that it is important that an implementation is allowed  (but not required)\n> > to change NaN patterns on any such [[Get]]/[[Set]] sequence.\n> \n> When they are being gotten as floating point numbers, yes.\n> \n> \n> >  If so, then\n> > there may be observable difference between implementations and it might even\n> > revealing of implementation details such as its preferred.\n> \n> In for a penny....\n> \n> We already paid this cost when we allowed storing a NaN to store any NaN bit\n> pattern. Since we only have one abstract NaN value at the JavaScript level,\n> and we decided we can't afford to canonicalize the bit pattern, I don't see\n> that we have any other choice.\n> \n> \n> > finally, I assume that implementations already do memmove where ever they\n> > think they can.  What we are trying to do here is make sure that we don't\n> > unintentionally have spec. languages that says they can't do that.\n> \n> Having the spec allow the implementation more freedom does not threaten this."},{"commentid":12616,"comment_count":6,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-13 17:53:41 -0800","thetext":"I see. I misunderstood. I withdraw the objection. Looks fine to me."},{"commentid":12671,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-14 10:50:48 -0800","thetext":"fixed in rev34 editor's draft\n\nIn the end, I decided that the best thing to do was to explicitly specify encoding preserving data transfers in the situations where that makes sense.\n\nthe three places are TypedType copyWithin, slice, and set(TypedArray)"},{"commentid":13092,"comment_count":8,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-19 19:11:01 -0800","thetext":"fixed in rev34"}]}}
---
