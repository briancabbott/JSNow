---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2978,"creation_ts":"2014-06-06 07:55:00 -0700","short_desc":"Array.prototype.sort: specify the expected behaviour of, e.g., `[Infinity, -Infinity].sort( (a, b) => a - b )`","delta_ts":"2014-08-15 07:57:52 -0700","product":"Draft for 6th Edition","component":"normative change from ES5.x","version":"Rev 26: July 18, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"claude.pache","name":"Claude Pache"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["ecmascript","erights"],"long_desc":[{"commentid":8867,"comment_count":0,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-06-06 07:55:07 -0700","thetext":"Consider the following code:\n\n    let compareFn = (a,b) => a - b\n    [Infinity, 9, 3, 4 , -Infinity, 6, Infinity, 2].sort(compareFn)\n\nThe behaviour of the `sort` method is left undefined by the spec, because the `compareFn` produce `NaN` instead of `0` in the following case:\n\n    compareFn(Infinity, Infinity)\n\nHowever, four browsers I've tried (latest stable versions of Safari, Firefox, IE and Chrome) do produce the expected result in that particular example.\n\nThat case could be easily specified by allowing `compareFn(a, b)` to produce any number including `NaN`, and by requiring to treat `NaN` the same way as `0`."},{"commentid":9258,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-18 09:26:54 -0700","thetext":"fixed in rev26 editor's draft"},{"commentid":9287,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-18 14:45:55 -0700","thetext":"in rev26"},{"commentid":9288,"comment_count":3,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-07-18 15:41:03 -0700","thetext":"What if NaNs appear in the list to be sorted?"},{"commentid":9556,"comment_count":4,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-07-25 10:39:49 -0700","thetext":"(In reply to Mark Miller from comment #3)\n> What if NaNs appear in the list to be sorted?\n\nSome experience with current browsers show inconsistent results (generally an incompletely sorted array).\n\njs> [NaN, 4, 2, NaN, 1, NaN, 3].sort(function(a, b) { return a - b })\n\nSafari 7:   [NaN, 1, 2, 4, NaN, NaN, 3]\nFirefox 31: [3, NaN, 1, NaN, 2, 4, NaN]\nChrome 36:  [NaN, 2, 4, NaN, 1, NaN, 3]\nIE 11:      [NaN, 2, 4, NaN, 1, NaN, 3]"},{"commentid":9644,"comment_count":5,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-07-29 16:12:08 -0700","thetext":"This is maybe nitpicking, but...\n\nThe change made in Rev. 26 has consisted of adding a special case for NaN in the SortCompare Abstract Operation algorithm (Section 22.1.3.24.1; step 17.d).\n\nNow: In case `comparefn` produces `NaN` for some pairs of values, then `comparefn` is never a \"consistent comparison function\" (as defined in Section 22.1.3.24 Array.prototype.sort), and thus the behaviour of sort is still allowed to be \"implementation-defined\".\n\nBut actually, we are not interested whether `comparefn` is a consistent comparison function, but whether SortCompare (defined in Section 22.1.3.24.1 Runtime Semantics: SortCompare Abstract Operation) is \"consistent\".\n\nHowever, since the change made in Rev.26, it is no longer the same thing for SortCompare or for `comparefn` to be consistent...\n\nI think that the more elegant way to resolve the issue is as follows:\n\n* Revert the change made in Rev. 26; that is, in the abstract operation SortCompare, remove the special-casing for NaN. That will effectively remove the discrepancy between the \"consistence\" of `comparefn` and the \"consistence\" of SortCompare.\n\n* Change the definition of \"consistent comparison function\" by allowing NaN to denote the \"equality\"; more precisely, make the following changes in the text:\n\n  * \"a =CF b means comparefn(a,b) = 0 (of either sign)\"\n      ==> \"a =CF b means comparefn(a,b) is +0, -0, or NaN\"\n  \n  * \"Furthermore, Type(v) is Number, and v is not NaN.\"\n      ==> \"Furthermore, Type(v) is Number.\""},{"commentid":9793,"comment_count":6,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-08-15 07:57:52 -0700","thetext":"In fact, the objection of Comment #5 may be applied to further cases, e.g. when the `compareFn` does not produce values of type Number. In that case, implementations have also a more well-defined behaviour than what is currently specced; see Bug #3137.\n\nI'm reclosing this Bug because of that, and because it is superseded by Bug #3137. In case I'm finding a convenient formulation for \"consistent\" that handles more cases than \"non-NaN numbers\", I could open a new Bug."}]}}
---
