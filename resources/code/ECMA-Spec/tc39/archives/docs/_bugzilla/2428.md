---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2428,"creation_ts":"2014-01-23 01:17:00 -0800","short_desc":"metavariables in upright font","delta_ts":"2014-06-02 11:25:35 -0700","product":"Draft for 6th Edition","component":"editorial issue","version":"Rev 22: January 20, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"jmdyck","name":"Michael Dyck"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":6989,"comment_count":0,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2014-01-23 01:17:51 -0800","thetext":"A bunch of metavariables that were italic in rev21 are now in an upright font (in the PDF at least).\n\nE.g.:\n    5.3 / alg 1 / step 1.b.i 'contained'\n    6.2.2.4 / alg 2 / step 2 'argument'\n    12.2.2.1 / alg 1 / step 5 'propertyNameValue'\n    12.2.5.2 / alg 2 / step 1 'propertyKey'\n    12.2.5.2 / alg 2 / step 2 'strict'\n    14.5.16 / alg 1 / step 1 'className'\n    14.5.16 / alg 1 / step 2 'value'\n    14.5.16 / alg 1 / step 4 'hasNameProperty'\n    14.5.16 / alg 1 / step 7 'env'\n    14.5.16 / alg 1 / step 8 'status'\n\nThis is a brief list because I'm hoping that you can fix *all* cases just by repairing a document style. If that's not the case, I could work on a fuller list.\n\n(Either way, it's somewhat annoying to get regressions in old, supposedly stable parts of the spec. Is there some way to prevent it happening again?)"},{"commentid":7243,"comment_count":1,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2014-02-10 15:37:10 -0800","thetext":"In a message today in es-discuss, AWB said \"sure, add the complete list\", so here it is (60 corrections on 37 lines):\n\n5.3 / alg 1 / step 1.b.i\n    Let contained be the result of /sym/ Contains /symbol/.\n        italicize \"contained\"\n\n6.2.2.4 / alg 2 / step 1\n    If argument is an abrupt completion, then return argument.\n        italicize \"argument\"\n        italicize \"argument\"\n\n6.2.2.4 / alg 2 / step 2\n    Else if argument is a Completion Record,\n    then let argument be argument.[[value]].\n        italicize \"argument\"\n        italicize \"argument\"\n        italicize \"argument\"\n\n6.2.6.2 / alg 1 / step 7.a\n    Set toBlock[toIndex] to the value of fromBlock[fromIndex].\n        italicize \"toBlock\"\n        italicize \"toIndex\"\n        italicize \"fromBlock\"\n        italicize \"fromIndex\"\n\n9.2.13 / alg 1 / step 3\n    Assert: Type(newName) is one of Undefined, String, or Symbol.\n        italicize \"newName\"\n\n11.6 / para 4\n    ... are only required to do bitwise comparison on IdentifierName values).\n        italicize \"IdentifierName\" ?\n\n12.2.2.1 / alg 1 / step 5\n    Let propertyNameValue be GetValue(propertyNameReference).\n        italicize \"propertyNameValue\"\n        italicize \"propertyNameReference\"\n\n12.2.5.2 / alg 2 / step 1\n    Let propertyKey be StringValue of IdentifierName.\n        italicize \"propertyKey\"\n        italicize \"IdentifierName\"\n\n12.2.5.2 / alg 2 / step 2\n    If the code matched by the syntactic production that is being evaluated\n    is strict mode code, let strict be *true*, else let strict be *false*.\n        italicize \"strict\"\n        italicize \"strict\"\n\n12.2.5.2 / alg 2 / step 3\n    Return the result of MakeSuperReference(propertyKey, strict).\n        italicize \"propertyKey\"\n        italicize \"strict\"\n\n14.5.16 / alg 1 / step 1\n    Let className be StringValue of BindingIdentifier.\n        italicize \"className\"\n        italicize \"BindingIdentifier\"\n\n14.5.16 / alg 1 / step 2\n    Let value be the result of ClassDefinitionEvaluation of /ClassTail/\n    with argument className\n        italicize \"value\"\n        italicize \"className\"\n\n14.5.16 / alg 1 / step 3\n    ReturnIfAbrupt(value).\n        italicize \"value\"\n\n14.5.16 / alg 1 / step 4\n    Let hasNameProperty be the result of HasOwnProperty(value, \"name\").\n        italicize \"hasNameProperty\"\n        italicize \"value\"\n\n14.5.16 / alg 1 / step 5\n    ReturnIfAbrupt(hasNameProperty).\n        italicize \"hasNameProperty\"\n\n14.5.16 / alg 1 / step 6\n    If hasNameProperty is *false*, then\n        italicize \"hasNameProperty\"\n\n14.5.16 / alg 1 / step 6.a\n    Perform SetFunctionName(value, className).\n        italicize \"value\"\n        italicize \"className\"\n\n14.5.16 / alg 1 / step 7\n    Let env be the running execution context's LexicalEnvironment.\n        italicize \"env\"\n\n14.5.16 / alg 1 / step 8\n    Let status be the result of performing BindingInitialisation\n    for BindingIdentifier passing value and env as the arguments.\n        italicize \"status\"\n        italicize \"BindingIdentifier\"\n        italicize \"value\"\n        italicize \"env\"\n\n14.5.16 / alg 1 / step 9\n    ReturnIfAbrupt(status).\n        italicize \"status\"\n\n14.6.2 / alg 19 / step 1\n    If this /CallExpression/ is nonterminal, then return *true*.\n        italicize \"nonterminal\"\n\n15.2.1.2 / alg 4 / step 3\n    Return names.\n        italicize \"names\"\n\n15.2.1.2 / alg 5 / step 3\n    Return names.\n        italicize \"names\"\n\n15.2.3.2 / Table 34 / [[Kind]]\n    ... the module is declarative, and load.[[Body]] contains a Module parse.\n        italicize \"load\" ?\n\n15.2.3.2 / Table 34 / [[Dependencies]]\n    ... from declaration in load.[[Body]], ...\n        italicize \"load\" ?\n\n15.2.6.1 / alg 1 / step 2\n    Assert: load.[[Status]] is \"linked\".\n        italicize \"load\"\n\n15.2.6.1 / alg 1 / step 3\n    Let /module/ be load.[[Module]].\n        italicize \"load\"\n\n15.2.6.2 / alg 1 / step 7\n    Let status be the result of performing\n    ModuleDeclarationInstantiation(/mod/.[[Body]], /mod/.[[Environment]]).\n        italicize \"status\"\n\n18.2.6.4 / alg 1 / step 4\n    Return the result of calling Encode(/uriString/, unescapedURISet)\n        italicize \"unescapedURISet\"\n\n19.1.2.1 / alg 1 / step 9.d.v.1\n    Let propValue be Get(from, nextKey).\n        italicize \"propValue\"\n        italicize \"from\"\n        italicize \"nextKey\"\n\n19.1.2.1 / alg 1 / step 9.d.v.2\n    If propValue is an abrupt completion, then\n        italicize \"propValue\"\n\n19.1.2.1 / alg 1 / step 9.d.v.2.a\n    If pendingException is *undefined*, then set pendingException to propValue.\n        italicize \"pendingException\"\n        italicize \"pendingException\"\n        italicize \"propValue\"\n\n19.1.2.1 / alg 1 / step 9.d.v.3.b.i\n    If pendingException is *undefined*, then set pendingException to status.\n        italicize \"pendingException\"\n        italicize \"pendingException\"\n        italicize \"status\"\n\n19.1.3.6 / alg 1 / step 19\n    Return the String value that is the result of concatenating\n    the three Strings \"[object \", tag, and \"]\".\n        italicize \"tag\"\n\n24.1.1.2 / alg 1 / step 1\n    ReturnIfAbrupt(arrayBuffer).\n        italicize \"arrayBuffer\"\n\n25.4.4.5 / alg 1 / step 4\n    Let /rejectResult/ be the result of calling the [[Call]] internal method\n    of /promiseCapability/.[[Reject]] with *undefined* as /thisArgument/ and\n    List(r) as /argumentsList/.\n        italicize \"r\"\n\n26.3.3 / alg 1 / step 1\n    If Type(/value/) is Object and value has a [[LoaderRecord]] internal slot,\n        italicize \"value\""},{"commentid":8426,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-05-14 13:20:42 -0700","thetext":"fixed in rev25 editor's draft"},{"commentid":8815,"comment_count":3,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2014-06-02 11:25:35 -0700","thetext":"confirmed fixed."}]}}
---
