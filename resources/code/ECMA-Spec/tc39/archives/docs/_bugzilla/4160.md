---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4160,"creation_ts":"2015-03-13 01:41:00 -0700","short_desc":"Can GeneratorResumeAbrupt throw an exception?","delta_ts":"2015-03-17 16:57:05 -0700","product":"Draft for 6th Edition","component":"editorial issue","version":"Rev 35: March 4, 2015 Release Candidate 2","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"axel","name":"Axel Rauschmayer"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":13718,"comment_count":0,"who":{"uid":"axel","name":"Axel Rauschmayer"},"bug_when":"2015-03-13 01:41:42 -0700","thetext":"25.3.3.4 GeneratorResumeAbrupt(generator, abruptCompletion)\n\nStep 11 says: “Let _result_ be the value returned by the resumed computation.”\n\nIf you resume the computation and `abruptCompletion.[[type]]` is `throw`, is it possible that the resumed computation throws an exception? That would mean that GeneratorResumeAbrupt would throw an exception, right? Independently of the answers to these questions, I’d explain the effect of `throw` completions."},{"commentid":13720,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-13 09:29:43 -0700","thetext":"If fact, getting a throw completion back as result is the most common case.\n\nAssume we have an active generator created like:\n\nfunction * counter(n) {\n   while (true) yield n++\n}\nlet g=counter(0);\n\nAnd its consumer executes something like:\n\ng.next();  //start the loop\ng.throw(\"abort counting\");\n\nFrom the perspective of g, that will be equivalent to replacing the yield with the above throw.  The exception  will go all the way to the top  counter's body eventually landing in step 4.1 of GeneratorStart with result being the throw completion record  for \"about counting\". Step 4.7.b sends control back to GeneratorResumeAbrupt step 11 with that same throw completion record. That eventually returns to the g.throw call site, with the throw completion so the exception continues to propagate from there.\n\nSo, from there perspective of the client, in this case g.throw(...) was essentially equivalent to just saying: throw \"abort counting\""},{"commentid":13721,"comment_count":2,"who":{"uid":"axel","name":"Axel Rauschmayer"},"bug_when":"2015-03-13 09:44:34 -0700","thetext":"Ah, good, thanks for confirming my suspicions.\n\nFor your example, I see a different control flow:\n\n* Generator.prototype.throw (25.3.1.4)\n* GeneratorResumeAbrupt (25.3.3.4)\n* The state of the generator is \"suspendedYield\" (step 5ff)\n* The part that I find a bit unclear is step 11 (of GeneratorResumeAbrupt): “Let _result_ be the value returned by the resumed computation.” It sounds like a value being returned is the normal case, but with `throw`, it isn’t. Therefore, I’d mention what happens if the “resumed computation” throws an exception. I’m assuming that that leads to GeneratorResumeAbrupt throwing an exception(?)"},{"commentid":13722,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-13 10:17:34 -0700","thetext":"(In reply to Axel Rauschmayer from comment #2)\n\n> * The part that I find a bit unclear is step 11 (of GeneratorResumeAbrupt):\n> “Let _result_ be the value returned by the resumed computation.” It sounds\n> like a value being returned is the normal case, but with `throw`, it isn’t.\n> Therefore, I’d mention what happens if the “resumed computation” throws an\n> exception. I’m assuming that that leads to GeneratorResumeAbrupt throwing an\n> exception(?)\n\n\"value\" in this case, is the completion record ([[type]] throw in this case) returned from the inner algorithm of 25.3.3.1.\n\nThat completion record is just returned as the completion record for GeneratorResumeAbrupt and execution proceeds as if the throw method had directly thrown the exception.\n\n Note that in my example the exception represent by that completion record is the one injected via the throw method call.  But if the yield was in the scope of a catch clause, the catch clause or other generator function code might have thrown a different exception.  In that case the GeneratorResumeAbrupt completion record would reflect that other exception."},{"commentid":13723,"comment_count":4,"who":{"uid":"axel","name":"Axel Rauschmayer"},"bug_when":"2015-03-13 10:57:45 -0700","thetext":"If it’s a completion then that resolves my confusion. How about s/value/completion/ in the following sentence? “Let _result_ be the value returned by the resumed computation.”\n\n> Note that in my example the exception represent by that completion record is the one injected via the throw method call.  But if the yield was in the scope of a catch clause, the catch clause or other generator function code might have thrown a different exception.  In that case the GeneratorResumeAbrupt completion record would reflect that other exception.\n\nRight. Due to `try-catch` (and `finally`), it wouldn’t even have to be an exception, the returned completion could have been created by a `return` or by a `yield`."},{"commentid":13724,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-13 11:45:46 -0700","thetext":"fixed in rev26 editor's draft"},{"commentid":13816,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-17 16:57:05 -0700","thetext":"in rev36"}]}}
---
