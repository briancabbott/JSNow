---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2884,"creation_ts":"2014-05-22 09:23:00 -0700","short_desc":"for-of and Array.from treat strings as iterable; nothing else does","delta_ts":"2014-07-18 14:27:37 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 23: April 5, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"jorendorff","name":"Jason Orendorff"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":8576,"comment_count":0,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-05-22 09:23:31 -0700","thetext":"Features using the `for-of` syntax consistently use ToObject, which means strings are iterable. For example, in \"12.2.4.2.4 Runtime Semantics: ComprehensionComponentEvaluation\":\n> 3. Let obj be ToObject(exprValue).\n> 4. ReturnIfAbrupt(obj).\n> 5. Let keys be GetIterator(obj).\n\nArray.from also uses ToObject() on its argument.\n\nBut in \"12.2.4.1.2 Runtime Semantics: ArrayAccumulation\":\n> 4. If Type(spreadObj) is not Object, then throw a TypeError exception.\n> 5. Let iterator be GetIterator(spreadObj).\n\nIncidentally, step 4 is technically redundant there, as GetIterator(x) step 2 throws a TypeError if x is primitive."},{"commentid":8578,"comment_count":1,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-05-22 09:52:48 -0700","thetext":"The ES6 spec is missing a high-level prose phrase that can be used in algorithms and means \"now use ES6 iteration\".\n\nIt could define one; here's how it might look, using Array.from step 8 as an example, (modified lines marked with !):\n> 8.  If usingIterator is not undefined, then\n>     a.  If IsConstructor(C) is true, then\n>         i.  Let A be the result of calling the [[Construct]] internal method of C with an empty argument list.\n>     b.  Else,\n>         i.  Let A be ArrayCreate(0).\n>     c.  ReturnIfAbrupt(A).\n>     d.  Let k be 0.\n>!    e.  Repeat, for each value nextValue produced by iterating over items\n>         i.  Let Pk be ToString(k).\n>         ii. If mapping is true, then\n>             1.  Let mappedValue be the result of calling the [[Call]]\n>                 internal method of mapfn with T as thisArgument and\n>                 (nextValue, k) as argumentsList.\n>             2.  ReturnIfAbrupt(mappedValue).\n>         iii. Else, let mappedValue be nextValue.\n>         iv. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).\n>         v.  ReturnIfAbrupt(defineStatus).\n>         vi. Increase k by 1.\n>!    f.  Let putStatus be Put(A, \"length\", k, true).\n>!    g.  ReturnIfAbrupt(putStatus).\n>!    h.  Return A.\n\nI think this would making mean adding a note in \"5.2 Algorithm Conventions\" that says something like:\n\n    A step in an algorithm that says \"Repeat for each value x produced by\n    iterating through y,\" followed by a list of substeps, means the same\n    thing as these steps:\n\n    1.  Let iterator be GetIterator(y).\n    2.  ReturnIfAbrupt(iterator).\n    3.  Let x be NextValue(iterator).\n    4.  ReturnIfAbrupt(x).\n    5.  Repeat, until x is **empty**\n        a.  Perform the substeps listed.\n        b.  Set x to NextValue(iterator).\n        c.  ReturnIfAbrupt(x).\n\nwith NextValue appropriately defined elsewhere. ReturnIfAbrupt is already defined as a sort of macro-expansion, so this should work.\n\nI think other specifications (particularly WebIDL) would love to have convenient-but-precise language for this. But quite apart from any external benefit, it would make the ES6 algorithms a lot easier to read."},{"commentid":8581,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-05-22 10:42:11 -0700","thetext":"In JS code an expression like:\n   \"abc\"[Symbol.iterator]\nis equivalent to\n   Object(\"abc\")[Symbol.iterator]\n\n(see 6.2.3.1)\n\nSo, in generally strings should act as Iterables. In looks like I need to carefully review uses of GetIterator and add use ToObject appropriately for the supposedly Iterable values. \n\nHowever, TC39 explicitly decided that they didn't want to ToObject the source value or default values of destructing.  For example:\n\n   {replace, slice} = \"\";  //this throws becase RHS is not an object\n\nSo, does this rule also apply to the spread operator in array leterals?  Maybe it shouldn't\n\n let codepoints = [...someString];\n\nseems like a very nice way to parse a string into its individual code points."},{"commentid":9205,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-15 11:02:05 -0700","thetext":"fixed in rev26 editor's draft\n\nStrings are treated as iterable by:\nspread, yield *, comprehensions, Set/WeakSet(iterable)"},{"commentid":9273,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-18 14:27:37 -0700","thetext":"in rev26"}]}}
---
