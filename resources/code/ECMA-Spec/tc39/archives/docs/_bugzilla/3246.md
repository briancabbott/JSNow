---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3246,"creation_ts":"2014-09-22 08:45:00 -0700","short_desc":"super.x = value should throw if super.x is not a setter","delta_ts":"2015-07-10 08:34:18 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 27: August 24, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"major","everconfirmed":true,"reporter":{"uid":"arv","name":"Erik Arvidsson"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["dslomov","erik.arvidsson"],"long_desc":[{"commentid":10239,"comment_count":0,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-09-22 08:45:13 -0700","thetext":"super.x = value should throw if super.x is not a setter\n\nIf it doesn't we get into the strange case where we end up changing a data property on the prototype chain which might be shadowed by an instance property.\n\nclass A {}\nA.prototype.x = 5; // data property on a prototype\n\nclass B extends A {\n  m() {\n    print(super.x);  // 5\n    super.x = 10;  // data properties are not inherited, \n                   // hence x is installed on a receiver\n    print(super.x); // 5\n    print(this.x);  // 10\n  }\n}"},{"commentid":10240,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-22 10:58:01 -0700","thetext":"I'm not looking at the spec. right now but this doesn't sound correct.  The [[Put]] receiver parameter should cause a data property to be set on the this object"},{"commentid":10241,"comment_count":2,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-09-22 11:21:15 -0700","thetext":"I think you are right.\n\nhttps://people.mozilla.org/~jorendorff/es6-draft.html#sec-putvalue\n\nhttps://people.mozilla.org/~jorendorff/es6-draft.html#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver\n\nsuper.x = 5 ends up calling [[HomeObject]].__proto__.[[Set]]('x', 5, this) which ends up setting 'x' on this (the receiver)"},{"commentid":10242,"comment_count":3,"who":{"uid":"dslomov","name":"Dmitry Lomov"},"bug_when":"2014-09-22 17:58:36 -0700","thetext":"Wait I do not understand.\n\nWhat this bug says is that precisely this semantics (super.x = 5 causing data property to be set on the receiver) is confusing and wrong. Yes according to the spec 'super.x = 5'  ends up like 'this.x = 5', and this causes weird results here:\n\nclass A {}\nA.prototype.x = 5; // data property on a prototype\n\nclass B extends A {\n  m() {\n    print(super.x);  // 5\n    super.x = 10;  // data properties are not inherited, \n                   // hence x is installed on a receiver\n    print(super.x); // 5\n    print(this.x);  // 10\n  }\n}\n\nyou assign to super.x, but when you read from super.x, you get a different value - confusing. \n\nIt gets worse: \nclass B {\n   method() { super.x = 10; }\n   get x() { return 15; }\n}\n\nlet b = new B();\nb.x; // 15;\nb.x = 5; // strict mode exception\nb.method(); \nb.x; // 10;\nb.x = 5; // ok\nb.x; // 5\n\nSuddenly you can override a getter unintentionally.\n\nMy suggestion would be to disallow 'super.x = ..' and 'super.x' if x is not an accessor property.\n\nOr maybe I am missing something here?"}]}}
---
