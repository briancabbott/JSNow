---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":294,"creation_ts":"2012-03-06 19:51:00 -0800","short_desc":"ch15/15.3/15.3.5/15.3.5.4/15.3.5.4_2-95gs depends on implementation-defined behavior","delta_ts":"2015-10-02 14:33:05 -0700","product":"ECMA-262, Editions 5 and 5.1","component":"technical content","version":"Edition 5.1","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"utatane.tea","name":"Yusuke Suzuki"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["allen","andrebargull","erights"],"long_desc":[{"commentid":727,"comment_count":0,"who":{"uid":"utatane.tea","name":"Yusuke Suzuki"},"bug_when":"2012-03-06 19:51:15 -0800","thetext":"ch15/15.3/15.3.5/15.3.5.4/15.3.5.4_2-95gs expects TypeError thrown.\ndescription is below\n\n@description Strict mode - checking access to strict function caller from non-strict, constructor-based function (FunctionDeclaration includes strict directive prologue)\n\nAccording to ECMA262 5.1 section 15.3.2.1-9\n    If body is strict mode code (see 10.1.1) then let strict be true, else let strict be false\n\nand 15.3.2.1-11\n  Return a new Function object created as specified in 13.2 passing P as the FormalParameterListopt and body as the FunctionBody. Pass in the Global Environment as the Scope parameter and strict as the Strict flag.\n\nSo, created function from `Function(\"return gNonStrict.caller;\")` is always non-strict function even if global code is strict code.\n\nAnd according to the section 13.2 Creating Function Objects, step 19\n\n  If Strict is true, then\n    Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n    Call the [[DefineOwnProperty]] internal method of F with arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false.\n    Call the [[DefineOwnProperty]] internal method of F with arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false.\n\nSo if function is non-strict code, function.caller can be undefined. (Function.caller is non-standard https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/Caller)\n\nThen, 15.3.5.4, [[Get]] step 2\n  If P is \"caller\" and v is a strict mode Function object, throw a TypeError exception.\n\nIt is implementation dependent that v is function object, so this test depends implementation-dependent."},{"commentid":732,"comment_count":1,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2012-03-08 08:54:40 -0800","thetext":"Allen, the following code snippet is expected to throw a TypeError by the test:\n  var gNonStrict = Function(\"return gNonStrict.caller;\");\n\n  function f() {\n      \"use strict\";\n      return gNonStrict();\n  }\n  f();\n\n\nThe relevant ES5 algorithm is:\n1. Let v be the result of calling the default [[Get]] internal method (8.12.3) on F passing P as the property name argument.\n2. If P is \"caller\" and v is a strict mode Function object, throw a TypeError exception.\n3. Return v.\n\n\nMy take is:\n- function 'f' is clearly a strict mode function\n- gNonStrict is not a strict mode function\n- as far as 15.3.5.4 is concerned: P===\"caller\" && F===\"gNonStrict\" => v===f\n- v is indeed a strict mode Function Object.  I.e., it being accessed from non-strict code doesn't change the fact that 'f' is strict => TypeError is thrown"},{"commentid":733,"comment_count":2,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-03-08 11:11:07 -0800","thetext":"Most of the tests in ch15/15.3/15.3.5/15.3.5.4 rely on implementations providing the non-standard \"caller\" property for non-strict functions. This is wrong to begin with. Therefore the tests need to be updated to cope with implementations which don't provide \"caller\" at all, similar to the suggested fix in bug 288."},{"commentid":734,"comment_count":3,"who":{"uid":"utatane.tea","name":"Yusuke Suzuki"},"bug_when":"2012-03-08 15:30:58 -0800","thetext":"> - gNonStrict is not a strict mode function\n> - as far as 15.3.5.4 is concerned: P===\"caller\" && F===\"gNonStrict\" => v===f\n> - v is indeed a strict mode Function Object.  I.e., it being accessed from\n\nThe key point is that, because function.caller property of non-strict function is implementation-dependent behavior, v is allowed to be undefined by spec. v !== f.\n\n> Therefore the tests need to be updated to cope with implementations which don't provide \"caller\" at all, similar to the suggested fix in bug 288.\nAgreed."},{"commentid":735,"comment_count":4,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-03-08 15:47:47 -0800","thetext":"I've just sent a mail to es5-discuss concerning 15.3.5.4, maybe the whole issue will get a wider attention there."},{"commentid":736,"comment_count":5,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2012-03-08 20:58:27 -0800","thetext":"I'm dyslexic today.  Do you agree the following generic change would alleviate the \"Function.caller's not implemented\" issue for the test cases expected to throw type errors:\n  var gNonStrict = Function(\"return gNonStrict.caller || gNonStrict.caller.shouldThrowTypeError;\");\n\n  function f() {\n      \"use strict\";\n      return gNonStrict();\n  }\n  f();\n\nEven with this change I think it belongs in the best practices directory (at best;) ).  Thanks for spotting this!"},{"commentid":737,"comment_count":6,"who":{"uid":"utatane.tea","name":"Yusuke Suzuki"},"bug_when":"2012-03-08 23:08:07 -0800","thetext":"> Do you agree the following generic change would alleviate\n> the \"Function.caller's not implemented\" issue for the test cases expected to\n> throw type errors:\n\nI agree to this change, `Function(\"return gNonStrict.caller || gNonStrict.caller.shouldThrowTypeError;\")` :-)\nThanks for your work and test262!"},{"commentid":739,"comment_count":7,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2012-03-09 14:00:37 -0800","thetext":"The change '||\ngNonStrict.caller.shouldThrowTypeError;\");' change has been checked-in.  Still think that minimally the following might not be strictly required by ES5.1:\n15.3.5.4_2-10gs\tStrict mode - checking access to strict function caller from non-strict function (New'ed Function constructor includes strict directive prologue)\t\n15.3.5.4_2-16gs\tStrict mode - checking access to strict function caller from non-strict function (New'ed object from FunctionDeclaration includes strict directive prologue)\t\n15.3.5.4_2-18gs\tStrict mode - checking access to strict function caller from non-strict function (New'ed object from FunctionExpression includes strict directive prologue)\t\n15.3.5.4_2-20gs\tStrict mode - checking access to strict function caller from non-strict function (New'ed object from Anonymous FunctionExpression includes strict directive prologue)\t\n15.3.5.4_2-2gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration includes strict directive prologue)\t\n15.3.5.4_2-30gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration defined within a FunctionDeclaration with a strict directive prologue)\t\n15.3.5.4_2-31gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression defined within a FunctionDeclaration with a strict directive prologue)\t\n15.3.5.4_2-32gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression defined within a FunctionDeclaration with a strict directive prologue)\t\n15.3.5.4_2-33gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration defined within a FunctionExpression with a strict directive prologue)\t\n15.3.5.4_2-34gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression defined within a FunctionExpression with a strict directive prologue)\t\n15.3.5.4_2-35gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression defined within a FunctionExpression with a strict directive prologue)\t\n15.3.5.4_2-36gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration defined within an Anonymous FunctionExpression with a strict directive prologue)\t\n15.3.5.4_2-37gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression defined within an Anonymous FunctionExpression with a strict directive prologue)\t\n15.3.5.4_2-38gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression defined within an Anonymous FunctionExpression with a strict directive prologue)\t\n15.3.5.4_2-39gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration with a strict directive prologue defined within a FunctionDeclaration)\t\n15.3.5.4_2-40gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression with a strict directive prologue defined within a FunctionDeclaration)\t\n15.3.5.4_2-41gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression with a strict directive prologue defined within a FunctionDeclaration)\t\n15.3.5.4_2-42gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration with a strict directive prologue defined within a FunctionExpression)\t\n15.3.5.4_2-43gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression with a strict directive prologue defined within a FunctionExpression)\t\n15.3.5.4_2-44gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression with a strict directive prologue defined within a FunctionExpression)\t\n15.3.5.4_2-45gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionDeclaration with a strict directive prologue defined within an Anonymous FunctionExpression)\t\n15.3.5.4_2-46gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression with a strict directive prologue defined within an Anonymous FunctionExpression)\t\n15.3.5.4_2-47gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression with a strict directive prologue defined within an Anonymous FunctionExpression)\t\n15.3.5.4_2-4gs\tStrict mode - checking access to strict function caller from non-strict function (FunctionExpression includes strict directive prologue)\t\n15.3.5.4_2-53gs\tStrict mode - checking access to strict function caller from non-strict function (Injected getter includes strict directive prologue)\t\n15.3.5.4_2-55gs\tStrict mode - checking access to strict function caller from non-strict function (Injected setter includes strict directive prologue)\t\n15.3.5.4_2-56gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by non-strict function declaration)\t\n15.3.5.4_2-57gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by non-strict eval)\t\n15.3.5.4_2-58gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by non-strict Function constructor)\t\n15.3.5.4_2-59gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by non-strict new'ed Function constructor)\t\n15.3.5.4_2-60gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.apply())\t\n15.3.5.4_2-61gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.apply(null))\t\n15.3.5.4_2-62gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.apply(undefined))\t\n15.3.5.4_2-63gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.apply(someObject))\t\n15.3.5.4_2-64gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.apply(globalObject))\t\n15.3.5.4_2-65gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.call())\t\n15.3.5.4_2-66gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.call(null))\t\n15.3.5.4_2-67gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.call(undefined))\t\n15.3.5.4_2-68gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.call(someObject))\t\n15.3.5.4_2-69gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.call(globalObject))\t\n15.3.5.4_2-6gs\tStrict mode - checking access to strict function caller from non-strict function (Anonymous FunctionExpression includes strict directive prologue)\t\n15.3.5.4_2-8gs\tStrict mode - checking access to strict function caller from non-strict function (Function constructor includes strict directive prologue)\t\n15.3.5.4_2-94gs\tStrict mode - checking access to strict function caller from non-strict function expression (FunctionDeclaration includes strict directive prologue)\t\n15.3.5.4_2-95gs\tStrict mode - checking access to strict function caller from non-strict, constructor-based function (FunctionDeclaration includes strict directive prologue)\t\n15.3.5.4_2-96gs\tStrict mode - checking access to strict function caller from non-strict property (FunctionDeclaration includes strict directive prologue)\t\n//--Maybe's\n15.3.5.4_2-49gs\tStrict mode - checking access to strict function caller from non-strict function (Literal getter includes strict directive prologue)\t\n15.3.5.4_2-51gs\tStrict mode - checking access to strict function caller from non-strict function (Literal setter includes strict directive prologue)\t\n15.3.5.4_2-89gs\tStrict mode - checking access to strict function caller from non-strict function (non-strict function declaration called by strict Function.prototype.bind()())\t\n15.3.5.4_2-70gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.bind()())\t\n15.3.5.4_2-71gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.bind(null)())\t\n15.3.5.4_2-72gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.bind(undefined)())\t\n15.3.5.4_2-73gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.bind(someObject)())\t\n15.3.5.4_2-74gs\tStrict mode - checking access to strict function caller from non-strict function (strict function declaration called by Function.prototype.bind(globalObject)())\t\n15.3.5.4_2-90gs\tStrict mode - checking access to strict function caller from non-strict function (non-strict function declaration called by strict Function.prototype.bind(null)())\t\n15.3.5.4_2-91gs\tStrict mode - checking access to strict function caller from non-strict function (non-strict function declaration called by strict Function.prototype.bind(undefined)())\t\n15.3.5.4_2-92gs\tStrict mode - checking access to strict function caller from non-strict function (non-strict function declaration called by strict Function.prototype.bind(someObject)())\t\n15.3.5.4_2-93gs\tStrict mode - checking access to strict function caller from non-strict function (non-strict function declaration called by strict Function.prototype.bind(globalObject)())\t\n15.3.5.4_2-97gs\tStrict mode - checking access to strict function caller from bound non-strict function (FunctionDeclaration includes strict directive prologue)"},{"commentid":747,"comment_count":8,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-03-11 11:38:44 -0700","thetext":"15.3.5.4_2-96gs and 15.3.5.4_2-97gs need to be fixed as well"},{"commentid":761,"comment_count":9,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2012-03-14 15:45:34 -0700","thetext":"Good spot on 5.3.5.4_2-9(6|7)gs.js.  These had eluded my RegExp Fu.\n\nAndré, do you happen to know what was the final call on this category of tests from TC39?  Standard, best practice, or invalid?  Thanks!"},{"commentid":763,"comment_count":10,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-03-15 04:21:13 -0700","thetext":"On es5-discuss, everybody agreed that 15.3.5.4 itself is buggy since it redefines [[Get]] instead of [[GetOwnProperty]] and does not account for implementations without \"caller\" support (at least not in a reasonable way). But strictly speaking, no final decision was made concerning test262, mainly because the discussion was later focused on how to implement \"caller\"."},{"commentid":764,"comment_count":11,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2012-03-15 08:57:54 -0700","thetext":"Thanks for the update André.  At this point I've verified all files still containing \".caller;\" (i.e., \"return gNonStrict.caller;\") under ch15/15.3/15.3.5/15.3.5.4 fall into one of the following categories:\n* they're subject to global strict mode and a TypeError is expected\n* they're not subject to global strict mode and no TypeError is expected\n\nReassigning this as an ECMA-262 bug to get clear guidance whether any other test changes are still required due to the ES5.1 bugs."},{"commentid":11035,"comment_count":12,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-12-13 22:25:41 -0800","thetext":"See https://bugs.ecmascript.org/show_bug.cgi?id=3113"},{"commentid":14737,"comment_count":13,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-10-02 14:33:05 -0700","thetext":"Bulk resolving ES5.1 errata issues as a sampling suggests these are all fixed. If this is in error, please open a new issue on GitHub."}]}}
---
