---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1549,"creation_ts":"2013-06-06 06:03:00 -0700","short_desc":"9.3.3: Remove step 3 from CreateOwnDataProperty","delta_ts":"2013-07-15 17:03:19 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 15: May 14, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"tomvc.be","long_desc":[{"commentid":4145,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-06-06 06:03:47 -0700","thetext":"Remove this step from 9.3.3  CreateOwnDataProperty (O, P, V):\n\n3.  Assert: O does not have an own property whose key is P\n\n\nTest case which triggers the assertion:\n\njs> Reflect.set({}, \"foo\", 0, {foo: 0})\nException in thread \"main\" java.lang.AssertionError\n        at com.github.anba.es6draft.runtime.AbstractOperations.CreateOwnDataProperty(AbstractOperations.java:516)\n        at com.github.anba.es6draft.runtime.types.builtins.OrdinaryObject.set(OrdinaryObject.java:470)\n        at com.github.anba.es6draft.runtime.types.builtins.OrdinaryObject.set(OrdinaryObject.java:465)\n        at com.github.anba.es6draft.runtime.objects.reflect.Reflect$ReflectedFunctions.set(Reflect.java:183)\n\n\nThe stack trace corresponds to the following methods:\n15.17.1.9  Reflect.set (target, propertyKey, V, receiver=target), step 6\n-> 8.3.10  [[Set]] (P, V, Receiver), step 4.c.i\n--> 8.3.10  [[Set]] (P, V, Receiver), step 4.d.ii\n---> 9.3.3  CreateOwnDataProperty (O, P, V), step 3"},{"commentid":4247,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-06-18 11:17:43 -0700","thetext":"Interesting misuse of Reflect.set\n\nInstead of eliminating the assertion (which really is intended to be the case, it caught this issue....) I restructured ordinary [[Put]] so that step 4.d.i sets ownDesc to the default data property descriptor.  It then falls into step 5.\n\nThis way the same semantics apply to setting a receiver data property, regardless of whether or not it physically inherits from O (passing an object as the receiver means that it logically inherits from O).\n\nfixed in rev 16 editor's draft."},{"commentid":4269,"comment_count":2,"who":{"uid":"tomvc.be","name":"Tom Van Cutsem"},"bug_when":"2013-06-19 23:58:23 -0700","thetext":"I think you meant step 4.d.i. in \"ordinary [[Set]]\" rather than \"ordinary [[Put]]\".\n\nI like this change: it removes some redundancy in the [[Set]] algorithm.\n\nIIUC, the code snippet above would now be accepted. And if the property already exists on the receiver, it will now be *updated* rather than *overridden* with a new data property.\n\nIIUC, the following tests should now pass (please correct me if I'm wrong):\n\nvar target = {};\nvar receiver = {};\n\nReflect.set(target, \"foo\", 1, receiver);\nassert(target.foo === undefined);\nassert(receiver.foo === 1); // new property added to receiver\n\nObject.defineProperty(receiver, \"bar\",\n  { value: 0,\n    writable: true,\n    enumerable: false,\n    configurable: true });\n\nReflect.set(target, \"bar\", 1, receiver);\n\nassert(receiver.bar === 1); // value of existing receiver property updated\nassert(Object.getOwnPropertyDescriptor(receiver,\"bar\").enumerable === false); // enumerability was not overridden"},{"commentid":4270,"comment_count":3,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-06-20 02:25:51 -0700","thetext":"The test in comment 2 as well as the original test case both succeed the proposed update. Also no regressions from test262."},{"commentid":4398,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-07-15 17:03:19 -0700","thetext":"fixed in rev16 draft.  July 15, 2013"}]}}
---
