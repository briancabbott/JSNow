---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":513,"creation_ts":"2012-07-12 10:41:00 -0700","short_desc":"15.1.2.1: Clarify Unicode processing in eval","delta_ts":"2014-12-01 20:36:11 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 9: July 8, 2012 Draft","rep_platform":"All","op_sys":"All","bug_status":"VERIFIED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"ecmascriptbugs","name":"Norbert"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":1289,"comment_count":0,"who":{"uid":"ecmascriptbugs","name":"Norbert"},"bug_when":"2012-07-12 10:41:21 -0700","thetext":"The specification of eval() needs to clarify how x is converted to the Unicode code points expected in parsing. In particular, it needs to clarify that unpaired surrogates are converted to their corresponding surrogate code points and are not treated as errors or converted to a fallback character. An inverse function to the UTF-16 Encoding function in clause 6 would be the best solution."},{"commentid":1296,"comment_count":1,"who":{"uid":"ecmascriptbugs","name":"Norbert"},"bug_when":"2012-07-12 11:58:36 -0700","thetext":"Actually, I provided just such an inverse function, and it found a home in section 8.4 :-)"},{"commentid":1567,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-08-30 16:16:50 -0700","thetext":"corrected in editor's draft"},{"commentid":1702,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-09-28 12:24:18 -0700","thetext":"fixed in rev10, Sept. 27 2012 draft"},{"commentid":9624,"comment_count":4,"who":{"uid":"ecmascriptbugs","name":"Norbert"},"bug_when":"2014-07-27 19:43:25 -0700","thetext":"Checked in rev 26 draft: There's now a cross-reference to section 10.1.1, but that's not the right section to reference - it describes the mapping from a code point to UTF-16, while we need the mapping from a sequence of UTF-16 code units to a sequence of code points. The algorithm that needs to be referenced here is the one at the end of section 6.1.1.\n\n(This bug was actually correctly fixed in rev 10, but somewhere in between the reference got changed to the wrong section)."},{"commentid":9722,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-07 15:34:14 -0700","thetext":"fixed in rev27 editor's draft"},{"commentid":9930,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-25 08:29:27 -0700","thetext":"fixed in rev27 draft"},{"commentid":10696,"comment_count":7,"who":{"uid":"ecmascriptbugs","name":"Norbert"},"bug_when":"2014-12-01 20:36:11 -0800","thetext":"Verified in rev 28 draft."}]}}
---
