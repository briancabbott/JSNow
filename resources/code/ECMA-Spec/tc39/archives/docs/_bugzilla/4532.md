---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4532,"creation_ts":"2015-08-26 15:33:00 -0700","short_desc":"Assignment of global variables deleted by their RHS in strict mode is permitted","delta_ts":"2015-08-26 15:41:38 -0700","product":"ECMA-262 Edition 6","component":"technical issues","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"CONFIRMED","priority":"Normal","bug_severity":"major","everconfirmed":true,"reporter":{"uid":"bakkot","name":"Kevin Gibbons"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["bakkot","bugs.ecmascript","erights"],"long_desc":[{"commentid":14693,"comment_count":0,"who":{"uid":"bakkot","name":"Kevin Gibbons"},"bug_when":"2015-08-26 15:33:36 -0700","thetext":"See https://esdiscuss.org/topic/assignment-of-global-variables-deleted-by-their-rhs-in-strict-mode.\n\nIn short, it is possible to have a Reference to a global variable which has been deleted. Normally, bare assignments to undeclared variables in strict mode cause ReferenceErrors. However, calling PutValue on a reference to a global variable which has been deleted since the reference was created does not throw a ReferenceError in strict mode, even though, at the time of writing, that variable does not exist.\n\nThis circumvents a protection which strict mode is intended to provide."}]}}
---
