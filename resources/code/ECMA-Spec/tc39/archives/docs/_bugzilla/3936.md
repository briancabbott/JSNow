---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3936,"creation_ts":"2015-02-14 13:51:00 -0800","short_desc":"B.3.3: applying the extensions","delta_ts":"2015-02-19 19:10:49 -0800","product":"Draft for 6th Edition","component":"editorial issue","version":"Rev 33: February 12, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"jmdyck","name":"Michael Dyck"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":12680,"comment_count":0,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2015-02-14 13:51:04 -0800","thetext":"[Same neighbourhood as Bug 3918, but different.]\n\nIn B.3.3 \"Block-Level Function Declarations Web Legacy Compatibility Semantics\",\nwe're given an algorithm that modifies/replaces algorithms elsewhere in the spec (9.2.13 and 14.1.23). That alone would be odd, but what's even odder is that these changes aren't 'universal', i.e. the changes only affect *some* applications of the changed algorithms. So now we have to imagine that for each affected algorithm, there are actually two versions, with the choice of which to use for any given application being made somewhat magically.\n\nI think a far more straightforward approach would be to take the steps 2.a.* and 2.b.* out of the B.3.3 algorithm, and insert them at the corresponding points in 9.2.13 and 14.1.23 respectively, but embed them in an 'If' that only invokes them when appropriate. The condition would be something along the lines of:\n    the ECMAScript host implements the annex B.3.3 extension\n    and\n    we're dealing with a FunctionDeclaration that's affected by that extension\n\nIt would probably make sense to define an abstract operation that ascertains whether a FunctionDeclaration is affected by the B.3.3 extension. It would use the remains of the B.3.3 algorithm, and also some of its preamble, something like:\n    1. Assert: /f/ is a /FunctionDeclaration/.\n    2. If /f/ is directly contained in the /StatementList/ of a /Block/,\n       /CaseClause/, or /DefaultClause/ that is part of the function code\n       of non-strict mode function /g/, then\n       a. Let F be StringValue of the BindingIdentifier of /f/.\n       b. If replacing /f/ with a /VariableStatement/ [etc], then return true.\n    3. Return false"},{"commentid":12925,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-18 14:01:32 -0800","thetext":"I really don't want to embed annex B semantics into the main body of the specification.  Instead I placed marker place holder step in 89.2.13 and a note in 14.1.21 reference B.3.3\n\nfixed in rev34 editor's draft"},{"commentid":12935,"comment_count":2,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2015-02-18 15:11:47 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #1)\n> I really don't want to embed annex B semantics into the main body of the\n> specification.\n\nYeah, I can understand that.\n\nOkay, how about something in-between: the annex B semantics stay in annex B, but you still get rid of the weirdness of an algorithm that makes variants of other algorithms. Specifically, B.3.3 could say (something like):\n\n  Step 29 of the algorithm in 9.2.13 is replaced with the following step:\n\n     29. If $code is the FunctionBody of a FunctionDeclaration f,\n         and f is affected by B.3.3, then:\n           i.   Let F be StringValue of the BindingIdentifier of f.\n           ii.  NOTE A var binding for F ...\n           iii. If instantiated VarNames does not contain F, ...\n\n  The FunctionDeclaration Evaluation algorithm in 14.1.23 is replaced with:\n\n    1. If this FunctionDeclaration is affected by B.3.3, then:\n         a. Let F be StringValue of the BindingIdentifier of this FunctionDecl\n         b. Let fenv be ...\n         c. Let benv be ...\n         d. [etc]\n    2. Else, return NormalCompletion(empty)\n\nwhere \"is affected by B.3.3\" could be a suitably-named abstract operation that you also define in B.3.3."},{"commentid":12988,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-19 19:10:49 -0800","thetext":"fixed in rev34"}]}}
---
