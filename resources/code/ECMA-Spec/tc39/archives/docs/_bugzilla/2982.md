---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2982,"creation_ts":"2014-06-10 08:27:00 -0700","short_desc":"Ch.12, cumulative bugs & suggestions","delta_ts":"2015-02-15 16:07:50 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 23: April 5, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","see_also":"https://bugs.ecmascript.org/show_bug.cgi?id=3148","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"rossberg","name":"Andreas Rossberg"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":8873,"comment_count":0,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-06-10 08:27:35 -0700","thetext":"Ch.12, cumulative bugs & suggestions\n\n[Note: this is against Rev. 23, some things might have been fixed or changed already.]\n\n\nTECHNICAL ISSUES\n\n12.2.2.1: the actual algorithm seems to be gone amiss\n\n12.2.5.3: there seem to be several cases missing for this algorithm\n12.2.5.9, 1st case: call to DefineProperty seems bogus in step 6, already happened at this point\n12.2.5.9, 3rd case: shouldn't setting [[MethodName]] be skipped if propKey is a symbol?\n\n12.3.1.1: there seem to be some cases missing for MemberExpression and CallExpression\n12.3.3.1: this doesn't handle tail calls, which it should. Why not simply say that \"new NewExpression\" is evaluated as \"new NewExpression()\"?\n12.3.4.1, 1st case, step 2.a: \"check if direct eval\" -- is this a todo?\n\n12.5.4.1, 2nd bullet: this formulation doesn't really make sense to me; whatever phrase you can derive via CoverParenthesizedEAAPL will always have outermost parentheses, so the previous rule would never apply to it.\n\n12.5.6.1, step 2.b: wrong level, this should be step 3\n\n12.14.1, 1st case, 1st bullet: this seems to disallow parentheses around LHS array or object patterns, which seem unfortunate. Is that intentional?\n12.14.1, 1st case 3rd bullet: \"can be statically determined\" is far too vague here. Consider \"const x = 0; with ({__proto__: null}) x = 1;\" -- it is possible (and in this case even fairly easy) to statically determine the condition. Or \"const x = 0; { eval(\"\"); x = 1}\". But those are clearly not cases that you want to require an error for. The spec needs to be more specific, probably by explicitly ruling out cases with intervening object environments, or scopes with sloppy eval.\n12.14.1, 2nd case 1st bullet: dito\n12.14.5.1, 3rd case, 3rd bullet: dito\n12.14.5.2, 'AssignmentProperty: IdentifierReference Initializer_opt' case, step 4.b: the call to ToObject seems bogus here\n12.14.5.3, AssignmentElement case: steps 1-6 as well as 8 need to be substeps of 1.\n12.14.5.3, AssignmentRestElement case: this algorithm is not sufficiently recursive; it needs to allow the case where DestructuringAssignmentTarget is itself an object or array literal\n..., step 5.d: this should be step 5.c.i\n12.14.5.4, step 1: \"name\" -> \"propertyName\"\n\n\nSUGGESTIONS\n\n12.1.1, Identifier :: IdentifierName but not ...: why not combine the first two bullets?\n\n12.2.3: Literal/ValueLiteral nonterminal distinction seems redundant, drop?\n12.2.3.1: Perhaps rename CheckObjectCoercible -- the current name suggests a predicate or check that should return either Bool or nothing.\n\n12.2.4.1.2, case for SpreadElement: ...AssignmentExpression, step 4: seems redundant (subsumed by step 5)\n12.2.4.1.3, 1st production: perhaps assert that the Put in step 3 can't fail?\n12.2.4.1.3, 2nd production: likewise step 4 here\n12.2.4.1.3, 3rd production: and step 5 here\n12.2.4.2.2: it would seem more modular and extensible to fold the type-check into BindingInitialization itself\n12.2.4.2.4: fold steps 3-4 into GetIterator?\n\n12.3.4.2: perhaps fold type check in step 5 into the IsCallable predicate?\n12.3.5.2, 2nd case: for consistency with ordinary property access, why not describe the 2nd case via desugaring into the first?\n12.3.6.1, 3rd case: perhaps fold type check in step 5 into GetIterator?\n12.3.6.1, 4th case, step 6: this seems like a very convoluted way of saying \"append arg to list and return the result\" :)\n\n12.9.4: perhaps fold type check in step 1 into GetMethod?\n\n\nTYPOS & FORMATTING\n\n12.1.1, IdentifierReference: Identifier, bullet: formatting after \"Identifier\"\n12.1.2: \"This is the case for var statements [+and] formal parameters\"\n12.1.3, first rule: \"IdentifierName\" -> \"Identifier\"\n12.1.4: formatting of \"StringValue\"\n12.2.0: weird section numbering?\n12.2.2: \"See 12.1 for ...\" - wrong xref?\n12.2.5.1, 1st bullet: formatting of PropertyNameList\n12.2.5.6: formatting of \"PropName\"\n12.2.7.2, Note: \"In that case [-use] other ... means must be used\"\n12.3.2, 1st grammar: formatting"},{"commentid":9740,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-09 09:16:37 -0700","thetext":"12.2.5.3, 12.3.1.1: only cases where the default algorithm in 5.3 doesn't apply, need explicit algorithms.  Are there specific productions that you think need to this?\n\n12.2.5.9 #2: no [[MethodName]] can be a symbol. \n\n12.3.4.1: yes"},{"commentid":9855,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-24 10:17:06 -0700","thetext":"Bug 3148 created for  \"can be statically determined\" items"},{"commentid":9858,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-24 11:26:13 -0700","thetext":"Re: suggestion 12.9.4.  For retty much every other use of GetMethod we already know that the first argument is an object."},{"commentid":12746,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-15 16:07:50 -0800","thetext":"I think everything here has been addressed in rev26 or rev27 or are otherwise stale."}]}}
---
