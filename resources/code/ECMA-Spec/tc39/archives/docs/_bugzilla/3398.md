---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3398,"creation_ts":"2014-12-02 07:45:00 -0800","short_desc":"Native implementation of reduceRight in JavaScript is wrong","delta_ts":"2015-10-04 08:59:34 -0700","product":"ECMA-262, Editions 5 and 5.1","component":"technical content","version":"Edition 5","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","bug_file_loc":"http://stackoverflow.com/q/27252657/783743","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"aaditmshah","name":"Aadit M Shah"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"brterlso","long_desc":[{"commentid":10703,"comment_count":0,"who":{"uid":"aaditmshah","name":"Aadit M Shah"},"bug_when":"2014-12-02 07:45:25 -0800","thetext":"For an associative operation `f` over the elements of an array `a`, the following relation should hold true: `a.reduce(f)` should be equivalent to `a.reduceRight(f)`.\n\nIndeed, it does hold true for operations that are both associative and commutative. For example:\n\n    var a = [1,2,3,4,5,6,7,8,9,0];\n\n    alert(a.reduce(add) === a.reduceRight(add));\n\n    function add(a, b) {\n        return a + b;\n    }\n\nHowever it doesn't hold true for operations that are associative but not commutative. For example:\n\n    var a = [[1,2],[3,4],[5,6],[7,8],[9,0]];\n\n    alert(equals(a.reduce(concat), a.reduceRight(concat)));\n\n    function concat(a, b) {\n        return a.concat(b);\n    }\n\n    function equals(a, b) {\n        var length = a.length;\n        if (b.length !== length) return false;\n        for (var i = 0; i < length; i++)\n            if (a[i] !== b[i]) return false;\n        return true;\n    }\n\nWe need to flip the arguments of `f` for `reduceRight` to make them equivalent:\n\n    var a = [[1,2],[3,4],[5,6],[7,8],[9,0]];\n\n    alert(equals(a.reduce(concat), a.reduceRight(concatRight)));\n\n    function concat(a, b) {\n        return a.concat(b);\n    }\n\n    function concatRight(b, a) {\n        return a.concat(b);\n    }\n\n    function equals(a, b) {\n        var length = a.length;\n        if (b.length !== length) return false;\n        for (var i = 0; i < length; i++)\n            if (a[i] !== b[i]) return false;\n        return true;\n    }\n\nThis makes me believe that the native implementation of `reduceRight` is wrong.\n\nI believe that the `reduceRight` function should be implemented as follows:\n\n    var REDUCE_ERROR = \"Reduce of empty array with no initial value\";\n\n    Array.prototype.reduceRight = function (f, acc) {\n        var a = this, length = a.length;\n\n        if (arguments.length < 2) {\n            if (length !== 0) var right = a[--length];\n            else throw new TypeError(REDUCE_ERROR);\n        } else var right = acc;\n\n        while (length !== 0) right = f(a[--length], right, length, a);\n\n        return right;\n    };\n\nSince `right` represents the previous value (right-hand side value), it makes sense to make it the second parameter of the function `f`. The current value represent the left-hand side value. Hence, it makes sense to make the current value the first parameter of the function `f`. This way, even for non-commutative associative operations, the aforementioned relation holds true.\n\nMy suggestions are:\n\n1. Either fix this in ECMAScript Harmony (not backwards compatible and will in all probability break existing code).\n2. Or provide a separate native operation which does the right thing. You could call it `reduceR` (shorter and sweeter).\n\nLinked StackOverflow question: http://stackoverflow.com/q/27252657/783743"},{"commentid":14773,"comment_count":1,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-10-04 08:59:34 -0700","thetext":"We can't break reduceRight. To propose a new API, see https://github.com/tc39/ecma262/blob/master/CONTRIBUTING.md."}]}}
---
