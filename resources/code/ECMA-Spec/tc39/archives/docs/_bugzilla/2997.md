---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2997,"creation_ts":"2014-06-25 15:40:00 -0700","short_desc":"Destructuring assignment can call .next() on a spent iterator","delta_ts":"2015-01-18 13:23:47 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 25: May 22, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"jorendorff","name":"Jason Orendorff"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"jmdyck","long_desc":[{"commentid":9099,"comment_count":0,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-06-25 15:40:19 -0700","thetext":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-iteratordestructuringassignmentevaluation\n\nIs this intentional? IteratorDestructuringAssignmentEvaluation of the production\n\n> AssignmentElement : DestructuringAssignmentTarget Initializer_opt\n\ncalls IteratorStep unconditionally. This means that if an ArrayAssignmentPattern contains multiple such AssignmentElements, and iterator.next() returns {done:true} when called for the first element, it will be called again for the other elements anyway."},{"commentid":9102,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-06-25 19:16:35 -0700","thetext":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface  requires that a valid Iterator implementation must continue to return {done: true} on subsequent calls to next. \n\nOf course there is not guarantee that an user provided supposed iterator will behave that way, but nothing else we assume is guaranteed either. There may not even be a next method or it might disappear after a few iterations.  Regardless, the behavior of a destructuring assignment is fully specified (relative to the behavior of the iterator object), even for cases where the supposed iterator is poorly behaved.\n\n(Also, note that iterator.next() is also called unconditionally at least once for an AssignmentRegElement.)\n\nI could add extra logic to the spec. to keep track of whether the iterator that is being used has ready reported done: true and not make the iterator.next() calls in that case. But I'm not sure that it would be any better if we did that.   It would add complexity to the spec. and probably to implementations but it still wouldn't guarantee that the iterator won't misbehave in other ways.\n\nGiven all the ways that destructing can fail to complete normally, trying to do something about this one form of failure doesn't seem necessary.\n\nBut, if you have a stronger argument for explicitly tracking done, I'd be happy to consider it."},{"commentid":9104,"comment_count":2,"who":{"uid":"jmdyck","name":"Michael Dyck"},"bug_when":"2014-06-26 00:57:37 -0700","thetext":"[Changing this bug's 'Version' from rev23 to rev25, as it seems just as relevant to rev25, and there's not much point raising it against an old version.]"},{"commentid":11545,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-18 13:23:47 -0800","thetext":"I looked at this again today and changing the spec. the destructuring spec. to stop calling spent iterators would still require significant spec. changes and I still don't seen any actual problems it creates.\n\nI'm resolving it as won't fix."}]}}
---
