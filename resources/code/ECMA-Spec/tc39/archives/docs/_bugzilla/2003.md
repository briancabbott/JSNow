---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2003,"creation_ts":"2013-09-30 06:00:00 -0700","short_desc":"23.1.5.2.2 Flatten map and set \"next\" iterator method specifications","delta_ts":"2013-10-29 09:46:00 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 19: September 27, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"wingo","name":"Andy Wingo"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"jorendorff","long_desc":[{"commentid":5678,"comment_count":0,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2013-09-30 06:00:09 -0700","thetext":"Currently the Set and Map iterator next methods are specified using \"loop\" language, but they are not generators: they are prototype methods.  It would be much more clear if they were written as the ArrayIterator specification is.\n\nCurrently they are missing a bit that when they are finished, to set the nextIndex to +Infinity in order to prevent the iterators from coming back to life."},{"commentid":5679,"comment_count":1,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2013-09-30 07:32:33 -0700","thetext":"So there are two issues here.  Regarding the loop, I misinterpreted the language to imply that the loop was a generator loop and not just a normal part of a method specification.  The spec is not ambiguous there, though it could be clearer.\n\nFor the second, that iterators can come back to life -- I thought the spec was an unintentional thing.  If that is not the case, two points:\n\n * Calling next on an iterator that is already at the last insertion position should not advance the insertion position.  This way you can:\n\n  var o = Map();\n  var i = o[@@iterator]();\n  i.next() // { value: undefined, done: true }\n  o.put('foo', 'bar');\n  i.next() // { value: 'foo', done: false }\n  i.next() // { value: undefined, done: true }\n\n * The behavior of the map iterator should be consistent with the array iterator.  If the map iterator can come back to life, then the same with the array iterator.\n\nI tend to think that iterators should stay done once they are done for the first time, but YMMV."},{"commentid":5680,"comment_count":2,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2013-09-30 07:36:51 -0700","thetext":"(In reply to comment #1)\n>  * The behavior of the map iterator should be consistent with the array\n> iterator.  If the map iterator can come back to life, then the same with the\n> array iterator.\n\nThis point is very compelling. They should be consistent.\n\nPermanently closing the iterator seems best."},{"commentid":5733,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-09-30 15:57:55 -0700","thetext":"It's unintentional that they can come back to life.  I'll change that.\n\nThe loop is simply an incidental artifact of the specification's linear data structure and is needed to skip over deleted elements. Most of the Map/set algorithms have some sort of loop, like this."},{"commentid":5737,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-09-30 17:48:25 -0700","thetext":"fixed in rev20 editor's draft"},{"commentid":6119,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-10-29 09:46:00 -0700","thetext":"fixed in rev20 draft, Oct. 28, 2013"}]}}
---
