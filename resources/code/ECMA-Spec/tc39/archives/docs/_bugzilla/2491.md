---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2491,"creation_ts":"2014-02-02 12:47:00 -0800","short_desc":"Changes to default constructor breaks \"existing\" code","delta_ts":"2015-07-10 08:35:05 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 21: November 8, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"arv","name":"Erik Arvidsson"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["claude.pache","erik.arvidsson"],"long_desc":[{"commentid":7169,"comment_count":0,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-02-02 12:47:38 -0800","thetext":"The change to add a return to the default constructor broke some tests we have.\n\nBefore\n\nconstruct(..args) {\n  super(...args);\n}\n\nNow\n\nconstruct(..args) {\n  return super(...args);\n}\n\nThe problem arises when we extend an old school \"class\" where the code does not explicitly set constructor.\n\nfunction B() {}\nB.prototype = { ... }\nclass C extends B {}\nnew C() instanceof C  // false\n\nThe reason why this fails is that `B.prototype.constructor === Object` so `new C()` returns `Object()`.\n\nThe work around is to set `B.prototype.constructor = B` but I feel like the problem, adding return added solved, is smaller than the problem it introduces."},{"commentid":7281,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-02-12 16:58:15 -0800","thetext":"fixed in rev23 editor's draft\n\nreverted back to the \"before\" definition"},{"commentid":7579,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-06 11:30:56 -0700","thetext":"fixed in rev23 draft"}]}}
---
