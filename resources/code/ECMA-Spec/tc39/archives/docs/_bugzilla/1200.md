---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1200,"creation_ts":"2013-01-17 14:16:00 -0800","short_desc":"8.4.2.4: ArraySetLength algorithm can produce broken arrays","delta_ts":"2013-03-08 14:44:22 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 13: December 21, 2012 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","blocked":1262,"everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":3128,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2013-01-17 14:16:09 -0800","thetext":"The ArraySetLength algorithm can produce arrays which no longer respect the array invariant described in [8.4.2]. \n\ntest case sketch (most likely only reproducible if you use a custom ES5/6 implementation):\n---\nfunction defLen(arr, len, f) {\n  Object.defineProperty(arr, \"length\", {value: {valueOf: function(){ f && f(); return len }}});\n}\n\na = [];\ndefLen(a, 1, function() {defLen(a, 10); a[5]='test'});\n---\n\n\nArraySetLength retrieves and stores the current 'length' PropertyDescriptor in steps 1-2. When ToUint32() is called in step 5, user defined code can be executed (e.g. a custom 'valueOf' function, see above). This user code may change the array's length again and thereby invalidate the previously stored `oldLen` value. And as a result, both ArraySetLength invocations assume `newLen >= oldLen` (step 8) and no array trimming will be applied. \n\na = [];\na.[[DefineOwnProperty]](\"length\", {[[Value: 1 (user code)]]})\n -> ArraySetLength(A = a, Desc = {[[Value: 1 (user code)]]})\n   -> oldLen = 0\n   -> newLen = ToUint32(Desc.[[Value]]) = 1\n     /* start user code as a side-effect of ToUint32() */\n     -> a.[[DefineOwnProperty]](\"length\", {[[Value: 10]]})\n       -> ArraySetLength(A = a, Desc = {[[Value: 10]]})\n         -> oldLen = 0\n         -> newLen = ToUint32(Desc.[[Value]]) = 10\n         -> newLen(10) >= oldLen(0) => OrdinaryDefineOwnProperty(A, \"length\", newLenDesc = {[[Value: 10]]})\n         -> return\n     -> a.[[SetP]](\"5\", 'test', a)\n     /* end user code as a side-effect of ToUint32() */\n   -> newLen(1) >= oldLen(0) => OrdinaryDefineOwnProperty(A, \"length\", newLenDesc = {[[Value: 1]]})\n\nNow `a`'s \"length\" property will be `1`, but the property at index 5 wasn't removed. \n\n\nThis bug is also present in the ES5.1 specification."},{"commentid":3293,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-03-06 13:48:27 -0800","thetext":"Really good catch! Please find more like this..,\n\nFixed in rev 14 editor's draft"},{"commentid":3356,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-03-08 14:44:22 -0800","thetext":"in Rev 14 draft"}]}}
---
