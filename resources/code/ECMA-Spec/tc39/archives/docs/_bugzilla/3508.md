---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3508,"creation_ts":"2015-01-03 05:46:00 -0800","short_desc":"6.1.6 The Number Type: Paragraph about NaN value detection requires updates","delta_ts":"2015-05-29 06:19:10 -0700","product":"Draft for 7th Edition","component":"Deferred from 6th edition","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"CONFIRMED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"dehrenberg","long_desc":[{"commentid":11301,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-03 05:46:48 -0800","thetext":"6.1.6  The Number Type\n\n> In some implementations, external code might be able to detect a\n> difference between various Not-a-Number values, but such behaviour \n> is implementation-dependent; to ECMAScript code, all NaN values are \n> indistinguishable from each other.\n\nThe last part is no longer true, ECMAScript user code is now able to distinguish between different NaN values, because Float{32,64}Arrays do not canonicalize NaN values on write operations.\n\n\nUnfortunate side-effect of the new ability to distinguish between different NaN values: The MOP level changes from ES3 -> ES5 in [[Put]] are now visible to user code. \n\nES3, 8.6.2.2 [[Put]], step 4:\nThe value of an own, writable property is always updated. \n\nES5.1, 8.12.5 [[Put]], 3.b + 8.12.9 [[DefineOwnProperty]], step 6:\nThe value of an own, writable property is not updated if the value stays the same if compared with the SameValue algorithm.\n\nNote: Implementations [1,2] seem to follow ES3 [[Put]] semantics with NaN values, but I guess this is more a performance thing than an ES3 compatibility decision.\n\n[1] Tested with JavaScriptCore, V8, Nashorn, IE11 (Win10 9879), SpiderMonkey\n\n\nTest code:\n---\nfunction numberToRawBits(v) {\n  var isLittleEndian = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  var reduce = Array.prototype[isLittleEndian ? 'reduceRight' : 'reduce'];\n  var float64 = new Float64Array(1);\n  float64[0] = v;\n  var uint8 = new Uint8Array(float64.buffer);\n  return reduce.call(uint8, function(a, v) {\n    return (a * 256) + v;\n  }, 0);\n}\n\nvar o = {};\nObject.defineProperty(o, \"p\", {value: 0, writable: true, enumerable: true, configurable: true});\n\n// nan1 and nan2 are two different NaN values\no.p = nan1;\no.p = nan2;\n\nprint(\"nan1:\", numberToRawBits(nan1).toString(16));\nprint(\"nan2:\", numberToRawBits(nan2).toString(16));\nprint(\"o.p:\", numberToRawBits(o.p).toString(16)); // same as nan2 in ES3, same as nan1 in ES5/6\n---"},{"commentid":11302,"comment_count":1,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-03 06:14:23 -0800","thetext":"There's also a slightly inconsistent behaviour for own, writable property updates when you take a look at mapped arguments objects, because mapped properties are always updated in ES5/6."},{"commentid":11343,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-13 16:11:03 -0800","thetext":"(In reply to André Bargull from comment #0)\n> 6.1.6  The Number Type\n> \n> > In some implementations, external code might be able to detect a\n> > difference between various Not-a-Number values, but such behaviour \n> > is implementation-dependent; to ECMAScript code, all NaN values are \n> > indistinguishable from each other.\n> \n> The last part is no longer true, ECMAScript user code is now able to\n> distinguish between different NaN values, because Float{32,64}Arrays do not\n> canonicalize NaN values on write operations.\n\nBut, only by examining the bytes of  a binary ArrayBuffer.  I'm not sure that this is fundamentally different from using \"external code\" to write a Number to a file and then using byte level reads to examine what was written. Also, in ES6 the ArrayBuffer SetValueInBuffer operations state that the actual value stored for NaN values is implementation dependent, so what you see in the buffer doesn't imply anything about the NaN encoding of the original value that was stored.\n\n6.1.6 is really talking about the ECMAScript Number data type, and such values aren't directly stored in ArrayBuffers but instead are converted to IEEE binary64  values. Arguably, 6.1.6 doesn't even apply to such values in a buffer.\n\nFinally, I suspect what the original authors had in mind for the quoted sentence was Number values passed as arguments to native code procedures which could directly inspect the bit-level encoding of the arguments.  Nothing has changed in that regard in either ES5 or ES6.\n\nTo sum up, it's not clear to me that there is anything wrong in what 6.1.6 says or whether anything else really need to be stated.  But I added this note immediately following that paragraph:\n\n\"NOTE\tThe bit pattern that might be observed in an ArrayBuffer (see 24.1) after a Number value has been stored into it is not necessarily the same as the internal representation of that Number value used by the ECMAScript implementation. \"\n\n> \n> \n> Unfortunate side-effect of the new ability to distinguish between different\n> NaN values: The MOP level changes from ES3 -> ES5 in [[Put]] are now visible\n> to user code. \n> \n> ES3, 8.6.2.2 [[Put]], step 4:\n> The value of an own, writable property is always updated. \n> \n> ES5.1, 8.12.5 [[Put]], 3.b + 8.12.9 [[DefineOwnProperty]], step 6:\n> The value of an own, writable property is not updated if the value stays the\n> same if compared with the SameValue algorithm.\n\nIn ES6, [[Set]] has an over-riding definition for IntegerIndexed Exotic objects (ie, Typed Arrays) that doesn't do that SameValue check"},{"commentid":11353,"comment_count":3,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-14 09:16:34 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #2)\n> But, only by examining the bytes of  a binary ArrayBuffer.  I'm not sure\n> that this is fundamentally different from using \"external code\" to write a\n> Number to a file and then using byte level reads to examine what was\n> written. \n\nYes. \n\n\n> Also, in ES6 the ArrayBuffer SetValueInBuffer operations state that\n> the actual value stored for NaN values is implementation dependent, so what\n> you see in the buffer doesn't imply anything about the NaN encoding of the\n> original value that was stored.\n\nHmm, I hope the current spec for SetValueInBuffer won't create a loophole where a non-configurable + non-writable data property with a NaN value is allowed to change to a different NaN value (as observed by using ArrayBuffers like in the `numberToRawBits` function from above). That would be bad because it creates a communication channel, right? More below...\n\n\n> 6.1.6 is really talking about the ECMAScript Number data type, and such\n> values aren't directly stored in ArrayBuffers but instead are converted to\n> IEEE binary64  values. Arguably, 6.1.6 doesn't even apply to such values in\n> a buffer.\n\n6.1.6 in context of ECMAScript user code only means to express: Given any operation `op` when `op` is applied to two distinct NaN values `nan1` and `nan2`, the result will be the same. Basically `SameValue(op(nan1), op(nan2))` is true. (Well, except when `op` returns an Object value, but let's ignore that issue for the time being.)\n\n\n> Finally, I suspect what the original authors had in mind for the quoted\n> sentence was Number values passed as arguments to native code procedures\n> which could directly inspect the bit-level encoding of the arguments. \n> Nothing has changed in that regard in either ES5 or ES6.\n\nYes. \n\n\n> \n> To sum up, it's not clear to me that there is anything wrong in what 6.1.6\n> says or whether anything else really need to be stated.  But I added this\n> note immediately following that paragraph:\n> \n> \"NOTE\tThe bit pattern that might be observed in an ArrayBuffer (see 24.1)\n> after a Number value has been stored into it is not necessarily the same as\n> the internal representation of that Number value used by the ECMAScript\n> implementation. \"\n> \n\nOk.\n\n\n> > ES3, 8.6.2.2 [[Put]], step 4:\n> > The value of an own, writable property is always updated. \n> > \n> > ES5.1, 8.12.5 [[Put]], 3.b + 8.12.9 [[DefineOwnProperty]], step 6:\n> > The value of an own, writable property is not updated if the value stays the\n> > same if compared with the SameValue algorithm.\n> \n> In ES6, [[Set]] has an over-riding definition for IntegerIndexed Exotic\n> objects (ie, Typed Arrays) that doesn't do that SameValue check\n\nSo, should 9.1.6 [[DefineOwnProperty]] resp. ValidateAndApplyPropertyDescriptor be changed to omit the SameValue check for writable and/or configurable properties?\n\n\nEven if SetValueInBuffer is allowed to change a NaN value to a different (quiet) NaN value, this example should not assert:\n---\n// Let nan1 and nan2 be two different NaN values.\n\nvar o = {};\n\nObject.defineProperty(o, \"p\", {value: nan1});\nvar bitsNan1 = numberToRawBits(o.p).toString(16);\n\nObject.freeze(o);\n\nObject.defineProperty(o, \"p\", {value: nan2});\nvar bitsNan2 = numberToRawBits(o.p).toString(16);\n\nassertEq(bitsNan1, bitsNan2);\n---\n\nOtherwise an attacker is able to create a communication channel which seems unfortunate. (Also: An attacker probably knows how SetValueInBuffer is implemented in a given implementation and therefore knows how NaNs are handled.)\n\n\n\nLet's summarize this issue:\nWhen an own, writable property is updated in the ordinary [[Set]] internal method, [[Set]] calls the ordinary [[DefineOwnProperty]] method which in turn calls ValidateAndApplyPropertyDescriptor. The `Desc` parameter for ValidateAndApplyPropertyDescriptor in this case is `Desc = PropertyDescriptor{[[Value]]: V}`. Step 4 of ValidateAndApplyPropertyDescriptor will then perform a SameValue check on `Desc.Value` and if the SameValue check returns true, ValidateAndApplyPropertyDescriptor simply returns. \nIn implementations this SameValue check does not take place when ValidateAndApplyPropertyDescriptor is called from [[Set]]. It is performed when ValidateAndApplyPropertyDescriptor is called from [[DefineOwnProperty]], for example when `Object.defineProperty` is invoked. And users are able to observe this difference with the example code given in comment #0.\n\nIIUC implementations are allowed to skip the SameValue check for [[Set]] because SetValueInBuffer may use a different quiet NaN value when a NaN value is written into an ArrayBuffer. And that means it is perfectly valid for an implementation to write different binary64 values into an ArrayBuffer if even SetValueInBuffer is called with the same NaN value. For example the first call to SetValueInBuffer with a specific NaN value writes the binary64 value `binary64Value1`, the next call to SetValueInBuffer with the same NaN value writes `binary64Value2`. And `binary64Value1` is not equal to `binary64Value2`.\n\nThat explanation allows to skip the SameValue check for [[Set]], but it also provides a loophole to create a communication channel for non-writable + non-configurable NaN properties. Because when [[Set]] is allowed to skip the SameValue check, why not also skip it in [[DefineOwnProperty]]? An implementor could just excuse herself by saying that NaN detection through SetValueInBuffer leads to implementation defined behaviour and be done with it. \n\nIf you ask yourself whether or not this actually matters in practice - yes it does. For example Nashorn used to allow to change non-configurable + non-writable NaN properties to a different NaN value. An old bug report from me: https://bugs.openjdk.java.net/browse/JDK-8030197"},{"commentid":11354,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-14 15:22:27 -0800","thetext":"(In reply to André Bargull from comment #3)\n> (In reply to Allen Wirfs-Brock from comment #2)\n> \n> \n> So, should 9.1.6 [[DefineOwnProperty]] resp.\n> ValidateAndApplyPropertyDescriptor be changed to omit the SameValue check\n> for writable and/or configurable properties?\n> \n> \n> Even if SetValueInBuffer is allowed to change a NaN value to a different\n> (quiet) NaN value, this example should not assert:\n> ---\n> // Let nan1 and nan2 be two different NaN values.\n> \n> var o = {};\n> \n> Object.defineProperty(o, \"p\", {value: nan1});\n> var bitsNan1 = numberToRawBits(o.p).toString(16);\n> \n> Object.freeze(o);\n\nNote that ES6 specifies that the indexable properties of Typed Array are implicitly non-confiburable, and writable and that such a property can not be made non-writable (see http://people.mozilla.org/~jorendorff/es6-draft.html#sec-integer-indexed-exotic-objects-defineownproperty-p-desc steps 3.c.viii-x )\n\nSo, trying to freeze such an object will fail. So if you are passing a typed array around you already have a much bigger communications channel."},{"commentid":11364,"comment_count":5,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-15 05:50:43 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #4)\n> Note that ES6 specifies that the indexable properties of Typed Array are\n> implicitly non-confiburable, [...]\n\nYup, except in my examples there are no Typed Arrays, but ordinary objects using the ordinary internal method definitions."},{"commentid":11366,"comment_count":6,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-15 06:46:05 -0800","thetext":"WDYT about this change for SetValueInBuffer:\n  https://gist.github.com/anba/284212fe803be2d06d8a\n\nAnd this change for ValidateAndApplyPropertyDescriptor:\n  https://gist.github.com/anba/5bc82dc36549d8f5b149"},{"commentid":11367,"comment_count":7,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-01-15 07:11:16 -0800","thetext":"I guess I should have explained the intention behind the ValidateAndApplyPropertyDescriptor change:\n\nBy removing step 4 of the original algorithm, a property update takes place even if the property value does not change when compared with the SameValue algorithm. That way implementations are no longer required to perform a SameValue check in the ordinary [[Set]] internal method."},{"commentid":11555,"comment_count":8,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-19 15:54:25 -0800","thetext":"OK, I think I now get what you concern is all about.\n\nI think you added sentence for setValueInBuffer is a good idea and I have incorporated that into the ES6 spec.\n\nWRT your rewrite of ValidateAndApplyPropertyDescriptor, I think it looks promising.  However, I'm hesitant to apply it to ES6 at this stage of its development. One of the hardest parts of ES5 development was getting that algorithm to point where everyone was convinced it was correct. (for example, see http://wiki.ecmascript.org/doku.php?id=es3.1:attribute_states) I probably needs to get more review then just you and me. However, right now there seems like there are many more important things in ES6 that people should be focusing on reviewing.\n\nRight now, step 4 of the current algorithm, seems like an early-out optimization that doesn't need to be there. However, I have a vague recollection that including it allowed us to simplify the rest of the algorithm. But that recollection might be wrong. (we might find some hints by comparing it in various ES5 drafts http://wiki.ecmascript.org/doku.php?id=es3.1:es3.1_proposal_working_draft but that also doesn't seem like the most important think to spend time on right now).\n\nI think we should probably take the time to do a more thorough review and target fixing it for ES7."},{"commentid":12682,"comment_count":9,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-02-14 14:19:08 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #8)\n> I think we should probably take the time to do a more thorough review and\n> target fixing it for ES7.\n\nAgreed."},{"commentid":14465,"comment_count":10,"who":{"uid":"dehrenberg","name":"Daniel Ehrenberg"},"bug_when":"2015-05-28 12:25:28 -0700","thetext":"It seems like the security issue primarily comes up due to this:\n\n\"In implementations this SameValue check does not take place when ValidateAndApplyPropertyDescriptor is called from [[Set]]. It is performed when ValidateAndApplyPropertyDescriptor is called from [[DefineOwnProperty]], for example when `Object.defineProperty` is invoked. And users are able to observe this difference with the example code given in comment #0.\"\n\nWouldn't those implementations be non-conformant? I tried it in V8, and V8 seems to be conformant in returning the initial NaN representation for the code in #3 (whether using = or defineOwnProperty)."},{"commentid":14466,"comment_count":11,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-05-28 13:27:02 -0700","thetext":"(In reply to Daniel Ehrenberg from comment #10)\n> It seems like the security issue primarily comes up due to this:\n> \n> \"In implementations this SameValue check does not take place when\n> ValidateAndApplyPropertyDescriptor is called from [[Set]]. It is performed\n> when ValidateAndApplyPropertyDescriptor is called from\n> [[DefineOwnProperty]], for example when `Object.defineProperty` is invoked.\n> And users are able to observe this difference with the example code given in\n> comment #0.\"\n\nThe next two paragraphs are more important for the potential communication channel issue:\n\n\"IIUC implementations are allowed to skip the SameValue check for [[Set]] because SetValueInBuffer may use a different quiet NaN value when a NaN value is written into an ArrayBuffer. [...]\n\nThat explanation allows to skip the SameValue check for [[Set]], but it also provides a loophole to create a communication channel for non-writable + non-configurable NaN properties. Because when [[Set]] is allowed to skip the SameValue check, why not also skip it in [[DefineOwnProperty]]? An implementor could just excuse herself by saying that NaN detection through SetValueInBuffer leads to implementation defined behaviour and be done with it. \"\n\n\nThe \"IIUC\" refers to Allen's response in comment #2:\n\"But, only by examining the bytes of  a binary ArrayBuffer.  I'm not sure that this is fundamentally different from using \"external code\" to write a Number to a file and then using byte level reads to examine what was written. Also, in ES6 the ArrayBuffer SetValueInBuffer operations state that the actual value stored for NaN values is implementation dependent, so what you see in the buffer doesn't imply anything about the NaN encoding of the original value that was stored.\"\n\n\n> \n> Wouldn't those implementations be non-conformant? I tried it in V8, and V8\n> seems to be conformant in returning the initial NaN representation for the\n> code in #3 (whether using = or defineOwnProperty).\n\nAll major engines are spec-conformant for the example in #3, but no engine is spec-conformant for the example in #0."},{"commentid":14469,"comment_count":12,"who":{"uid":"dehrenberg","name":"Daniel Ehrenberg"},"bug_when":"2015-05-28 23:00:10 -0700","thetext":"It could really be useful to have more flexibility with NaN representation than the current spec text allows. I don't know if any implementation wants to do this, but it'd be useful to have this flexibility, for example: Say an ECMAScript implementation wants to serialize and deserialize the execution state of an executing program. Maybe NaNs aren't normally canonicalized. Then the implementation would be prohibited from canonicalizing NaNs when serializing or deserializing.\n\nThe whole argument about this potential optimization feels a bit off to me. Because the spec doesn't specify how NaNs are encoded, what if an implementation got ready the next value that it was going to return for Math.random() and stashed part of it in the next NaN payload for a new NaN value that was generated? Then, you could observe that part of the next random number, which would be a security issue! And it would be spec compliant to put the next random number there. But an implementation would have no reason to set the NaN payload to that value. Unless there's a reason that an implementation would want to do it, I see this \"optimization\" as something similar.\n\nWhile it'd be spec-compliant, I can't really imagine why an implementation would want to \"optimize\" DefineOwnProperty by doing this sort of write when a property is not writable or configurable, leading to this leak. So can we just prohibit this \"optimization\"?\n\nI wonder if there's some other way we can block this, more on the DefineOwnProperty end than on the SetValueInBuffer end. The reasoning motivating the current spec text is actually pretty obscure: we only put the restriction in SetValueInBuffer so that it's observable that DefineOwnProperty really does do that SameValue check and doesn't set the property when it's the SameValue. What the we made SetValueInBuffer prohibit the runtime changing NaN values silently behind the user's back?\n\nIf we can just prohibit the \"optimization\" when writing a property, I think we can prevent this communications channel. It's a little funny to spec out the change because the spec already, in fact, says that if it's the same value! What if we wrote a non-normative note near the definition of ValidateAndApplyPropertyDescriptor, step 4, emphasizing that a different NaN value shouldn't be written into the property just because it is the SameValue."},{"commentid":14470,"comment_count":13,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-05-29 06:19:10 -0700","thetext":"The current specification of SetValueInBuffer tries to express that NaN encoding has to be performed deterministically. If NaN encoding is allowed to be a non-deterministic function, then all bets are off w.r.t. observing different NaN values.\n\nThat includes it's no longer possible to verify ValidateAndApplyPropertyDescriptor performs the SameValue check for NaN values. But there could be also different applications where deterministic behaviour of NaN encoding is expected. \n\n\nIt's probably possible to change the spec to:\n---\nIf value is NaN, rawValue may be set to any implementation\nchosen non-signaling NaN encoding. An implementation must always choose the same non-signaling NaN encoding for a distinct Not-a-Number value within the execution of an ECMAScript program.\n---\n\nThat makes it possible to use a different NaN encoding of a distinct Not-a-Number value in different executions of an ECMAScript program (*). Does this help to implement the outlined serializing/deserializing use case?\n\n(*) \"execution of an ECMAScript program\" requires a proper definition based on the OS process running the ECMAScript implementation."}]}}
---
