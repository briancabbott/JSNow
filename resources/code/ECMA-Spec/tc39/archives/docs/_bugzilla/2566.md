---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2566,"creation_ts":"2014-02-27 00:37:00 -0800","short_desc":"Promise.p.then: defaulting of handlers inconsistent with normal default arguments","delta_ts":"2014-05-06 16:46:52 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 22: January 20, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"rossberg","name":"Andreas Rossberg"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"d","long_desc":[{"commentid":7402,"comment_count":0,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-02-27 00:37:47 -0800","thetext":"In 25.4.5.3, Promise.prototype.then, the resolve handler is defaulted with the following steps:\n\n7. If IsCallable(onRejected) is true, then\n   a. Let rejectionHandler be onRejected.\n8. Else,\n   a. Let rejectionHandler be a new Thrower Function (see 25.4.5.3.3).\n\nThis implies that not just undefined will be replaced by the default function, but arbitrary arguments, e.g. 65. That seems both weird and inconsistent with the behaviour of default arguments of ordinary JS functions. I think the logic should be:\n\n7. If onRejected is undefined, then\n   a. Let rejectionHandler be a new Thrower Function (see 25.4.5.3.3).\n8. Else, if IsCallable(onRejected) is false, then\n   a. Throw a TypeError\n8'. Else,\n   a. Let rejectionHandler be onRejected.\n\nSimilarly for steps 9-10 handling the reject handler."},{"commentid":7414,"comment_count":1,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-03-03 13:08:48 -0800","thetext":"Around seven months ago it was decided to use `JSON.parse`/`JSON.stringify`-style optional functions instead of `Array.prototype.sort`-style:\n\nhttp://esdiscuss.org/topic/promises-consensus-with-a-terminology#content-10\n\nThis feature has been present in all drafts presented since then and has not seen objections until now. It is shipping in Blink and Firefox.\n\nThrowing synchronously as a behavior of `then` would be horrible, in any case; returning a rejected promise is more coherent, as noted in the above thread.\n\nSome previous discussion in Promises/A+ space:\n\nhttps://github.com/promises-aplus/promises-spec/pull/32#issuecomment-10335630"},{"commentid":7415,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-03-03 14:01:32 -0800","thetext":"A agree with Andreas on this.  Treating any non-function as a request to use the default is not idiomatic ES, even if JSON.stringify/parse work that way. We should have sanitized those in ES5, but missed it. \n\nI also don't agree that the associated error (if any) should be asynchronous. Passing a non-function in those argument positions is an error relating to the  the then call site rather than an error related to the  deferred action:\n\naPromise.then(new Array, new Map)// oops passing the wrong things to 'then'\n            //should be an immediate exception.\n\nThere are already other synchronous exceptions: steps 4 and 6 in Rev22 draft of 'then'. A wrong argument type exception would be comparable in nature to those.\n\nFinally, I don't think what FF and Blink is particularly relevant.  In TC39 we try not to let early implementation choices prevent us from spec'ing the right thing."},{"commentid":7416,"comment_count":3,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-03-03 14:04:16 -0800","thetext":"The other precedence for IsCallable checks is valueOf, toString, etc. Somewhat different, but still.\n\nLiterally the only place where non-callable arguments result in a thrown error is Array.prototype.sort.\n\nAnyway this would break tons of promise code in the wild that is using falsy sentinels (`null` and `false` in particular). So you would have to special-case those two at the very least."},{"commentid":7418,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-03-03 14:12:11 -0800","thetext":"(In reply to comment #3)\n> \n> Anyway this would break tons of promise code in the wild that is using falsy\n> sentinels (`null` and `false` in particular). So you would have to special-case\n> those two at the very least.\n\nReally?? Do you have examples? (I'm not questioning your assertion, I just curious to see why somebody would do that.)"},{"commentid":7419,"comment_count":5,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-03-03 14:15:13 -0800","thetext":"Lots of examples on GitHub with https://github.com/search?l=javascript&q=%2B%22.then%28null%22&ref=searchresults&type=Code; hard to narrow down which of those are using native promises, if any."},{"commentid":7420,"comment_count":6,"who":{"uid":"dherman","name":"Dave Herman"},"bug_when":"2014-03-03 14:15:58 -0800","thetext":"First of all, code like\n\n    p.then(null, handler)\n\nis extremely common in idiomatic promise code.\n\nSecond of all, we as TC39 need to respect the fact that promises started out in DOM-land and have already landed in both Chrome and Firefox. Moreover, the January changes are causing genuine hardship for Chrome implementors. I understand that ES6 isn't completely finalized, but promises are a high-visibility, highly desired feature, and are already implemented in two browsers. It's well past time for changes that break common development idioms.\n\nDave"},{"commentid":7421,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-03-03 14:36:34 -0800","thetext":"(In reply to comment #6)\n> First of all, code like\n> \n>     p.then(null, handler)\n> \n> is extremely common in idiomatic promise code.\n> \nAnd that makes sense coming from DOM land (and even arguably in s pure JS context).  But do we really want to enable:\n\np.then({a:42}, handler);\n\nDo we think anybody ever coded that where it wasn't a misunderstanding of the then API?  Allowing it is obscuring a bug.\n\n> Second of all, we as TC39 need to respect the fact that promises started out in\n> DOM-land and have already landed in both Chrome and Firefox. Moreover, the\n> January changes are causing genuine hardship for Chrome implementors. I\n> understand that ES6 isn't completely finalized, but promises are a\n> high-visibility, highly desired feature, and are already implemented in two\n> browsers. It's well past time for changes that break common development idioms.\n\nWell, any webidl based API definition would throw an exception if an non-callable object was passed to a parameter position that expected callback. And, it was Andreas Rossberg who opened this bug.\n\nClearly null needs to be accepted. But it is a lot less clear that other numbers, strings, booleans, and non-callable objects should be accepted or that rejecting them would breaking anythng."},{"commentid":7423,"comment_count":8,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-03-04 03:47:57 -0800","thetext":"I agree it's fine to special-case 'null' for legacy compatibility. But as Allen said, it is difficult to imagine any other case that is not actually a bug. (FWIW, I just searched some representative patterns on both GitHub and Google's internal CodeSearch, and neither did come up with anything.)"},{"commentid":7442,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-03-18 12:35:43 -0700","thetext":"(In reply to comment #8)\n> I agree it's fine to special-case 'null' for legacy compatibility. But as Allen\n> said, it is difficult to imagine any other case that is not actually a bug.\n> (FWIW, I just searched some representative patterns on both GitHub and Google's\n> internal CodeSearch, and neither did come up with anything.)\n\nI also did some searching and couldn't find any on github.  I'm going to only allow undefined and null unless  somebody can find real examples where values other than null or undefined are used as defaulting values."},{"commentid":7444,"comment_count":10,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-03-18 14:44:33 -0700","thetext":"I don't care much which values are allowed, but I feel strongly that when interfacing with asynchronous APIs, the errors given should be asynchronous. Otherwise, programmers cannot isolate errors reliably in sections of their code using a single catching technique, and they are forced to double-wrap code in .catch() and try { } catch { }.\n\nUsing promise APIs to isolate errors is one of their primary use cases. Trying to distinguish between \"an error relating to the the then call site rather than an error related to the deferred action\" is fruitless: no APIs distinguish this way currently. If you do\n\ntry {\n  doSomethingSync(badArg);\n} catch (e) {\n  // isolate e from other parts of my app, allowing them to continue\n}\n\nthere is no exception for the fact that badArg is a \"call-site error\"; it gets caught anyway. Similarly, if you do\n\ndoSomethingAsync(badArg).catch(e => {\n  // isolate e from other parts of my app, allowing them to continue\n});\n\nyou would not expect the error to escape your catch and bubble up to other parts of the program, or possibly crash your server if you are using something like Node.js.\n\n---\n\nI am strongly against this consensus-breaking change, as I believe are Mark and Yehuda. It should not be done."},{"commentid":7716,"comment_count":11,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-14 09:15:53 -0700","thetext":"TC39 at its April 2014 meeting agreed to treat all non-callable then arguments as defaulting values\n\nchanged in rev24 editor's draft"},{"commentid":7758,"comment_count":12,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-16 15:52:38 -0700","thetext":"fixed in rev24 editor's draft"},{"commentid":8187,"comment_count":13,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-05-06 16:46:52 -0700","thetext":"fixed in rev24"}]}}
---
