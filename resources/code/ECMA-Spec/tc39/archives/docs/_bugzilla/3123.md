---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3123,"creation_ts":"2014-08-12 12:29:00 -0700","short_desc":"Should typeof be really allowed to produce \"function\" for an object not implementing [[Call]]?","delta_ts":"2014-10-14 15:17:54 -0700","product":"Draft for 6th Edition","component":"normative change from ES5.x","version":"Rev 26: July 18, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"claude.pache","name":"Claude Pache"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["erights","erights"],"long_desc":[{"commentid":9766,"comment_count":0,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-08-12 12:29:31 -0700","thetext":"Section 12.5.6 The typeof Operator\nTable 34 â€” typeof Operator Results\n\nAccording to the last row of the table, `typeof` called on a non-standard exotic object that does not implement [[Call]] may result in \"function\" nonetheless. I'm not able to think of a valid reason for such a behaviour, and it deceives the expectation that `typeof` produces \"function\" iff the object is callable.\n\nEither such an object should not be permitted to have \"function\" as `typeof` result, or a NOTE should be added specifying that this is intentional."},{"commentid":9770,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-12 13:34:24 -0700","thetext":"Mark,\n\nDo you agree that it is a bug that we didn't list \"function\" is the list of \"must nots\"?  \n\nDo you recall whether there were some know nonconforming host objects that we were trying to grandfather in."},{"commentid":9776,"comment_count":2,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-08-12 19:17:43 -0700","thetext":"Hi Allen, Claude,\n\nI do agree that it is a bug. I do not remember if there was a host object counter-example. But even if there is, it seems we could grandfather it in by simply specifying that it does have a [[Call]] method that always throws."},{"commentid":9777,"comment_count":3,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-08-13 02:42:23 -0700","thetext":"(In reply to Mark Miller from comment #2)\n> But even if there is, it seems we could grandfather it in\n> by simply specifying that it does have a [[Call]] method that always throws.\n\nThere is a subtle difference between objects that have a [[Call]] method that always throws, and objects that don't have a [[Call]] method. For instance, let `f` be an object, and consider:\n\n    Function.prototype.bind.call(f, null)\n\nThat expression will throw an error iff `f` does not have a [[Call]] internal method (to a first approximation at least, for one can find several obscure ways for that expression to fail)."},{"commentid":9778,"comment_count":4,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-08-13 03:26:44 -0700","thetext":"Good point. But probably there is no significant legacy constraint on preserving the throwing behavior of  Function.prototype.bind.call(f, null) on these host objects. If the consequence attributing a [[Call]] method to these host objects is that the bind succeeds and the throwing is postponed until the bound method is called, I suspect we could get away with that."},{"commentid":10363,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-10-14 12:00:22 -0700","thetext":"fixed in rev28 editor's draft.\n\nAdded \"function\" to the list."},{"commentid":10439,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-10-14 15:17:54 -0700","thetext":"fixed in rev28"}]}}
---
