---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":33,"creation_ts":"2011-02-26 03:45:00 -0800","short_desc":"Disabling 15.2.3.5-4-14 Object.create - argument 'Properties' is an Error object (15.2.3.7 step 2)","delta_ts":"2011-05-25 14:08:47 -0700","product":"Test262","component":"ECMA-262 Tests","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"bruant.d","name":"David Bruant"},"assigned_to":{"uid":"dfugate","name":"Dave Fugate"},"long_desc":[{"commentid":64,"comment_count":0,"who":{"uid":"bruant.d","name":"David Bruant"},"bug_when":"2011-02-26 03:45:38 -0800","thetext":"This test assumes that, at a maximum, Error objects have a set of own properties included in ['description', 'message', 'name']. This is in contradiction with Section 16:\n\"An implementation may provide additional types, values, objects, properties,\nand functions beyond those described in this specification.\"\n\nIf an implementation decides to add an own property to all Error instances and that this property isn't a non-null object, the implementation will fail the test while it is allowed to add the property.\n\nFor this reason, I'd recommand to disable the test.\n\nFor the record, there is no mention of Error properties (own or inherited) which would be named 'description' or 'name'. Is there a reason why these properties have been redefined in the test?"},{"commentid":65,"comment_count":1,"who":{"uid":"bruant.d","name":"David Bruant"},"bug_when":"2011-02-26 04:28:53 -0800","thetext":"Same for Test 15.2.3.5-4-37 for which Error instances could have other implementation-defined own non-object properties."},{"commentid":66,"comment_count":2,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2011-02-28 09:08:43 -0800","thetext":"The test case reads as:\n        var props = new Error(\"test\");\n        var result = false;\n        props.description = { value: 11 };\n        props.message = { value: 11 };\n        props.name = { value: 11 };\n\n\n        Object.defineProperty(props, \"prop\", {\n            get: function () {\n                result = this instanceof Error;\n                return {};\n            },\n            enumerable: true\n        });\n        var newObj = Object.create({}, props);\n        return result && newObj.hasOwnProperty(\"prop\");\n\n\nWhat if lines 3-5 were replaced by the more generic:\n        var tempNames = Object.getOwnPropertyNames(props);\n        for (var name in tempNames) {\n            name = tempNames[name];\n            props[name] = {value:11};\n        }"},{"commentid":68,"comment_count":3,"who":{"uid":"bruant.d","name":"David Bruant"},"bug_when":"2011-02-28 09:39:47 -0800","thetext":"(In reply to comment #2)\n> What if lines 3-5 were replaced by the more generic:\n>         var tempNames = Object.getOwnPropertyNames(props);\n>         for (var name in tempNames) {\n>             name = tempNames[name];\n>             props[name] = {value:11};\n>         }\nVery interesting suggestion. I think it works.\nSince we're dealing with an array, I would go more for something like:\n\n(Object.getOwnPropertyNames(props)).forEach(function(name){props[name] = {value:11, configurable:true}});\n\nA precondition to test for .forEach availability would need to be added.\nI have added the \"configurable:true\" in case an implementation would already define a 'prop' property in Error. If it was the case, without the configurable true, we would make it not configurable and the Object.defineProperty would fail.\n\n\nHowever, if an implementation was defining a non-configurable 'prop' property on Error objects, then... mmm... we're screwed aren't we?\n\nSo our solution is a good fix for now, but to be fully rigourous, we'd need a way to generate a property name which isn't already on an object.\n\nIs there already such a function in the TestHarness?"},{"commentid":70,"comment_count":4,"who":{"uid":"dfugate","name":"Dave Fugate"},"bug_when":"2011-02-28 10:58:27 -0800","thetext":"(In reply to comment #3)\n> (In reply to comment #2)\n> > What if lines 3-5 were replaced by the more generic:\n> >         var tempNames = Object.getOwnPropertyNames(props);\n> >         for (var name in tempNames) {\n> >             name = tempNames[name];\n> >             props[name] = {value:11};\n> >         }\n> Very interesting suggestion. I think it works.\n> Since we're dealing with an array, I would go more for something like:\n> (Object.getOwnPropertyNames(props)).forEach(function(name){props[name] =\n> {value:11, configurable:true}});\n> A precondition to test for .forEach availability would need to be added.\n> I have added the \"configurable:true\" in case an implementation would already\n> define a 'prop' property in Error. If it was the case, without the configurable\n> true, we would make it not configurable and the Object.defineProperty would\n> fail.\nDone.  The change will take place with the next IE Test Center-based updated to Test262.\n\n> However, if an implementation was defining a non-configurable 'prop' property\n> on Error objects, then... mmm... we're screwed aren't we?\nI was thinking the same thing.  An alternative would be to bail (successfully) if we find such a case."},{"commentid":71,"comment_count":5,"who":{"uid":"bruant.d","name":"David Bruant"},"bug_when":"2011-02-28 11:31:11 -0800","thetext":"I think I have a function that can help us out:\n-----------------------------------\nfunction unusedPropertyName(o){\n    var ownPropNames = Object.getOwnPropertyNames(o)\n\n    var unusedName = ownPropNames.reduce(\n                               function(prev, curr, i){\n                                  var A = 'a', B = 'b';\n                                  var l = curr[i];\n                                  l = (l=== undefined || l !== A) ? A : B;\n                                  \n                                  return prev + l;\n                               }, '');\n\n    return unusedName;\n}\n-----------------------------------\nWe have an object. We get all its own property names. Based on that array, we create a string which, at index i has a letter that is different from the i-th letter of the i-th property name (it's kind of Kantor's diagonal method inspired).\nAt the end, we have a name which is different from all the property names currently on the object.\n\nAt some point, I was worried that the string could be too big (if there are too many properties), but I haven't seen any limitation on the spec about string length.\n\nArray extras are just awesome. Love them :-) (first time I use .reduce for something useful)\n\nMaybe that this function or some equivalent could be used in order to deal with implementation-independency issues of native objects properties ?\n\nIn our particular case, 'prop' could be replaced by a variable initialized with\nunusedPropertyName(props) ?"},{"commentid":79,"comment_count":6,"who":{"uid":"bruant.d","name":"David Bruant"},"bug_when":"2011-03-01 05:14:20 -0800","thetext":"Last night, I came up with another idea for the function.\nOne of the \"issue\" with the previous one is that if there are a lot of properties, the resulting string is going to be long and since it's concatenating strings, it's not very garbage-collector friendly (at least on Firefox, I don't know how other ES engines handle string garbage collection).\n\nHere is the other idea:\n-----------------------------------\nfunction unusedPropertyName(o){\n    var ownPropNames = Object.getOwnPropertyNames(o)\n    // Get the length of the longest property name\n    var maxLen = ownPropNames.reduce(function(p, c){\n                                         return c.length>p? c.length : p;\n                                     }, 1);\n\n    // Return a string with a length which is maxLen+1\n    return Array(maxLen+1).map(function(){return 'a';}).join('');\n}\n-----------------------------------\n\nObviously, some combination of both approaches could be use."},{"commentid":168,"comment_count":7,"who":{"uid":"bruant.d","name":"David Bruant"},"bug_when":"2011-03-22 13:32:52 -0700","thetext":"(In reply to comment #6)\n> return Array(maxLen+1).map(function(){return 'a';}).join('');\nThis doesn't work.\n\nHowever, this does:\n  return Array(maxLen+1+1).join('a');\n(the additional \"+1\" is because join adds the array.length -1 separator)"}]}}
---
