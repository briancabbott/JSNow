---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3113,"creation_ts":"2014-08-08 06:29:00 -0700","short_desc":"Add `Function.prototype.arguments` and `Function.prototype.caller`","delta_ts":"2015-07-10 08:35:03 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 27: August 24, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Highest","bug_severity":"blocker","everconfirmed":true,"reporter":{"uid":"mathias","name":"Mathias Bynens"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["claude.pache","erights","erik.arvidsson","jorendorff","jwalden+beo","princexcess69"],"long_desc":[{"commentid":9729,"comment_count":0,"who":{"uid":"mathias","name":"Mathias Bynens"},"bug_when":"2014-08-08 06:29:48 -0700","thetext":"http://javascript.spec.whatwg.org/#function.prototype.arguments\nhttp://javascript.spec.whatwg.org/#function.prototype.caller\n\nThese are required for Web compatibility. Adding them to the ES6 spec (and properly defining their semantics) would improve interoperability, as at the moment all engines implement them slightly differently.\n\nSome tests: http://mathias.html5.org/tests/javascript/function/"},{"commentid":9744,"comment_count":1,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-08-09 10:13:05 -0700","thetext":"The whatwg spec is wrong. It describes the behavior of sloppy function own properties but not the behavior of the Function.prototype properties, as it claims."},{"commentid":9745,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-09 12:30:44 -0700","thetext":"properties with these names are explicitly poisoned for built-in functions and for ECMAScript functions defined in strict mode."},{"commentid":9751,"comment_count":3,"who":{"uid":"mathias","name":"Mathias Bynens"},"bug_when":"2014-08-10 05:11:28 -0700","thetext":"(In reply to Mark Miller from comment #1)\n> The whatwg spec is wrong. It describes the behavior of sloppy function own\n> properties but not the behavior of the Function.prototype properties, as it\n> claims.\n\nRight; apologies for my confusion. Forget about the WHATWG spec. Let’s continue discussing the `Function.prototype` properties.\n\n(In reply to Allen Wirfs-Brock from comment #2)\n> properties with these names are explicitly poisoned for built-in functions\n> and for ECMAScript functions defined in strict mode.\n\nAre you saying this is in the ES6 draft already? Where? I searched for `Function.prototype.caller` and `Function.prototype.arguments` but couldn’t find anything.\n\n    > Function.prototype.caller\n    null\n    > Function.prototype.arguments\n    null\n\nRe-opening"},{"commentid":9994,"comment_count":4,"who":{"uid":"claude.pache","name":"Claude Pache"},"bug_when":"2014-08-26 13:13:06 -0700","thetext":"(In reply to Mathias Bynens from comment #3)\n> Are you saying this is in the ES6 draft already? Where? I searched for\n> `Function.prototype.caller` and `Function.prototype.arguments` but couldn’t\n> find anything.\n\nIt is here: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-createintrinsics\nstep 12: Perform AddRestrictedFunctionProperties(funcProto, realmRec).\n\n\nNote that this is a change from ES5, which is what current browsers implement: the equivalent of AddRestrictedFunctionProperties() is applied to every strict-mode function (see [2], step 19), but not to `Function.prototype`; whereas ES6 apply it to `Function.prototype` only and rely on prototypal inheritance.\n\n[2] ES5.1, section 13.2: http://www.ecma-international.org/ecma-262/5.1/#sec-13.2"},{"commentid":9995,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-26 14:08:18 -0700","thetext":"(In reply to Claude Pache from comment #4)\n> ...\n> It is here:\n> http://people.mozilla.org/~jorendorff/es6-draft.html#sec-createintrinsics\n> step 12: Perform AddRestrictedFunctionProperties(funcProto, realmRec).\n> \n> \n> Note that this is a change from ES5, which is what current browsers\n> implement: the equivalent of AddRestrictedFunctionProperties() is applied to\n> every strict-mode function (see [2], step 19), but not to\n> `Function.prototype`; whereas ES6 apply it to `Function.prototype` only and\n> rely on prototypal inheritance.\n> \n and upon the restriction in http://people.mozilla.org/~jorendorff/es6-draft.html#sec-forbidden-extensions"},{"commentid":10003,"comment_count":6,"who":{"uid":"jwalden+beo","name":"Jeff Walden (remove +beo to mail)"},"bug_when":"2014-08-28 16:28:53 -0700","thetext":"SpiderMonkey just got rid of .arguments and .caller on *all* functions (including strict mode functions), in favor of single accessors on Function.prototype.  Those accessors, when invoked upon strict mode functions, and (for .caller) upon functions where the result would be a strict mode function, have almost identical behavior to the ES5 semantics.  The only difference is in this case:\n\n[jwalden@find-waldo-now src]$ dbg/js/src/js # with patch\njs> function f() {}\njs> \"use strict\"; f.caller = 5\n5\n\nwhere according to ES5 semantics the result should actually be:\n\n[jwalden@find-waldo-now src]$ dbg/js/src/js # without patch\njs> function f() {}\njs> \"use strict\"; f.caller = 5\ntypein:2:14 TypeError: setting a property that has only a getter\n\nIt remains to be seen whether anyone depends upon the ES5 semantics.  I heavily doubt anyone does.\n\nIf this succeeds in a release (it's too new to be in anything but nightlies), I see no reason why the spec couldn't be modified to make arguments/caller into accessors on Function.prototype.  Pace comment 0, I don't think it's desirable or necessary to specify their behavior on all inputs.  But it wouldn't be that bad to say they have algorithms that tail-call into implementation-defined behavior, once the spec-required must-throw-a-TypeError cases are handled."},{"commentid":10004,"comment_count":7,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-08-28 16:48:33 -0700","thetext":"(In reply to Jeff Walden (remove +beo to mail) from comment #6)\n> SpiderMonkey just got rid of .arguments and .caller on *all* functions\n> (including strict mode functions), in favor of single accessors on\n> Function.prototype.  Those accessors, when invoked upon strict mode\n> functions, and (for .caller) upon functions where the result would be a\n> strict mode function, have almost identical behavior to the ES5 semantics. \n> The only difference is in this case:\n> \n> [jwalden@find-waldo-now src]$ dbg/js/src/js # with patch\n> js> function f() {}\n> js> \"use strict\"; f.caller = 5\n> 5\n> \n> where according to ES5 semantics the result should actually be:\n> \n> [jwalden@find-waldo-now src]$ dbg/js/src/js # without patch\n> js> function f() {}\n> js> \"use strict\"; f.caller = 5\n> typein:2:14 TypeError: setting a property that has only a getter\n> \n> It remains to be seen whether anyone depends upon the ES5 semantics.  I\n> heavily doubt anyone does.\n\nIronically, SES currently does, and is broken by this change. See https://code.google.com/p/google-caja/issues/detail?id=1935\nBut don't worry about that. I support this change and will fix SES to work with it.\n\nThanks for trying this out!\n\n\n\n> \n> If this succeeds in a release (it's too new to be in anything but\n> nightlies), I see no reason why the spec couldn't be modified to make\n> arguments/caller into accessors on Function.prototype.  Pace comment 0, I\n> don't think it's desirable or necessary to specify their behavior on all\n> inputs.  But it wouldn't be that bad to say they have algorithms that\n> tail-call into implementation-defined behavior, once the spec-required\n> must-throw-a-TypeError cases are handled."},{"commentid":10122,"comment_count":8,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-02 21:19:42 -0700","thetext":"The Rev27 section 16.1 restrictions on no-own 'caller' and 'arguments' only seem to restrict strict function per se, without explicitly restricting built-ins. The good news re the Nightly implementation is that at least the builtins I examined do not implement their own 'caller':\n\n> var gopd = Object.getOwnPropertyDescriptor;\n> gopd(Object, 'caller') === void 0\ntrue\n\n> Object.hasOwnProperty('caller')\nfalse\n\nSeveral bits of bad news re the Nightly implementation:\n\nThe various occurrences of ThrowTypeError are not ===:\n\n> var tte = gopd(Function.prototype, 'caller').get;\n> var tte2 = gopd(Function.prototype, 'arguments').get;\n> tte === tte2\nfalse\n\nThrowTypeError doesn't always throw. Sometimes it returns null instead:\n\n> Object.caller;\nnull\n\n> tte.call(Object);\nnull\n\n\nThe spec is too weak for security, and the Nightly implementation seems to deviate from the spec in ways I can't predict and thus don't understand the implications of. Because a mistake here is a potentially fatal security hole -- which is why we worked so hard on getting the ES5 poisoning right -- I'm escalating this to \"Highest\"/\"blocker\"."},{"commentid":10123,"comment_count":9,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-02 21:20:49 -0700","thetext":"Those tests were on Nightly 35.0a1 (2014-09-02)"},{"commentid":10124,"comment_count":10,"who":{"uid":"jwalden+beo","name":"Jeff Walden (remove +beo to mail)"},"bug_when":"2014-09-03 07:00:05 -0700","thetext":"(In reply to Mark Miller from comment #8)\n> Several bits of bad news re the Nightly implementation:\n> \n> The various occurrences of ThrowTypeError are not ===:\n> \n> > var tte = gopd(Function.prototype, 'caller').get;\n> > var tte2 = gopd(Function.prototype, 'arguments').get;\n> > tte === tte2\n> false\n\nI have no idea how this could be expected to work.  These accessors exist once, only, on Function.prototype.  But they have to behave like the old things on any non-strict, non-builtin function.  That means .caller returns a caller function, .arguments returns an arguments object.  Those return values aren't the same, so how could the two accessor functions be identical?\n\n> ThrowTypeError doesn't always throw. Sometimes it returns null instead:\n> \n> > Object.caller;\n> null\n> \n> > tte.call(Object);\n> null\n\nI deliberately didn't at this time make the accessors throw a TypeError when called on builtin functions.  I wanted to perform the minimal experiment of having .caller and .arguments exist only on Function.prototype.  I didn't want to expand the experiment to require that these properties throw when accessed on builtin functions.  That would have introduced noise into the results: if something broke, was it due to accessors only on Function.prototype, or was it due to throwing on builtins?  The kind of code that breaks for the first is quite different from the kind that breaks on the second.\n\nIt's easy at this point to change the behavior for builtins.  I'll try to go back and do that later today."},{"commentid":10125,"comment_count":11,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-03 08:11:47 -0700","thetext":"(In reply to Mark Miller from comment #8)\n> The Rev27 section 16.1 restrictions on no-own 'caller' and 'arguments' only\n> seem to restrict strict function per se, without explicitly restricting\n> built-ins.\n\nNot correct, last sentence of first bullet in Rev27 16.1:\n\n\">>...Built-in functions<<, Strict mode functions created using the Function or Generator constructors and functions created using the bind and toMethod methods also must not (be, added in rev28) created with such own properties.\"\n\n> ...\n> \n> The spec is too weak for security, \n\nIn what way, specifically?  It's saying what we agreed to at recent TC39 meetings.\n\n\n>and the Nightly implementation seems to\n> deviate from the spec in ways I can't predict and thus don't understand the\n> implications of. Because a mistake here is a potentially fatal security hole\n> -- which is why we worked so hard on getting the ES5 poisoning right -- I'm\n> escalating this to \"Highest\"/\"blocker\"."},{"commentid":10126,"comment_count":12,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-03 08:29:54 -0700","thetext":"(In reply to Jeff Walden (remove +beo to mail) from comment #10)\n...\n> > > var tte = gopd(Function.prototype, 'caller').get;\n> > > var tte2 = gopd(Function.prototype, 'arguments').get;\n> > > tte === tte2\n> > false\n> \n> I have no idea how this could be expected to work.  These accessors exist\n> once, only, on Function.prototype.  But they have to behave like the old\n> things on any non-strict, non-builtin function.  That means .caller returns\n> a caller function, .arguments returns an arguments object.  Those return\n> values aren't the same, so how could the two accessor functions be identical?\n\nThe intent is that the legacy extension  caller/arguments properties must be implemented as own property (either an access or via [[Get]] hacks) of each non-strict function.\n\nThe values of F.p.caller and F.p.arguments are supposed to be the same (per realm) intrinsic function that unconditionally throws a TypeError exception"},{"commentid":10127,"comment_count":13,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 09:13:43 -0700","thetext":"(In reply to Jeff Walden (remove +beo to mail) from comment #10)\n> (In reply to Mark Miller from comment #8)\n> > Several bits of bad news re the Nightly implementation:\n> > \n> > The various occurrences of ThrowTypeError are not ===:\n> > \n> > > var tte = gopd(Function.prototype, 'caller').get;\n> > > var tte2 = gopd(Function.prototype, 'arguments').get;\n> > > tte === tte2\n> > false\n> \n> I have no idea how this could be expected to work.  These accessors exist\n> once, only, on Function.prototype.  But they have to behave like the old\n> things on any non-strict, non-builtin function.\n\nOutside the spec, let's call these \"sloppy functions\". As Allen points out, each sloppy function that wishes to implement the legacy magic should have an own .caller and .arguments property. The .caller and .arguments inherited from Function.prototype must be only as specified -- accessors whose getter and setter are the unique per-realm ThrowTypeError, where this function's [[Call]] behavior is only to throw a TypeError of that realm.\n\nFurther, for safety (as was discussed at the TC39 meeting but may not have been recorded): The magic legacy own .caller and .arguments properties of sloppy functions should remain pseudo-data properties, so that their magic behavior is not reifiable as first class getter functions. The hard safety constraint is, if such a magic getter is visible, it *must not* act magically if applied to a non-sloppy function. By making these pseudo-data properties, we mostly[*] don't need to worry about this possibility.\n\nIn writing this, I wrote \"mostly\" just now because a possible problematic case occurred to me:\n\nfunction fStrict() {\"use strict\"; ...}\nfunction gSloppy() {...}\n\nfStrict.__proto__ = gSloppy;\n... fStrict.caller ...\n\nNow that all non-sloppy functions other than Function.prototype no longer have their own .caller and .arguments, no matter whether gSloppy.caller is an own accessor or an own pseudo-data property, without additional mechanism, fStrict above would inherit gSloppy's .caller. However, safety demands that gSloppy's .caller's magic, as applied to fStrict, not act magically. Ideally, it would still throw a TypeError. This probably requires additional spec and implementation mechanism.\n\nIn light of these edge cases, I worry that it may be too high risk to try to reform the ES5 poisoning at this late date, since we cannot afford a mistake in this area. Perhaps we should keep the ES5 poison in ES6 and reform it afterwards, once we can take the time to get it right?\n\n\n\n\n>  That means .caller returns\n> a caller function, .arguments returns an arguments object.  Those return\n> values aren't the same, so how could the two accessor functions be identical?\n> \n> > ThrowTypeError doesn't always throw. Sometimes it returns null instead:\n> > \n> > > Object.caller;\n> > null\n> > \n> > > tte.call(Object);\n> > null\n> \n> I deliberately didn't at this time make the accessors throw a TypeError when\n> called on builtin functions.  I wanted to perform the minimal experiment of\n> having .caller and .arguments exist only on Function.prototype.  I didn't\n> want to expand the experiment to require that these properties throw when\n> accessed on builtin functions.  That would have introduced noise into the\n> results: if something broke, was it due to accessors only on\n> Function.prototype, or was it due to throwing on builtins?  The kind of code\n> that breaks for the first is quite different from the kind that breaks on\n> the second.\n> \n> It's easy at this point to change the behavior for builtins.  I'll try to go\n> back and do that later today.\n\nYes, that is extremely important. Thanks!\n\nFWIW, the right way to have taken the intermediate experimental step you explain above is not to complexify the behavior of Function.prototype.caller and Function.prototype.arguments themselves. Safety of the new design demands that these be dirt simple and obviously safe. They should just unconditionally throw TypeError irrespective of the this-arg they are applied to. The right way to have done this intermediate experiment would have been to give each builtin (other than Function.prototype itself) its own configurable/deletable own .caller and .arguments properties that overrode the inherited behavior -- unless and until deleted."},{"commentid":10128,"comment_count":14,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 09:20:49 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #11)\n> (In reply to Mark Miller from comment #8)\n> > The Rev27 section 16.1 restrictions on no-own 'caller' and 'arguments' only\n> > seem to restrict strict function per se, without explicitly restricting\n> > built-ins.\n> \n> Not correct, last sentence of first bullet in Rev27 16.1:\n> \n> \">>...Built-in functions<<, Strict mode functions created using the Function\n> or Generator constructors and functions created using the bind and toMethod\n> methods also must not (be, added in rev28) created with such own properties.\"\n\nOops. My mistake. Somehow I missed the \"Built-in functions\" part of that sentence.\n\n\n\n> > ...\n> > \n> > The spec is too weak for security, \n> \n> In what way, specifically?  It's saying what we agreed to at recent TC39\n> meetings.\n\nWhen I wrote this, I was concerned about the allegedly missing \"Built-in functions\" which you correctly point out was not missing.\n\nHowever, there remain the issues I just raised in comment 13: Since the magic is still allowed to exist for own .caller and .arguments of sloppy functions, we must ensure the magic stays quarantined there. At TC39 we thought that it would be adequate for them to remain pseudo-data properties, so that their magic getters would not be reified. However, the fStrict and gSloppy scenario of comment 13 should that even this restriction is not adequate to ensure that the magic not be applied to non-sloppy functions.\n\n\n> \n> \n> >and the Nightly implementation seems to\n> > deviate from the spec in ways I can't predict and thus don't understand the\n> > implications of. Because a mistake here is a potentially fatal security hole\n> > -- which is why we worked so hard on getting the ES5 poisoning right -- I'm\n> > escalating this to \"Highest\"/\"blocker\"."},{"commentid":10129,"comment_count":15,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 09:28:11 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #12)\n> (In reply to Jeff Walden (remove +beo to mail) from comment #10)\n> ...\n> > > > var tte = gopd(Function.prototype, 'caller').get;\n> > > > var tte2 = gopd(Function.prototype, 'arguments').get;\n> > > > tte === tte2\n> > > false\n> > \n> > I have no idea how this could be expected to work.  These accessors exist\n> > once, only, on Function.prototype.  But they have to behave like the old\n> > things on any non-strict, non-builtin function.  That means .caller returns\n> > a caller function, .arguments returns an arguments object.  Those return\n> > values aren't the same, so how could the two accessor functions be identical?\n> \n> The intent is that the legacy extension  caller/arguments properties must be\n> implemented as own property (either an access or via [[Get]] hacks) of each\n> non-strict function.\n\nYes, but only of sloppy functions. Built-ins and bounds are non-strict but must not get any magic.\n\nAnd the magic must stay quarantined to these sloppy functions somehow. Having these be explicit accessors a) makes this more difficult, and b) is a change from the current pseudo-data legacy.\n\nAs the fStrict / gSloppy scenario of comment 13 demonstrates, just making these be pseudo-data own properties is no longer adequate to quarantine the magic.\n\n> \n> The values of F.p.caller and F.p.arguments are supposed to be the same (per\n> realm) intrinsic function that unconditionally throws a TypeError exception\n\nYes. And only that. These must do no more than the spec specifies -- always throw. Keep these simple enough to be obviously safe!"},{"commentid":10130,"comment_count":16,"who":{"uid":"jwalden+beo","name":"Jeff Walden (remove +beo to mail)"},"bug_when":"2014-09-03 10:52:38 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #12)\n> The intent is that the legacy extension  caller/arguments properties must be\n> implemented as own property (either an access or via [[Get]] hacks) of each\n> non-strict function.\n\nOur experiment isn't concerned about spec intent at all.  (At the time we did it, I don't believe there was any draft.)  It's trying to get rid of all magical-appearance behavior anywhere for .caller and .arguments on any function, and to demonstrate this is feasible.  That's strict mode functions, non-strict functions (or sloppy if you want, I don't care), builtins, arrow functions, functions with rest arguments, bound functions, *everything*.\n\n> The values of F.p.caller and F.p.arguments are supposed to be the same (per\n> realm) intrinsic function that unconditionally throws a TypeError exception\n\nAgain, this was not a goal of our experiment.  Burdening non-strict functions with anti-poison pills is, IMO, as hostile to implementation as poison pills on strict mode/builtin/bound functions is.  Worse, even, as such functions are presently the common case.\n\n(In reply to Mark Miller from comment #13)\n> Further, for safety (as was discussed at the TC39 meeting but may not have\n> been recorded): The magic legacy own .caller and .arguments properties of\n> sloppy functions should remain pseudo-data properties, so that their magic\n> behavior is not reifiable as first class getter functions. The hard safety\n> constraint is, if such a magic getter is visible, it *must not* act\n> magically if applied to a non-sloppy function. By making these pseudo-data\n> properties, we mostly[*] don't need to worry about this possibility.\n\nThe SpiderMonkey team generally considers anything exceeding the scope of data properties or accessor properties, in ES5 terms, to be incredibly unsafe.  We have such a concept (more than one, depending how you count) in SpiderMonkey now.  We're working to get rid of it because we are not smart enough to reason about it -- its implementation, its security properties, its correctness considered in concert with all ES6's flexibility, particularly proxies.  The ES5 concepts we can handle.  We don't want to add something more, and have to provide our own fallible reasoning as to how it fits into every aspect of the ES5/6 MOP.  I'm strongly opposed to any behavior, magical or otherwise, that can't be exposed as a data property or an accessor property.\n\nI think your \"mostly\" case is a contribution to the argument that magic properties are a bad idea.  :-)\n\n> FWIW, the right way to have taken the intermediate experimental step you\n> explain above is not to complexify the behavior of Function.prototype.caller\n> and Function.prototype.arguments themselves.\n\nYour proposed step is a good deal more complex than the one we took, for what it's worth.\n\n> Safety of the new design demands that these be dirt simple and obviously\n> safe.\n\nI disagree.  The requirement that such accessors throw in an enumerated list of cases is pretty easy to specify.  Behavior in other cases can easily be specified as implementation-defined behavior.\n\nIn a build with the make-builtins-throw change applied, these are the cases that throw for arguments accessors:\n\n* if the function is builtin\n* if the function has strict mode code\n* if the function is a bound function\n* if the function has a rest argument\n\nAnd these are the cases that throw for caller accessors:\n\n* if the function is builtin\n* if the function has strict mode code\n* if the function is a bound function\n\nIt's true caller needs a little more to say that if the retrieved caller function would be strict mode code, a TypeError should be thrown.  But that doesn't particularly change the safety/complexity of the restrictions."},{"commentid":10131,"comment_count":17,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 12:01:57 -0700","thetext":"(In reply to Jeff Walden (remove +beo to mail) from comment #16)\n> (In reply to Allen Wirfs-Brock from comment #12)\n> > The intent is that the legacy extension  caller/arguments properties must be\n> > implemented as own property (either an access or via [[Get]] hacks) of each\n> > non-strict function.\n> \n> Our experiment isn't concerned about spec intent at all.\n\nMy mistake. I had not realized this. Given that this happened after the last TC39 mtg, I assumed this was more than just a coincidence ;).\n\n\n>  (At the time we\n> did it, I don't believe there was any draft.)  It's trying to get rid of all\n> magical-appearance behavior anywhere for .caller and .arguments on any\n> function, and to demonstrate this is feasible.\n\nThe best solution all around would be to kill the magic legacy .caller and .arguments behavior completely. I doubt this is what you mean, but since it would be so wonderful, I thought I'd check first before assuming away this happy possibility. Is it?\n\nIf not, and we still retain this unsafe magical behavior, then the question is how to quarantine the magic, so that it doesn't prevent safety within contexts that prohibit sloppy code. Agreed?\n\n\n> That's strict mode\n> functions, non-strict functions (or sloppy if you want, I don't care),\n\nJust to be clear, the reason I care is built-in functions are neither strict nor sloppy. Since they are not strict, IMO we sow confusion by saying that builtins are \"not strict and not non-strict\". To the non-pedant, if builtins are \"not non-strict\", then surely they must be strict, right? I think our terminology on this is screwed up. I doubt we can agree on \"sloppy\" as an official spec term, but we need something clearer than \"non-strict\".\n\n\n> builtins, arrow functions, functions with rest arguments, bound functions,\n> *everything*.\n> \n> > The values of F.p.caller and F.p.arguments are supposed to be the same (per\n> > realm) intrinsic function that unconditionally throws a TypeError exception\n> \n> Again, this was not a goal of our experiment.  Burdening non-strict\n> functions with anti-poison pills is, IMO, as hostile to implementation as\n> poison pills on strict mode/builtin/bound functions is.  Worse, even, as\n> such functions are presently the common case.\n\nIt's no worse than the ES5 situation, which is where we are unless we can agree on something that's clearly safer.\n\nIn any case, the point of the change that TC39 discussed was to unburden non-sloppy functions from requiring the poison pills. Making sloppy functions cheaper would also be good, all else being equal. Perhaps this can still be an outcome of this design direction -- I am actually hopeful it can. But this level of research this late in the ES6 standardization cycle is scary. At this point, this discussion makes me feel more strongly that ES6 should stick with ES5 poisoning, and this poisoning reform research should be postponed to ES7.\n\nThat said, if we do want to sacrifice the schedule to get this into ES6, let's arrange some f2f meetings to hash through the various issues at low latency. I do think something like you propose can be made to work.\n\n\n> (In reply to Mark Miller from comment #13)\n> > Further, for safety (as was discussed at the TC39 meeting but may not have\n> > been recorded): The magic legacy own .caller and .arguments properties of\n> > sloppy functions should remain pseudo-data properties, so that their magic\n> > behavior is not reifiable as first class getter functions. The hard safety\n> > constraint is, if such a magic getter is visible, it *must not* act\n> > magically if applied to a non-sloppy function. By making these pseudo-data\n> > properties, we mostly[*] don't need to worry about this possibility.\n> \n> The SpiderMonkey team generally considers anything exceeding the scope of\n> data properties or accessor properties, in ES5 terms, to be incredibly\n> unsafe.  We have such a concept (more than one, depending how you count) in\n> SpiderMonkey now.  We're working to get rid of it because we are not smart\n> enough to reason about it -- its implementation, its security properties,\n> its correctness considered in concert with all ES6's flexibility,\n> particularly proxies.  The ES5 concepts we can handle.  We don't want to add\n> something more, and have to provide our own fallible reasoning as to how it\n> fits into every aspect of the ES5/6 MOP.  I'm strongly opposed to any\n> behavior, magical or otherwise, that can't be exposed as a data property or\n> an accessor property.\n> \n> I think your \"mostly\" case is a contribution to the argument that magic\n> properties are a bad idea.  :-)\n\nI do not know how to reason about the legacy sloppy .caller and .arguments behaviors. Again, if we can actually get rid of that magic, I would be overjoyed; but surprised. Can we?\n\n\n\n> > FWIW, the right way to have taken the intermediate experimental step you\n> > explain above is not to complexify the behavior of Function.prototype.caller\n> > and Function.prototype.arguments themselves.\n> \n> Your proposed step is a good deal more complex than the one we took, for\n> what it's worth.\n\nI can't tell whether the step you took safely quarantines the legacy sloppy .caller and .arguments behaviors. If it does not, then it is either too complex, or is simply fatally unsafe. Can you convince me that you have safely quarantined these?\n\nGiven two designs that we can be confident safely quarantine these behaviors, I agree that the less magical one, whichever that is, is almost certainly better.\n\n\nMore later..."},{"commentid":10132,"comment_count":18,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-09-03 12:04:07 -0700","thetext":"(In reply to Mark Miller from comment #15)\n> > The values of F.p.caller and F.p.arguments are supposed to be the same (per\n> > realm) intrinsic function that unconditionally throws a TypeError exception\n> \n> Yes. And only that. These must do no more than the spec specifies -- always\n> throw. Keep these simple enough to be obviously safe!\n\nLet me try to convince you that Jeff's approach is \"obviously safe\".\n\n- Each of the two properties has a single implementation, a getter function.\n\n- The code of those getters says that if |this| is a strict function, we throw.\n\nThis completes the proof. The safety rules are explicitly spelled out in a single place, as close as possible to the location of the danger---literally in the same algorithm, just before the part where dangerous information would be exposed.\n\nThat \"as close as possible\" bit is what gets me. The other approaches end up spreading the enforcement of the safety rules through multiple parts of the spec and multiple parts of our codebase. Jeff's approach is the obviously safe one.\n\nAs a bonus, we get to make Function objects ordinary, which to me makes them a lot easier to reason about."},{"commentid":10133,"comment_count":19,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 12:08:28 -0700","thetext":"(In reply to Jason Orendorff from comment #18)\n> (In reply to Mark Miller from comment #15)\n> > > The values of F.p.caller and F.p.arguments are supposed to be the same (per\n> > > realm) intrinsic function that unconditionally throws a TypeError exception\n> > \n> > Yes. And only that. These must do no more than the spec specifies -- always\n> > throw. Keep these simple enough to be obviously safe!\n> \n> Let me try to convince you that Jeff's approach is \"obviously safe\".\n> \n> - Each of the two properties has a single implementation, a getter function.\n> \n> - The code of those getters says that if |this| is a strict function, we\n> throw.\n\nSince you make a claim of obviousness, I feel unembarrassed to make a pedantic reply:\n\nWhat about builtins (and bound, etc)? Without these, your allegedly obviously safe rule is actually obviously unsafe.\n\n\n\n\n> \n> This completes the proof. The safety rules are explicitly spelled out in a\n> single place, as close as possible to the location of the danger---literally\n> in the same algorithm, just before the part where dangerous information\n> would be exposed.\n> \n> That \"as close as possible\" bit is what gets me. The other approaches end up\n> spreading the enforcement of the safety rules through multiple parts of the\n> spec and multiple parts of our codebase. Jeff's approach is the obviously\n> safe one.\n> \n> As a bonus, we get to make Function objects ordinary, which to me makes them\n> a lot easier to reason about."},{"commentid":10134,"comment_count":20,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-09-03 12:14:16 -0700","thetext":"(In reply to Jason Orendorff from comment #18)\n> - The code of those getters says that if |this| is a strict function, we\n> throw.\n\nP.S. This of course is not the actual complete suite of safety rules, but that doesn't affect the line of reasoning I'm trying to convey here, to wit: The best way to specify a set of safety rules is to write them all down in a single place. The best way to enforce them is by checking immediately before the dangerous operation."},{"commentid":10135,"comment_count":21,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-09-03 12:16:40 -0700","thetext":"(In reply to Mark Miller from comment #19)\n> Since you make a claim of obviousness, I feel unembarrassed to make a\n> pedantic reply:\n\nOh, for shame. :-)\n\nI hope comment 20 is an adequate reply! Otherwise we should chat."},{"commentid":10136,"comment_count":22,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 12:19:27 -0700","thetext":"(In reply to Jason Orendorff from comment #20)\n> (In reply to Jason Orendorff from comment #18)\n> > - The code of those getters says that if |this| is a strict function, we\n> > throw.\n> \n> P.S. This of course is not the actual complete suite of safety rules, but\n> that doesn't affect the line of reasoning I'm trying to convey here, to wit:\n> The best way to specify a set of safety rules is to write them all down in a\n> single place. The best way to enforce them is by checking immediately before\n> the dangerous operation.\n\nYou may be right. Please make an \"obviously safe\" argument that is complete enough that I can try to attack it.\n\n> I hope comment 20 is an adequate reply! Otherwise we should chat.\n\nWe should chat."},{"commentid":10137,"comment_count":23,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-09-03 12:25:59 -0700","thetext":"(In reply to Mark Miller from comment #22)\n> > I hope comment 20 is an adequate reply! Otherwise we should chat.\n> \n> We should chat.\n\nOK, cool -- please join the #jslang channel on irc.mozilla.org and say my name -- I'm jorendorff there (and on Freenode, in case that's more convenient). Other options would be fine too, I'm easy."},{"commentid":10139,"comment_count":24,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-09-03 13:24:49 -0700","thetext":"(In reply to Mark Miller from comment #22)\n> You may be right. Please make an \"obviously safe\" argument that is complete\n> enough that I can try to attack it.\n\n(bashfully) Well, I may not understand all the rules! But here is a first cut at a concrete specification of .caller:\n\n\n### get Function.prototype.caller\n\nFunction.prototype.caller is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:\n\n1. Let F be the this value.\n\n2. If F is not a non-strict mode ECMAScript function, throw a TypeError exception.\n\n3. Let C be an implementation-defined value that is either a Function Object or null.\n\n4. If C is not a non-strict mode ECMAScript function, return null.\n\n5. Return C.\n\n\nNow, I may not have correctly specified the safety rules in steps 2 and 4, but surely you grant that it's possible to do so? And that done, \"obviously\" the rules would then be correctly enforced, right?\n\nI further claim that this style of specification (whitelisting the kind of legacy code that we have to avoid breaking) makes gaps less likely."},{"commentid":10140,"comment_count":25,"who":{"uid":"jorendorff","name":"Jason Orendorff"},"bug_when":"2014-09-03 13:44:36 -0700","thetext":"For completeness, here are some NOTEs I would add:\n\nNOTE    This is a legacy feature. Implementations have long provided a .caller property on function objects that provides (very) rudimentary access to the call stack. As a tool for examining the state of a running program, it is less than ideal: it does not handle stacks containing recursion; it does not properly identify scripts or eval code, as those are not functions; it skips built-in functions; it was never fully specified. Furthermore, exposing this capability in the first place is a security concern for some systems, as the .caller property can be used by untrusted code to obtain a reference to a function that might otherwise be impossible to reach. For this reason, the mechanism is explicitly specified *not* to work except for non-strict mode functions. Secure systems can force the untrusted code they run into strict mode by prepending a Use Strict Directive before running it.\n\nNOTE 2    In implementations that predate this standard, .caller is commonly implemented as a special own data property on all Function objects. Deleting `Function.prototype.caller` is useless as a security measure in such implementations."},{"commentid":10141,"comment_count":26,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-03 13:52:46 -0700","thetext":"Mark, \n\nRather than continuing to invent asymptotically better roadblocks to keep implementers from implementing the legacy 'caller' and 'argument' properties, why don't we just get even more specific in 16.1 about what they are forbidden to do.  After all, totally forbidding 'caller' still wouldn't stop an implementation from  implementing 'callerEx' that had the same undesirable behavior.\n\nI think you probably need to take the first draft at articulating what you want said, but I imagine it could be along the lines of something like:\n\nAn implementation must not provide any extensions that, depending solely based upon access to a function, reveals the identity of any strict or built-in function that, has previously  called the accessible function."},{"commentid":10144,"comment_count":27,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 15:42:22 -0700","thetext":"(In reply to Jason Orendorff from comment #24)\n> (In reply to Mark Miller from comment #22)\n> > You may be right. Please make an \"obviously safe\" argument that is complete\n> > enough that I can try to attack it.\n> \n> (bashfully) Well, I may not understand all the rules! But here is a first\n> cut at a concrete specification of .caller:\n> \n> \n> ### get Function.prototype.caller\n> \n> Function.prototype.caller is an accessor property whose set accessor\n> function is undefined. Its get accessor function performs the following\n> steps:\n> \n> 1. Let F be the this value.\n> \n> 2. If F is not a non-strict mode ECMAScript function, throw a TypeError\n> exception.\n> \n> 3. Let C be an implementation-defined value that is either a Function Object\n> or null.\n> \n> 4. If C is not a non-strict mode ECMAScript function, return null.\n> \n> 5. Return C.\n> \n> \n> Now, I may not have correctly specified the safety rules in steps 2 and 4,\n> but surely you grant that it's possible to do so? And that done, \"obviously\"\n> the rules would then be correctly enforced, right?\n> \n> I further claim that this style of specification (whitelisting the kind of\n> legacy code that we have to avoid breaking) makes gaps less likely.\n\n\nHi Jason, this is excellent. It is clear enough that I've been able to think about attacking it, and I can tell I'm failing to attack it. This is precisely what I was looking for. The NOTEs are good too, especially NOTE 2.\n\nOf course, we need a similar treatment of Function.prototype.arguments. \n\nWe should wonder if there are any changes we should make to arguments.callee and arguments.caller. It seems a bit weird that these remain own-poisoned, but I don't immediately see an alternative. Assuming these are not changed, we should still wonder if there is some interaction between these and arguments.calle* that potentially creates a problem. But I don't see one.\n\nI feel much more relaxed about all this. Thanks!"},{"commentid":10145,"comment_count":28,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 15:45:58 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #26)\n> Mark, \n> \n> Rather than continuing to invent asymptotically better roadblocks to keep\n> implementers from implementing the legacy 'caller' and 'argument'\n> properties, why don't we just get even more specific in 16.1 about what they\n> are forbidden to do.  After all, totally forbidding 'caller' still wouldn't\n> stop an implementation from  implementing 'callerEx' that had the same\n> undesirable behavior.\n> \n> I think you probably need to take the first draft at articulating what you\n> want said, \n\nI agree. I will think about how to approach this. When would you need it by for it to be a candidate for inclusion in ES6?\n\n\n> but I imagine it could be along the lines of something like:\n> \n> An implementation must not provide any extensions that, depending solely\n> based upon access to a function, reveals the identity of any strict or\n> built-in function that, has previously  called the accessible function.\n\nI see various problems with this phrasing, but no matter. I take your point, and this suggestion is enough to seed the effort. Thanks!"},{"commentid":10146,"comment_count":29,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-03 16:02:13 -0700","thetext":"(In reply to Mark Miller from comment #28)\n> (In reply to Allen Wirfs-Brock from comment #26)\n> > Mark, \n> > \n> > Rather than continuing to invent asymptotically better roadblocks to keep\n> > implementers from implementing the legacy 'caller' and 'argument'\n> > properties, why don't we just get even more specific in 16.1 about what they\n> > are forbidden to do.  After all, totally forbidding 'caller' still wouldn't\n> > stop an implementation from  implementing 'callerEx' that had the same\n> > undesirable behavior.\n> > \n> > I think you probably need to take the first draft at articulating what you\n> > want said, \n> \n> I agree. I will think about how to approach this. When would you need it by\n> for it to be a candidate for inclusion in ES6?\n> \n\nHow about by the end of September.  Of course, sooner is always better."},{"commentid":10147,"comment_count":30,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2014-09-03 16:21:06 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #29)\n> (In reply to Mark Miller from comment #28)\n> > (In reply to Allen Wirfs-Brock from comment #26)\n> > > Mark, \n> > > \n> > > Rather than continuing to invent asymptotically better roadblocks to keep\n> > > implementers from implementing the legacy 'caller' and 'argument'\n> > > properties, why don't we just get even more specific in 16.1 about what they\n> > > are forbidden to do.  After all, totally forbidding 'caller' still wouldn't\n> > > stop an implementation from  implementing 'callerEx' that had the same\n> > > undesirable behavior.\n> > > \n> > > I think you probably need to take the first draft at articulating what you\n> > > want said, \n> > \n> > I agree. I will think about how to approach this. When would you need it by\n> > for it to be a candidate for inclusion in ES6?\n> > \n> \n> How about by the end of September.  Of course, sooner is always better.\n\nYeah, I was afraid of that but not surprised. I'm sure I couldn't get that done by then. I'll take it as an ES7 suggestion.\n\nIn any case, the more I think about it, the more I like Jason's formulation of the new .caller rules. I am hopeful that we can get this solid by ES6."},{"commentid":10148,"comment_count":31,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-09-03 16:23:27 -0700","thetext":"(In reply to Mark Miller from comment #27)\n> We should wonder if there are any changes we should make to arguments.callee\n> and arguments.caller. It seems a bit weird that these remain own-poisoned,\n> but I don't immediately see an alternative. Assuming these are not changed,\n> we should still wonder if there is some interaction between these and\n> arguments.calle* that potentially creates a problem. But I don't see one.\n\nFWIW, V8 uses own getter/setter for arguments.calle* for strict functions and own data property for non strict functions.\n\nfunction strictF() {\n  'use strict';\n  console.log(Object.getOwnPropertyDescriptor(arguments, 'callee'))\n}\nstrictF()  // {get: function, set: function, enumerable: false, configurable: false}\n\nfunction sloppyF() {\n  console.log(Object.getOwnPropertyDescriptor(arguments, 'callee'))\n}\nsloppyF()  // {value: function, writable: true, enumerable: false, configurable: true}"},{"commentid":10149,"comment_count":32,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-09-03 16:26:09 -0700","thetext":"(In reply to Mark Miller from comment #30)\n> (In reply to Allen Wirfs-Brock from comment #29)\n> > \n> > How about by the end of September.  Of course, sooner is always better.\n> \n> Yeah, I was afraid of that but not surprised. I'm sure I couldn't get that\n> done by then. I'll take it as an ES7 suggestion.\n\nIf necessary, I can probably give you more time.  Maybe even until mid-November.  It's shouldn't be a lot to integrate"},{"commentid":12980,"comment_count":33,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-19 12:15:51 -0800","thetext":"There has been language in clause 16.1 (forbidden extensions) for quite awhile that address this issue. In Rev34 I've augment that language a bit. \n\nMark, you should review that."},{"commentid":13174,"comment_count":34,"who":{"uid":"erights","name":"Mark Miller"},"bug_when":"2015-02-19 22:07:41 -0800","thetext":"I do not see a flaw with the current language. Looks great.\n\nIs there anything in particular you remain worried about, that you'd like me to examine in greater depth?"},{"commentid":13337,"comment_count":35,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-24 16:35:34 -0800","thetext":"fixed in rev34"}]}}
---
