---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3205,"creation_ts":"2014-08-30 14:30:00 -0700","short_desc":"Pipelines: promises evolved","delta_ts":"2015-10-15 16:56:43 -0700","product":"Draft for 7th Edition","component":"New feature suggestons","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"kolan_n","name":"KOLANICH"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"brterlso","long_desc":[{"commentid":10091,"comment_count":0,"who":{"uid":"kolan_n","name":"KOLANICH"},"bug_when":"2014-08-30 14:30:18 -0700","thetext":"I think, it would be very good to have the following asyncronous model.\n\nnew Pipe(PipeObject)\nPipeObject has the following schema\n{\ninit:function(){\n //ctor\n},\nsync:function(syncObj){\n//syncObj is obj, whose fields are the input ports and they are true is the signal have come\n}\ni:{\n portA:()=>{},//default implementation, null can be used instead\n portB:function(b){.....}//some custom code\n......\n}\no:outputInterface{\n portC:(obj)=>obj;,//postprocessing functions (here is default implementation), null can be used instead\n portD:function(){}\n......\n}\n}\n\nnew Pipe transforms that PipeObject  object into Pipe object with prototype\n{\ni{\nset portA:function(port){this.__portA.bind(port)};//connects output port to port a\nget portA:function(){return this.__portA};//allows access to methods of Port object\n......\n},\no:{\nget portC:function(){...},\n....\n},\ntrigger:function(){...},\nbind:function(){....}\n}\n\n\nInputPort object\n{\nbind:function(port){},//attaches output port port to input port this\nunbind:function(port),\n}\n\nSo we can create a graph.\n\nfunction createImgSrc(img){\nreturn new Pipe({\n  init:function(img){\n   var canv=document.createElement(\"CANVAS\");\n   var ctx=canv.getContext(\"2d\");\n   //ajusting sizes and drawing image\n   .......\n   o.image(ctx);\n  },\n o:{ctx:null}\n}\n});\n\nvar src=createImageSource(img);\nvar edgeDetector=new Pipe({\n i:{\n  ctx:function(ctx){\n   //edge detection\n  }\n },\n o:outputInterface{\n  ctx:null,\n  error:null\n }\n});\n\nvar gaussianBlur=new Pipe({\n i:{\n  ctx:function(ctx){\n   //bluring\n  }\n },\n o:outputInterface{\n  ctx:null,\n  error:null\n }\n});\n\nvar tween=new Pipe({\n sync:function(s){\n if(s.ctx1&&s.ctx2&&!s.err){\n  makeTween()\n }\n},\n i:{\n  ctx1:function(ctx){\n  },\n  ctx2:function(ctx){\n  },\n  err:function(){}\n },\n o:outputInterface{\n  ctx:null,\n  error:null\n },\nmakeTween:function(ctx1,ctx2){\n....making tweening\no.ctx(ctx);\n}\n});\n\nvar save= new Pipe({\n i:{\n  ctx:function(ctx){\n   ctx.canvas.toBlobHD((b)=>{window.location.href=URL.createObjectURL(b)});\n  }\n }\n});\n\n//binding graph\nsave.i.ctx=tween.o.ctx;\ntween.i.ctx1=gaussianBlur.o.ctx;\ntween.i.ctx2=edgeDetector.o.ctx;\ntween.i.err=Pipe.Any([edgeDetector.o.err,gaussianBlur.o.err]);\ngaussianBlur.i.ctx=src.o.ctx;\nedgeDetector.i.ctx=src.o.ctx;\nsrc.trigger();\n\n\n//Pipes can be bound to each other automatically if they have at least partly compatible interfaces\nsave.bind(tween);\ntween.i.ctx1=gaussianBlur.o.ctx;\ntween.i.ctx2=edgeDetector.o.ctx;\ntween.i.err=Pipe.Any([edgeDetector.o.err,gaussianBlur.o.err]);\ngaussianBlur.bind(src);\nedgeDetector.bind(src);\nsrc.trigger();\n\n\nexecution is asynchronic, \n\n\ninspired by verilog modules https://en.wikibooks.org/wiki/Programmable_Logic/Verilog_Module_Structure"},{"commentid":14806,"comment_count":1,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-10-15 16:56:43 -0700","thetext":"Feature requests should follow the proposal process."}]}}
---
