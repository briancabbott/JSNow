---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":159,"creation_ts":"2011-07-20 17:16:00 -0700","short_desc":"assertion in 10.2.1.1.3 step 2 is incorrect","delta_ts":"2014-12-23 20:23:27 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Initial draft July 12, 2011","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","bug_severity":"normal","dependson":79,"everconfirmed":true,"reporter":{"uid":"allen","name":"Allen Wirfs-Brock"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":357,"comment_count":0,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2011-07-20 17:16:07 -0700","thetext":"+++ This bug was initially created as a clone of Bug #79 +++\n\nfrom: https://mail.mozilla.org/pipermail/es5-discuss/2010-November/003839.html \n\nIn answering some questions about how SpiderMonkey implements assignment in the face of crazy concerns like those raised in the \"Assigning to globals in strict mode\" thread, I wrote this example to demonstrate the precise semantics specified and implemented:\n\n   var x = \"global\";\n   function fun(s) { eval(s); return function(s) { return eval(s); }; }\n   var closure = fun(\"var x = 'local'; x = (delete x, 'overwrite');\");\n   assert(x === \"global\");\n   assert(closure(\"x\") === \"overwrite\");\n\nWhen I went to verify our behavior/implementation conforms to ES5, I discovered that ES5 asserts this situation to be impossible!\n\neval calls CreateMutableBinding for x.  The binding is configurable because it is introduced by eval code.  The assignment to x starts by evaluating x to a Reference rx whose base is the lexical environment for the call to fun and whose name is \"x\".  Next we evaluate the right-hand side, along the way calling DeleteBinding for x and successfully removing that binding because it was configurable.  The assignment algorithm completes by calling PutValue(rx, \"overwrite\").  Step 5 of PutValue calls SetMutableBinding on the lexical environment.  Step 2 of SetMutableBinding asserts that a binding for x already exists -- but it doesn't because we deleted it!\n\nES5 can't assert the binding exists.  SpiderMonkey, when it assigns to a deleted binding, appears to reintroduce a configurable, mutable binding:\n\n   [jwalden at find-waldo-now src]$ dbg/js\n   js> var x = \"global\";\n   js> function foo(s) { eval(s); return function(s) { return eval(s); }; }\n   js> var closure = foo(\"var x = 'local'; \" +\n                         \"x = (delete x, 'overwrite'); \" +\n                         \"print(x); \" +\n                         \"delete x; \" +\n                         \"print(x); \" +\n                         \"eval('var x = \\\"local2\\\";'); \" +\n                         \"print(x);\")\n   overwrite\n   global\n   local2\n\nThus I *think* the right change (awful as it is) is to replace step 2 with:\n\n2. If envRec does not have a binding for N, call CreateMutableBinding(N, true).\n\nand perhaps add a note to the end of the algorithm explaining how this can occur.  But I could well be missing something here -- please poke holes in my suggestion.  :-)\n\nJeff"},{"commentid":10989,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-10 16:53:18 -0800","thetext":"fixed in rev30 editor's draft.\n\nSee 8.1.1.1.5\n\nCreated a replacement binding as suggested.  It would probably be a better fix to re-resolve the identifier using the scope chain.  However, in the specification, the current scope chain isn't available within SetMutableBinding.  It would take more rework than is probably justified to make the scope chain available."},{"commentid":11165,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-23 20:23:27 -0800","thetext":"fixed in rev30"}]}}
---
