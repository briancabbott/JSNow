---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2605,"creation_ts":"2014-04-06 20:21:00 -0700","short_desc":"Promise.prototype.then now throws for non-functions","delta_ts":"2014-04-29 23:03:36 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 23: April 5, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"d","name":"Domenic Denicola"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["medikoo+ecmascript.org","rossberg"],"long_desc":[{"commentid":7611,"comment_count":0,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-04-06 20:21:22 -0700","thetext":"As discussed in a previous bug synchronous throw behavior for Promise.prototype.then is a massive footgun, a departure from all previous existing practice, and something that breaks consensus on previously agreed-upon behavior. Please revert this change.\n\nIf there is talk of returning a rejected promise upon bad argument values, that is a separate decision, and the consequences there are simply that it breaks with all existing practice and existing consensus, and should still be run by the committee. But I stridently object to adding synchronous throw behavior in those cases."},{"commentid":7612,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-06 20:46:06 -0700","thetext":"yup, argument validation should be part of the synchronous call validation and has nothing to do with the async behavior of then. this fix derives from bug 2566\n\nWe'll discuss it at this weeks TC39 meeting. \n\nCan you find any example with such an \"early error\" would cause any issues with valid code that works with existing libraries.\n\nchange the importance to normal, this is no more important than a bunch of other issues we have."},{"commentid":7618,"comment_count":2,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-04-07 01:50:37 -0700","thetext":"I am very sympathetic of this change, if we are sufficiently certain that it does not break existing code (but I have a hard time seeing how). I fully agree with Allen's argument: this is a different class of errors -- fatal bugs in the actual program -- that should not be confused with execution errors stemming from unexpected data or events. I see very little practical reason for lumping the two together. In particular, you want bugs reported as eagerly as possible, and there usually is no point in trying to recover from them, at least not locally."},{"commentid":7619,"comment_count":3,"who":{"uid":"medikoo+ecmascript.org","name":"Mariusz Nowak"},"bug_when":"2014-04-07 03:07:16 -0700","thetext":"I think programmer errors should throw naturally, it's how it's solved in all other types of async API's and I don't remember it being an issue. Why it should be different for promises?\n\nThis makes a good read on that subject: http://www.joyent.com/developers/node/design/errors\n\nAs a side note I work with promise implementation that does that and find it as highly expected behavior."},{"commentid":7620,"comment_count":4,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-04-07 05:56:31 -0700","thetext":"OK, let's talk about existing code.\n\nI have spent the last few hours doing a survey of a several existing large codebases using promises at my current job. I've done this both by inspection and by running through various codepaths with modified versions of the libraries in question. These are all unfortunately proprietary client software, and so I cannot link into the examples or even give them verbatim for fear of being sued, but I can extract the important details of each situation with different variable names etc.\n\nSome of these applications run in Node.js and use Q; others run in browsers and use a combination of Q, jQuery, or in two recent cases ES6 promises (with a fallback to existing shims), so that they use the existing implementations in Chrome and Firefox.\n\nIn all cases the setup is largely the same: we have a promise-returning function in one isolated part of the application or UI, perhaps written by a different team; and we have another part of the application that calls that promise-returning function. And let's remember that the goal of this is not to critique coding style or impugn upon the competence of the original authors, but to discover the impact on existing code and refactoring hazards therein.\n\n### Case 1\n\nThe function in question is\n\nfunction f(options) {\n  return aPromise.then(options.doTransformation && someTransformFunction);\n}\n\nA call site that exists in another part of the codebase is\n\nfunction respondToSpecificRoute(res, req) {\n  f({ doTransformation: false }).then(\n    function () {\n      res.send(200);\n    },\n    function (err) {\n      res.send(500, err);\n    }\n  );\n}\n\nIf we switched from Q to ES6 promises with the change in the existing draft, **every call to this route would cause our production servers to crash**, shutting down all existing connections to them until the auto-restart daemon kicks in. This would be a horrible impact on our business and open us up to essentially DDOS attacks, all because a function that previously failed asynchronously now fails synchronously.\n\nIf we switched from Q to ES6 promises which started returning _rejected_ promises, then instead of crashing the server it would simply send a 500 every time this route is hit. Our monitoring would pick this up just as quickly as the crashing server, but it would not have the horrible business impact, and instead just inconvenience users who were trying to use that route, until we changed the code to compensate for ES6's shortcomings. So it is still a refactoring hazard, but not one that hurts the business as badly.\n\n\n### Case 2\n\nThis code was quite surprising. It's pretty bad code to be honest. (But of course in real life it seems reasonable at first glance, given that there is much more stuff going on in the real codebase.) After I distill it down to its essence, it is:\n\n// Call as: g(onError), or g(options, onError)\nfunction g(onErrorOrOptions, onError) {\n  return getAPromise(onErrorOrOptions).catch(onErrorOrOptions).then(\n    function () {\n      // This code assumes onErrorOrOptions was a function, so the error was recovered from\n      // It does some stuff\n    },\n    function (originalErrFromAPromise) {\n      // This code assumes onErrorOrOptions was an options object, so the error still needs to be handled\n      // It does some stuff and then does\n      onError(aPromise);\n    }\n  );\n}\n\nA call site that exists in another part of the codebase is\n\nfunction handleUserAction() {\n  disableButton();\n  g({ option1: \"value1\" }, function (err) {\n    showErrorDialog(err.message);\n    reenableButton();\n  });\n}\n\nAs you can see this code, which I promise is not as obviously horrible when obfuscated by layers of business logic, depends crucially on .catch(onErrorOrOptions) acting as a no-op passthrough of the error, so that it can handle the original error (originalErrFromAPromise) later.\n\nIf Chrome updated their implementation to throw errors when objects were passed for onRejected, then this code would start breaking: instead of showing an error dialog with the original error's message (which is in this case a legitimate business reason, regarding transactions being unable to go through), the error would get thrown, unwinding the call stack surrounding handleUserAction and ending up in the console. The user would receive no actionable feedback, and the button would stay forever-disabled, forcing the user to refresh the page.\n\nIf Chrome updated their implementation to return rejected promises when objects were passed for onRejected, then this code would end up calling onError with the resulting TypeError. Thus the user would be confronted with a nonsense error message about promises inside the error dialog, but at least the button would be reenabled.\n\n### And So On\n\nI actually have several more cases available after my cursory audit, but this is getting long and I think the above two are some of the more representative ones. If they are not convincing, or if I have not made the scope of the problem clear, I am happy to write up the others."},{"commentid":7626,"comment_count":5,"who":{"uid":"medikoo+ecmascript.org","name":"Mariusz Nowak"},"bug_when":"2014-04-08 00:28:54 -0700","thetext":"> If we switched from Q to ES6 promises with the change in the existing draft,\n**every call to this route would cause our production servers to crash**\n\nHas it crashed because `options.doTransformation && someTransformFunction` resolved to neither function nor null nor undefined?\n\nStill, if it visibly crashed, then I take it was immediately obvious where the crash occurred and for what reason (it wouldn't be the case if error would be swallowed, so it's just for better).\n\nSwitching from Q to ES6 you made a breaking change to other API that behaves differently. It's pretty normal that your code may crash and things should be tested upfront in such case.\n\nIt looks as your point is: do not do it because *code written for Promises/A+ lib would break on that* and not because *it makes much more sense from logical point of view* I think we should focus strictly on latter part here."},{"commentid":7794,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-17 12:33:03 -0700","thetext":"April 2014 TC39 meeting decided to remove the throw\n\nin rev24 editor's draft"},{"commentid":8039,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-04-29 23:03:36 -0700","thetext":"fixed in rev24"}]}}
---
