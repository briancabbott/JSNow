---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3009,"creation_ts":"2014-07-17 13:03:00 -0700","short_desc":"typeof on TDZ variable","delta_ts":"2015-03-16 14:26:48 -0700","product":"Draft for 6th Edition","component":"new feature","version":"Rev 25: May 22, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"getify","name":"getify@gmail.com"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":9231,"comment_count":0,"who":{"uid":"getify","name":"getify@gmail.com"},"bug_when":"2014-07-17 13:03:49 -0700","thetext":"typeof x; // \"undefined\"\n\n{\n  // TDZ\n  typeof x; // ReferenceError\n  let x = 42;\n}\n\nNot debating TDZ semantics here.\n\nBut I think since `typeof` has the special case that it doesn't throw an error on undeclared variables, it would be good for consistency if `typeof` on a variable in its TDZ was also error-safe, and just also returned \"undefined\"."},{"commentid":9237,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-17 15:30:50 -0700","thetext":"You can take this up on esdiscuss if you want to get other opinions, but I don't agree.\n\nIn you example 'x' isn't undeclared, it's uninitialized.  The TDZ is designed to find errors like this.  Why would you want to hide them.\n\nType legacy typeof behavior presumably goes back to the days when it was considered ok to create global variable simply by assigning to an undeclared named. From that perspective you could consider all possible names to preexist as global variables with the value undefined."},{"commentid":9238,"comment_count":2,"who":{"uid":"getify","name":"getify@gmail.com"},"bug_when":"2014-07-17 15:56:48 -0700","thetext":"(In reply to comment #1)\n> In you example 'x' isn't undeclared, it's uninitialized.\n\nI never claimed that the `x` in the block was undeclared. But it is unusable (without an error) at that point in a very similar way to how undeclared variables are unusable.\n\nI (and many others) have always considered it a useful feature of `typeof` that you can \"safely\" (without an error) check if a variable can be referenced. I would like the same capability with `let` declarations.\n\nAnd that goes a thousand times more since the official stance from TC39 seems to be \"let is the new var\".\n\n\n\n> The TDZ is designed  to find errors like this.  Why would you want to hide them.\n\nI don't consider it an error anymore than the common practice of checking to see if a global has been defined -- if so, using it; if not, using some other value.\n\nThis kind of pattern has been around in JS for ages:\n\nvar y = (typeof x !== \"undefined\") ? x : z;\n\nI'm suggesting that the same type of pattern could be useful for `let` declarations.\n\n\n\n> Type legacy typeof behavior presumably goes back to the days when it was\n> considered ok to create global variable simply by assigning to an undeclared\n> named. From that perspective you could consider all possible names to preexist\n> as global variables with the value undefined.\n\nI'm not sure if that's where this exception to `typeof` comes from historically, but it's not at all the motivating scenario for my issue report (see above).\n\nI most definitely don't want to assign to variables to implicitly declare them. I (like almost everyone else) explicitly warn to do the exact opposite."},{"commentid":13752,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-16 14:26:48 -0700","thetext":"closing\n\nI don't think you are going to find any T39 interest in this proposal"}]}}
---
