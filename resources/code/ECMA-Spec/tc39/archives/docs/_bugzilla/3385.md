---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3385,"creation_ts":"2014-11-13 14:49:00 -0800","short_desc":"Require that the mandatory parameter to object literal setter syntax not have an overall default","delta_ts":"2014-11-13 15:33:15 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 28: October 14, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"jwalden+beo","name":"Jeff Walden (remove +beo to mail)"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":10635,"comment_count":0,"who":{"uid":"jwalden+beo","name":"Jeff Walden (remove +beo to mail)"},"bug_when":"2014-11-13 14:49:24 -0800","thetext":"The grammar for a setter in an object literal is:\n\n> MethodDefinition [Yield] :\n>   ...\n>   set PropertyName ( PropertySetParameterList ) { FunctionBody }\n\nAnd we have\n\n> PropertySetParameterList :\n>   FormalParameter\n\nand then\n\n> FormalParameter [Yield,GeneratorParameter] :\n>   BindingElement [?Yield, ?GeneratorParameter]\n\nand then\n\n> BindingElement [Yield, GeneratorParameter ] :\n>   SingleNameBinding [?Yield, ?GeneratorParameter]\n>   [+GeneratorParameter] BindingPattern [?Yield,GeneratorParameter] Initializer [In]opt\n>   [~GeneratorParameter] BindingPattern [?Yield] Initializer [In, ?Yield]opt\n\nand\n\n> SingleNameBinding [Yield,GeneratorParameter] :\n>   [+GeneratorParameter] BindingIdentifier [Yield] Initializer [In]opt\n>   [~GeneratorParameter] BindingIdentifier [?Yield] Initializer [In, ?Yield]opt\n\nEvery expansion of BindingElement permits an initializer.  But setter method syntax is unique and unusual in that it is specifically tailored to setters, in that exactly one argument must be present.  No provision is made for the setter being a general function taking any number of arguments other than 1.  Given that precedent and the ongoing existence of PropertySetParameterList, it seems strange that top-level initializers are permitted here.\n\nInstead of the current grammar, I think we should instead have\n\nPropertySetFormalParameter :\n  BindingIdentifier\n  BindingPattern\n\nto restrict this argument to a name or a destructuring pattern *without* an initializer.  (Note that nested initializers would still be fine with this, as in the following example -- this just prohibits an initializer for the single argument passed to the setter.)\n\nvar API =\n  {\n    _count: 0,\n    _rational: true,\n    set options({ count = 17, rational = true }) {\n     this._count = count;\n     this._rational = rational;\n    }\n  };\nAPI.options = { count: 25 }; // would imply rational = true"},{"commentid":10636,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-11-13 15:11:49 -0800","thetext":"But, default parameter value initializes are also trigger by passing the value undefined.  So you might reasonably say:\n\nvar o={set foo(value=null) {doSomething(value)}};\no.value = undefined;  //null gets passed to doSomething\n\nIt since use cases like this are possible, it seems reasonable to not try to special case away the initializer.  Even though it will be very infrequently used. Fewer special cases is better."},{"commentid":10637,"comment_count":2,"who":{"uid":"jwalden+beo","name":"Jeff Walden (remove +beo to mail)"},"bug_when":"2014-11-13 15:33:15 -0800","thetext":"Oh, right, I forgot that defaults aren't just for not-present arguments (a decision I don't particularly like, but whatever).  Never mind then."}]}}
---
