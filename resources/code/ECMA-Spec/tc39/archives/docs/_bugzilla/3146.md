---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3146,"creation_ts":"2014-08-22 10:08:00 -0700","short_desc":"Please add EnsureNonNeuteredArrayBuffer() common abstract operation","delta_ts":"2015-02-09 17:31:34 -0800","product":"Draft for 6th Edition","component":"editorial issue","version":"Rev 26: July 18, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"d","name":"Domenic Denicola"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":9844,"comment_count":0,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-08-22 10:08:29 -0700","thetext":"Many places in the spec want to check that something is a usable array buffer. We also want to do so for binary streams [1].\n\nCurrently this involves\n\n1. If Type(O) is not Object, throw a TypeError exception.\n2. If O does not have an [[ArrayBufferData]] internal slot throw a TypeError exception.\n3. If the value of Oâ€™s [[ArrayBufferData]] internal slot is undefined, then throw a TypeError exception.\n4. If IsNeuteredBuffer(O) is true, then throw a TypeError exception.\n\nIt would be great to abstract this into\n\n1. ReturnIfAbrupt(EnsureNonNeuteredArrayBuffer(O))\n\n(or, in promise-using specs, RejectIfAbrupt(EnsureNonNeuteredArrayBuffer(O), capability).)\n\n[1]: https://github.com/whatwg/streams/pull/173"},{"commentid":12271,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-09 17:31:21 -0800","thetext":"Step 3 is no longer necessary and a routine doing this would still require two steps to call it and check for the exception, and the difference between two and three steps isn't that great.\n\nPlus, it turns out that now there aren't very many (3-5) places that need to use this exact sequence.\n\nSo, I'm not going to bother with it this time around."}]}}
---
