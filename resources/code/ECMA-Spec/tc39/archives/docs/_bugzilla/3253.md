---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3253,"creation_ts":"2014-10-01 11:58:00 -0700","short_desc":"assignment to const variable don't throw in non-strict code","delta_ts":"2014-12-07 14:34:59 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 27: August 24, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"allen","name":"Allen Wirfs-Brock"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"dslomov","long_desc":[{"commentid":10258,"comment_count":0,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-10-01 11:58:33 -0700","thetext":"On Sep 30, 2014, at 5:09 PM, Shu-yu Guo wrote:\n\nHi all,\n\nIn the current draft, I see 2 different places where assigning to an immutable binding ('const') throws an error:\n\n1) Dynamically throwing a TypeError in SetMutableBinding, http://people.mozilla.org/~jorendorff/es6-draft.html#sec-declarative-environment-records-setmutablebinding-n-v-s\n...\n1) throws only in strict mode code, while 2) throws regardless. 2) is also best effort; seems to be implementation-dependent what \"can statically determine\" entails.\n\nIs the intention that assigning to consts silently nops if the implementation cannot determine the assignment to be to a const statically, in non-strict code, but implementations *should* make a best effort to report such cases eagerly, regardless of strictness? Seems kind of odd to me; perhaps I am misreading?\n\n>response\n\n1) looks like a bug to me.  I pretty sure it was never the intent for assignments to const binding to silently fail in non-strict code. The current semantics of SetMutableBinding is a carry over from ES5 where immutable bindings were only used (I have to double check this) for FunctionExpression function name bindings. The legacy of ES3 (hence non-strict ES5) was to did not throw on assignments to such function name bindings.\n\nI'll probably have to do some extra special casing to preserve the ES3/5 semantics for assignment to function names and make the throw unconditional to other immutable bindings\n\nAllen"},{"commentid":10278,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-10-08 09:12:17 -0700","thetext":"however, after thinking about this for a while I think the current spec'ed behavior is probably necessary in order to not break existing code that uses various pre-ES6 standard forms of const declarations."},{"commentid":10683,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-11-25 22:33:09 -0800","thetext":"also see https://github.com/tc39/tc39-notes/blob/master/es6/2014-11/nov-18.md#43-assignment-to-a-const-static-error\n\nfixed in rev29 editor's draft"},{"commentid":10833,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-12-07 14:34:59 -0800","thetext":"fixed in rev29"}]}}
---
