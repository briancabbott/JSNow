---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":178,"creation_ts":"2011-07-27 10:43:00 -0700","short_desc":"Must settle scoping details for block-scoped bindings","delta_ts":"2011-11-07 13:27:21 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Initial draft July 12, 2011","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","bug_file_loc":"http://wiki.ecmascript.org/doku.php?id=harmony:block_scoped_bindings","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"erights","name":"Mark S. Miller"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"rossberg","flag":{"_attributes":{"name":"TC39Review","id":"5","type_id":"1","status":"?","setter":"allen"}},"long_desc":[{"commentid":392,"comment_count":0,"who":{"uid":"erights","name":"Mark S. Miller"},"bug_when":"2011-07-27 10:43:10 -0700","thetext":"As I recall, there were three possibilities recently raised verbally that are candidates for consensus. The first, which I believe corresponds to the current proposal on the wiki, has the following characteristics:\n\n\"letrec\" semantics with dynamic dead zone\n\n1) Function declarations bring their variable into scope throughout their containing block.\n2) The initialized function variable is initialized hoisted to the beginning of that block.\n3) Const, and let declarations all bring their variable into scope throughout their containing block.\n4) Const and let variables are initialized at the point of their declaration.\n5) Once initialized, const and let variables are live.\n6) An attempt to read a const or let variable before it's live should throw a ReferenceError (or TypeError?).\n7) An attempt to assign to a let variable before it's live should throw a ReferenceError (or TypeError?).\n8) Any attempt to assign to a const variable should be an early error (SyntaxError?).\n\n\"letrec\" semantics with static and dynamic dead zone\n\n9) Like '\"letrec\" semantics with dynamic dead zone' except that, if a const or let variable is used in its block textually \"before\" its declaration, that's an early error. \"before\" means, in earlier statements and declarations, and in the right hand side of the variable's own declaration.\n\n\"let*\" semantics with dynamic dead zone\n\n3) Const and let declarations bring their variable in scope starting from their point of declaration through the end of their containing block, but not including the right side of that declaration.\n1,2,4-8) All the rest are like letrec.\n\n\nI favor '\"letrec\" semantics with dynamic dead zone'."},{"commentid":393,"comment_count":1,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2011-07-27 14:01:14 -0700","thetext":"The main arguments I see for the dynamic dead zone semantics (which essentially views a block as one big recursive binding) are:\n\n1.) let* (or \"C\") semantics for `let' and `const' is inconsistent with the existing lifting semantics for `function', whose scope stretches over the whole block.\n\n2.) letrec with static dead zone does not detect the general case, while also ruling out some perfectly useful programs (e.g., recursive or mutually recursive object definitions via let or const).\n\n3.) Binding semantics should be consistent between local blocks and module/global scope. Since modules are recursive, this pretty much mandates letrec semantics with no static restriction."},{"commentid":398,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2011-07-28 09:04:38 -0700","thetext":"0)formal parameters are treated as if they were let declarations that bring their binding in scope prior to step 1. formal parameters (including parameters bound within destructuring patterns) are bound in left to right order.  If a formal parameter has an initializer, the parameter is only considered initialized after the evaluation of the initializer.  (ie, it is an early error for an initializer to reference the parameter it is initializing or any parameter that is defined to the right of the initializer.)"},{"commentid":399,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2011-07-28 09:13:10 -0700","thetext":"(In reply to comment #1)\n> The main arguments I see for the dynamic dead zone semantics (which essentially\n> views a block as one big recursive binding) are:\n> \n> 1.) let* (or \"C\") semantics for `let' and `const' is inconsistent with the\n> existing lifting semantics for `function', whose scope stretches over the whole\n> block.\n> \n> 2.) letrec with static dead zone does not detect the general case, while also\n> ruling out some perfectly useful programs (e.g., recursive or mutually\n> recursive object definitions via let or const).\n\nbut dynamic deadzones don't help with mutually recursive objects either:\n\nconst obj1 = {other: obj2};  //dynamic error on reference to obj2\nconst obj2 = {other: obj1};\n\nthe error in the definition of obj1 might as well be static\n\nIt is only uplevel references from within inner functions that benefit need to use a dynamic deadzone\n\n\n> \n> 3.) Binding semantics should be consistent between local blocks and\n> module/global scope. Since modules are recursive, this pretty much mandates\n> letrec semantics with no static restriction.\n\nCan you give an example with static would be a problem for the top level WRT modules?"},{"commentid":400,"comment_count":4,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2011-07-28 14:29:07 -0700","thetext":"(In reply to comment #3)\n> (In reply to comment #1)\n> > The main arguments I see for the dynamic dead zone semantics (which essentially\n> > views a block as one big recursive binding) are:\n> > \n> > 1.) let* (or \"C\") semantics for `let' and `const' is inconsistent with the\n> > existing lifting semantics for `function', whose scope stretches over the whole\n> > block.\n> > \n> > 2.) letrec with static dead zone does not detect the general case, while also\n> > ruling out some perfectly useful programs (e.g., recursive or mutually\n> > recursive object definitions via let or const).\n> \n> but dynamic deadzones don't help with mutually recursive objects either:\n> \n> const obj1 = {other: obj2};  //dynamic error on reference to obj2\n> const obj2 = {other: obj1};\n> \n> the error in the definition of obj1 might as well be static\n> \n> It is only uplevel references from within inner functions that benefit need to\n> use a dynamic deadzone\n\nYes. The example I had in mind is one where the recursion goes through methods:\n\nconst x = {f() { ...y...}};\nconst y = {g() { ...x...}};\n\nNow, I think what you had in mind is to make a distinction between references in the same scope, and references in a nested (function) scope. But that seems like even more complication for minor benefit.\n\n> > 3.) Binding semantics should be consistent between local blocks and\n> > module/global scope. Since modules are recursive, this pretty much mandates\n> > letrec semantics with no static restriction.\n> \n> Can you give an example with static would be a problem for the top level WRT\n> modules?\n\nWhen you have recursive modules, all module bodies together basically form one big letrec. So treating their bindings as sequential isn't very meaningful. A per-module static dead zone wouldn't be unsound, but it would be an even less reliable analysis than in function scope."},{"commentid":505,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2011-11-07 13:27:21 -0800","thetext":"These issues were resolved in at TC39 meetings and the resolutions are reflected in the revisions 4 spec. draft."}]}}
---
