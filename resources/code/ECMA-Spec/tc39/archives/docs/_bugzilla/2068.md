---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2068,"creation_ts":"2013-10-07 07:29:00 -0700","short_desc":"Should the method name be added to the method body environment?","delta_ts":"2015-07-10 08:34:19 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 19: September 27, 2013 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"normal","everconfirmed":false,"reporter":{"uid":"arv","name":"Erik Arvidsson"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["andrebargull","erik.arvidsson","waldron.rick"],"long_desc":[{"commentid":5855,"comment_count":0,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2013-10-07 07:29:20 -0700","thetext":"There seems to be some uncertainty about whether the name of a method is bound to the function object inside the method body or not.\n\nhttps://twitter.com/awbjs/status/386690330180874240\nhttps://github.com/google/traceur-compiler/issues/354\n\nFor example:\n\nvar x = 1;\n\nclass C {\n  x() {\n    print(typeof x);\n  }\n}\n\nnew C().x();\n\nWhat does the above print? \"number\" or \"function\"?\n\nThe current draft does not create an immutable binding to the PropertyName for the environment record."},{"commentid":5856,"comment_count":1,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2013-10-07 07:32:56 -0700","thetext":"Marking as invalid. There should be no name binding in the lexical scope."},{"commentid":5857,"comment_count":2,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2013-10-07 08:51:33 -0700","thetext":"In ES5:\n\n  var x = 1;\n\n  var o = {\n    x: function x() {\n      print(typeof x);\n    }\n  }\n\n  o.x(); // function\n\n...Which is exactly what I would expect. \n\nES6:\n\n  var x = 1;\n\n  var o = {\n    x() {\n      print(typeof x);\n    }\n  }\n\n  o.x(); // number\n\n\nThat would surprise me and if it were an issue in the ES5 code, I would've just renamed one or the other to ensure that \"x\" wasn't shadowed in the method's body."},{"commentid":5858,"comment_count":3,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2013-10-07 08:52:25 -0700","thetext":"Erik, I'm going to reopen this because I don't think enough discussion has gone into the semantics as they are currently specified."},{"commentid":5859,"comment_count":4,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2013-10-07 08:55:46 -0700","thetext":"More here: https://github.com/google/traceur-compiler/issues/354#issuecomment-25816117"},{"commentid":5860,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2013-10-07 10:19:43 -0700","thetext":"The question is, given\n    var o = {\n      x() {\n       print(typeof x);\n     }\n   }\n\nwhat is the binding of x with the function body.  Should it be equivalent to:\n    var o = {\n     x: function x() {\n       print(typeof x);  //x is locally bound to the function object\n     }\n   }\n\nor to:\n    var o = {\n     x: function () {\n       print(typeof x);  //x  binds to any outer scope declarations\n     }\n   }\n\nI content that either is a plausible semantics.  But we must decide on only one.  I think that the no binding equivalences is the better choice for the following reasons:\n\n1) Legacy consistency.  We already have a literal property short hand that was introduced in ES5:\n\n    var o = {\n     get x () {\n       print(typeof x);  //x  binds to any outer scope declarations\n     }\n    }   \nAs defined by ES5, getter and setter functions do not bind the property name as the function name. See http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5 and note that a scope containing a binding for the property name is not created. \n\nBecause there isn't any other strong reason for choosing between the alternative concise method name binding semantics, consistency between concise methods and getter/setter functions is probably enough to drive the decision.\n\n2) Lack of utility. The primary use case for binding the function name is so a function may recursively refer to itself.  However, we are talking about concise *methods*.  Methods are functions that are intended to be invoked via a property access and typically refer to a 'this' binding.  The proper way for a method to recursively invoke itself is via a method invocation:\n    var o = {\n      x() {\n       //refine this\n       this.x();\n     }\n   }\nrather than via a direct call. Binding the name of the function is not needed and does not facilitate correct recursive methods. \n\nBased upon these two points I think we should not bind the names of concise methods."},{"commentid":5861,"comment_count":6,"who":{"uid":"waldron.rick","name":"Rick Waldron"},"bug_when":"2013-10-07 10:58:06 -0700","thetext":"(In reply to comment #5)\n> I content that either is a plausible semantics.  But we must decide on only\n> one.  I think that the no binding equivalences is the better choice for the\n> following reasons:\n> \n> 1) Legacy consistency.  We already have a literal property short hand that was\n> introduced in ES5:\n> \n>     var o = {\n>      get x () {\n>        print(typeof x);  //x  binds to any outer scope declarations\n>      }\n>     }   \n> As defined by ES5, getter and setter functions do not bind the property name as\n> the function name. See\n> http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5 and note that a\n> scope containing a binding for the property name is not created. \n> \n> Because there isn't any other strong reason for choosing between the\n> alternative concise method name binding semantics, consistency between concise\n> methods and getter/setter functions is probably enough to drive the decision.\n\nYep, this makes sense. I had thought of the get/set case, but dismissed it because I hoped method shorthand was different enough.\n\n\n> \n> 2) Lack of utility. The primary use case for binding the function name is so a\n> function may recursively refer to itself.  However, we are talking about\n> concise *methods*.  Methods are functions that are intended to be invoked via a\n> property access and typically refer to a 'this' binding.  The proper way for a\n> method to recursively invoke itself is via a method invocation:\n>     var o = {\n>       x() {\n>        //refine this\n>        this.x();\n>      }\n>    }\n> rather than via a direct call. Binding the name of the function is not needed\n> and does not facilitate correct recursive methods. \n> \n> Based upon these two points I think we should not bind the names of concise\n> methods.\n\nI agree, these are the arguments that I was looking for earlier, thank you."}]}}
---
