---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2515,"creation_ts":"2014-02-07 16:05:00 -0800","short_desc":"Resource leak for Promise.race([])","delta_ts":"2014-11-30 10:12:34 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 22: January 20, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"INVALID","priority":"Normal","bug_severity":"enhancement","everconfirmed":false,"reporter":{"uid":"ecmascript","name":"C. Scott Ananian"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["d","ljharb"],"long_desc":[{"commentid":7214,"comment_count":0,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-07 16:05:57 -0800","thetext":"It seems rather suboptimal to have Promise.race() hang forever when given an iterable with no items (likely leaking the returns promise and any promises chained to that, since they will always be 'pending').\n\nIf given an iterable with no items, it would be better to reject with a TypeError (as Array.prototype.reduce does in a similar situation).  You might also resolve with 'undefined', I suppose.  Either way the promise is resolved and the chained promises can be resolved and then disposed.\n\n(If Promise.race() continues to take only an immediate array, not a promise for an array (see issue 2514), then the TypeError could be thrown synchronously.  I think it would be more consistent to allow Promise.race() to accept a promise and to always throw the TypeError asynchronously.)"},{"commentid":7218,"comment_count":1,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-02-08 12:10:30 -0800","thetext":"This is intentional and has been discussed before.\n\nhttps://github.com/domenic/promises-unwrapping/issues/75"},{"commentid":7220,"comment_count":2,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-08 13:12:42 -0800","thetext":"I've added my two cents over in https://github.com/domenic/promises-unwrapping/issues/75 but to briefly recap here:\n\nI strongly disagree with writing a resource leak into the spec.  I think Promise.race() should throw TypeError.  But if you want to make it hang forever for reasons of \"algebraic consistency\" then I think the spec needs to be updated to allow promises chained after a Promise.race([]) to be disposed.\n\nI think the simplest way of doing that is to add a new 'forever-pending' value for [[PromiseStatus]].  We can then observe this status and avoid creating references to uncallable handlers in the implementation of Promise.prototype.then.  A rough draft of how this might be done:\n\n25.4.4.4 Promise.race:\nadd between steps 5 and 6, \"let seen be false\"\nstep 6c of Promise.race, \"if next is false, then: (1) if seen is false, return NewForeverPendingPromise(C). (2) return promiseCapability.[[Promise]].\"\nadd step 6j, \"set seen to true\"\n\n25.4.5.3 Promise.prototype.then ( onFulfilled , onRejected )\nadd between steps 19 and 20, \"Else if the value of promise's [[PromiseStatus]] internal slot is \"forever-pending\", return NewForeverPendingPromise(C)\"\n\n25.4.6 Properties of Promise Instances\nadd \"forever-pending\" to list of acceptable values of [[PromiseStatus]]\nadd \"or not 'forever-pending'\" to the end of the description of [[PromiseResult]]\n\nAdd new helper, \"NewForeverPendingPromise(C)\" with the following definition:\n1. Let promiseCapability be NewPromiseCapability(C).\n2. ReturnIfAbrupt(promiseCapability).\n3. Let promise be promiceCapability.[[Promise]]\n3. If promise does not have a [[PromiseStatus]] internal slot, or its value is not undefined, then throw a TypeError exception.\n4. Set promise's [[PromiseStatus]] internal slot to \"forever-pending\".\n5. Return promise."},{"commentid":7221,"comment_count":3,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-08 13:14:53 -0800","thetext":"Reopening and retitling bug to describe how to avoid the resource leak if the infinite hang is actually desired."},{"commentid":7223,"comment_count":4,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-08 14:02:22 -0800","thetext":"The algorithm in comment 2 is not quite right.  For example:\n\nclass TimeoutPromise extends Promise {\n    constructor(resolver) {\n      super((resolve, reject) => {\n        setTimeout(() => reject(new TimeoutError()), TIMEOUT);\n        return resolver(resolve, reject);\n      });\n    }\n}\nTimeoutPromise.race([]); // this should actually reject\n\nThe easiest solution is to only return a new NewForeverPendingPromise if C is %Promise%.\n\nBut a better solution is to probably use weak references carefully such that the only strong references to a promise P are held by its resolve and reject functions.  For example, all references in a PromiseCapability (held by PromiseReaction, etc) would be weak.  If done carefully, a \"forever pending\" promise would magically become gc'able when it is no longer possible to resolve or reject it, as in Promise.race([]), and disposing that promise would then eliminate the references to the resolution functions of other promises chained with `then`.  That is, the goal would be that after:\n\nvar p = Promise.race([]).then(function(){...}).then(function(){...});\n\nonly 1 promise (and none of the anonymous onFulfill functions) should be live."},{"commentid":7224,"comment_count":5,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-08 14:44:13 -0800","thetext":"Hm.  I think I'm about to eat my words.\n\nI drew a little diagram of where all the strong references are, and I think\n\nvar p = Promise.race([]).then(function(){...}).then(function(){...});\n\nalready works as I wanted, according to the spec.  The two cases are:\n\nvar p = new Promise(function(f, r) { ... }); // case 1\n\nIn case 1, f and r hold the only references to p, exactly how we'd like.\n\nvar p2 = p1.then(f, r); // case 2\n\nIn case 2 we create a number of objects:\n1) pc, a PromiseCapability for p2\n2) pr1, a rejection PromiseReaction, which holds pc and r\n3) prh, a Promise Resolution Handler, which holds p1, f, and r\n4) pr2, a resolution PromiseReaction, which holds pc and prh\n\nAnd then p1 is made to hold pr1 and pr2.\n\nSo if p1 becomes unreachable (and its resolution functions are unreachable, as in the case of the result of Promise.race([])), then pr1 and pr2 are also unreachable, which makes pc, prh, f, and r unreachable.  Assuming that no one has stolen copies of pc's [[Resolve]] and [[Reject]] functions, then p2 is unreachable as well, just as we want.\n\nSo p2 ultimately isn't holding any sort of reference to p1, and unresolvable promises ultimately become unreachable.  QED.\n\nI still think that Promise.race([]) is a debugging nightmare.  But at least it's not a resource leak."},{"commentid":7225,"comment_count":6,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2014-02-08 15:32:38 -0800","thetext":"I would still caution you against taking the spec's descriptions of the data structures in play as having any actual impact on what strong references are present in the system. Only the observable semantics matter, not the exact algorithmic steps given in the spec."},{"commentid":7286,"comment_count":7,"who":{"uid":"ecmascript","name":"C. Scott Ananian"},"bug_when":"2014-02-12 20:17:50 -0800","thetext":"I don't like the API as a developer, but I'm convinced there isn't an inherent resource leak here.  Resolving as invalid."}]}}
---
