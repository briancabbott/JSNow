---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3526,"creation_ts":"2015-01-15 04:57:00 -0800","short_desc":"yield* broken for throw()","delta_ts":"2015-02-02 18:38:52 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 31: January 15, 2015 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"wingo","name":"Andy Wingo"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["andrebargull","jandemooij","jorendorff","marc.nieper+bugzilla"],"long_desc":[{"commentid":11361,"comment_count":0,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2015-01-15 04:57:28 -0800","thetext":"The semantics for the interaction between throw() and yield* seem to have changed in a recent revision of the spec.  The text now is:\n\nYieldExpression : yield * AssignmentExpression\n1. Let exprRef be the result of evaluating AssignmentExpression.\n2. Let value be GetValue(exprRef).\n3. Let iterator be GetIterator(value).\n4. ReturnIfAbrupt(iterator).\n5. Let received be NormalCompletion(undefined).\n6. Repeat\n   a. If received.[[type]] is normal, then\n      i. Let innerResult be IteratorNext(iterator, received.[[value]]).\n      ii. ReturnIfAbrupt(innerResult).\n      iii. Let done be IteratorComplete(innerResult).\n      iv. ReturnIfAbrupt(done).\n      v. If done is true, then\n         1. Return IteratorValue (innerResult).\n      vi. Let received be GeneratorYield(innerResult).\n   b. Else if received.[[type]] is throw, then\n      i. Let hasThrow be HasProperty(iterator, \"throw\").\n      ii. ReturnIfAbrupt(hasThrow).\n      iii. If hasThrow is true, then\n         1. Let innerResult be Invoke(iterator, \"throw\", «‍received.[[value]]»).\n         2. ReturnIfAbrupt(innerResult).\n         3. NOTE: Exceptions from the inner iterator throw method are propagated.\n      iv. Return received.\n   c. Else,\n      i. Assert: received.[[type]] is return.\n      ii. Let hasReturn be HasProperty(iterator, \"return\").\n      iii. ReturnIfAbrupt(hasReturn).\n      iv. If hasReturn is false, then return received.\n      v. Let innerReturnValue be Invoke(iterator, \"return\", «‍received.[[value]]»).\n      vi. ReturnIfAbrupt(innerReturnValue).\n      vii. If Type(innerReturnValue) is not Object, then throw a TypeError exception.\n      viii. Let returnValue be IteratorValue(innerReturnValue).\n      ix. ReturnIfAbrupt(returnValue).\n      ix. Return Completion{[[type]]: return , [[value]]: returnValue , [[target]]:empty}.\n\nSo now if we have the coroutine:\n\nfunction* ones_coroutine() {\n  while (true) {\n    try {\n      yield 1;\n    } catch (e) {}\n  }\n}\n\nAnd the yield* wrapper:\n\nfunction* wrap(iterable) {\n  return yield* iterable\n}\n\nI thought that the intention behind yield* was that wrap(ones_coroutine()) would be equivalent to ones_coroutine().\n\nHowever now they are different; consider\n\nvar i1 = ones_coroutine()\ni1.next() // { value: 1, done: false }\ni1.throw('foo') // { value: 1, done: false }\ni1.next() // { value: 1, done: false }\n\nvar i2 = wrap(ones_coroutine())\ni2.next() // { value: 1, done: false }\ni2.throw(42) // { value: undefined, done: true }\ni2.next() // { value: undefined, done: true }\n\nThis is particularly egregious for async functions, consider:\n\nvar task = async(function* () { ... yield* subtask(); ... });\nvar subtask = async(function* () { ... });\n\nNow if a promise yielded by subtask() fails, subtask() will not have the chance to recover from the error and continue processing, yielding further values.  This seems to me to be an error in the specification."},{"commentid":11363,"comment_count":1,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2015-01-15 05:09:58 -0800","thetext":"Jan pointed out to me that i2.throw(42) would throw 42 instead of returning { done: true, value: undefined }.  Thanks Jan.  Still, the point stands."},{"commentid":11550,"comment_count":2,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2015-01-19 01:41:27 -0800","thetext":"This behavior is present in the latest draft too.  Allen, can you confirm please?"},{"commentid":11551,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-19 08:12:39 -0800","thetext":"I haven't had a chance to get into it yet.  Hopefully this week"},{"commentid":11553,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-19 14:05:16 -0800","thetext":"(In reply to Andy Wingo from comment #0)\n> The semantics for the interaction between throw() and yield* seem to have\n> changed in a recent revision of the spec.  The text now is:\n> \n\nActually, it's been this way since generator semantics for first incorporated into the spec. (I checked)\n\nBut, I agree the currently spec'd behavior is a bug.\n\nFix on the way."},{"commentid":11554,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-19 14:14:39 -0800","thetext":"fixed in rev32 editor's draft.\n\nthe 'ReturnIfAbrupt' in step 6.b.iii.2 should just be a 'return'"},{"commentid":11557,"comment_count":6,"who":{"uid":"wingo","name":"Andy Wingo"},"bug_when":"2015-01-20 00:36:33 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #5)\n> fixed in rev32 editor's draft.\n> \n> the 'ReturnIfAbrupt' in step 6.b.iii.2 should just be a 'return'\n\nThanks for taking a look, Allen! :)\n\nShouldn't 6.b.iv not be executed if hasThrow is true?  I mean, if the iterator has \"throw\", calling the throw method should update \"received\" and loop, seems to me."},{"commentid":11561,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-20 09:58:27 -0800","thetext":"(In reply to Andy Wingo from comment #6)\n\n> \n> Shouldn't 6.b.iv not be executed if hasThrow is true?  I mean, if the\n> iterator has \"throw\", calling the throw method should update \"received\" and\n> loop, seems to me.\n\nIt's even more complex than that:\n\n\nb.  Else if received.[[type]] is throw, then\n  i.  Let hasThrow be HasProperty(iterator, \"throw\").\n  ii.  ReturnIfAbrupt(hasThrow).\n  iii. If hasThrow is true, then\n    1.   Let innerResult be Invoke(iterator, \"throw\", «received.[[value]]»).\n    2.\t ReturnIfAbrupt(innerResult).\n    3.\t NOTE:  Exceptions from the inner iterator throw method are propagated. Normal completions from an inner throw method are processed just like an inner next.\n    4.\t If Type(innerResult) is not Object, throw a TypeError exception.\n    5.\t Let done be IteratorComplete(innerResult).\n    6.\t ReturnIfAbrupt(done).\n    7.\t If done is true, return IteratorValue(innerResult).\n    8.\t Let received  be GeneratorYield(innerResult).\n      iv.  Else,\n        1.   NOTE:  If iterator does not have a throw method, this throw is going to terminate the yield* loop. But first we need to give iterator a chance to clean up.\n        2.   Return IteratorClose(iterator,  received)."},{"commentid":11749,"comment_count":8,"who":{"uid":"marc.nieper+bugzilla","name":"Marc Nieper-Wißkirchen"},"bug_when":"2015-01-29 02:49:44 -0800","thetext":"What about the following example?\n\nvar x;\n\nfunction* ones_coroutine() {\n  try {\n    yield 1;\n  } finally {\n    yield 2;\n    x = 10;\n  }\n}\n\nfunction* wrap(iterable) {\n  return yield* iterable;\n}\n\nx = 0;\nlet g = ones_coroutine();\ng.next() // -> {value: 1, done: false}\ng.return(42) // -> {value: 2, done: false}\ng.next() // -> {value: 42, done: true}\nx // -> 10\n\nx = 0;\nlet h = wrap(ones_coroutine());\nh.next() // -> {value: 1, done: false}\nh.return(42) // -> {value: 2, done: true}\nh.next() // -> {value: undefined, done: true}\nx // -> 0\n\nIf I understand the rev 31 of the draft correctly, the values behind the comments // -> reflect what the draft describes. However, this means that ones_coroutine() behaves very differently to wrap(ones_coroutine()).\n\nThis semantics seems not very plausible to me. I would be expecting that all finally clauses are being run when a generator (even an inner one) is being closed by a call to return."},{"commentid":11956,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-02 18:38:52 -0800","thetext":"fixed in rev32 draft"}]}}
---
