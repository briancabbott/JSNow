---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4315,"creation_ts":"2015-04-17 09:21:00 -0700","short_desc":"Extend Object.is to reject suspicious invocation patterns","delta_ts":"2015-04-17 09:21:43 -0700","product":"Draft for 7th Edition","component":"New feature suggestons","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"CONFIRMED","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":"mike","assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":14283,"comment_count":0,"who":"mike","bug_when":"2015-04-17 09:21:43 -0700","thetext":"The ES6 specification defines `Object.is` as follows:\n\n> 19.1.2.10 Object.is ( value1, value2 )\n> \n> When the is function is called with arguments value1 and value2 the following\n> steps are taken:\n>\n>     1. Return SameValue(value1, value2).\n\nThis allows for two somewhat bizarre invocations:\n\n    Object.is(undefined); // true\n    Object.is();          // true\n\nThe latter looks more strange, but it is unlikely to cause problems in real code. The former presents a refactoring hazard. Generally speaking, code written like this:\n\n     if (Object.is(x,y[z])) {\n       // etc.\n     }\n\nMay be mistakenly refactored as:\n\n    if (Object.is(x[z])) {\n      // etc.\n    }\n\nThis kind of problem is most frequently exhibited by JavaScript assertion libraries today. By silently accepting suspicious invocation patterns, functions like these miss an important opportunity to alert developers of probable sources of errors.\n\nI'd like to propose an extension to the implementation of `Object.is`:\n\n> 19.1.2.10 Object.is ( value1, value2 )\n> \n> When the is function is called with arguments value1 and value2 the following\n> steps are taken:\n>\n> 1. If value1 is not present or if value2 is not present,\n>    then throw a TypeError exception.\n> 2. Return SameValue(value1, value2)."}]}}
---
