---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3111,"creation_ts":"2014-08-07 12:44:00 -0700","short_desc":"MapConstructor & WeakMapConstructor should do ToObject too?","delta_ts":"2015-07-10 08:34:21 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 26: July 18, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"arv","name":"Erik Arvidsson"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"erik.arvidsson","long_desc":[{"commentid":9710,"comment_count":0,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-08-07 12:44:37 -0700","thetext":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-weakmap-iterable\n\n7d: Let iter be the result of GetIterator(iterable).\n\nFor Set & WeakSet we are doing GetIteraror(ToObject(iterable))\n\nHowever, maybe we should just change GetIterator to not throw on non Objects."},{"commentid":9715,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-07 14:04:15 -0700","thetext":"fixed in rev27 editor's draft"},{"commentid":9757,"comment_count":2,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-08-11 20:00:20 -0700","thetext":"Allen, what was the resolution?"},{"commentid":9759,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-12 08:14:45 -0700","thetext":"(In reply to Erik Arvidsson from comment #2)\n> Allen, what was the resolution?\n\nBy passing ToObject(iterable) to GetIterator\n\nIf we made GetIterator not throw on none objects, then we'd have to define what it does instead.  Return an empty iterator?  After reviewing everyplace GetIterator is used, I don't think it is necessary."},{"commentid":9764,"comment_count":4,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-08-12 11:02:28 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #3)\n> (In reply to Erik Arvidsson from comment #2)\n> > Allen, what was the resolution?\n> \n> By passing ToObject(iterable) to GetIterator\n> \n> If we made GetIterator not throw on none objects, then we'd have to define\n> what it does instead.  Return an empty iterator?  After reviewing everyplace\n> GetIterator is used, I don't think it is necessary.\n\nGetIterator + CheckIterator throws if not an object or the value of Get(obj, @@iterator) is not callable. It also throws if the result of that call is not an object.\n\nAn alternative approach would be to use CheckObjectCoercible and throw (throw for null and undefined). Then do the Get(value, @@iterator) and throw if not callable or the result of that call is not an object.\n\nThis is of course observable if you have a getter for Number.prototype[Symbol.iterator] and you check the type of this (in strict mode)."},{"commentid":9765,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-12 11:53:08 -0700","thetext":"(In reply to Erik Arvidsson from comment #4)\n> (In reply to Allen Wirfs-Brock from comment #3)\n> > (In reply to Erik Arvidsson from comment #2)\n> > > Allen, what was the resolution?\n> > \n> > By passing ToObject(iterable) to GetIterator\n> > \n> > If we made GetIterator not throw on none objects, then we'd have to define\n> > what it does instead.  Return an empty iterator?  After reviewing everyplace\n> > GetIterator is used, I don't think it is necessary.\n> \n> GetIterator + CheckIterator throws if not an object or the value of Get(obj,\n> @@iterator) is not callable. It also throws if the result of that call is\n> not an object.\n> \n> An alternative approach would be to use CheckObjectCoercible and throw\n> (throw for null and undefined). Then do the Get(value, @@iterator) and throw\n> if not callable or the result of that call is not an object.\n> \n> This is of course observable if you have a getter for\n> Number.prototype[Symbol.iterator] and you check the type of this (in strict\n> mode).\n\nIt's really up to the caller of GetIteator to decide if it wants to accept primitive values and and at what point it wants any observable ToObject operations to occur.  \n\nI don't really see any issues in the way it currently works."},{"commentid":9767,"comment_count":6,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-08-12 12:36:33 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #5)\n> (In reply to Erik Arvidsson from comment #4)\n> > (In reply to Allen Wirfs-Brock from comment #3)\n> > > (In reply to Erik Arvidsson from comment #2)\n> > > > Allen, what was the resolution?\n> > > \n> > > By passing ToObject(iterable) to GetIterator\n> > > \n> > > If we made GetIterator not throw on none objects, then we'd have to define\n> > > what it does instead.  Return an empty iterator?  After reviewing everyplace\n> > > GetIterator is used, I don't think it is necessary.\n> > \n> > GetIterator + CheckIterator throws if not an object or the value of Get(obj,\n> > @@iterator) is not callable. It also throws if the result of that call is\n> > not an object.\n> > \n> > An alternative approach would be to use CheckObjectCoercible and throw\n> > (throw for null and undefined). Then do the Get(value, @@iterator) and throw\n> > if not callable or the result of that call is not an object.\n> > \n> > This is of course observable if you have a getter for\n> > Number.prototype[Symbol.iterator] and you check the type of this (in strict\n> > mode).\n> \n> It's really up to the caller of GetIteator to decide if it wants to accept\n> primitive values and and at what point it wants any observable ToObject\n> operations to occur.  \n> \n> I don't really see any issues in the way it currently works.\n\nThe problem right now is that GetIterator requires the argument to be an object. I would prefer if GetIterator worked on values and if the caller does not want to iterator values they can throw if not an object.\n\nThe way it is now creates a useless object (which is observable)"},{"commentid":9768,"comment_count":7,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-12 12:53:45 -0700","thetext":"(In reply to Erik Arvidsson from comment #6)\n I don't really see any issues in the way it currently works.\n> \n> The problem right now is that GetIterator requires the argument to be an\n> object. I would prefer if GetIterator worked on values and if the caller\n> does not want to iterator values they can throw if not an object.\n> \n> The way it is now creates a useless object (which is observable)\n\nBut that observable object is just the same as the semantics of \n   44[anyKey]\nwhen anykey is an accessor property of Number.prototype which has a non-strict getter function. So I don't see why you are concerned about that observable object.\n\nWe could special case all the places where we use GetIterator so they each decide exactly which primitive values they want to accept.  It it seems much more consistent for the normal behavior to just be ToObject.\n\nfinbally, while Number.prototype doesn't have an standard @@iterator, I don't think we would want to preclude somebody from defining it."},{"commentid":9769,"comment_count":8,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-08-12 13:16:14 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #7)\n> (In reply to Erik Arvidsson from comment #6)\n>  I don't really see any issues in the way it currently works.\n> > \n> > The problem right now is that GetIterator requires the argument to be an\n> > object. I would prefer if GetIterator worked on values and if the caller\n> > does not want to iterator values they can throw if not an object.\n> > \n> > The way it is now creates a useless object (which is observable)\n> \n> But that observable object is just the same as the semantics of \n>    44[anyKey]\n> when anykey is an accessor property of Number.prototype which has a\n> non-strict getter function. So I don't see why you are concerned about that\n> observable object.\n\nI'm not concerned about the observable effect but as it is now the spec mandates that you do a ToObject first or it will fail the test262 test for this edge case.\n\n> We could special case all the places where we use GetIterator so they each\n> decide exactly which primitive values they want to accept.  It it seems much\n> more consistent for the normal behavior to just be ToObject.\n\nMy point is that we should not special case GetIterator + CheckIterator. It should just do `value[Symbol.iterator]()` and not care what type value has.\n \n> finbally, while Number.prototype doesn't have an standard @@iterator, I\n> don't think we would want to preclude somebody from defining it.\n\nOf course. I used Number.prototype as an example because it does not have an iterator in ES6."},{"commentid":9773,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-12 14:54:29 -0700","thetext":"(In reply to Erik Arvidsson from comment #8)\n> (In reply to Allen Wirfs-Brock from comment #7)\n> > \n\n> > But that observable object is just the same as the semantics of \n> >    44[anyKey]\n> > when anykey is an accessor property of Number.prototype which has a\n> > non-strict getter function. So I don't see why you are concerned about that\n> > observable object.\n> \n> I'm not concerned about the observable effect but as it is now the spec\n> mandates that you do a ToObject first or it will fail the test262 test for\n> this edge case.\n\nRight, the way I have it currently spec'ed\n  1.  ToObject and any observable effects\n  2   Any oberable effects of Get @@iterator\n  3.  IsCallable exceptions\n  3.  object TypeCheck on result\n\n44[anykey]() does:\n  1. CheckObjectCoercible/ToObject\n  2. Get anykey\n  3. IsCallable\n\nSo, the  ordering of observable events is the same, which is presumably something that could/should be checked by test262\n\n> \n> > We could special case all the places where we use GetIterator so they each\n> > decide exactly which primitive values they want to accept.  It it seems much\n> > more consistent for the normal behavior to just be ToObject.\n> \n> My point is that we should not special case GetIterator + CheckIterator. It\n> should just do `value[Symbol.iterator]()` and not care what type value has.\n\nBut at the spec level we don't have a single abstraction operation that does the equivalent of 'value[Symbol.Iterator]()'.  And we have plenty of places where we throw instead of coerce prior to calling a property.  \n\nI could do some restructuring and have some more abstract operations, but it wouldn't change the actual semantics and at this point in time, I doen't think it would be a high priority.  \n\n\nOf course, I may just be stubbornly missing your point.  If so keeping trying and I'll probably eventually see it."},{"commentid":9774,"comment_count":10,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2014-08-12 15:00:16 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #9)\n\n> Of course, I may just be stubbornly missing your point.  If so keeping\n> trying and I'll probably eventually see it.\n\nI think you are missing my point. I'll try to create a diff on the spec with what I mean tomorrow."},{"commentid":9918,"comment_count":11,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-25 08:29:25 -0700","thetext":"fixed in rev27 draft"}]}}
---
