---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":2984,"creation_ts":"2014-06-10 08:57:00 -0700","short_desc":"Ch.14, cumulative bugs & suggestions","delta_ts":"2014-07-18 14:40:27 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 23: April 5, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","see_also":"https://bugs.ecmascript.org/show_bug.cgi?id=3005","priority":"Normal","bug_severity":"enhancement","everconfirmed":true,"reporter":{"uid":"rossberg","name":"Andreas Rossberg"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"andrebargull","long_desc":[{"commentid":8875,"comment_count":0,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-06-10 08:57:25 -0700","thetext":"Ch.14, cumulative bugs & suggestions\n\n[Note: this is against Rev. 23, some things might have been fixed or changed already.]\n\n\nTECHNICAL ISSUES\n\n14.1.2, 1st case, last bullet: I thought we decided to drop this restriction (at the 2014/09/18 meeting)\n14.2.1, 1st case, 2nd bullet: dito\n14.2.1, 2nd case: \"if any early errors are present\" seems an inadequate formulation. For example, there might be early ReferenceErrors. It doesn't make sense to convert them to SyntaxErrors in this rule.\n\n14.3.1, 1st case, 2nd bullet: we decided to drop this, see above\n14.3.1, 2nd case, last bullet: dito\n14.4.1, 1st case, 2nd bullet: dito\n14.4.1, 2nd case, last bullet: dito\n\n14.5.17: steps 15.b and 17.b return without resetting the context's environment\n\n14.6: The specification of IsInTailPosition seems broken. It just verifies that there exists _some_ occurrence of the phrase in question in tail position, but does not check that it is the one we are looking for. For example, consider \"() => { f(); return f() }\". AFAICS, given the definition as is, IsInTailPosition would give true no matter which call to f() we are asking for.\n\n14.6.2.1, last case: \"Finally\" -> \"Block\"\n14.6.3, step 3: \"it remains in its suspended state\" -- I'm not sure I understand, \"it\" refers to the now-on-top context, which is not the suspended one\n\n\nSUGGESTIONS\n\n14.1.8: Why not define that in terms of BoundNames being empty/non-empty?\n\n\nTYPOS & FORMATTING\n\n14.1.2: layout of first production\n14.1.14: bogus xref to 13.11.2\n14.2.16: bogus xref to 14.1.18 (should be 14.1.19)\n14.2.16, Note: \"is\" -> \"in\"\n14.4.11: spurious comma in xrefs\n14.4.13: bogus xref to 14.1.18 (should be 14.1.19)\n14.5.1, 2nd case, 1st bullet: formatting\n14.6.2.2, cases for Expression: formatting of 'Expression' and 'AssignmentExpression'"},{"commentid":9123,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-02 11:13:27 -0700","thetext":"Re: let redeclaration of parameters in body issues (14.1.2, 14.2.1):\n\nhttps://github.com/rwaldron/tc39-notes/blob/master/es6/2013-09/sept-18.md#--rules-about-redeclaration show an example: \n\nfunction f(x = {}) {\n  let x;\n}\n\n// Error for redeclaration.\n\nand I don't see any discussion or recorded decision that changes that. \n\nAs the the rationale, consider:\n\nfunction (x  = { } {\n   var x;\n   let x;\n}\n\nwould definitely be an error under our current static semantics. It's a var/let conflict. And formal parameters are var-like, in the sense that in:\n\nfunction (x= { }) {\n   var x;\n}\n\nthe var declaration of x does not introduce a new x binding the body scope.  Hence, it is equivalent to: \n\nfunction (x= { }) {\n}\n\nGiven that equivalence, it seems that\nfunction (x  = { } {\n   var x;\n   let x;\n}\n\nand \n\nfunction (x  = { } {\n   let x;\n}\n\nshould use the static 'let/var conflict rules.\n\nThe rule: It is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the LexicallyDeclaredNames of FunctionBody.\n\nIs an easy to understand statement of this restriction."},{"commentid":9124,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-02 13:19:10 -0700","thetext":"fixed in rev26 editor's draft.\n\nExcept for the the parameter/let conflict which I don't I believe is correct.\n\nFor 14.6 added a note that the algorithms are comparing an actual matched production corresponding to a specific source code range and looking for the equivalent source.  A round about way to avoid talking about ASTs and AST subtree matching."},{"commentid":9125,"comment_count":3,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-07-03 04:51:14 -0700","thetext":"Hm, it's the logical consequence of the two scopes decision. I notedly remember this point being clarified in the discussion (by Brendan?), but yeah, I can't find that in the notes. OTOH, I think the code snippet you cite was merely a discussion item, not a resolution.\n\nThe arguments were: Minimise rules and special cases. {} indicates a block, it should behave like one. No reason for special nannying in this one case.\n\nIn particular, I think one can reasonably expect the following equivalence to hold for arrow functions and do expressions in ES7:\n\n  (...) => {...}    ===    (...) => do {...}"},{"commentid":9126,"comment_count":4,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-07-03 05:48:08 -0700","thetext":"(In reply to comment #3)\n> Hm, it's the logical consequence of the two scopes decision.\n\nTwo scopes are only created if parameter defaults are present. If no defaults are present a single scope is required to preserve backwards compatibility (-> deletable eval bindings). \n\n\n> The arguments were: Minimise rules and special cases. {} indicates a block, it\n> should behave like one. No reason for special nannying in this one case.\n\nExcept in `catch` blocks, but that's a different story..."},{"commentid":9128,"comment_count":5,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-07-03 22:36:58 -0700","thetext":"(In reply to comment #4)\n> Two scopes are only created if parameter defaults are present. If no defaults\n> are present a single scope is required to preserve backwards compatibility (->\n> deletable eval bindings). \n\nThe question only affects block-scoped bindings, so there shouldn't be any compatibility issue either way.\n\n> > The arguments were: Minimise rules and special cases. {} indicates a block, it\n> > should behave like one. No reason for special nannying in this one case.\n> \n> Except in `catch` blocks, but that's a different story...\n\nRight. I think the same principle should apply there."},{"commentid":9129,"comment_count":6,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-07-03 23:47:34 -0700","thetext":"(In reply to comment #5)\n> The question only affects block-scoped bindings, so there shouldn't be any\n> compatibility issue either way.\n> \n\nDoes that mean that in the following function `f`, `p` and `a` are in the same scope, whereas `b` is in a different (nested) scope?\n\nfunction f(p) {\n  var a;\n  let b;\n}\n\nVar-scoped variables and parameters need to live in the same scope, so compatibility is preserved for this example:\n\nfunction g(x) {\n  print(x);\n  eval(\"var x = 1\");\n  print(x);\n  delete x;\n  print(x);\n}\ng(0); // Prints \"0 1 1\"\n\nNB: If `x` is a default parameter, the example will print \"0 1 0\" instead (per the current semantics in rev25)."},{"commentid":9131,"comment_count":7,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-07-07 02:42:35 -0700","thetext":"(In reply to comment #6)\n> (In reply to comment #5)\n> > The question only affects block-scoped bindings, so there shouldn't be any\n> > compatibility issue either way.\n> \n> Does that mean that in the following function `f`, `p` and `a` are in the same\n> scope, whereas `b` is in a different (nested) scope?\n> \n> function f(p) {\n>   var a;\n>   let b;\n> }\n\nThis would simply behave like\n\n function f(p) {{\n   var a;\n   let b;\n }}\n\ndoes with what's currently spec'ed. That is, `a` is hoisted to the same scope as `p`, but `b`, being block-scoped, isn't.\n\nI'm not sure I understand what your concern is. The question is whether function bodies should behave as block scopes. That's irrelevant to `var`, because its meaning is never affected by the absence or presence of block scopes. Var-scoping is broken beyond repair, nobody suggests we could fix that. But having as simple & uniform rules as possible for lexical scoping would be preferable.\n\n> Var-scoped variables and parameters need to live in the same scope, so\n> compatibility is preserved for this example:\n> \n> function g(x) {\n>   print(x);\n>   eval(\"var x = 1\");\n>   print(x);\n>   delete x;\n>   print(x);\n> }\n> g(0); // Prints \"0 1 1\"\n> \n> NB: If `x` is a default parameter, the example will print \"0 1 0\" instead (per\n> the current semantics in rev25).\n\nYes, no change here."},{"commentid":9132,"comment_count":8,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-07-07 05:38:09 -0700","thetext":"(In reply to comment #7)\n> This would simply behave like\n> \n>  function f(p) {{\n>    var a;\n>    let b;\n>  }}\n> \n> does with what's currently spec'ed. That is, `a` is hoisted to the same scope\n> as `p`, but `b`, being block-scoped, isn't.\n\nIIUC: Functions without default parameters will have two scopes - one scope for parameters and var-declared bindings and an additional scope for lexical bindings. Functions with defaults will have three scopes - the parameter list scope, the var-declared bindings scope and the lexical bindings scope. Is that correct?\n\n> I'm not sure I understand what your concern is. The question is whether\n> function bodies should behave as block scopes.\n\nI just wanted to point out that parameters and var-declared bindings in functions without defaults should live in the same scope. That way (unnecessary?) differences between ES5 and ES6 semantics are reduced. Cf. the wrong \"invisible environment\" statement in [1].\n\n[1] https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-8.md#41-review-latest-spec-draft"},{"commentid":9144,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-10 13:14:24 -0700","thetext":"added bug 3005 to track issue regard parameter/let name conflict early error"},{"commentid":9283,"comment_count":10,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-07-18 14:40:27 -0700","thetext":"in rev26"}]}}
---
