---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":78,"creation_ts":"2011-03-21 12:02:00 -0700","short_desc":"global declarations and preexisting inherited global properties","delta_ts":"2015-10-02 14:33:03 -0700","product":"ECMA-262, Editions 5 and 5.1","component":"technical content","version":"Edition 5.1","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","bug_severity":"major","blocked":152,"everconfirmed":true,"reporter":{"uid":"allen","name":"Allen Wirfs-Brock"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["brendan","dherman","jorendorff","mathias","rossberg","waldron.rick"],"long_desc":[{"commentid":165,"comment_count":0,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2011-03-21 12:02:12 -0700","thetext":"From https://mail.mozilla.org/pipermail/es5-discuss/2011-January/003882.html \n\nIn an previous thread (https://mail.mozilla.org/pipermail/es5-discuss/2010-July/003606.html), issues related to processing global function declarations whose name is the same as an already defined property of the global object were discussed.  The result was a change to the ES5 Declaration Binding Instantiations section 10.5 steps 5.e-5.f that have been incorporated into the ES 5.1 spec.\n\nThose changes were motivated mostly by issues related to what happens if the preexisting property is not configurable or if it is a setter.  In general, we tried to preserve ES3 semantics except where it directly clashed with new ES5 features.\n\nOne issue we didn't explicitly deal with in the previous discussion was the handling for preexisting global properties that are inherited properties rather than own properties of the global objects.  That is the topic of this post.  (Also see https://bugzilla.mozilla.org/show_bug.cgi?id=624364 )\n\nMore concretely, how should ECMAScript deal with the following situation in an implementation where the global object inherits from Object.prototype:\n\n<script type=\"text/javascript\">\nObject.defineProperty(Object.prototype,\"a\", {writable: false, configurable: false});\nObject.defineProperty(Object.prototype,\"b\", {writable: false, configurable: false});\nObject.defineProperty(Object.prototype,\"c\", {writable: true, configurable: false});\n</script>\n<script type=\"text/javascript\">\nfunction a() {}\n</script>\n<script type=\"text/javascript\">\n var b=\"foo\";\n</script>\n<script type=\"text/javascript\">\nvar c=\"bar\";\n</script>\n\nNote that multiple script blocks are shown to indicate that they are sequentially processed as independent ECMAScript Programs. According to the ES5.1 spec.  The function declaration will throw a TypeError because the the inherited property \"a\" is not writable. The declaration of b does not create a own property of the global object (because the a inherited property already exists) and its initialization assignment will silently do nothing (default action for a [[Put]] to an inherited non-writable property. The declaration of c also does not directly create an own property of the global object; however, the initialization assignment does create such an own property whose [[Configurable]] attribute is always true even though var declaration (outside of evals) create properties whose [[Configurable]] attribute is false.\n\nThe root of the problem is that the Object Environment Records treat inherited properties as defined bindings and the 10.5 algorithm does not create new bindings when one does already exist.  This is arguably consistent with ES3 which does not distinguishes between own and inherited properties  in its variable instantiation spec.  However, in ES3 it wasn't an important distinction as without user configurable attributes it was hard to observe the difference.  \n\nBefore describing, the specification fix it's probably a good idea to define the actual desire behavior:\n\n1) \"variable\" accesses that bind to inherited properties of the global object should return the current value of the inherited property.\n2) \"variable\" assignments  to inherited properties of the global object should be equivalent to a [[Put]] to the global object.  Whether or not a own property is created depends upon the [[Writable]] attribute of the inherited property and the extensible internal property of the global object.\n\nThe ES5.1 spec. correctly defines the above two behaviors\n\n3) global function and var declarations always create own properties of the global object.  If an inherited property of the same name already exists it is over-ridden with an own property. \n4) The declaration instantiation rules relating to pre-existing bindings are only consider own properties of the global object.  Inherited properties of the global object have no effect upon the processing of function and var declarations.\n\nThe ES5.1 spec. does not correctly define behaviors 3&4.\n\nThe fixes:\n\nFunction declarations are handled by step 5 of 10.5.  The ES5.1 spec. is:\n\n5.     For each FunctionDeclaration f in code, in source text order do\n   a.      Let fn be the Identifier in FunctionDeclaration f.\n   b.      Let fo be the result of instantiating FunctionDeclaration f as described in Clause 13.\n   c.      Let funcAlreadyDeclared be the result of calling env’s HasBinding concrete method passing fn as the argument.\n   d.      If funcAlreadyDeclared is false, call env’s CreateMutableBinding concrete method passing fn and configurableBindings as the arguments.\n   e.      Else if env is the environment record component of the global environment then\n          i.         Let go be the global object.\n         ii.         Let existingProp be the resulting of calling the [[GetProperty]] internal method of go with argument fn.\n        iii.         If existingProp .[[Configurable]] is true, then\n               1.     Call the [[DefineOwnProperty]] internal method of go, passing fn, Property Descriptor {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configurableBindings }, and true as arguments.\n        iv.         Else if IsAccessorDescriptor(existingProp) or existingProp does not have attribute values {[[Writable]]: true, [[Enumerable]]: true}, then\n                1.     Throw a TypeError exception.\n   f.        Call env’s SetMutableBinding concrete method passing fn, fo, and strict as the arguments.\n\nThe correction for the ES5.1 spec. is:\n\n5.     For each FunctionDeclaration f in code, in source text order do\n   a.      Let fn be the Identifier in FunctionDeclaration f.\n   b.      Let fo be the result of instantiating FunctionDeclaration f as described in Clause 13.\n   c.      Let funcAlreadyDeclared be the result of calling env’s HasBinding concrete method passing fn as the argument.\n   d.      If funcAlreadyDeclared is false, call env’s CreateMutableBinding concrete method passing fn and configurableBindings as the arguments.\n   e.      Else if env is the environment record component of the global environment then\n          i.         Let go be the global object.\n         ii.         Let existingProp be the resulting of calling the [[GetOwnProperty]] internal method of go with argument fn.\n        iii.         If existingProp is undefined or existingProp .[[Configurable]] is true, then\n               1.     Call the [[DefineOwnProperty]] internal method of go, passing fn, Property Descriptor {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configurableBindings }, and true as arguments.\n        iv.         Else if IsAccessorDescriptor(existingProp) or existingProp does not have attribute values {[[Writable]]: true, [[Enumerable]]: true}, then\n                1.     Throw a TypeError exception.\n   f.        Call env’s SetMutableBinding concrete method passing fn, fo, and strict as the arguments.\n\nThe changes are in lines e.ii and e.iii\n\nLarger changes are needed to handle var declaration in step 8 because special case processing for global declaration similar to what is is step 5 needs to be added.  The corrected ES5.1 spec. adds step 8.d and its sub-steps:\n\n8.     For each VariableDeclaration and VariableDeclarationNoIn d in code, in source text order do\n   a.     Let dn be the Identifier in d.\n   b.     Let varAlreadyDeclared be the result of calling env’s HasBinding concrete method passing dn as the argument.\n   c.      If varAlreadyDeclared is false, then\n          i.         Call env’s CreateMutableBinding concrete method passing dn and configurableBindings as the arguments.\n         ii.         Call env’s  SetMutableBinding  concrete method passing dn, undefined, and strict as the arguments.\n    d.    else if env is the environment record component of the global environment then\n          i.         Let go be the global object.\n         ii.         Let existingProp be the resulting of calling the [[GetOwnProperty]] internal method of go with argument fn.\n        iii.         If existingProp is undefined,    then\n               1.     Call the [[DefineOwnProperty]] internal method of go, passing dn,  Property Descriptor {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configurableBindings }, and true as arguments.\n\nAn alternative approach to fixes these issues would involve changes to Object Environment Record and possibly the common interface shared by all environment records.  Those changes would have broader impact than the above.  More work will probably have to be done in the Harmony context where we will be dealing with a wide variety of declarative forms."},{"commentid":586,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-01-12 12:28:33 -0800","thetext":"set IN_PROGRESS to indicated this should go into ES5.1 Errata."},{"commentid":849,"comment_count":2,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-03-29 10:21:13 -0700","thetext":"fix verified at March 2012 meeting."},{"commentid":861,"comment_count":3,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2012-04-11 06:22:40 -0700","thetext":"In the proposed fix, can't all the steps 5.e.i-iv now be collapsed to just:\n\n5.e. Call the [[DefineOwnProperty]] internal method of the global object,\n     passing fn, Property Descriptor {[[Value]]: undefined,\n     [[Writable]]: true, [[Enumerable]]: true,\n     [[Configurable]]: configurableBindings}, and true as arguments.\n\nAs far as I can see, all the additional error cases treated by the other steps are already handled by [[DefineOwnProperty]].\n\n\nAs another simplification, one might also consider removing all the special case logic for the global object here and folding it into the spec of CreateMutableBinding, SetMutableBinding, & friends on object environment records (10.2.1.2). Moreover, given that the global environment is the only object environment that can ever be used as a variable environment, there is no need to even distinguish its behaviour."},{"commentid":862,"comment_count":4,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2012-04-12 08:13:22 -0700","thetext":"Ah, scratch the first part of my previous comment. The one additional case the text allows is the existing property being non-configurable, but writable and enumerable already. In that case, it falls back to Set instead of Define. (Not sure I like that special case of a special case, but I suppose it's motivated by some compatibility issue?)\n\nThe second half still stands, though."},{"commentid":863,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-04-12 09:40:43 -0700","thetext":"(In reply to comment #3)\n> \n> As another simplification, one might also consider removing all the special\n> case logic for the global object here and folding it into the spec of\n> CreateMutableBinding, SetMutableBinding, & friends on object environment\n> records (10.2.1.2). Moreover, given that the global environment is the only\n> object environment that can ever be used as a variable environment, there is no\n> need to even distinguish its behaviour.\n\nYes, this was always a possibility.  However, since this was initially developed as a \"correction\" to the ES5 spec. (that needed further correction in ES5.1) I tried to localize the \"patch\" to a single place.\n\nFor ES6 I might do something less hackish, but so far I'm waiting for some consensus on the other global scope issues."},{"commentid":1421,"comment_count":6,"who":{"uid":"brendan","name":"Brendan Eich"},"bug_when":"2012-08-10 09:29:51 -0700","thetext":"See http://lists.w3.org/Archives/Public/public-webapps/2012JulSep/0392.html for how the fix for this erratum, which SpiderMonkey (and other engines, but their DOM bindings mitigated the effects) implemented ahead of schedule, blew back.\n\n/be"},{"commentid":14734,"comment_count":7,"who":{"uid":"brterlso","name":"Brian Terlson"},"bug_when":"2015-10-02 14:33:03 -0700","thetext":"Bulk resolving ES5.1 errata issues as a sampling suggests these are all fixed. If this is in error, please open a new issue on GitHub."}]}}
---
