---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":4083,"creation_ts":"2015-02-24 13:57:00 -0800","short_desc":"Module exotic object and GetOwnProperty?","delta_ts":"2015-07-10 08:34:23 -0700","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 34: February 20, 2015 Release Candidate 1","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"WONTFIX","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"arv","name":"Erik Arvidsson"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":["adamk","andrebargull","d","dherman","erights","erik.arvidsson"],"long_desc":[{"commentid":13312,"comment_count":0,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-24 13:57:27 -0800","thetext":"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-module-namespace-exotic-objects-getownproperty-p\n\nWhy does [[GetOwnProperty]] throw here?"},{"commentid":13356,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-25 15:17:03 -0800","thetext":"Mostly to avoid any implication that the properties that correspond to module exports are specifically either data properties or accessor properties.   (they really are neither). Returning undefined wouldn't be right either, because that would imply that the property doesn't exist.\n\nMore generally module objects are very exotic and the reflection that is supported on them is very limited.  You can enumerate the the exported name property and test to see whether a property exists or access its values, but not very much else."},{"commentid":13358,"comment_count":2,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-25 15:22:11 -0800","thetext":"My concern is that some spec algorithms use [[GetOwnProperty]] and now they are going to throw. \n\nSorry for rehashing this but what were the reasons we decided to not uses getters for these?"},{"commentid":13360,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-25 15:34:09 -0800","thetext":"(In reply to Erik Arvidsson from comment #2)\n> My concern is that some spec algorithms use [[GetOwnProperty]] and now they\n> are going to throw. \n> \n> Sorry for rehashing this but what were the reasons we decided to not uses\n> getters for these?\n\nThen the get functions would be exposed and could be passed around. Instead we over-ride [[Get]].\n\nWhat algorithms that use [[GetOwnProperty]] would be reasonably applied to a module namespace object?  If we really need to support that, the way to do it would be for them to expose the attributes of a data property, rather than an accessor."},{"commentid":13361,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-25 15:41:23 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #3)\n> \n> What algorithms that use [[GetOwnProperty]] would be reasonably applied to a\n> module namespace object? \n\nI just did a quick check (including HasOwnProperty which is defined in terms of [[GetOwnProperty]]) and I didn't see any that would be an issue"},{"commentid":13394,"comment_count":5,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-26 10:37:16 -0800","thetext":"The only one I can think of that will be very confusing to people is getOwnPropertyDescriptor.\n\n> Then the get functions would be exposed and could be passed around. Instead we over-ride [[Get]].\n\nWhy is that a problem?\n\nEven if you don't want that to work we could make getters work. They could do some kind of \"brand check\" to ensure that the function is called with the right this."},{"commentid":13395,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-26 11:05:38 -0800","thetext":"(In reply to Erik Arvidsson from comment #5)\n> The only one I can think of that will be very confusing to people is\n> getOwnPropertyDescriptor.\n\nThe existence of Proxy makes any use of the Object.* meta operations upon arbitrary objects totally unpredictable .\n\n> \n> > Then the get functions would be exposed and could be passed around. Instead we over-ride [[Get]].\n> \n> Why is that a problem?\n> \n> Even if you don't want that to work we could make getters work. They could\n> do some kind of \"brand check\" to ensure that the function is called with the\n> right this.\n\nTo me, the whole point of having a MOP is that specialized object behaviors can be defined without exposing implementation details like the use of accessor properties.  What benefit is there to requiring an implementation to expose accessor properties (other than making down version trans-compilation easier in the absence of Proxies)."},{"commentid":13396,"comment_count":7,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-26 11:25:09 -0800","thetext":"Anything that is exotic requires a \"proxy\" which will lead to higher implementation costs and performance penalty.\n\nThis is not about transpilers."},{"commentid":13398,"comment_count":8,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2015-02-26 12:13:37 -0800","thetext":"Strongly agreed. The presence of a well-specified MOP does not change the fact that exotic objects are painful exceptions to the language for both authors and implementers. We should not be introducing more exotic objects like this."},{"commentid":13402,"comment_count":9,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-26 14:34:46 -0800","thetext":"(In reply to Domenic Denicola from comment #8)\n> Strongly agreed. The presence of a well-specified MOP does not change the\n> fact that exotic objects are painful exceptions to the language for both\n> authors and implementers. We should not be introducing more exotic objects\n> like this.\n\nModule name space objects, howeever they are specified are highly exotic.  Look at the rest of their behavior particularly their [[Get]] behavior. That burden is there however you look at it.\n\nThe current specification gives implementors maximal flexibility in how they go about support their module linkage semantics. \n\nI'd entertain an argument that that their [[GetOwnProperty]] should report the exported names as non-configurable, non-writeable, enumerable data properties.  But requiring exposing them as an accessor property with an visible per name per namespace get attribute function is a very bad idea."},{"commentid":13405,"comment_count":10,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-02-26 15:02:41 -0800","thetext":"(In reply to Allen Wirfs-Brock from comment #9)\n> I'd entertain an argument that that their [[GetOwnProperty]] should report\n> the exported names as non-configurable, non-writeable, enumerable data\n> properties. \n\nNon-configurable and non-writeable is not possible without violating the essential internal method invariants. Only non-configurable and writeable is valid. (Even if a property is reported as writable, it's not required to expose a mechanism to give the property a different value.)"},{"commentid":13406,"comment_count":11,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-02-26 15:03:53 -0800","thetext":"Isn't it a violation to throw as well? It should be."},{"commentid":13407,"comment_count":12,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2015-02-26 15:10:49 -0800","thetext":"(In reply to Erik Arvidsson from comment #11)\n> Isn't it a violation to throw as well? It should be.\n\nNo, throwing is always allowed - otherwise revocable proxies wouldn't be possible. Or in general all proxies because user code in proxy traps can throw."},{"commentid":13408,"comment_count":13,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-26 15:19:26 -0800","thetext":"(In reply to André Bargull from comment #10)\n> \n> Non-configurable and non-writeable is not possible without violating the\n> essential internal method invariants. Only non-configurable and writeable is\n> valid. (Even if a property is reported as writable, it's not required to\n> expose a mechanism to give the property a different value.)\n\nYes, of course! It would have to be writable: true.  Of course, [[Set]] and [[DefineOwnProperty]] still unconditionally return false (in other words, refuse to modify the value)"},{"commentid":13731,"comment_count":14,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-15 11:42:44 -0700","thetext":"I'm not going to change this, as none of the arguments presented seem sufficient to change this intentional design decision.  Exposing get functions via accessors property descriptors still seems like a bad idea. Exposing them as data properties would require saying that they are writable: true. and that seems  likely to mess up user written reflection algorithms.\n\nThrowing here seems like appropriate notification that you shouldn't be reflecting upon module namespace objects."},{"commentid":13739,"comment_count":15,"who":{"uid":"d","name":"Domenic Denicola"},"bug_when":"2015-03-15 21:21:55 -0700","thetext":"Allen, you did not answer Erik's question\n\n\n>> Then the get functions would be exposed and could be passed around. Instead we over-ride [[Get]].\n>\n> Why is that a problem?\n\nIndeed, it seems to be no more of a problem than exposing `import * as foo from 'foo'; export function getMNOProperty() { return foo.bar; }`.\n\nI think it's not appropriate to close this without further discussion given there is implementer feedback that this will make the spec harder to implement."},{"commentid":13743,"comment_count":16,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-03-16 10:46:39 -0700","thetext":"(In reply to Domenic Denicola from comment #15)\n> Allen, you did not answer Erik's question\n> \n> \n> >> Then the get functions would be exposed and could be passed around. Instead we over-ride [[Get]].\n> >\n> > Why is that a problem?\n> \n> Indeed, it seems to be no more of a problem than exposing `import * as foo\n> from 'foo'; export function getMNOProperty() { return foo.bar; }`.\n\n\nIt would force an implementation to create and expose a distinct get function for each property of a Module Namespace object that is exposed via [[GetOwnProperty]]. Those function would only need to exist because of the need to populated the property descriptor. While those functions could be lazily created, they would presumably need to be indefinitely retained, because there would be a reasonable expectation that:\n    Reflect.getOwnOPropertyDescriptor(someModNS. \"foo\").get === Reflect.getOwnOPropertyDescriptor(someModNS. \"foo\").get\n\nBut this is really about about something much deeper. Module Namespace objects are not ordinary objects and their properties are not accessor properties.\n\nTheir essential behavior is defined in terms of their [[Get]] and [[Set]] internal methods, not in terms of [[GetOwnProperty]] and [[DefineOwnProperty]].\n\nChanging that intentional part of the design would be a much bigger issues, than what we have been talking about so far. (And not the topic of this bug)\n\n> \n> I think it's not appropriate to close this without further discussion given\n> there is implementer feedback that this will make the spec harder to\n> implement.\n\nThere are many implementors and many opinions. \n(No disrespect to Arv, he just made a general observation and one that I don't necessarily disagree with. There are always trade-off involved when choosing to define exotic objects. The general observation applies at least as much to Typed Arrays as it does to Module Namespace objects.)\n\nES6 is done, unless you are saying you don't think we should go for GA approval in June. \n\nFeel free to proposal a change for ES7, but as far as ES6 is concerned WONTFIX seems like exactly the right resolution (giving that we lack a WORKSASINTENDED).\nThe ES6 design is quite future proof in this regard (something that could not be said if [[GetOwnProperty]] did anything other than throw)."},{"commentid":13916,"comment_count":17,"who":{"uid":"arv","name":"Erik Arvidsson"},"bug_when":"2015-03-19 12:51:18 -0700","thetext":"We talked a bit about this.\n\nData properties are fine. However, it would be preferable if getOwnPropertyDescriptor returns\n\n{\n  value: ...\n  configurable: false,\n  writable: true\n  enumerable: true\n}\n\nNote, that reporting writable false would be a violation since the value might change.\n\nSince [[Set]] always returns false without doing anything else this is no violation of the internal methods."}]}}
---
