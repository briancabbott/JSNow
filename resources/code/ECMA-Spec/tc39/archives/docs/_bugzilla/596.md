---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":596,"creation_ts":"2012-07-29 07:37:00 -0700","short_desc":"Coverage: 15.4.4.11 - identical elements and array holes","delta_ts":"2016-03-03 13:58:00 -0800","product":"Test262","component":"ECMA-262 Tests","version":"unspecified","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"billti","name":"Bill Ticehurst"},"cc":["dehrenberg","rossberg"],"long_desc":[{"commentid":1392,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-07-29 07:37:11 -0700","thetext":"Two additional test cases for Array.prototype.sort [15.4.4.11]:\n\n1) The SortCompare abstract operation calls ToString() for identical elements (step 14/15)\n2) Array.prototype.sort does not change non-existent elements to undefined elements, that means holes are preserved (cf. spec text about [[Delete]] and sparse arrays)\n\n\ntest case for (1):\n---\nvar counter = 0;\nvar object = {toString: function(){ counter++; return \"\"; }};\n[object, object].sort();\nif (counter < 2) {\n  // sort calls ToString() for each element at least once\n  $ERROR(\"...\");\n}\n---\n\n\ntest case for (2):\n---\nvar array = ['a',,void 0];\n\nif (array.length !== 3) { $ERROR(\"...\") }\nif (array.hasOwnProperty('0') !== true) { $ERROR(\"...\"); }\nif (array.hasOwnProperty('1') !== false) { $ERROR(\"...\"); }\nif (array.hasOwnProperty('2') !== true) { $ERROR(\"...\"); }\n\narray.sort();\n\nif (array.length !== 3) { $ERROR(\"...\") }\nif (array.hasOwnProperty('0') !== true) { $ERROR(\"...\"); }\nif (array.hasOwnProperty('1') !== true) { $ERROR(\"...\"); }\nif (array.hasOwnProperty('2') !== false) { $ERROR(\"...\"); }\n---"},{"commentid":9865,"comment_count":1,"who":{"uid":"rossberg","name":"Andreas Rossberg"},"bug_when":"2014-08-25 06:59:15 -0700","thetext":"I think the first test (bug_596_1) is bogus. The spec allows an \"arbitrary sequence of calls\" to SortCompare. In particular, it is valid to not call it at all, as long as the two given conditions are met for the sorted result. In this particular case, that happens to be possible without ever calling SortCompare (and thus toString). So count===0 is a perfectly legal result. In fact, doing reference comparison before ToString is an important optimisation.\n\n(Arguably, you could check that toString is called an _even_ number of times, though.)\n\nHowever, there clearly is a spec issue here. I filed it separately:\nhttps://bugs.ecmascript.org/show_bug.cgi?id=3150"},{"commentid":9980,"comment_count":2,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-08-25 09:20:25 -0700","thetext":"(In reply to Andreas Rossberg from comment #1)\n> I think the first test (bug_596_1) is bogus. The spec allows an \"arbitrary\n> sequence of calls\" to SortCompare. In particular, it is valid to not call it\n> at all, as long as the two given conditions are met for the sorted result.\n\nMy interpretation of the algorithm is that SortCompare is called for every comparison operation during the sort. That includes comparing identical elements which means observable side-effects in ToString are possible. But the spec text is fuzzy enough to allow different interpretations, so I guess removing \"test/suite/es6/bug_596_1.js\" is acceptable."},{"commentid":14933,"comment_count":3,"who":{"uid":"dehrenberg","name":"Daniel Ehrenberg"},"bug_when":"2016-03-03 13:58:00 -0800","thetext":"This issue seems to be fixed. The new contents look valid to me per spec.\n\n----\n\nvar counter = 0;\nvar object = {\n    toString: function(){\n        counter++;\n        return \"\";\n    }\n};\n\n[object, object].sort();\nif (counter < 2) {\n  // sort calls ToString() for each element at least once\n  $ERROR('#1: [object, object].sort(); counter < 22. Actual: ' + (counter));\n}"}]}}
---
