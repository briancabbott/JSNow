---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":3136,"creation_ts":"2014-08-15 07:00:00 -0700","short_desc":"19.1.1.1 Object: Change ObjectCreate to OrdinaryCreateFromConstructor?","delta_ts":"2015-01-15 16:19:03 -0800","product":"Draft for 6th Edition","component":"technical issue","version":"Rev 26: July 18, 2014 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"long_desc":[{"commentid":9790,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-08-15 07:00:54 -0700","thetext":"19.1.1.1 Object ( [ value ] ):\n\nStep 1 currently calls `ObjectCreate(%ObjectPrototype%)`, maybe it should be changed to `OrdinaryCreateFromConstructor(F, %ObjectPrototype%)` where F is the currently active function. \n\n\nAlso see 19.2.1.1 step 14b, 22.1.1.1 step 5b, 19.5.1.1 step 3a etc. where OrdinaryCreateFromConstructor or similar operations are already used."},{"commentid":9827,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-20 15:49:26 -0700","thetext":"I don't think so. This is a specific definition for Object, called as a function, and isn't intended to be subclassed. Parameterizing it with via F.prototype may also have legacy compatibility issues."},{"commentid":9834,"comment_count":2,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-08-21 04:11:48 -0700","thetext":"I don't understand why 19.2.1.1 Function or 19.5.1.1 Error use OrdinaryCreateFromConstructor (resp. GetPrototypeFromConstructor in 19.2.1.1), instead of simply using the intrinsic prototype object. And why 19.1.1.1 Object is allowed to use the intrinsic prototype object. \n\nWhen we look at 19.5.1.1 Error, step 3a calls OrdinaryCreateFromConstructor(func, %ErrorPrototype%, ([[ErrorData]])) where `func` is the currently active function, so `func` is either the intrinsic Error function or a cloned Error function. No other case is possible here. In the case that `func` is the intrinsic Error function, OrdinaryCreateFromConstructor will always use the intrinsic Error prototype object since the \"prototype\" property on Error is non-writable + non-configurable. If `func` is a cloned Error function, OrdinaryCreateFromConstructor needs to retrieve the value of \"prototype\" dynamically at runtime. \n\nSo the only benefit (?) of using OrdinaryCreateFromConstructor in 19.5.1.1 Error (instead of using ObjectCreate) is that cloned Error functions can set a different prototype object. \n\nChanging 19.1.1.1 to use OrdinaryCreateFromConstructor instead of ObjectCreate only has an effect for cloned Object functions."},{"commentid":9847,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2014-08-23 12:47:35 -0700","thetext":"(In reply to André Bargull from comment #2)\n> I don't understand why 19.2.1.1 Function or 19.5.1.1 Error use\n> OrdinaryCreateFromConstructor (resp. GetPrototypeFromConstructor in\n> 19.2.1.1), instead of simply using the intrinsic prototype object. And why\n> 19.1.1.1 Object is allowed to use the intrinsic prototype object. \n> \n> When we look at 19.5.1.1 Error, step 3a calls\n> OrdinaryCreateFromConstructor(func, %ErrorPrototype%, ([[ErrorData]])) where\n> `func` is the currently active function, so `func` is either the intrinsic\n> Error function or a cloned Error function. No other case is possible here.\n> In the case that `func` is the intrinsic Error function,\n> OrdinaryCreateFromConstructor will always use the intrinsic Error prototype\n> object since the \"prototype\" property on Error is non-writable +\n> non-configurable. If `func` is a cloned Error function,\n> OrdinaryCreateFromConstructor needs to retrieve the value of \"prototype\"\n> dynamically at runtime. \n> \n> So the only benefit (?) of using OrdinaryCreateFromConstructor in 19.5.1.1\n> Error (instead of using ObjectCreate) is that cloned Error functions can set\n> a different prototype object. \n\nThe concern is about subclassing more than cloning, although there are similarities between those two scenarios.  There is also a need to balance  legacy compatibility against ES6 sublcassing capabilities. \n\nIn the case, of Error, it is reasonable to assume that programmer will define subclasses of Error, via \n  class MyError extends Error {};\n\nSuch a subclass uses the Error constructor, but needs to set the new instance prototype to MyError.prototype.  So we use OrdinaryCreateFromConstructor.  There is a small chance of an incompatibility for legacy code, but the risk seems low compared to the importance of the new functionality. \n\n> \n> Changing 19.1.1.1 to use OrdinaryCreateFromConstructor instead of\n> ObjectCreate only has an effect for cloned Object functions.\n\nObject, on the other hand, is not intended to be explicitly subclassed.  You normally say\n  class MyClass {};\ninstead of \n  class MyClass extends Object {};\n\nThere is special case semantics for class definitions that makes sure that the Object constructor is not called for Subclasses like MyClass. So, we don't have to worry (too much) about 19.1.1.1 being super called in a subclass constructor.\n\nOn the other hand, 19.1.1.1 was specified prior to ES6 to creates objects with their [[Prototype]] set to the intrinsic Object.prototype.  My guess is that there is a much higher chance that legacy code exists that depends upon that specific behavior. \n\nSo, 19.1.1.1 preserves legacy behavior, while 19.2.1.1 and 19.5.1.1 (and really all legacy constructors except for Object) is taking a risk at relaxing legacy behavior in order to facilitate subclassing."},{"commentid":9857,"comment_count":4,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2014-08-24 11:19:33 -0700","thetext":"(In reply to Allen Wirfs-Brock from comment #3)\n> The concern is about subclassing more than cloning, although there are\n> similarities between those two scenarios.  There is also a need to balance \n> legacy compatibility against ES6 sublcassing capabilities. \n> \n\nI still don't understand how subclassing comes into play here. :-(\n\nIf step 1 of 19.1.1.1 is changed to:\n> 1. If value is null, undefined or not supplied, then\n>  a. Let func be the active function object.\n>  b. Return OrdinaryCreateFromConstructor(func, %ObjectPrototype%).\n\nthere will be no difference for the intrinsic Object constructor function when compared to the current step 1 of 19.1.1.1. \n\n\nI do _not_ suggest to change 19.1.1.1 to:\n> 1. If value is null, undefined or not supplied, then\n>  a. Let func be the this value.\n>  b. Return OrdinaryCreateFromConstructor(func, %ObjectPrototype%).\n\nSuch a change will have effects on subclassing and legacy behaviour and therefore should not be applied."},{"commentid":11407,"comment_count":5,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-15 16:11:30 -0800","thetext":"fixed in rev31 editor's draft"},{"commentid":11435,"comment_count":6,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-01-15 16:19:03 -0800","thetext":"In Rev31"}]}}
---
