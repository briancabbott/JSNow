---
{"_attributes":{"version":"4.4.4+","urlbase":"https://bugs.ecmascript.org/","maintainer":"dherman@mozilla.com"},"bug":{"bug_id":1059,"creation_ts":"2012-11-26 15:36:00 -0800","short_desc":"[12.5 Runtime Semantics: Evaluation] Completion reform for If-Statement","delta_ts":"2015-02-19 19:11:12 -0800","product":"Draft for 6th Edition","component":"normative change from ES5.x","version":"Rev 12: November 22, 2012 Draft","rep_platform":"All","op_sys":"All","bug_status":"RESOLVED","resolution":"FIXED","priority":"Normal","bug_severity":"normal","everconfirmed":true,"reporter":{"uid":"andrebargull","name":"André Bargull"},"assigned_to":{"uid":"allen","name":"Allen Wirfs-Brock"},"cc":"dherman","long_desc":[{"commentid":2857,"comment_count":0,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-11-26 15:36:37 -0800","thetext":"Step 4 of the [Runtime Semantics: Evaluation] for the production `IfStatement : if ( Expression ) Statement` has been changed to return `NormalCompletion(undefined)` based on the proposed completion reform. \n\nThat means the following code will now return `undefined` instead of `\"pre\"`:\n---\neval(\"'pre'; if(false) {'if-true'}\")\n---\n\nThis code is not affected by the proposed completion reform, so it still returns `\"pre\"`:\n---\neval(\"'pre'; if(true) {}\")\n---\n\n\nHowever `IfStatement : if ( Expression ) Statement else Statement` has not been changed and therefore the following code also preserves the completion value of previous ECMAScript versions, i.e. it returns `\"pre\"`:\n---\neval(\"'pre'; if(false) {'if-true'} else {}\")\n---\n\nTo ensure `if (<cond>) {<stmt>}` and `if (<cond>) {<stmt>} else {}` yield the same result, [Runtime Semantics: Evaluation] for the production `IfStatement : if ( Expression ) Statement else Statement` needs to be changed as follows (Note: I've changed step 4 in addition to step 5 to cover both cases):\n---\n1. leave-as-is\n2. leave-as-is\n3. leave-as-is\n4. If exprValue is true, then\n  a. Let stmt be the result of evaluating the first Statement\n  b. ReturnIfAbrupt(stmt)\n  c. If stmt.[[value]] is not empty, return stmt\n  d. Return NormalCompletion(undefined)\n5. Else,\n  a. Let stmt be the result of evaluating the second Statement\n  b. ReturnIfAbrupt(stmt)\n  c. If stmt.[[value]] is not empty, return stmt\n  d. Return NormalCompletion(undefined)\n---\n\nApplying that change will lead to changing [Runtime Semantics: Evaluation] for the production `IfStatement : if ( Expression ) Statement` as follows:\n---\n1. leave-as-is\n2. leave-as-is\n3. leave-as-is\n4. If exprValue is false, return NormalCompletion(undefined)\n5. Else,\n  a. Let stmt be the result of evaluating Statement\n  b. ReturnIfAbrupt(stmt)\n  c. If stmt.[[value]] is not empty, return stmt\n  d. Return NormalCompletion(undefined)\n---\n\n\n\nSimilar problems can be shown for the While-Statement, for example consider:\n---\neval(\"'pre'; while(false);\")\n\neval(\"'pre'; while(true)break;\")\n---\n\nWith the current changes for the completion reform, the first eval() call will return `undefined` whereas the second call will return `\"pre\"`. I'd expect both calls to yield the same result, that means `undefined`."},{"commentid":2997,"comment_count":1,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2012-12-06 13:50:49 -0800","thetext":"sounds right....\n\nAlso, my reading of the completion reform proposal, is that every Statement except EmptyStatement (and Declarations) should have a non-empty value.\n\nthis means that a BlockStatemnt like:\n  { }\nshould return NormalCompletion(undefind).\n\nand that\n   while (true) {break};\nshould also evaluate to NormalCopletion(undefined);\n\nBut \n   while (true) {42; break};\nshould also evaluate to NormalCopletion(42); \n\ndherman, Do you agree???"},{"commentid":3007,"comment_count":2,"who":{"uid":"andrebargull","name":"André Bargull"},"bug_when":"2012-12-13 09:08:29 -0800","thetext":"On a related note, `finally`'s completion value semantics may also need to be changed. When a `finally` statement returns with an abrupt completion, its completion value is used whereas when it returns with a normal completion the `try`-statement's completion value is used. I'm not sure if this is intended...\n\n---\n\"in-try\" === eval(\"while(true){ try{ 'in-try' }finally{ 'in-finally'; } break; }\")\n\n\n\"in-finally\" === eval(\"while(true){ try{ 'in-try' }finally{ 'in-finally'; break; } }\")\n---"},{"commentid":12502,"comment_count":3,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-12 19:28:12 -0800","thetext":"fixed in rev34 editor's draft\n\nfixed a rather nasty bug in LabelledEvaluation of  BreakableStatement\n\nAlso, {} at the statement list  level is now equivalent to an empty statement. That maintains legacy compat for eval('1; {}') which had been explicitly document as having a value of 1;  This fix doesn't change control structure the completion values of statements like :\n    if (true) {}\nThose all still have completion values of undefined. \n\nAdded, missing undefined completion defaulting to WithStatement\n\nAlso, dealt with force empty try and catch blocks to NormalCompetion(undefined).  Break in finally get's turned in NormalCompletion(undefined) by enclosing Breakable or LabelledStatment"},{"commentid":13168,"comment_count":4,"who":{"uid":"allen","name":"Allen Wirfs-Brock"},"bug_when":"2015-02-19 19:11:12 -0800","thetext":"fixed in rev34"}]}}
---
