<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./ecmarkup.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./ecmarkup.js"></script>
<pre class="metadata">
title: TypedArray Stride Parameter
status: proposal
stage: 1
contributors: Shu-yu Guo, Surma
</pre>

<emu-clause id="sec-modifications-iieo">
  <h1>Modifications to Integer-Indexed Exotic Objects definitions</h1>

  <emu-clause id="sec-modifications-iieo">
    <h1>Integer-Indexed Exotic Objects</h1>
    <p>An Integer-Indexed exotic object is an exotic object that performs special handling of integer index property keys.</p>
      <p><emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref> have the same internal slots as ordinary objects and additionally [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], <ins>[[Stride]],</ins> [[ContentType]], and [[TypedArrayName]] internal slots.</p>
      <p>An object is an <dfn id="integer-indexed-exotic-object">Integer-Indexed exotic object</dfn> if its [[GetOwnProperty]], [[HasProperty]], [[DefineOwnProperty]], [[Get]], [[Set]], and [[OwnPropertyKeys]] internal methods use the definitions in this section, and its other essential internal methods use the definitions found in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>. These methods are installed by IntegerIndexedObjectCreate.</p>
  </emu-clause>

  <emu-clause id="sec-tobyteindex" aoid-"ToByteIndex">
    <h1>ToByteIndex ( _O_, _index_ )</h1>
    <emu-note type=editor>
      <p>This is a new abstract operation.</p>
    </emu-note>
    <p>The abstract operation ToByteIndex takes two arguments, an Integer-Indexed Exotic Object _O_ and an integer _index_, and transforms the index to the byte index on the underlying ArrayBuffer.</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Assert: ! IsValidIntegerIndex(_O_, _index_) is *true*.
      1. Let _stride_ be _O_.[[Stride]].
      1. Let _offset_ be _O_.[[ByteOffset]].
      1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Return (_index_ &times; _elementSize_ &times; _stride_) + _offset_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-modifications-integerindexedobjectcreate" aoid="IntegerIndexedObjectCreate">
    <h1>IntegerIndexedObjectCreate ( _prototype_ )</h1>
    <p>The abstract operation IntegerIndexedObjectCreate is used to specify the creation of new <emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref>. IntegerIndexedObjectCreate performs the following steps:</p>
    <emu-alg>
      1. Let _internalSlotsList_ be &laquo; [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], <ins>[[Stride]],</ins> [[ArrayLength]] &raquo;.
      1. Let _A_ be ! MakeBasicObject(_internalSlotsList_).
      1. Set _A_.[[GetOwnProperty]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-getownproperty-p"></emu-xref>.
      1. Set _A_.[[HasProperty]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-hasproperty-p"></emu-xref>.
      1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-defineownproperty-p-desc"></emu-xref>.
      1. Set _A_.[[Get]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-get-p-receiver"></emu-xref>.
      1. Set _A_.[[Set]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-set-p-v-receiver"></emu-xref>.
      1. Set _A_.[[OwnPropertyKeys]] as specified in <emu-xref href="#sec-integer-indexed-exotic-objects-ownpropertykeys"></emu-xref>.
      1. Set _A_.[[Prototype]] to _prototype_.
      1. Return _A_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-modifications-integerindexedelementget" aoid="IntegerIndexedElementGet">
    <h1>IntegerIndexedElementGet ( _O_, _index_ )</h1>
    <p>The abstract operation IntegerIndexedElementGet with arguments _O_ and _index_ performs the following steps:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Assert: Type(_index_) is Number.
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
      1. If ! IsValidIntegerIndex(_O_, _index_) is *false*, return *undefined*.
      1. <ins>Let _indexedPosition_ be ToByteIndex(_O_, _index_).</ins>
      1. <del>Let _offset_ be _O_.[[ByteOffset]].</del>
      1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
      1. <del>Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. <del>Let _indexedPosition_ be (_index_ &times; _elementSize_) + _offset_.</del>
      1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Return GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, ~Unordered~).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-modifications-integerindexedelementset" aoid="IntegerIndexedElementSet">
    <h1>IntegerIndexedElementSet ( _O_, _index_, _value_ )</h1>
    <p>The abstract operation IntegerIndexedElementSet with arguments _O_, _index_, and _value_ performs the following steps:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Assert: Type(_index_) is Number.
      1. If _O_.[[ContentType]] is ~BigInt~, let _numValue_ be ? ToBigInt(_value_).
      1. Otherwise, let _numValue_ be ? ToNumber(_value_).
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
      1. If ! IsValidIntegerIndex(_O_, _index_) is *false*, return *false*.
      1. <ins>Let _indexedPosition_ be ToByteIndex(_O_, _index_).</ins>
      1. <del>Let _offset_ be _O_.[[ByteOffset]].</del>
      1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
      1. <del>Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.</del>
      1. <del>Let _indexedPosition_ be (_index_ &times; _elementSize_) + _offset_.</del>
      1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _numValue_, *true*, ~Unordered~).
      1. Return *true*.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-modifications-typedarray">
  <h1>Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-modifications-abstract-operations-for-arraybuffer-objects">
    <h1>Modifications to Abstract Operations For ArrayBuffer Objects</h1>

    <emu-clause id="sec-modifications-clonearraybuffer" aoid="CloneArrayBuffer">
      <h1>CloneArrayBuffer ( _srcBuffer_, _srcByteOffset_,<ins> _srcElementSize_, _srcStride_,</ins> _srcLength_, _cloneConstructor_ )</h1>
      <emu-note type=editor>
        <p>The cloned ArrayBuffer returned by this abstract operation does not preserve stride.</p>
      </emu-note>
      <p>The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer _srcBuffer_, an integer offset _srcByteOffset_,<ins> an integer _srcElementSize_, an integer stride _srcStride_,</ins> an integer length _srcLength_, and a constructor function _cloneConstructor_. It creates a new ArrayBuffer whose data is a copy of _srcBuffer_'s data over the range starting at _srcByteOffset_ and continuing for _srcLength_<ins> &times; _srcByteStride_</ins> bytes. This operation performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_srcBuffer_) is Object and it has an [[ArrayBufferData]] internal slot.
        1. Assert: IsConstructor(_cloneConstructor_) is *true*.
        1. Let _targetBuffer_ be ? AllocateArrayBuffer(_cloneConstructor_, _srcLength_).
        1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
        1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].
        1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].
        1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_,<ins> _srcElementSize_, _srcStride_,</ins> _srcLength_).
        1. Return _targetBuffer_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-copydatablockbytes" aoid="CopyDataBlockBytes">
      <h1>CopyDataBlockBytes ( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_,<ins> _fromElementSize_, _fromStride_,</ins> _count_ )</h1>
      <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
      <emu-alg>
        1. Assert: _fromBlock_ and _toBlock_ are distinct Data Block or Shared Data Block values.
        1. Assert: _fromIndex_,<ins> _fromStride_,</ins> _toIndex_, and _count_ are integer values &ge; 0.
        1. Let _fromSize_ be the number of bytes in _fromBlock_.
        1. Assert: _fromIndex_ + _count_<ins> &times; _fromStride_</ins> &le; _fromSize_.
        1. Let _toSize_ be the number of bytes in _toBlock_.
        1. Assert: _toIndex_ + _count_ &le; _toSize_.
        1. Repeat, while _count_ &gt; 0
          1. <ins>Let _countBytes_ be _fromElementSize_.</ins>
          1. <ins>Repeat, while _countBytes_ &gt; 0</ins>
            1. If _fromBlock_ is a Shared Data Block, then
              1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
              1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
              1. Let _bytes_ be a List of length 1 that contains a nondeterministically chosen byte value.
              1. NOTE: In implementations, _bytes_ is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
              1. Let _readEvent_ be ReadSharedMemory { [[Order]]: ~Unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }.
              1. Append _readEvent_ to _eventList_.
              1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } to _execution_.[[ChosenValues]].
              1. If _toBlock_ is a Shared Data Block, then
                1. Append WriteSharedMemory { [[Order]]: ~Unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } to _eventList_.
              1. Else,
                1. Set _toBlock_[_toIndex_] to _bytes_[0].
            1. Else,
              1. Assert: _toBlock_ is not a Shared Data Block.
              1. Set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].
            1. Set _toIndex_ to _toIndex_ + 1.
            1. Set _fromIndex_ to _fromIndex_ + 1.
            1. <ins>Set _countBytes_ to _countBytes_ - 1.</ins>
            1. Set _count_ to _count_ - 1.
            1. <ins>NOTE: _count_ already accounts for stride.</ins>
          1. <ins>Set _fromIndex_ to _fromIndex_ + _fromElementSize_ &times (_fromStride_ - 1).</ins>
          1. <ins>Set _countBytes_ to _fromElementSize_</ins>
        1. Return NormalCompletion(~empty~).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modifications-properties-of-the-%typedarray%-intrinsic-object">
    <h1>Modifications to Properties of the %TypedArray% Intrinsic Object</h1>

    <emu-clause id="sec-modifications-%typedarray%.prototype.copywithin">
      <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
      <p>The interpretation and use of the arguments of %TypedArray%`.prototype.copyWithin` are the same as for `Array.prototype.copyWithin` as defined in <emu-xref href="#sec-array.prototype.copywithin"></emu-xref>.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? ValidateTypedArray(_O_).
        1. Let _len_ be _O_.[[ArrayLength]].
        1. Let _relativeTarget_ be ? ToInteger(_target_).
        1. If _relativeTarget_ &lt; 0, let _to_ be max((_len_ + _relativeTarget_), 0); else let _to_ be min(_relativeTarget_, _len_).
        1. Let _relativeStart_ be ? ToInteger(_start_).
        1. If _relativeStart_ &lt; 0, let _from_ be max((_len_ + _relativeStart_), 0); else let _from_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
        1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
        1. Let _count_ be min(_final_ - _from_, _len_ - _to_).
        1. If _count_ &gt; 0, then
          1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _typedArrayName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _typedArrayName_.
          1. <ins>Let _stride_ be _O_.[[Stride]].</ins>
          1. Let _byteOffset_ be _O_.[[ByteOffset]].
          1. Let _toByteIndex_ be _to_ &times; _elementSize_ <ins>&times; _stride_ </ins>+ _byteOffset_.
          1. Let _fromByteIndex_ be _from_ &times; _elementSize_ <ins>&times; _stride_ </ins>+ _byteOffset_.
          1. <del>Let _countBytes_ be _count_ &times; _elementSize_.</del>
          1. If _fromByteIndex_ &lt; _toByteIndex_ and _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_, then
            1. Let _direction_ be -1.
            1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.
            1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.
          1. Else,
            1. Let _direction_ be 1.
          1. Repeat, while <del>_countBytes_</del><ins>_count_</ins> &gt; 0
            1. <ins>Let _countBytes_ be _elementSize_.</ins>
            1. <ins>Repeat, while _countBytes_ &gt; 0</ins>
              1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~Uint8~, *true*, ~Unordered~).
              1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
              1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.
              1. Set _toByteIndex_ to _toByteIndex_ + _direction_.
              1. <ins>Set _countBytes_ to _countBytes_ - 1.</ins>
            1. <ins>Set _fromByteIndex_ to _fromByteIndex_ + _direction_ &times; _elementSize_ &times; (_stride_ - 1).</ins>
            1. <ins>Set _toByteIndex_ to _toByteIndex_ + _direction_ &times; _elementSize_ &times; (_stride_ - 1).</ins>
            1. <ins>Set _count_ to _count_ - 1.</ins>
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-modifications-%typedarray%.prototype.set-array-offset">
      <h1>%TypedArray%.prototype.set ( _array_ [ , _offset_ ] )</h1>
      <p>Sets multiple values in this _TypedArray_, reading the values from the object _array_. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
      <emu-alg>
        1. Assert: _array_ is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-typedarray-offset"></emu-xref> applies.
        1. Let _target_ be the *this* value.
        1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).
        1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _targetOffset_ be ? ToInteger(_offset_).
        1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
        1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
        1. Let _targetLength_ be _target_.[[ArrayLength]].
        1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
        1. Let _targetElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. <ins>Let _targetStride_ be _target_.[[Stride]].</ins>
        1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
        1. Let _src_ be ? ToObject(_array_).
        1. Let _srcLength_ be ? LengthOfArrayLike(_src_).
        1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
        1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ <ins>&times; _targetStride_ </ins>+ _targetByteOffset_.
        1. Let _k_ be 0.
        1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; <ins>_targetStride_ &times; </ins>_srcLength_.
        1. Repeat, while _targetByteIndex_ &lt; _limit_
          1. Let _Pk_ be ! ToString(_k_).
          1. Let _value_ be ? Get(_src_, _Pk_).
          1. If _target_.[[ContentType]] is ~BigInt~, set _value_ to ? ToBigInt(_value_).
          1. Otherwise, set _value_ to ? ToNumber(_value_).
          1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
          1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).
          1. Set _k_ to _k_ + 1.
          1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_<ins> &times; _targetStride_</ins>.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.set-typedarray-offset">
      <h1>%TypedArray%.prototype.set ( _typedArray_ [ , _offset_ ] )</h1>
      <p>Sets multiple values in this _TypedArray_, reading the values from the _typedArray_ argument object. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
      <emu-alg>
        1. Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"></emu-xref> applies.
        1. Let _target_ be the *this* value.
        1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).
        1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _targetOffset_ be ? ToInteger(_offset_).
        1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
        1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
        1. Let _targetLength_ be _target_.[[ArrayLength]].
        1. Let _srcBuffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
        1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
        1. Let _targetType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
        1. <ins>Let _targetByteOffset_ be _target_.[[Stride]]</ins>.
        1. Let _srcName_ be the String value of _typedArray_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcLength_ be _typedArray_.[[ArrayLength]].
        1. Let _srcByteOffset_ be _typedArray_.[[ByteOffset]].
        1. <ins>Let _srcStride_ be _typedArray_.[[Stride]].</ins>
        1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
        1. If _target_.[[ContentType]] is not equal to _typedArray_.[[ContentType]], throw a *TypeError* exception.
        1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then
          1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.
        1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).
        1. If _same_ is *true*, then
          1. Let _srcByteLength_ be _typedArray_.[[ByteLength]].
          1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, <ins>_srcElementSize_, _srcStride_, </ins>_srcByteLength_, %ArrayBuffer%).
          1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
          1. Let _srcByteIndex_ be 0.
          1. <ins>Set _srcStride_ to 1.</ins>
          1. <ins>NOTE: CloneArrayBuffer does not preserve stride.</ins>
        1. Else, let _srcByteIndex_ be _srcByteOffset_.
        1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_<ins> &times; _targetStride_</ins> + _targetByteOffset_.
        1. Let _limit_ be _targetByteIndex_ + _targetElementSize_<ins> &times; _targetStride_</ins> &times; _srcLength_.
        1. If _srcType_ is the same as _targetType_, then
          1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
          1. Repeat, while _targetByteIndex_ &lt; _limit_
            1. <ins>Let _countBytes_ be _elementSize_.</ins>
            1. <ins>Repeat, while _countBytes_ &gt; 0</ins>
              1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~true~, *Uint8*, ~Unordered~).
              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
              1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
              1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
              1. <ins>Set _countBytes_ to _countBytes_ - 1.</ins>
            1. <ins>Set _srcByteIndex_ to _srcByteIndex_ + _elementSize_ &times; (_srcStride_ - 1).</ins>
            1. <ins>Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_ &times; (_targetStride_ - 1).</ins>
        1. Else,
          1. Repeat, while _targetByteIndex_ &lt; _limit_
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_<ins> &times; _srcStride_</ins>.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_<ins> &times _targetStride_</ins>.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-modifications-%typedarray%.prototype.slice">
      <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
      <emu-note type=editor>
        <p><ins>This method clones the underlying buffer and does not preserve stride.</ins></p>
      </emu-note>
      <p>The interpretation and use of the arguments of %TypedArray%`.prototype.slice` are the same as for `Array.prototype.slice` as defined in <emu-xref href="#sec-array.prototype.slice"></emu-xref>. The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? ValidateTypedArray(_O_).
        1. Let _len_ be _O_.[[ArrayLength]].
        1. Let _relativeStart_ be ? ToInteger(_start_).
        1. If _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
        1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
        1. Let _count_ be max(_final_ - _k_, 0).
        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; _count_ &raquo;).
        1. Let _srcName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _targetName_ be the String value of _A_.[[TypedArrayName]].
        1. Let _targetType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. If _srcType_ is different from _targetType_, then
          1. Let _n_ be 0.
          1. Repeat, while _k_ &lt; _final_
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_O_, _Pk_).
            1. Perform ! Set(_A_, ! ToString(_n_), _kValue_, *true*).
            1. Set _k_ to _k_ + 1.
            1. Set _n_ to _n_ + 1.
        1. Else if _count_ &gt; 0, then
          1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
          1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _srcType_.
          1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
          1. <ins>Let _stride_ be _O_.[[Stride]].</ins>
          1. Let _srcByteOffet_ be _O_.[[ByteOffset]].
          1. Let _targetByteIndex_ be _A_.[[ByteOffset]].
          1. Let _srcByteIndex_ be (_k_ &times; _elementSize_) + _srcByteOffet_.
          1. <ins>Repeat, while _count_ &gt; 0</ins>
            1. <ins>Let _countBytes_ be _elementSize_.</ins>
            1. <ins>Repeat, while _countBytes_ &gt; 0</ins>
              1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~Uint8~, *true*, ~Unordered~).
              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
              1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
              1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
              1. <ins>Set _countBytes_ to _countBytes_ - 1.</ins>
            1. <ins>Set _srcByteIndex_ to _srcByteIndex_ + _elementSize_ &times; (_stride_ - 1).</ins>
            1. <ins>Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_ &times; (_stride_ - 1).</ins>
            1. <ins>Set _count_ to _count_ - 1.</ins>
        1. Return _A_.
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-modifications-%typedarray%.prototype.subarray">
      <h1>%TypedArray%.prototype.subarray ( _begin_, _end_ )</h1>
      <emu-note type=editor>
        <p><ins>This method does not clone the underlying buffer and preserves stride.</ins></p>
      </emu-note>
      <p>Returns a new _TypedArray_ object whose element type is the same as this _TypedArray_ and whose ArrayBuffer is the same as the ArrayBuffer of this _TypedArray_, referencing the elements at _begin_, inclusive, up to _end_, exclusive. If either _begin_ or _end_ is negative, it refers to an index from the end of the array, as opposed to from the beginning.</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. Let _srcLength_ be _O_.[[ArrayLength]].
        1. Let _relativeBegin_ be ? ToInteger(_begin_).
        1. If _relativeBegin_ &lt; 0, let _beginIndex_ be max((_srcLength_ + _relativeBegin_), 0); else let _beginIndex_ be min(_relativeBegin_, _srcLength_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else let _relativeEnd_ be ? ToInteger(_end_).
        1. If _relativeEnd_ &lt; 0, let _endIndex_ be max((_srcLength_ + _relativeEnd_), 0); else let _endIndex_ be min(_relativeEnd_, _srcLength_).
        1. Let _newLength_ be max(_endIndex_ - _beginIndex_, 0).
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. <ins>Let _srcStride_ be _O_.[[Stride]].</ins>
        1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
        1. Let _beginByteOffset_ be _srcByteOffset_ + _beginIndex_ &times; _elementSize_<ins> &times; _stride_</ins>.
        1. Let _argumentsList_ be &laquo; _buffer_, _beginByteOffset_, _newLength_<ins>, _stride_</ins> &raquo;.
        1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modifications-typedarray-constructors">
    <h1>Modifications to the _TypedArray_ Constructors</h1>

    <emu-clause id="sec-modifications-allocatetypedarray" aoid="AllocateTypedArray">
      <h1>Runtime Semantics: AllocateTypedArray ( _constructorName_, _newTarget_, _defaultProto_ [ , _length_ ] )</h1>
      <p>The abstract operation AllocateTypedArray with arguments _constructorName_, _newTarget_, _defaultProto_ and optional argument _length_ is used to validate and create an instance of a TypedArray constructor. _constructorName_ is required to be the name of a TypedArray constructor in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>. If the _length_ argument is passed, an ArrayBuffer of that length is also allocated and associated with the new TypedArray instance. AllocateTypedArray provides common semantics that is used by all of the _TypedArray_ overloads. AllocateTypedArray performs the following steps:</p>
      <emu-alg>
        1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).
        1. Let _obj_ be ! IntegerIndexedObjectCreate(_proto_).
        1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.
        1. Set _obj_.[[TypedArrayName]] to _constructorName_.
        1. If _constructorName_ is *"BigInt64Array"* or *"BigUint64Array"*, set _obj_.[[ContentType]] to ~BigInt~.
        1. Otherwise, set _obj_.[[ContentType]] to ~Number~.
        1. If _length_ is not present, then
          1. Set _obj_.[[ByteLength]] to 0.
          1. Set _obj_.[[ByteOffset]] to 0.
          1. Set _obj_.[[ArrayLength]] to 0.
          1. <ins>Set _obj_.[[Stride]] to 1.</ins>
        1. Else,
          1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-modifications-allocatetypedarraybuffer" aoid="AllocateTypedArrayBuffer">
      <h1>Runtime Semantics: AllocateTypedArrayBuffer ( _O_, _length_ )</h1>
      <p>The abstract operation AllocateTypedArrayBuffer with arguments _O_ and _length_ allocates and associates an ArrayBuffer with the TypedArray instance _O_. It performs the following steps:</p>
      <emu-alg>
        1. Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
        1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.
        1. Assert: ! IsNonNegativeInteger(_length_) is *true*.
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _byteLength_ be _elementSize_ &times; _length_.
        1. Let _data_ be ? AllocateArrayBuffer(%ArrayBuffer%, _byteLength_).
        1. Set _O_.[[ViewedArrayBuffer]] to _data_.
        1. Set _O_.[[ByteLength]] to _byteLength_.
        1. Set _O_.[[ByteOffset]] to 0.
        1. Set _O_.[[ArrayLength]] to _length_.
        1. <ins>Set _O_.[[Stride]] to 1.</ins>
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-modifications-typedarray-typedarray">
      <h1>_TypedArray_ ( _typedArray_ )</h1>
      <emu-note type=editor>
        <p>When copying a source TypedArray using this constructor, the stride is not preserved.</p>
      </emu-note>
      <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object has a [[TypedArrayName]] internal slot.</p>
      <p>_TypedArray_ called with argument _typedArray_ performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_typedArray_) is Object and _typedArray_ has a [[TypedArrayName]] internal slot.
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for this <var>TypedArray</var> constructor.
        1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>.prototype%"</code>).
        1. Let _srcArray_ be _typedArray_.
        1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
        1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _elementLength_ be _srcArray_.[[ArrayLength]].
        1. Let _srcName_ be the String value of _srcArray_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
        1. <ins>Let _srcStride_ be _srcArray_.[[Stride]].</ins>
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _byteLength_ be _elementSize_ &times; _elementLength_.
        1. If IsSharedArrayBuffer(_srcData_) is *false*, then
          1. Let _bufferConstructor_ be ? SpeciesConstructor(_srcData_, %ArrayBuffer%).
        1. Else,
          1. Let _bufferConstructor_ be %ArrayBuffer%.
        1. If _elementType_ is the same as _srcType_, then
          1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_,<ins> _srcElementSize_, _srcStride_,</ins> _srcStride_, _byteLength_, _bufferConstructor_).
        1. Else,
          1. Let _data_ be ? AllocateArrayBuffer(_bufferConstructor_, _byteLength_).
          1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
          1. If _srcArray_.[[ContentType]] is not equal to _O_.[[ContentType]], throw a *TypeError* exception.
          1. Let _srcByteIndex_ be _srcByteOffset_.
          1. Let _targetByteIndex_ be 0.
          1. Let _count_ be _elementLength_.
          1. Repeat, while _count_ &gt; 0
            1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_<ins> &times _srcStride_</ins>.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
            1. Set _count_ to _count_ - 1.
        1. Set _O_.[[ViewedArrayBuffer]] to _data_.
        1. Set _O_.[[ByteLength]] to _byteLength_.
        1. Set _O_.[[ByteOffset]] to 0.
        1. Set _O_.[[ArrayLength]] to _elementLength_.
        1. <ins>Set _O_.[[Stride]] to 1.</ins>
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-modifications-typedarray-buffer-byteoffset-length">
      <h1>_TypedArray_ ( _buffer_ [ , _byteOffset_ [ , _length_ ] <ins>[ , _stride_ ] </ins>] )</h1>
      <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object has an [[ArrayBufferData]] internal slot.</p>
      <p>_TypedArray_ called with at least one argument _buffer_ performs the following steps:</p>
      <emu-alg>
        1. Assert: Type(_buffer_) is Object and _buffer_ has an [[ArrayBufferData]] internal slot.
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for this <var>TypedArray</var> constructor.
        1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>.prototype%"</code>).
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. <ins>If _stride_ is *undefined*, then</ins>
          1. <ins>Let _newStride_ be 1.</ins>
        1. <ins>Else,</ins>
          1. <ins>Let _newStride_ be ? ToInteger(_length_).</ins>
        1. <ins>If _newStride_ &le; 0, throw a *RangeError* exception.</ins>
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If _offset_ modulo <ins>(</ins>_elementSize_<ins> &times; _newStride_)</ins> &ne; 0, throw a *RangeError* exception.
        1. If _length_ is not *undefined*, then
          1. Let _newLength_ be ? ToIndex(_length_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be _buffer_.[[ArrayBufferByteLength]].
        1. If _length_ is *undefined*, then
          1. If _bufferByteLength_ modulo <ins>(</ins>_elementSize_ <ins>&times; _newStride_) </ins>&ne; 0, throw a *RangeError* exception.
          1. Let _newByteLength_ be <ins>(</ins>_bufferByteLength_ - _offset_<ins>) / _newStride_</ins>.
          1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
        1. Else,
          1. Let _newByteLength_ be _newLength_ &times; _elementSize_<ins> &times; _newStride_</ins>.
          1. If _offset_ + _newByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
        1. Set _O_.[[ByteLength]] to _newByteLength_.
        1. Set _O_.[[ByteOffset]] to _offset_.
        1. <ins>Set _O_.[[Stride]] to _newStride_.</ins>
        1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modifications-properties-of-typedarray-instances">
    <h1>Properties of _TypedArray_ Instances</h1>
    <p>_TypedArray_ instances are <emu-xref href="#integer-indexed-exotic-object">Integer-Indexed exotic objects</emu-xref>. Each _TypedArray_ instance inherits properties from the corresponding _TypedArray_ prototype object. Each _TypedArray_ instance has the following internal slots: [[TypedArrayName]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]], <ins>[[Stride]], </ins>and [[ArrayLength]].</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-modifications-atomics-object">
  <h1>Modifications to the Atomics Object</h1>

  <emu-clause id="sec-modifications-abstract-operations-for-atomics">
    <h1>Modifications to Abstract Operations for Atomics</h1>

    <emu-clause id="sec-modifications-atomicreadmodifywrite" aoid="AtomicReadModifyWrite">
      <h1>AtomicReadModifyWrite ( _typedArray_, _index_, _value_, _op_ )</h1>
      <p>The abstract operation AtomicReadModifyWrite takes four arguments, _typedArray_, _index_, _value_, and a pure combining operation _op_. The pure combining operation _op_ takes two List of byte values arguments and returns a List of byte values. The operation atomically loads a value, combines it with another value, and stores the result of the combination. It returns the loaded value. It performs the following steps:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. If _typedArray_.[[ContentType]] is ~BigInt~, let _v_ be ? ToBigInt(_value_).
        1. Otherwise, let _v_ be ? ToInteger(_value_).
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
        1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. <ins>Let _stride_ be _typedArray_.[[Stride]].</ins>
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_<ins> &times; _stride_</ins>) + _offset_.
        1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, _op_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomicload" aoid="AtomicLoad">
      <h1>AtomicLoad ( _typedArray_, _index_ )</h1>
      <p>The abstract operation AtomicLoad takes two arguments, _typedArray_, _index_. The operation atomically loads a value and returns the loaded value. It performs the following steps:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
        1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. <ins>Let _stride_ be _typedArray_.[[Stride]].</ins>
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_<ins> &times; _stride_</ins>) + _offset_.
        1. Return GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, ~SeqCst~).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics.compareexchange">
    <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
      1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
      1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
      1. If _typedArray_.[[ContentType]] is ~BigInt~, then
        1. Let _expected_ be ? ToBigInt(_expectedValue_).
        1. Let _replacement_ be ? ToBigInt(_replacementValue_).
      1. Else,
        1. Let _expected_ be ? ToInteger(_expectedValue_).
        1. Let _replacement_ be ? ToInteger(_replacementValue_).
      1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
      1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. <ins>Let _stride_ be _typedArray_.[[Stride]].</ins>
      1. Let _indexedPosition_ be (_i_ &times; _elementSize_<ins> &times; _stride_</ins>) + _offset_.
      1. Let `compareExchange` denote a semantic function of two List of byte values arguments that returns the second argument if the first argument is element-wise equal to _expectedBytes_.
      1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _replacement_, `compareExchange`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.store">
    <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
      1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
      1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
      1. If _arrayTypeName_ is *"BigUint64Array"* or *"BigInt64Array"*, let _v_ be ? ToBigInt(_value_).
      1. Otherwise, let _v_ be ? ToInteger(_value_).
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. <ins>Let _stride_ be _typedArray_.[[Stride]].</ins>
      1. Let _indexedPosition_ be (_i_ &times; _elementSize_<ins> &times; _stride_</ins>) + _offset_.
      1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, *true*, ~SeqCst~).
      1. Return _v_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.wait">
    <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
    <p>`Atomics.wait` puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg>
      1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
      1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
      1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
      1. If _arrayTypeName_ is *"BigInt64Array"*, let _v_ be ? ToBigInt64(_value_).
      1. Otherwise, let _v_ be ? ToInt32(_value_).
      1. Let _q_ be ? ToNumber(_timeout_).
      1. If _q_ is *NaN*, let _t_ be *+&infin;*; else let _t_ be max(_q_, 0).
      1. Let _B_ be AgentCanSuspend().
      1. If _B_ is *false*, throw a *TypeError* exception.
      1. Let _block_ be _buffer_.[[ArrayBufferData]].
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. <ins>Let _stride_ be _typedArray_.[[Stride]].</ins>
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _indexedPosition_ be (_i_ &times; _elementSize_<ins> &times; _stride_</ins>) + _offset_.
      1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
      1. Perform EnterCriticalSection(_WL_).
      1. Let _w_ be ! AtomicLoad(_typedArray_, _i_).
      1. If _v_ is not equal to _w_, then
        1. Perform LeaveCriticalSection(_WL_).
        1. Return the String *"not-equal"*.
      1. Let _W_ be AgentSignifier().
      1. Perform AddWaiter(_WL_, _W_).
      1. Let _notified_ be Suspend(_WL_, _W_, _t_).
      1. If _notified_ is *true*, then
        1. Assert: _W_ is not on the list of waiters in _WL_.
      1. Else,
        1. Perform RemoveWaiter(_WL_, _W_).
      1. Perform LeaveCriticalSection(_WL_).
      1. If _notified_ is *true*, return the String *"ok"*.
      1. Return the String *"timed-out"*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.notify">
    <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
    <p>`Atomics.notify` notifies some agents that are sleeping in the wait queue.  The following steps are taken:</p>
    <emu-alg>
      1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
      1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
      1. If _count_ is *undefined*, let _c_ be *+&infin;*.
      1. Else,
        1. Let _intCount_ be ? ToInteger(_count_).
        1. Let _c_ be max(_intCount_, 0).
      1. Let _block_ be _buffer_.[[ArrayBufferData]].
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. <ins>Let _stride_ be _typedArray_.[[Stride]].</ins>
      1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _indexedPosition_ be (_i_ &times; _elementSize_<ins> &times; _stride_</ins>) + _offset_.
      1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
      1. Let _n_ be 0.
      1. Perform EnterCriticalSection(_WL_).
      1. Let _S_ be RemoveWaiters(_WL_, _c_).
      1. Repeat, while _S_ is not an empty List,
        1. Let _W_ be the first agent in _S_.
        1. Remove _W_ from the front of _S_.
        1. Perform NotifyWaiter(_WL_, _W_).
        1. Set _n_ to _n_ + 1.
      1. Perform LeaveCriticalSection(_WL_).
      1. Return _n_.
    </emu-alg>
  </emu-clause>
</emu-clause>
